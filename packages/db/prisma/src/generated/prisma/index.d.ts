
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  id: string
  token: string | null
  createdAt: Date
  email: string
  isDeleted: boolean
  updatedAt: Date
  firstName: string
  lastName: string
  phone: string
  inviteId: string | null
  isSupportUser: boolean
  hasSeenProductTour: boolean
  productTourData: Prisma.JsonValue | null
  savedDashboardView: DashboardViews
  photoView: PhotoViews
  groupView: GroupByViews
  onboardingStatus: Prisma.JsonValue | null
}

/**
 * Model Organization
 * 
 */
export type Organization = {
  id: number
  publicId: string
  createdAt: Date
  name: string
  address: string
  faxNumber: string
  size: string
  isDeleted: boolean
  updatedAt: Date
  logoId: string | null
}

/**
 * Model Equipment
 * 
 */
export type Equipment = {
  id: number
  publicId: string
  createdAt: Date
  isDeleted: boolean
  name: string
  quantity: number
  organizationId: number
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  id: number
  publicId: string
  createdAt: Date
  isDeleted: boolean
  title: string
  content: string
  isSeen: boolean
  link: string | null
  linkText: string | null
  type: NotificationType
  userId: string
}

/**
 * Model OrganizationSavedOption
 * 
 */
export type OrganizationSavedOption = {
  id: number
  publicId: string
  createdAt: Date
  label: string
  value: string
  isDeleted: boolean
  type: SavedOptionType
  organizationId: number
}

/**
 * Model UserToOrganization
 * 
 */
export type UserToOrganization = {
  id: number
  createdAt: Date
  isAdmin: boolean
  isDeleted: boolean
  organizationId: number
  role: string | null
  accessLevel: AccessLevel | null
  userId: string
}

/**
 * Model OrganizationInvitation
 * 
 */
export type OrganizationInvitation = {
  id: number
  createdAt: Date
  isDeleted: boolean
  organizationId: number
  email: string
  invitationId: string
  isAccepted: boolean
}

/**
 * Model UserToProject
 * 
 */
export type UserToProject = {
  id: number
  createdAt: Date
  userId: string
  projectId: number
}

/**
 * Model Project
 * 
 */
export type Project = {
  id: number
  createdAt: Date
  closedAt: Date | null
  isDeleted: boolean
  organizationId: number
  assignmentNumber: string
  publicId: string
  name: string
  location: string
  clientName: string
  clientEmail: string
  clientPhoneNumber: string
  companyName: string
  managerName: string
  adjusterEmail: string
  adjusterName: string
  adjusterPhoneNumber: string
  insuranceCompanyName: string
  insuranceClaimId: string
  lossType: string
  catCode: number | null
  humidity: string
  lastTimeWeatherFetched: Date | null
  temperature: string
  wind: string
  lat: string
  lng: string
  forecast: string
  claimSummary: string
  roofSegments: Prisma.JsonValue[]
  roofSpecs: Prisma.JsonValue | null
  rcvValue: number | null
  actualValue: number | null
  status: ProjectStatus | null
  projectStatusValueId: number | null
}

/**
 * Model ProjectNotes
 * 
 */
export type ProjectNotes = {
  id: number
  createdAt: Date
  updatedAt: Date | null
  date: Date
  isDeleted: boolean
  publicId: string
  projectId: number
  body: string
  mentions: string[]
  userId: string
}

/**
 * Model ProjectStatusValue
 * 
 */
export type ProjectStatusValue = {
  id: number
  createdAt: Date
  isDeleted: boolean
  publicId: string
  label: string
  description: string
  color: string
  order: number | null
  organizationId: number
}

/**
 * Model PendingRoofReports
 * 
 */
export type PendingRoofReports = {
  id: number
  createdAt: Date
  isDeleted: boolean
  projectId: number
  isCompleted: boolean
}

/**
 * Model WeatherReportItem
 * 
 */
export type WeatherReportItem = {
  id: number
  createdAt: Date
  isDeleted: boolean
  projectId: number
  date: Date
  time: string
  f_scale: string | null
  speed: string | null
  size: string | null
  location: string
  county: string
  state: string
  lat: string
  lon: string
  comments: string
}

/**
 * Model ProjectEquipment
 * 
 */
export type ProjectEquipment = {
  id: number
  publicId: string
  createdAt: Date
  isDeleted: boolean
  quantity: number
  projectId: number
  equipmentId: number
}

/**
 * Model Cost
 * 
 */
export type Cost = {
  id: number
  createdAt: Date
  updatedAt: Date
  estimatedCost: number | null
  actualCost: number | null
  name: string | null
  projectId: number
  isDeleted: boolean
  type: CostType
}

/**
 * Model PropertyData
 * 
 */
export type PropertyData = {
  id: number
  createdAt: Date
  projectId: number | null
  bathrooms: number | null
  bedrooms: number | null
  squareFootage: number | null
  realtyMoleId: string | null
  data: Prisma.JsonValue | null
}

/**
 * Model DataDeletionRequest
 * 
 */
export type DataDeletionRequest = {
  id: number
  createdAt: Date
  fullName: string
  email: string
  isVerified: boolean
}

/**
 * Model PhotoAccessLink
 * 
 */
export type PhotoAccessLink = {
  id: number
  createdAt: Date
  expiresAt: Date | null
  accessId: string
  email: string | null
  phoneNumber: string | null
  projectId: number
}

/**
 * Model Image
 * 
 */
export type Image = {
  id: number
  createdAt: Date
  isDeleted: boolean
  publicId: string
  key: string
  projectId: number
  organizationId: number | null
  includeInReport: boolean
  description: string | null
}

/**
 * Model Annotation
 * 
 */
export type Annotation = {
  id: number
  createdAt: Date
  updatedAt: Date
  imageId: number
  coordinates: Prisma.JsonValue
  userId: string
  isDeleted: boolean
}

/**
 * Model ImageNote
 * 
 */
export type ImageNote = {
  id: number
  createdAt: Date
  updatedAt: Date
  imageId: number
  body: string
  mentions: string[]
  userId: string
  isDeleted: boolean
}

/**
 * Model Inference
 * 
 */
export type Inference = {
  id: number
  createdAt: Date
  isDeleted: boolean
  publicId: string
  imageId: number | null
  imageKey: string | null
  projectId: number
  roomId: number | null
}

/**
 * Model Room
 * 
 */
export type Room = {
  id: number
  createdAt: Date
  isDeleted: boolean
  publicId: string
  name: string
  projectId: number
  gpp: string | null
  humidity: string | null
  dehuReading: string | null
  temperature: string | null
  length: string | null
  width: string | null
  height: string | null
  totalSqft: string | null
  windows: number | null
  doors: number | null
  equipmentUsed: string[]
}

/**
 * Model RoomReading
 * 
 */
export type RoomReading = {
  id: number
  createdAt: Date
  date: Date
  humidity: string | null
  temperature: string | null
  moistureContentWall: string | null
  moistureContentFloor: string | null
  equipmentUsed: string[]
  roomId: number
  isDeleted: boolean
  publicId: string
  projectId: number
  gpp: string | null
}

/**
 * Model Notes
 * 
 */
export type Notes = {
  id: number
  createdAt: Date
  updatedAt: Date | null
  date: Date
  roomId: number
  isDeleted: boolean
  publicId: string
  projectId: number
  body: string
}

/**
 * Model NotesAuditTrail
 * 
 */
export type NotesAuditTrail = {
  id: number
  createdAt: Date
  notesId: number
  userId: string
  userName: string | null
  action: NotesAuditAction
  body: string
}

/**
 * Model AreaAffected
 * 
 */
export type AreaAffected = {
  id: number
  createdAt: Date
  date: Date
  roomId: number
  material: string | null
  totalAreaRemoved: string | null
  totalAreaMicrobialApplied: string | null
  cause: string | null
  category: number | null
  cabinetryRemoved: string | null
  isDeleted: boolean
  publicId: string
  projectId: number
  type: AreaAffectedType
}

/**
 * Model GenericRoomReading
 * 
 */
export type GenericRoomReading = {
  id: number
  createdAt: Date
  publicId: string
  type: RoomReadingType
  value: string
  humidity: string | null
  temperature: string | null
  gpp: string | null
  roomReadingId: number
  isDeleted: boolean
}

/**
 * Model Detection
 * 
 */
export type Detection = {
  id: number
  createdAt: Date
  isDeleted: boolean
  publicId: string
  inferenceId: number
  imageKey: string | null
  xMinCord: number | null
  yMinCord: number | null
  confidence: number | null
  xMaxCord: number | null
  yMaxCord: number | null
  projectId: number
  category: string
  code: string
  item: string
  quality: string
  roomId: number | null
  dimension: number | null
  unit: DimensionUnit | null
}

/**
 * Model TemplatesUsed
 * 
 */
export type TemplatesUsed = {
  id: number
  createdAt: Date
  templateCode: string
  roomId: number | null
}

/**
 * Model WaitList
 * 
 */
export type WaitList = {
  id: number
  createdAt: Date
  email: string
}

/**
 * Model RekognitionRuns
 * 
 */
export type RekognitionRuns = {
  id: number
  createdAt: Date
}

/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = {
  id: number
  publicId: string
  createdAt: Date
  updatedAt: Date
  subject: string
  payload: string
  projectId: number | null
  date: Date
  dynamicId: string
  isDeleted: boolean
  remindClient: boolean
  remindProjectOwners: boolean
}

/**
 * Model CalendarEventReminder
 * 
 */
export type CalendarEventReminder = {
  id: number
  reminderTarget: ReminderTarget
  createdAt: Date
  updatedAt: Date
  sendText: boolean
  sendEmail: boolean
  textSentAt: Date | null
  emailSentAt: Date | null
  calendarEventId: number | null
  date: Date
}

/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = {
  id: number
  xactimateKey: string
  xactimateDescription: string
  hasItems: boolean
}

/**
 * Model LineItem
 * 
 */
export type LineItem = {
  id: number
  xactimateCode: string
  xactimateDescription: string
  unit: string | null
  itemCategoryId: number
}

/**
 * Model RelatedItem
 * 
 */
export type RelatedItem = {
  id: number
  relationId: string
  lineItemId: number
}

/**
 * Model AlternateItem
 * 
 */
export type AlternateItem = {
  id: number
  alternateId: string
  lineItemId: number
}

/**
 * Model PlanEntitlements
 * 
 */
export type PlanEntitlements = {
  id: number
  createdAt: Date
  extPlanId: string
  maxImages: number
  maxProjects: number
  maxSeats: number
  description: string
  period: string
  price: number
}

/**
 * Model Customers
 * 
 */
export type Customers = {
  id: number
  customerId: string
  billingAddress: Prisma.JsonValue | null
  paymentMethod: Prisma.JsonValue | null
  organizationId: number
}

/**
 * Model Products
 * 
 */
export type Products = {
  id: string
  active: boolean
  name: string
  description: string | null
  image: string | null
  metadata: Prisma.JsonValue | null
}

/**
 * Model Prices
 * 
 */
export type Prices = {
  id: string
  productId: string
  active: boolean
  unitAmount: bigint | null
  currency: string
  type: PricingType
  interval: PricingPlanInterval | null
  intervalCount: number | null
  trialPeriodDays: number | null
  metadata: Prisma.JsonValue | null
  description: string
}

/**
 * Model Subscriptions
 * 
 */
export type Subscriptions = {
  id: string
  organizationId: number
  status: SubscriptionStatus
  metadata: Prisma.JsonValue | null
  pricesId: string
  quantity: number
  cancelAtPeriodEnd: boolean
  created: Date | null
  currentPeriodStart: Date | null
  currentPeriodEnd: Date | null
  endedAt: Date | null
  cancelAt: Date | null
  canceledAt: Date | null
  trialStart: Date | null
  trialEnd: Date | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const AccessLevel: {
  admin: 'admin',
  viewer: 'viewer',
  projectManager: 'projectManager',
  accountManager: 'accountManager',
  contractor: 'contractor'
  removed:
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const AreaAffectedType: {
  wall: 'wall',
  ceiling: 'ceiling',
  floor: 'floor'
};

export type AreaAffectedType = (typeof AreaAffectedType)[keyof typeof AreaAffectedType]


export const CostType: {
  subcontractor: 'subcontractor',
  miscellaneous: 'miscellaneous',
  materials: 'materials',
  labor: 'labor'
};

export type CostType = (typeof CostType)[keyof typeof CostType]


export const DashboardViews: {
  listView: 'listView',
  boardView: 'boardView',
  mapView: 'mapView'
};

export type DashboardViews = (typeof DashboardViews)[keyof typeof DashboardViews]


export const DimensionUnit: {
  sf: 'sf',
  lf: 'lf',
  ea: 'ea'
};

export type DimensionUnit = (typeof DimensionUnit)[keyof typeof DimensionUnit]


export const GroupByViews: {
  roomView: 'roomView',
  dateView: 'dateView'
};

export type GroupByViews = (typeof GroupByViews)[keyof typeof GroupByViews]


export const NotesAuditAction: {
  updated: 'updated',
  deleted: 'deleted',
  created: 'created'
};

export type NotesAuditAction = (typeof NotesAuditAction)[keyof typeof NotesAuditAction]


export const NotificationType: {
  notification: 'notification',
  activity: 'activity'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const PhotoViews: {
  photoListView: 'photoListView',
  photoGridView: 'photoGridView'
};

export type PhotoViews = (typeof PhotoViews)[keyof typeof PhotoViews]


export const PricingPlanInterval: {
  day: 'day',
  week: 'week',
  month: 'month',
  year: 'year'
};

export type PricingPlanInterval = (typeof PricingPlanInterval)[keyof typeof PricingPlanInterval]


export const PricingType: {
  one_time: 'one_time',
  recurring: 'recurring'
};

export type PricingType = (typeof PricingType)[keyof typeof PricingType]


export const ProjectStatus: {
  active: 'active',
  mitigation: 'mitigation',
  inspection: 'inspection',
  review: 'review',
  completed: 'completed',
  inactive: 'inactive',
  incomplete: 'incomplete'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ReminderTarget: {
  client: 'client',
  allAssigned: 'allAssigned',
  projectCreator: 'projectCreator'
};

export type ReminderTarget = (typeof ReminderTarget)[keyof typeof ReminderTarget]


export const RoomReadingType: {
  dehumidifer: 'dehumidifer'
};

export type RoomReadingType = (typeof RoomReadingType)[keyof typeof RoomReadingType]


export const SavedOptionType: {
  carrier: 'carrier',
  wallMaterial: 'wallMaterial',
  floorMaterial: 'floorMaterial'
};

export type SavedOptionType = (typeof SavedOptionType)[keyof typeof SavedOptionType]


export const SubscriptionStatus: {
  trialing: 'trialing',
  active: 'active',
  canceled: 'canceled',
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired',
  past_due: 'past_due',
  unpaid: 'unpaid'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<GlobalReject>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.organizationSavedOption`: Exposes CRUD operations for the **OrganizationSavedOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationSavedOptions
    * const organizationSavedOptions = await prisma.organizationSavedOption.findMany()
    * ```
    */
  get organizationSavedOption(): Prisma.OrganizationSavedOptionDelegate<GlobalReject>;

  /**
   * `prisma.userToOrganization`: Exposes CRUD operations for the **UserToOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToOrganizations
    * const userToOrganizations = await prisma.userToOrganization.findMany()
    * ```
    */
  get userToOrganization(): Prisma.UserToOrganizationDelegate<GlobalReject>;

  /**
   * `prisma.organizationInvitation`: Exposes CRUD operations for the **OrganizationInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationInvitations
    * const organizationInvitations = await prisma.organizationInvitation.findMany()
    * ```
    */
  get organizationInvitation(): Prisma.OrganizationInvitationDelegate<GlobalReject>;

  /**
   * `prisma.userToProject`: Exposes CRUD operations for the **UserToProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToProjects
    * const userToProjects = await prisma.userToProject.findMany()
    * ```
    */
  get userToProject(): Prisma.UserToProjectDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.projectNotes`: Exposes CRUD operations for the **ProjectNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectNotes
    * const projectNotes = await prisma.projectNotes.findMany()
    * ```
    */
  get projectNotes(): Prisma.ProjectNotesDelegate<GlobalReject>;

  /**
   * `prisma.projectStatusValue`: Exposes CRUD operations for the **ProjectStatusValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStatusValues
    * const projectStatusValues = await prisma.projectStatusValue.findMany()
    * ```
    */
  get projectStatusValue(): Prisma.ProjectStatusValueDelegate<GlobalReject>;

  /**
   * `prisma.pendingRoofReports`: Exposes CRUD operations for the **PendingRoofReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingRoofReports
    * const pendingRoofReports = await prisma.pendingRoofReports.findMany()
    * ```
    */
  get pendingRoofReports(): Prisma.PendingRoofReportsDelegate<GlobalReject>;

  /**
   * `prisma.weatherReportItem`: Exposes CRUD operations for the **WeatherReportItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherReportItems
    * const weatherReportItems = await prisma.weatherReportItem.findMany()
    * ```
    */
  get weatherReportItem(): Prisma.WeatherReportItemDelegate<GlobalReject>;

  /**
   * `prisma.projectEquipment`: Exposes CRUD operations for the **ProjectEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectEquipments
    * const projectEquipments = await prisma.projectEquipment.findMany()
    * ```
    */
  get projectEquipment(): Prisma.ProjectEquipmentDelegate<GlobalReject>;

  /**
   * `prisma.cost`: Exposes CRUD operations for the **Cost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costs
    * const costs = await prisma.cost.findMany()
    * ```
    */
  get cost(): Prisma.CostDelegate<GlobalReject>;

  /**
   * `prisma.propertyData`: Exposes CRUD operations for the **PropertyData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyData
    * const propertyData = await prisma.propertyData.findMany()
    * ```
    */
  get propertyData(): Prisma.PropertyDataDelegate<GlobalReject>;

  /**
   * `prisma.dataDeletionRequest`: Exposes CRUD operations for the **DataDeletionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataDeletionRequests
    * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
    * ```
    */
  get dataDeletionRequest(): Prisma.DataDeletionRequestDelegate<GlobalReject>;

  /**
   * `prisma.photoAccessLink`: Exposes CRUD operations for the **PhotoAccessLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotoAccessLinks
    * const photoAccessLinks = await prisma.photoAccessLink.findMany()
    * ```
    */
  get photoAccessLink(): Prisma.PhotoAccessLinkDelegate<GlobalReject>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<GlobalReject>;

  /**
   * `prisma.annotation`: Exposes CRUD operations for the **Annotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annotations
    * const annotations = await prisma.annotation.findMany()
    * ```
    */
  get annotation(): Prisma.AnnotationDelegate<GlobalReject>;

  /**
   * `prisma.imageNote`: Exposes CRUD operations for the **ImageNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageNotes
    * const imageNotes = await prisma.imageNote.findMany()
    * ```
    */
  get imageNote(): Prisma.ImageNoteDelegate<GlobalReject>;

  /**
   * `prisma.inference`: Exposes CRUD operations for the **Inference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inferences
    * const inferences = await prisma.inference.findMany()
    * ```
    */
  get inference(): Prisma.InferenceDelegate<GlobalReject>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<GlobalReject>;

  /**
   * `prisma.roomReading`: Exposes CRUD operations for the **RoomReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomReadings
    * const roomReadings = await prisma.roomReading.findMany()
    * ```
    */
  get roomReading(): Prisma.RoomReadingDelegate<GlobalReject>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **Notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.NotesDelegate<GlobalReject>;

  /**
   * `prisma.notesAuditTrail`: Exposes CRUD operations for the **NotesAuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotesAuditTrails
    * const notesAuditTrails = await prisma.notesAuditTrail.findMany()
    * ```
    */
  get notesAuditTrail(): Prisma.NotesAuditTrailDelegate<GlobalReject>;

  /**
   * `prisma.areaAffected`: Exposes CRUD operations for the **AreaAffected** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaAffecteds
    * const areaAffecteds = await prisma.areaAffected.findMany()
    * ```
    */
  get areaAffected(): Prisma.AreaAffectedDelegate<GlobalReject>;

  /**
   * `prisma.genericRoomReading`: Exposes CRUD operations for the **GenericRoomReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenericRoomReadings
    * const genericRoomReadings = await prisma.genericRoomReading.findMany()
    * ```
    */
  get genericRoomReading(): Prisma.GenericRoomReadingDelegate<GlobalReject>;

  /**
   * `prisma.detection`: Exposes CRUD operations for the **Detection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detections
    * const detections = await prisma.detection.findMany()
    * ```
    */
  get detection(): Prisma.DetectionDelegate<GlobalReject>;

  /**
   * `prisma.templatesUsed`: Exposes CRUD operations for the **TemplatesUsed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplatesUseds
    * const templatesUseds = await prisma.templatesUsed.findMany()
    * ```
    */
  get templatesUsed(): Prisma.TemplatesUsedDelegate<GlobalReject>;

  /**
   * `prisma.waitList`: Exposes CRUD operations for the **WaitList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaitLists
    * const waitLists = await prisma.waitList.findMany()
    * ```
    */
  get waitList(): Prisma.WaitListDelegate<GlobalReject>;

  /**
   * `prisma.rekognitionRuns`: Exposes CRUD operations for the **RekognitionRuns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RekognitionRuns
    * const rekognitionRuns = await prisma.rekognitionRuns.findMany()
    * ```
    */
  get rekognitionRuns(): Prisma.RekognitionRunsDelegate<GlobalReject>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<GlobalReject>;

  /**
   * `prisma.calendarEventReminder`: Exposes CRUD operations for the **CalendarEventReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEventReminders
    * const calendarEventReminders = await prisma.calendarEventReminder.findMany()
    * ```
    */
  get calendarEventReminder(): Prisma.CalendarEventReminderDelegate<GlobalReject>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<GlobalReject>;

  /**
   * `prisma.lineItem`: Exposes CRUD operations for the **LineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineItems
    * const lineItems = await prisma.lineItem.findMany()
    * ```
    */
  get lineItem(): Prisma.LineItemDelegate<GlobalReject>;

  /**
   * `prisma.relatedItem`: Exposes CRUD operations for the **RelatedItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelatedItems
    * const relatedItems = await prisma.relatedItem.findMany()
    * ```
    */
  get relatedItem(): Prisma.RelatedItemDelegate<GlobalReject>;

  /**
   * `prisma.alternateItem`: Exposes CRUD operations for the **AlternateItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlternateItems
    * const alternateItems = await prisma.alternateItem.findMany()
    * ```
    */
  get alternateItem(): Prisma.AlternateItemDelegate<GlobalReject>;

  /**
   * `prisma.planEntitlements`: Exposes CRUD operations for the **PlanEntitlements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanEntitlements
    * const planEntitlements = await prisma.planEntitlements.findMany()
    * ```
    */
  get planEntitlements(): Prisma.PlanEntitlementsDelegate<GlobalReject>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<GlobalReject>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<GlobalReject>;

  /**
   * `prisma.prices`: Exposes CRUD operations for the **Prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.prices.findMany()
    * ```
    */
  get prices(): Prisma.PricesDelegate<GlobalReject>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **Subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.SubscriptionsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: 1e7af066ee9cb95cf3a403c78d9aab3e6b04f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Equipment: 'Equipment',
    Notification: 'Notification',
    OrganizationSavedOption: 'OrganizationSavedOption',
    UserToOrganization: 'UserToOrganization',
    OrganizationInvitation: 'OrganizationInvitation',
    UserToProject: 'UserToProject',
    Project: 'Project',
    ProjectNotes: 'ProjectNotes',
    ProjectStatusValue: 'ProjectStatusValue',
    PendingRoofReports: 'PendingRoofReports',
    WeatherReportItem: 'WeatherReportItem',
    ProjectEquipment: 'ProjectEquipment',
    Cost: 'Cost',
    PropertyData: 'PropertyData',
    DataDeletionRequest: 'DataDeletionRequest',
    PhotoAccessLink: 'PhotoAccessLink',
    Image: 'Image',
    Annotation: 'Annotation',
    ImageNote: 'ImageNote',
    Inference: 'Inference',
    Room: 'Room',
    RoomReading: 'RoomReading',
    Notes: 'Notes',
    NotesAuditTrail: 'NotesAuditTrail',
    AreaAffected: 'AreaAffected',
    GenericRoomReading: 'GenericRoomReading',
    Detection: 'Detection',
    TemplatesUsed: 'TemplatesUsed',
    WaitList: 'WaitList',
    RekognitionRuns: 'RekognitionRuns',
    CalendarEvent: 'CalendarEvent',
    CalendarEventReminder: 'CalendarEventReminder',
    ItemCategory: 'ItemCategory',
    LineItem: 'LineItem',
    RelatedItem: 'RelatedItem',
    AlternateItem: 'AlternateItem',
    PlanEntitlements: 'PlanEntitlements',
    Customers: 'Customers',
    Products: 'Products',
    Prices: 'Prices',
    Subscriptions: 'Subscriptions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    UserToProject: number
    Notification: number
    ImageNote: number
    Annotation: number
  }

  export type UserCountOutputTypeSelect = {
    UserToProject?: boolean
    Notification?: boolean
    ImageNote?: boolean
    Annotation?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganizationCountOutputType
   */


  export type OrganizationCountOutputType = {
    Image: number
    invitations: number
    projects: number
    users: number
    Customers: number
    Subscriptions: number
    OrganizationSavedOption: number
    equipment: number
    ProjectStatusValue: number
  }

  export type OrganizationCountOutputTypeSelect = {
    Image?: boolean
    invitations?: boolean
    projects?: boolean
    users?: boolean
    Customers?: boolean
    Subscriptions?: boolean
    OrganizationSavedOption?: boolean
    equipment?: boolean
    ProjectStatusValue?: boolean
  }

  export type OrganizationCountOutputTypeGetPayload<S extends boolean | null | undefined | OrganizationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationCountOutputTypeArgs)
    ? OrganizationCountOutputType 
    : S extends { select: any } & (OrganizationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrganizationCountOutputType ? OrganizationCountOutputType[P] : never
  } 
      : OrganizationCountOutputType




  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect | null
  }



  /**
   * Count Type EquipmentCountOutputType
   */


  export type EquipmentCountOutputType = {
    ProjectEquipment: number
  }

  export type EquipmentCountOutputTypeSelect = {
    ProjectEquipment?: boolean
  }

  export type EquipmentCountOutputTypeGetPayload<S extends boolean | null | undefined | EquipmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EquipmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentCountOutputTypeArgs)
    ? EquipmentCountOutputType 
    : S extends { select: any } & (EquipmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EquipmentCountOutputType ? EquipmentCountOutputType[P] : never
  } 
      : EquipmentCountOutputType




  // Custom InputTypes

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect | null
  }



  /**
   * Count Type ProjectCountOutputType
   */


  export type ProjectCountOutputType = {
    images: number
    inferences: number
    rooms: number
    events: number
    projectAssignees: number
    roomReadings: number
    AreaAffected: number
    photoAccessLinks: number
    notes: number
    costs: number
    projectEquipment: number
    weatherReportItems: number
    PendingRoofReports: number
    ProjectNotes: number
  }

  export type ProjectCountOutputTypeSelect = {
    images?: boolean
    inferences?: boolean
    rooms?: boolean
    events?: boolean
    projectAssignees?: boolean
    roomReadings?: boolean
    AreaAffected?: boolean
    photoAccessLinks?: boolean
    notes?: boolean
    costs?: boolean
    projectEquipment?: boolean
    weatherReportItems?: boolean
    PendingRoofReports?: boolean
    ProjectNotes?: boolean
  }

  export type ProjectCountOutputTypeGetPayload<S extends boolean | null | undefined | ProjectCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProjectCountOutputTypeArgs)
    ? ProjectCountOutputType 
    : S extends { select: any } & (ProjectCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProjectCountOutputType ? ProjectCountOutputType[P] : never
  } 
      : ProjectCountOutputType




  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect | null
  }



  /**
   * Count Type ProjectStatusValueCountOutputType
   */


  export type ProjectStatusValueCountOutputType = {
    projects: number
  }

  export type ProjectStatusValueCountOutputTypeSelect = {
    projects?: boolean
  }

  export type ProjectStatusValueCountOutputTypeGetPayload<S extends boolean | null | undefined | ProjectStatusValueCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectStatusValueCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProjectStatusValueCountOutputTypeArgs)
    ? ProjectStatusValueCountOutputType 
    : S extends { select: any } & (ProjectStatusValueCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProjectStatusValueCountOutputType ? ProjectStatusValueCountOutputType[P] : never
  } 
      : ProjectStatusValueCountOutputType




  // Custom InputTypes

  /**
   * ProjectStatusValueCountOutputType without action
   */
  export type ProjectStatusValueCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValueCountOutputType
     */
    select?: ProjectStatusValueCountOutputTypeSelect | null
  }



  /**
   * Count Type ImageCountOutputType
   */


  export type ImageCountOutputType = {
    ImageNote: number
    Annotation: number
  }

  export type ImageCountOutputTypeSelect = {
    ImageNote?: boolean
    Annotation?: boolean
  }

  export type ImageCountOutputTypeGetPayload<S extends boolean | null | undefined | ImageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ImageCountOutputTypeArgs)
    ? ImageCountOutputType 
    : S extends { select: any } & (ImageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImageCountOutputType ? ImageCountOutputType[P] : never
  } 
      : ImageCountOutputType




  // Custom InputTypes

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect | null
  }



  /**
   * Count Type InferenceCountOutputType
   */


  export type InferenceCountOutputType = {
    detections: number
  }

  export type InferenceCountOutputTypeSelect = {
    detections?: boolean
  }

  export type InferenceCountOutputTypeGetPayload<S extends boolean | null | undefined | InferenceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InferenceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InferenceCountOutputTypeArgs)
    ? InferenceCountOutputType 
    : S extends { select: any } & (InferenceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InferenceCountOutputType ? InferenceCountOutputType[P] : never
  } 
      : InferenceCountOutputType




  // Custom InputTypes

  /**
   * InferenceCountOutputType without action
   */
  export type InferenceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InferenceCountOutputType
     */
    select?: InferenceCountOutputTypeSelect | null
  }



  /**
   * Count Type RoomCountOutputType
   */


  export type RoomCountOutputType = {
    detections: number
    inferences: number
    templates: number
    roomReadings: number
    areasAffected: number
    notes: number
  }

  export type RoomCountOutputTypeSelect = {
    detections?: boolean
    inferences?: boolean
    templates?: boolean
    roomReadings?: boolean
    areasAffected?: boolean
    notes?: boolean
  }

  export type RoomCountOutputTypeGetPayload<S extends boolean | null | undefined | RoomCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoomCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoomCountOutputTypeArgs)
    ? RoomCountOutputType 
    : S extends { select: any } & (RoomCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoomCountOutputType ? RoomCountOutputType[P] : never
  } 
      : RoomCountOutputType




  // Custom InputTypes

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect | null
  }



  /**
   * Count Type RoomReadingCountOutputType
   */


  export type RoomReadingCountOutputType = {
    genericRoomReadings: number
  }

  export type RoomReadingCountOutputTypeSelect = {
    genericRoomReadings?: boolean
  }

  export type RoomReadingCountOutputTypeGetPayload<S extends boolean | null | undefined | RoomReadingCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoomReadingCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoomReadingCountOutputTypeArgs)
    ? RoomReadingCountOutputType 
    : S extends { select: any } & (RoomReadingCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoomReadingCountOutputType ? RoomReadingCountOutputType[P] : never
  } 
      : RoomReadingCountOutputType




  // Custom InputTypes

  /**
   * RoomReadingCountOutputType without action
   */
  export type RoomReadingCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoomReadingCountOutputType
     */
    select?: RoomReadingCountOutputTypeSelect | null
  }



  /**
   * Count Type NotesCountOutputType
   */


  export type NotesCountOutputType = {
    notesAuditTrail: number
  }

  export type NotesCountOutputTypeSelect = {
    notesAuditTrail?: boolean
  }

  export type NotesCountOutputTypeGetPayload<S extends boolean | null | undefined | NotesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NotesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (NotesCountOutputTypeArgs)
    ? NotesCountOutputType 
    : S extends { select: any } & (NotesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof NotesCountOutputType ? NotesCountOutputType[P] : never
  } 
      : NotesCountOutputType




  // Custom InputTypes

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NotesCountOutputType
     */
    select?: NotesCountOutputTypeSelect | null
  }



  /**
   * Count Type CalendarEventCountOutputType
   */


  export type CalendarEventCountOutputType = {
    reminders: number
  }

  export type CalendarEventCountOutputTypeSelect = {
    reminders?: boolean
  }

  export type CalendarEventCountOutputTypeGetPayload<S extends boolean | null | undefined | CalendarEventCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CalendarEventCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CalendarEventCountOutputTypeArgs)
    ? CalendarEventCountOutputType 
    : S extends { select: any } & (CalendarEventCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CalendarEventCountOutputType ? CalendarEventCountOutputType[P] : never
  } 
      : CalendarEventCountOutputType




  // Custom InputTypes

  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventCountOutputType
     */
    select?: CalendarEventCountOutputTypeSelect | null
  }



  /**
   * Count Type ItemCategoryCountOutputType
   */


  export type ItemCategoryCountOutputType = {
    LineItem: number
  }

  export type ItemCategoryCountOutputTypeSelect = {
    LineItem?: boolean
  }

  export type ItemCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | ItemCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ItemCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ItemCategoryCountOutputTypeArgs)
    ? ItemCategoryCountOutputType 
    : S extends { select: any } & (ItemCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ItemCategoryCountOutputType ? ItemCategoryCountOutputType[P] : never
  } 
      : ItemCategoryCountOutputType




  // Custom InputTypes

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type LineItemCountOutputType
   */


  export type LineItemCountOutputType = {
    alternateItem: number
    relatedItem: number
  }

  export type LineItemCountOutputTypeSelect = {
    alternateItem?: boolean
    relatedItem?: boolean
  }

  export type LineItemCountOutputTypeGetPayload<S extends boolean | null | undefined | LineItemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LineItemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LineItemCountOutputTypeArgs)
    ? LineItemCountOutputType 
    : S extends { select: any } & (LineItemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LineItemCountOutputType ? LineItemCountOutputType[P] : never
  } 
      : LineItemCountOutputType




  // Custom InputTypes

  /**
   * LineItemCountOutputType without action
   */
  export type LineItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LineItemCountOutputType
     */
    select?: LineItemCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductsCountOutputType
   */


  export type ProductsCountOutputType = {
    prices: number
  }

  export type ProductsCountOutputTypeSelect = {
    prices?: boolean
  }

  export type ProductsCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductsCountOutputTypeArgs)
    ? ProductsCountOutputType 
    : S extends { select: any } & (ProductsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductsCountOutputType ? ProductsCountOutputType[P] : never
  } 
      : ProductsCountOutputType




  // Custom InputTypes

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect | null
  }



  /**
   * Count Type PricesCountOutputType
   */


  export type PricesCountOutputType = {
    Subscriptions: number
  }

  export type PricesCountOutputTypeSelect = {
    Subscriptions?: boolean
  }

  export type PricesCountOutputTypeGetPayload<S extends boolean | null | undefined | PricesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PricesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PricesCountOutputTypeArgs)
    ? PricesCountOutputType 
    : S extends { select: any } & (PricesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PricesCountOutputType ? PricesCountOutputType[P] : never
  } 
      : PricesCountOutputType




  // Custom InputTypes

  /**
   * PricesCountOutputType without action
   */
  export type PricesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PricesCountOutputType
     */
    select?: PricesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    email: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    inviteId: string | null
    isSupportUser: boolean | null
    hasSeenProductTour: boolean | null
    savedDashboardView: DashboardViews | null
    photoView: PhotoViews | null
    groupView: GroupByViews | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    email: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    inviteId: string | null
    isSupportUser: boolean | null
    hasSeenProductTour: boolean | null
    savedDashboardView: DashboardViews | null
    photoView: PhotoViews | null
    groupView: GroupByViews | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    email: number
    isDeleted: number
    updatedAt: number
    firstName: number
    lastName: number
    phone: number
    inviteId: number
    isSupportUser: number
    hasSeenProductTour: number
    productTourData: number
    savedDashboardView: number
    photoView: number
    groupView: number
    onboardingStatus: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    productTourData?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
    onboardingStatus?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    token: string | null
    createdAt: Date
    email: string
    isDeleted: boolean
    updatedAt: Date
    firstName: string
    lastName: string
    phone: string
    inviteId: string | null
    isSupportUser: boolean
    hasSeenProductTour: boolean
    productTourData: JsonValue | null
    savedDashboardView: DashboardViews
    photoView: PhotoViews
    groupView: GroupByViews
    onboardingStatus: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    email?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    inviteId?: boolean
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: boolean
    savedDashboardView?: boolean
    photoView?: boolean
    groupView?: boolean
    onboardingStatus?: boolean
    org?: boolean | UserToOrganizationArgs
    UserToProject?: boolean | User$UserToProjectArgs
    Notification?: boolean | User$NotificationArgs
    ImageNote?: boolean | User$ImageNoteArgs
    Annotation?: boolean | User$AnnotationArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    org?: boolean | UserToOrganizationArgs
    UserToProject?: boolean | User$UserToProjectArgs
    Notification?: boolean | User$NotificationArgs
    ImageNote?: boolean | User$ImageNoteArgs
    Annotation?: boolean | User$AnnotationArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'org' ? UserToOrganizationGetPayload<S['include'][P]> | null :
        P extends 'UserToProject' ? Array < UserToProjectGetPayload<S['include'][P]>>  :
        P extends 'Notification' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'ImageNote' ? Array < ImageNoteGetPayload<S['include'][P]>>  :
        P extends 'Annotation' ? Array < AnnotationGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'org' ? UserToOrganizationGetPayload<S['select'][P]> | null :
        P extends 'UserToProject' ? Array < UserToProjectGetPayload<S['select'][P]>>  :
        P extends 'Notification' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'ImageNote' ? Array < ImageNoteGetPayload<S['select'][P]>>  :
        P extends 'Annotation' ? Array < AnnotationGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    org<T extends UserToOrganizationArgs= {}>(args?: Subset<T, UserToOrganizationArgs>): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T> | Null>;

    UserToProject<T extends User$UserToProjectArgs= {}>(args?: Subset<T, User$UserToProjectArgs>): Prisma.PrismaPromise<Array<UserToProjectGetPayload<T>>| Null>;

    Notification<T extends User$NotificationArgs= {}>(args?: Subset<T, User$NotificationArgs>): Prisma.PrismaPromise<Array<NotificationGetPayload<T>>| Null>;

    ImageNote<T extends User$ImageNoteArgs= {}>(args?: Subset<T, User$ImageNoteArgs>): Prisma.PrismaPromise<Array<ImageNoteGetPayload<T>>| Null>;

    Annotation<T extends User$AnnotationArgs= {}>(args?: Subset<T, User$AnnotationArgs>): Prisma.PrismaPromise<Array<AnnotationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.UserToProject
   */
  export type User$UserToProjectArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    where?: UserToProjectWhereInput
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UserToProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToProjectScalarFieldEnum>
  }


  /**
   * User.Notification
   */
  export type User$NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * User.ImageNote
   */
  export type User$ImageNoteArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    where?: ImageNoteWhereInput
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ImageNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageNoteScalarFieldEnum>
  }


  /**
   * User.Annotation
   */
  export type User$AnnotationArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    where?: AnnotationWhereInput
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnnotationScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Organization
   */


  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    name: string | null
    address: string | null
    faxNumber: string | null
    size: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    logoId: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    name: string | null
    address: string | null
    faxNumber: string | null
    size: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    logoId: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    name: number
    address: number
    faxNumber: number
    size: number
    isDeleted: number
    updatedAt: number
    logoId: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
    _all?: true
  }

  export type OrganizationAggregateArgs = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs = {
    where?: OrganizationWhereInput
    orderBy?: Enumerable<OrganizationOrderByWithAggregationInput>
    by: OrganizationScalarFieldEnum[]
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }


  export type OrganizationGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    name: string
    address: string
    faxNumber: string
    size: string
    isDeleted: boolean
    updatedAt: Date
    logoId: string | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    name?: boolean
    address?: boolean
    faxNumber?: boolean
    size?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    logoId?: boolean
    Image?: boolean | Organization$ImageArgs
    invitations?: boolean | Organization$invitationsArgs
    projects?: boolean | Organization$projectsArgs
    users?: boolean | Organization$usersArgs
    Customers?: boolean | Organization$CustomersArgs
    Subscriptions?: boolean | Organization$SubscriptionsArgs
    OrganizationSavedOption?: boolean | Organization$OrganizationSavedOptionArgs
    equipment?: boolean | Organization$equipmentArgs
    ProjectStatusValue?: boolean | Organization$ProjectStatusValueArgs
    _count?: boolean | OrganizationCountOutputTypeArgs
  }


  export type OrganizationInclude = {
    Image?: boolean | Organization$ImageArgs
    invitations?: boolean | Organization$invitationsArgs
    projects?: boolean | Organization$projectsArgs
    users?: boolean | Organization$usersArgs
    Customers?: boolean | Organization$CustomersArgs
    Subscriptions?: boolean | Organization$SubscriptionsArgs
    OrganizationSavedOption?: boolean | Organization$OrganizationSavedOptionArgs
    equipment?: boolean | Organization$equipmentArgs
    ProjectStatusValue?: boolean | Organization$ProjectStatusValueArgs
    _count?: boolean | OrganizationCountOutputTypeArgs
  }

  export type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organization :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationArgs | OrganizationFindManyArgs)
    ? Organization  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Image' ? Array < ImageGetPayload<S['include'][P]>>  :
        P extends 'invitations' ? Array < OrganizationInvitationGetPayload<S['include'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < UserToOrganizationGetPayload<S['include'][P]>>  :
        P extends 'Customers' ? Array < CustomersGetPayload<S['include'][P]>>  :
        P extends 'Subscriptions' ? Array < SubscriptionsGetPayload<S['include'][P]>>  :
        P extends 'OrganizationSavedOption' ? Array < OrganizationSavedOptionGetPayload<S['include'][P]>>  :
        P extends 'equipment' ? Array < EquipmentGetPayload<S['include'][P]>>  :
        P extends 'ProjectStatusValue' ? Array < ProjectStatusValueGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrganizationArgs | OrganizationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Image' ? Array < ImageGetPayload<S['select'][P]>>  :
        P extends 'invitations' ? Array < OrganizationInvitationGetPayload<S['select'][P]>>  :
        P extends 'projects' ? Array < ProjectGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < UserToOrganizationGetPayload<S['select'][P]>>  :
        P extends 'Customers' ? Array < CustomersGetPayload<S['select'][P]>>  :
        P extends 'Subscriptions' ? Array < SubscriptionsGetPayload<S['select'][P]>>  :
        P extends 'OrganizationSavedOption' ? Array < OrganizationSavedOptionGetPayload<S['select'][P]>>  :
        P extends 'equipment' ? Array < EquipmentGetPayload<S['select'][P]>>  :
        P extends 'ProjectStatusValue' ? Array < ProjectStatusValueGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Organization ? Organization[P] : never
  } 
      : Organization


  type OrganizationCountArgs = 
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Organization'> extends True ? Prisma__OrganizationClient<OrganizationGetPayload<T>> : Prisma__OrganizationClient<OrganizationGetPayload<T> | null, null>

    /**
     * Find one Organization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Organization'> extends True ? Prisma__OrganizationClient<OrganizationGetPayload<T>> : Prisma__OrganizationClient<OrganizationGetPayload<T> | null, null>

    /**
     * Find the first Organization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrganizationGetPayload<T>>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs>
    ): Prisma__OrganizationClient<OrganizationGetPayload<T>>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Image<T extends Organization$ImageArgs= {}>(args?: Subset<T, Organization$ImageArgs>): Prisma.PrismaPromise<Array<ImageGetPayload<T>>| Null>;

    invitations<T extends Organization$invitationsArgs= {}>(args?: Subset<T, Organization$invitationsArgs>): Prisma.PrismaPromise<Array<OrganizationInvitationGetPayload<T>>| Null>;

    projects<T extends Organization$projectsArgs= {}>(args?: Subset<T, Organization$projectsArgs>): Prisma.PrismaPromise<Array<ProjectGetPayload<T>>| Null>;

    users<T extends Organization$usersArgs= {}>(args?: Subset<T, Organization$usersArgs>): Prisma.PrismaPromise<Array<UserToOrganizationGetPayload<T>>| Null>;

    Customers<T extends Organization$CustomersArgs= {}>(args?: Subset<T, Organization$CustomersArgs>): Prisma.PrismaPromise<Array<CustomersGetPayload<T>>| Null>;

    Subscriptions<T extends Organization$SubscriptionsArgs= {}>(args?: Subset<T, Organization$SubscriptionsArgs>): Prisma.PrismaPromise<Array<SubscriptionsGetPayload<T>>| Null>;

    OrganizationSavedOption<T extends Organization$OrganizationSavedOptionArgs= {}>(args?: Subset<T, Organization$OrganizationSavedOptionArgs>): Prisma.PrismaPromise<Array<OrganizationSavedOptionGetPayload<T>>| Null>;

    equipment<T extends Organization$equipmentArgs= {}>(args?: Subset<T, Organization$equipmentArgs>): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>| Null>;

    ProjectStatusValue<T extends Organization$ProjectStatusValueArgs= {}>(args?: Subset<T, Organization$ProjectStatusValueArgs>): Prisma.PrismaPromise<Array<ProjectStatusValueGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organization base type for findUnique actions
   */
  export type OrganizationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUnique
   */
  export interface OrganizationFindUniqueArgs extends OrganizationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization base type for findFirst actions
   */
  export type OrganizationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }

  /**
   * Organization findFirst
   */
  export interface OrganizationFindFirstArgs extends OrganizationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: Enumerable<OrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs = {
    /**
     * The data used to create many Organizations.
     */
    data: Enumerable<OrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization.Image
   */
  export type Organization$ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    where?: OrganizationInvitationWhereInput
    orderBy?: Enumerable<OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: OrganizationInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationInvitationScalarFieldEnum>
  }


  /**
   * Organization.projects
   */
  export type Organization$projectsArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Organization.users
   */
  export type Organization$usersArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    where?: UserToOrganizationWhereInput
    orderBy?: Enumerable<UserToOrganizationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UserToOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToOrganizationScalarFieldEnum>
  }


  /**
   * Organization.Customers
   */
  export type Organization$CustomersArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    where?: CustomersWhereInput
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Organization.Subscriptions
   */
  export type Organization$SubscriptionsArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    where?: SubscriptionsWhereInput
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionsScalarFieldEnum>
  }


  /**
   * Organization.OrganizationSavedOption
   */
  export type Organization$OrganizationSavedOptionArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    where?: OrganizationSavedOptionWhereInput
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: OrganizationSavedOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationSavedOptionScalarFieldEnum>
  }


  /**
   * Organization.equipment
   */
  export type Organization$equipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Organization.ProjectStatusValue
   */
  export type Organization$ProjectStatusValueArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    where?: ProjectStatusValueWhereInput
    orderBy?: Enumerable<ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectStatusValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectStatusValueScalarFieldEnum>
  }


  /**
   * Organization without action
   */
  export type OrganizationArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude | null
  }



  /**
   * Model Equipment
   */


  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    name: string | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    name: string | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    name: number
    quantity: number
    organizationId: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    id?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentSumAggregateInputType = {
    id?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
    _all?: true
  }

  export type EquipmentAggregateArgs = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs = {
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithAggregationInput>
    by: EquipmentScalarFieldEnum[]
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }


  export type EquipmentGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    name: string
    quantity: number
    organizationId: number
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    name?: boolean
    quantity?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
    ProjectEquipment?: boolean | Equipment$ProjectEquipmentArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }


  export type EquipmentInclude = {
    organization?: boolean | OrganizationArgs
    ProjectEquipment?: boolean | Equipment$ProjectEquipmentArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }

  export type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Equipment :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentArgs | EquipmentFindManyArgs)
    ? Equipment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends 'ProjectEquipment' ? Array < ProjectEquipmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EquipmentArgs | EquipmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends 'ProjectEquipment' ? Array < ProjectEquipmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Equipment ? Equipment[P] : never
  } 
      : Equipment


  type EquipmentCountArgs = 
    Omit<EquipmentFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EquipmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find one Equipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindUniqueOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EquipmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find the first Equipment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentFindManyArgs>(
      args?: SelectSubset<T, EquipmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
    **/
    create<T extends EquipmentCreateArgs>(
      args: SelectSubset<T, EquipmentCreateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Create many Equipment.
     *     @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     *     @example
     *     // Create many Equipment
     *     const equipment = await prisma.equipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentCreateManyArgs>(
      args?: SelectSubset<T, EquipmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentDeleteArgs>(
      args: SelectSubset<T, EquipmentDeleteArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentUpdateArgs>(
      args: SelectSubset<T, EquipmentUpdateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentDeleteManyArgs>(
      args?: SelectSubset<T, EquipmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentUpdateManyArgs>(
      args: SelectSubset<T, EquipmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentUpsertArgs>(
      args: SelectSubset<T, EquipmentUpsertArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EquipmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    ProjectEquipment<T extends Equipment$ProjectEquipmentArgs= {}>(args?: Subset<T, Equipment$ProjectEquipmentArgs>): Prisma.PrismaPromise<Array<ProjectEquipmentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Equipment base type for findUnique actions
   */
  export type EquipmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUnique
   */
  export interface EquipmentFindUniqueArgs extends EquipmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment base type for findFirst actions
   */
  export type EquipmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }

  /**
   * Equipment findFirst
   */
  export interface EquipmentFindFirstArgs extends EquipmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment create
   */
  export type EquipmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }


  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs = {
    /**
     * The data used to create many Equipment.
     */
    data: Enumerable<EquipmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }


  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment.ProjectEquipment
   */
  export type Equipment$ProjectEquipmentArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    where?: ProjectEquipmentWhereInput
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectEquipmentScalarFieldEnum>
  }


  /**
   * Equipment without action
   */
  export type EquipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    title: string | null
    content: string | null
    isSeen: boolean | null
    link: string | null
    linkText: string | null
    type: NotificationType | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    title: string | null
    content: string | null
    isSeen: boolean | null
    link: string | null
    linkText: string | null
    type: NotificationType | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    title: number
    content: number
    isSeen: number
    link: number
    linkText: number
    type: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    title: string
    content: string
    isSeen: boolean
    link: string | null
    linkText: string | null
    type: NotificationType
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    title?: boolean
    content?: boolean
    isSeen?: boolean
    link?: boolean
    linkText?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }


  export type NotificationInclude = {
    user?: boolean | UserArgs
  }

  export type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notification :
    S extends undefined ? never :
    S extends { include: any } & (NotificationArgs | NotificationFindManyArgs)
    ? Notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NotificationArgs | NotificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Notification ? Notification[P] : never
  } 
      : Notification


  type NotificationCountArgs = 
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): Prisma.PrismaPromise<Array<NotificationGetPayload<T>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs extends NotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs extends NotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     */
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude | null
  }



  /**
   * Model OrganizationSavedOption
   */


  export type AggregateOrganizationSavedOption = {
    _count: OrganizationSavedOptionCountAggregateOutputType | null
    _avg: OrganizationSavedOptionAvgAggregateOutputType | null
    _sum: OrganizationSavedOptionSumAggregateOutputType | null
    _min: OrganizationSavedOptionMinAggregateOutputType | null
    _max: OrganizationSavedOptionMaxAggregateOutputType | null
  }

  export type OrganizationSavedOptionAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    label: string | null
    value: string | null
    isDeleted: boolean | null
    type: SavedOptionType | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    label: string | null
    value: string | null
    isDeleted: boolean | null
    type: SavedOptionType | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    label: number
    value: number
    isDeleted: number
    type: number
    organizationId: number
    _all: number
  }


  export type OrganizationSavedOptionAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
    _all?: true
  }

  export type OrganizationSavedOptionAggregateArgs = {
    /**
     * Filter which OrganizationSavedOption to aggregate.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationSavedOptions
    **/
    _count?: true | OrganizationSavedOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationSavedOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSavedOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationSavedOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationSavedOptionMaxAggregateInputType
  }

  export type GetOrganizationSavedOptionAggregateType<T extends OrganizationSavedOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationSavedOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationSavedOption[P]>
      : GetScalarType<T[P], AggregateOrganizationSavedOption[P]>
  }




  export type OrganizationSavedOptionGroupByArgs = {
    where?: OrganizationSavedOptionWhereInput
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithAggregationInput>
    by: OrganizationSavedOptionScalarFieldEnum[]
    having?: OrganizationSavedOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationSavedOptionCountAggregateInputType | true
    _avg?: OrganizationSavedOptionAvgAggregateInputType
    _sum?: OrganizationSavedOptionSumAggregateInputType
    _min?: OrganizationSavedOptionMinAggregateInputType
    _max?: OrganizationSavedOptionMaxAggregateInputType
  }


  export type OrganizationSavedOptionGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    label: string
    value: string
    isDeleted: boolean
    type: SavedOptionType
    organizationId: number
    _count: OrganizationSavedOptionCountAggregateOutputType | null
    _avg: OrganizationSavedOptionAvgAggregateOutputType | null
    _sum: OrganizationSavedOptionSumAggregateOutputType | null
    _min: OrganizationSavedOptionMinAggregateOutputType | null
    _max: OrganizationSavedOptionMaxAggregateOutputType | null
  }

  type GetOrganizationSavedOptionGroupByPayload<T extends OrganizationSavedOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationSavedOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationSavedOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationSavedOptionGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationSavedOptionGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSavedOptionSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    label?: boolean
    value?: boolean
    isDeleted?: boolean
    type?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
  }


  export type OrganizationSavedOptionInclude = {
    organization?: boolean | OrganizationArgs
  }

  export type OrganizationSavedOptionGetPayload<S extends boolean | null | undefined | OrganizationSavedOptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationSavedOption :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationSavedOptionArgs | OrganizationSavedOptionFindManyArgs)
    ? OrganizationSavedOption  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrganizationSavedOptionArgs | OrganizationSavedOptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :  P extends keyof OrganizationSavedOption ? OrganizationSavedOption[P] : never
  } 
      : OrganizationSavedOption


  type OrganizationSavedOptionCountArgs = 
    Omit<OrganizationSavedOptionFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationSavedOptionCountAggregateInputType | true
    }

  export interface OrganizationSavedOptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OrganizationSavedOption that matches the filter.
     * @param {OrganizationSavedOptionFindUniqueArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationSavedOptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationSavedOptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrganizationSavedOption'> extends True ? Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>> : Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T> | null, null>

    /**
     * Find one OrganizationSavedOption that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationSavedOptionFindUniqueOrThrowArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationSavedOptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrganizationSavedOptionFindUniqueOrThrowArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Find the first OrganizationSavedOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindFirstArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationSavedOptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationSavedOptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrganizationSavedOption'> extends True ? Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>> : Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T> | null, null>

    /**
     * Find the first OrganizationSavedOption that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindFirstOrThrowArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationSavedOptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationSavedOptionFindFirstOrThrowArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Find zero or more OrganizationSavedOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationSavedOptions
     * const organizationSavedOptions = await prisma.organizationSavedOption.findMany()
     * 
     * // Get first 10 OrganizationSavedOptions
     * const organizationSavedOptions = await prisma.organizationSavedOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationSavedOptionWithIdOnly = await prisma.organizationSavedOption.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationSavedOptionFindManyArgs>(
      args?: SelectSubset<T, OrganizationSavedOptionFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrganizationSavedOptionGetPayload<T>>>

    /**
     * Create a OrganizationSavedOption.
     * @param {OrganizationSavedOptionCreateArgs} args - Arguments to create a OrganizationSavedOption.
     * @example
     * // Create one OrganizationSavedOption
     * const OrganizationSavedOption = await prisma.organizationSavedOption.create({
     *   data: {
     *     // ... data to create a OrganizationSavedOption
     *   }
     * })
     * 
    **/
    create<T extends OrganizationSavedOptionCreateArgs>(
      args: SelectSubset<T, OrganizationSavedOptionCreateArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Create many OrganizationSavedOptions.
     *     @param {OrganizationSavedOptionCreateManyArgs} args - Arguments to create many OrganizationSavedOptions.
     *     @example
     *     // Create many OrganizationSavedOptions
     *     const organizationSavedOption = await prisma.organizationSavedOption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationSavedOptionCreateManyArgs>(
      args?: SelectSubset<T, OrganizationSavedOptionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationSavedOption.
     * @param {OrganizationSavedOptionDeleteArgs} args - Arguments to delete one OrganizationSavedOption.
     * @example
     * // Delete one OrganizationSavedOption
     * const OrganizationSavedOption = await prisma.organizationSavedOption.delete({
     *   where: {
     *     // ... filter to delete one OrganizationSavedOption
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationSavedOptionDeleteArgs>(
      args: SelectSubset<T, OrganizationSavedOptionDeleteArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Update one OrganizationSavedOption.
     * @param {OrganizationSavedOptionUpdateArgs} args - Arguments to update one OrganizationSavedOption.
     * @example
     * // Update one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationSavedOptionUpdateArgs>(
      args: SelectSubset<T, OrganizationSavedOptionUpdateArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Delete zero or more OrganizationSavedOptions.
     * @param {OrganizationSavedOptionDeleteManyArgs} args - Arguments to filter OrganizationSavedOptions to delete.
     * @example
     * // Delete a few OrganizationSavedOptions
     * const { count } = await prisma.organizationSavedOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationSavedOptionDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationSavedOptionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationSavedOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationSavedOptions
     * const organizationSavedOption = await prisma.organizationSavedOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationSavedOptionUpdateManyArgs>(
      args: SelectSubset<T, OrganizationSavedOptionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationSavedOption.
     * @param {OrganizationSavedOptionUpsertArgs} args - Arguments to update or create a OrganizationSavedOption.
     * @example
     * // Update or create a OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.upsert({
     *   create: {
     *     // ... data to create a OrganizationSavedOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationSavedOption we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationSavedOptionUpsertArgs>(
      args: SelectSubset<T, OrganizationSavedOptionUpsertArgs>
    ): Prisma__OrganizationSavedOptionClient<OrganizationSavedOptionGetPayload<T>>

    /**
     * Count the number of OrganizationSavedOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionCountArgs} args - Arguments to filter OrganizationSavedOptions to count.
     * @example
     * // Count the number of OrganizationSavedOptions
     * const count = await prisma.organizationSavedOption.count({
     *   where: {
     *     // ... the filter for the OrganizationSavedOptions we want to count
     *   }
     * })
    **/
    count<T extends OrganizationSavedOptionCountArgs>(
      args?: Subset<T, OrganizationSavedOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationSavedOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationSavedOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationSavedOptionAggregateArgs>(args: Subset<T, OrganizationSavedOptionAggregateArgs>): Prisma.PrismaPromise<GetOrganizationSavedOptionAggregateType<T>>

    /**
     * Group by OrganizationSavedOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationSavedOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationSavedOptionGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationSavedOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationSavedOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationSavedOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationSavedOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationSavedOptionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrganizationSavedOption base type for findUnique actions
   */
  export type OrganizationSavedOptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }

  /**
   * OrganizationSavedOption findUnique
   */
  export interface OrganizationSavedOptionFindUniqueArgs extends OrganizationSavedOptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationSavedOption findUniqueOrThrow
   */
  export type OrganizationSavedOptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }


  /**
   * OrganizationSavedOption base type for findFirst actions
   */
  export type OrganizationSavedOptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSavedOptions.
     */
    distinct?: Enumerable<OrganizationSavedOptionScalarFieldEnum>
  }

  /**
   * OrganizationSavedOption findFirst
   */
  export interface OrganizationSavedOptionFindFirstArgs extends OrganizationSavedOptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationSavedOption findFirstOrThrow
   */
  export type OrganizationSavedOptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSavedOptions.
     */
    distinct?: Enumerable<OrganizationSavedOptionScalarFieldEnum>
  }


  /**
   * OrganizationSavedOption findMany
   */
  export type OrganizationSavedOptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter, which OrganizationSavedOptions to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: Enumerable<OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    distinct?: Enumerable<OrganizationSavedOptionScalarFieldEnum>
  }


  /**
   * OrganizationSavedOption create
   */
  export type OrganizationSavedOptionCreateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * The data needed to create a OrganizationSavedOption.
     */
    data: XOR<OrganizationSavedOptionCreateInput, OrganizationSavedOptionUncheckedCreateInput>
  }


  /**
   * OrganizationSavedOption createMany
   */
  export type OrganizationSavedOptionCreateManyArgs = {
    /**
     * The data used to create many OrganizationSavedOptions.
     */
    data: Enumerable<OrganizationSavedOptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrganizationSavedOption update
   */
  export type OrganizationSavedOptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * The data needed to update a OrganizationSavedOption.
     */
    data: XOR<OrganizationSavedOptionUpdateInput, OrganizationSavedOptionUncheckedUpdateInput>
    /**
     * Choose, which OrganizationSavedOption to update.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }


  /**
   * OrganizationSavedOption updateMany
   */
  export type OrganizationSavedOptionUpdateManyArgs = {
    /**
     * The data used to update OrganizationSavedOptions.
     */
    data: XOR<OrganizationSavedOptionUpdateManyMutationInput, OrganizationSavedOptionUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationSavedOptions to update
     */
    where?: OrganizationSavedOptionWhereInput
  }


  /**
   * OrganizationSavedOption upsert
   */
  export type OrganizationSavedOptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * The filter to search for the OrganizationSavedOption to update in case it exists.
     */
    where: OrganizationSavedOptionWhereUniqueInput
    /**
     * In case the OrganizationSavedOption found by the `where` argument doesn't exist, create a new OrganizationSavedOption with this data.
     */
    create: XOR<OrganizationSavedOptionCreateInput, OrganizationSavedOptionUncheckedCreateInput>
    /**
     * In case the OrganizationSavedOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationSavedOptionUpdateInput, OrganizationSavedOptionUncheckedUpdateInput>
  }


  /**
   * OrganizationSavedOption delete
   */
  export type OrganizationSavedOptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
    /**
     * Filter which OrganizationSavedOption to delete.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }


  /**
   * OrganizationSavedOption deleteMany
   */
  export type OrganizationSavedOptionDeleteManyArgs = {
    /**
     * Filter which OrganizationSavedOptions to delete
     */
    where?: OrganizationSavedOptionWhereInput
  }


  /**
   * OrganizationSavedOption without action
   */
  export type OrganizationSavedOptionArgs = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSavedOptionInclude | null
  }



  /**
   * Model UserToOrganization
   */


  export type AggregateUserToOrganization = {
    _count: UserToOrganizationCountAggregateOutputType | null
    _avg: UserToOrganizationAvgAggregateOutputType | null
    _sum: UserToOrganizationSumAggregateOutputType | null
    _min: UserToOrganizationMinAggregateOutputType | null
    _max: UserToOrganizationMaxAggregateOutputType | null
  }

  export type UserToOrganizationAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserToOrganizationSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserToOrganizationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    organizationId: number | null
    role: string | null
    accessLevel: AccessLevel | null
    userId: string | null
  }

  export type UserToOrganizationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    organizationId: number | null
    role: string | null
    accessLevel: AccessLevel | null
    userId: string | null
  }

  export type UserToOrganizationCountAggregateOutputType = {
    id: number
    createdAt: number
    isAdmin: number
    isDeleted: number
    organizationId: number
    role: number
    accessLevel: number
    userId: number
    _all: number
  }


  export type UserToOrganizationAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserToOrganizationSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserToOrganizationMinAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
  }

  export type UserToOrganizationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
  }

  export type UserToOrganizationCountAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
    _all?: true
  }

  export type UserToOrganizationAggregateArgs = {
    /**
     * Filter which UserToOrganization to aggregate.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: Enumerable<UserToOrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToOrganizations
    **/
    _count?: true | UserToOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToOrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToOrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToOrganizationMaxAggregateInputType
  }

  export type GetUserToOrganizationAggregateType<T extends UserToOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToOrganization[P]>
      : GetScalarType<T[P], AggregateUserToOrganization[P]>
  }




  export type UserToOrganizationGroupByArgs = {
    where?: UserToOrganizationWhereInput
    orderBy?: Enumerable<UserToOrganizationOrderByWithAggregationInput>
    by: UserToOrganizationScalarFieldEnum[]
    having?: UserToOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToOrganizationCountAggregateInputType | true
    _avg?: UserToOrganizationAvgAggregateInputType
    _sum?: UserToOrganizationSumAggregateInputType
    _min?: UserToOrganizationMinAggregateInputType
    _max?: UserToOrganizationMaxAggregateInputType
  }


  export type UserToOrganizationGroupByOutputType = {
    id: number
    createdAt: Date
    isAdmin: boolean
    isDeleted: boolean
    organizationId: number
    role: string | null
    accessLevel: AccessLevel | null
    userId: string
    _count: UserToOrganizationCountAggregateOutputType | null
    _avg: UserToOrganizationAvgAggregateOutputType | null
    _sum: UserToOrganizationSumAggregateOutputType | null
    _min: UserToOrganizationMinAggregateOutputType | null
    _max: UserToOrganizationMaxAggregateOutputType | null
  }

  type GetUserToOrganizationGroupByPayload<T extends UserToOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], UserToOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type UserToOrganizationSelect = {
    id?: boolean
    createdAt?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    role?: boolean
    accessLevel?: boolean
    userId?: boolean
    organization?: boolean | OrganizationArgs
    user?: boolean | UserArgs
  }


  export type UserToOrganizationInclude = {
    organization?: boolean | OrganizationArgs
    user?: boolean | UserArgs
  }

  export type UserToOrganizationGetPayload<S extends boolean | null | undefined | UserToOrganizationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToOrganization :
    S extends undefined ? never :
    S extends { include: any } & (UserToOrganizationArgs | UserToOrganizationFindManyArgs)
    ? UserToOrganization  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToOrganizationArgs | UserToOrganizationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserToOrganization ? UserToOrganization[P] : never
  } 
      : UserToOrganization


  type UserToOrganizationCountArgs = 
    Omit<UserToOrganizationFindManyArgs, 'select' | 'include'> & {
      select?: UserToOrganizationCountAggregateInputType | true
    }

  export interface UserToOrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToOrganization that matches the filter.
     * @param {UserToOrganizationFindUniqueArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToOrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToOrganizationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToOrganization'> extends True ? Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>> : Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T> | null, null>

    /**
     * Find one UserToOrganization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToOrganizationFindUniqueOrThrowArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToOrganizationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToOrganizationFindUniqueOrThrowArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Find the first UserToOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindFirstArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToOrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToOrganizationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToOrganization'> extends True ? Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>> : Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T> | null, null>

    /**
     * Find the first UserToOrganization that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindFirstOrThrowArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToOrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToOrganizationFindFirstOrThrowArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Find zero or more UserToOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToOrganizations
     * const userToOrganizations = await prisma.userToOrganization.findMany()
     * 
     * // Get first 10 UserToOrganizations
     * const userToOrganizations = await prisma.userToOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToOrganizationWithIdOnly = await prisma.userToOrganization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToOrganizationFindManyArgs>(
      args?: SelectSubset<T, UserToOrganizationFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToOrganizationGetPayload<T>>>

    /**
     * Create a UserToOrganization.
     * @param {UserToOrganizationCreateArgs} args - Arguments to create a UserToOrganization.
     * @example
     * // Create one UserToOrganization
     * const UserToOrganization = await prisma.userToOrganization.create({
     *   data: {
     *     // ... data to create a UserToOrganization
     *   }
     * })
     * 
    **/
    create<T extends UserToOrganizationCreateArgs>(
      args: SelectSubset<T, UserToOrganizationCreateArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Create many UserToOrganizations.
     *     @param {UserToOrganizationCreateManyArgs} args - Arguments to create many UserToOrganizations.
     *     @example
     *     // Create many UserToOrganizations
     *     const userToOrganization = await prisma.userToOrganization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToOrganizationCreateManyArgs>(
      args?: SelectSubset<T, UserToOrganizationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToOrganization.
     * @param {UserToOrganizationDeleteArgs} args - Arguments to delete one UserToOrganization.
     * @example
     * // Delete one UserToOrganization
     * const UserToOrganization = await prisma.userToOrganization.delete({
     *   where: {
     *     // ... filter to delete one UserToOrganization
     *   }
     * })
     * 
    **/
    delete<T extends UserToOrganizationDeleteArgs>(
      args: SelectSubset<T, UserToOrganizationDeleteArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Update one UserToOrganization.
     * @param {UserToOrganizationUpdateArgs} args - Arguments to update one UserToOrganization.
     * @example
     * // Update one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToOrganizationUpdateArgs>(
      args: SelectSubset<T, UserToOrganizationUpdateArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Delete zero or more UserToOrganizations.
     * @param {UserToOrganizationDeleteManyArgs} args - Arguments to filter UserToOrganizations to delete.
     * @example
     * // Delete a few UserToOrganizations
     * const { count } = await prisma.userToOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToOrganizationDeleteManyArgs>(
      args?: SelectSubset<T, UserToOrganizationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToOrganizations
     * const userToOrganization = await prisma.userToOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToOrganizationUpdateManyArgs>(
      args: SelectSubset<T, UserToOrganizationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToOrganization.
     * @param {UserToOrganizationUpsertArgs} args - Arguments to update or create a UserToOrganization.
     * @example
     * // Update or create a UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.upsert({
     *   create: {
     *     // ... data to create a UserToOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToOrganization we want to update
     *   }
     * })
    **/
    upsert<T extends UserToOrganizationUpsertArgs>(
      args: SelectSubset<T, UserToOrganizationUpsertArgs>
    ): Prisma__UserToOrganizationClient<UserToOrganizationGetPayload<T>>

    /**
     * Count the number of UserToOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationCountArgs} args - Arguments to filter UserToOrganizations to count.
     * @example
     * // Count the number of UserToOrganizations
     * const count = await prisma.userToOrganization.count({
     *   where: {
     *     // ... the filter for the UserToOrganizations we want to count
     *   }
     * })
    **/
    count<T extends UserToOrganizationCountArgs>(
      args?: Subset<T, UserToOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToOrganizationAggregateArgs>(args: Subset<T, UserToOrganizationAggregateArgs>): Prisma.PrismaPromise<GetUserToOrganizationAggregateType<T>>

    /**
     * Group by UserToOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: UserToOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToOrganizationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToOrganization base type for findUnique actions
   */
  export type UserToOrganizationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where: UserToOrganizationWhereUniqueInput
  }

  /**
   * UserToOrganization findUnique
   */
  export interface UserToOrganizationFindUniqueArgs extends UserToOrganizationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToOrganization findUniqueOrThrow
   */
  export type UserToOrganizationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where: UserToOrganizationWhereUniqueInput
  }


  /**
   * UserToOrganization base type for findFirst actions
   */
  export type UserToOrganizationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: Enumerable<UserToOrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToOrganizations.
     */
    distinct?: Enumerable<UserToOrganizationScalarFieldEnum>
  }

  /**
   * UserToOrganization findFirst
   */
  export interface UserToOrganizationFindFirstArgs extends UserToOrganizationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToOrganization findFirstOrThrow
   */
  export type UserToOrganizationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: Enumerable<UserToOrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToOrganizations.
     */
    distinct?: Enumerable<UserToOrganizationScalarFieldEnum>
  }


  /**
   * UserToOrganization findMany
   */
  export type UserToOrganizationFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter, which UserToOrganizations to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: Enumerable<UserToOrganizationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    distinct?: Enumerable<UserToOrganizationScalarFieldEnum>
  }


  /**
   * UserToOrganization create
   */
  export type UserToOrganizationCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * The data needed to create a UserToOrganization.
     */
    data: XOR<UserToOrganizationCreateInput, UserToOrganizationUncheckedCreateInput>
  }


  /**
   * UserToOrganization createMany
   */
  export type UserToOrganizationCreateManyArgs = {
    /**
     * The data used to create many UserToOrganizations.
     */
    data: Enumerable<UserToOrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToOrganization update
   */
  export type UserToOrganizationUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * The data needed to update a UserToOrganization.
     */
    data: XOR<UserToOrganizationUpdateInput, UserToOrganizationUncheckedUpdateInput>
    /**
     * Choose, which UserToOrganization to update.
     */
    where: UserToOrganizationWhereUniqueInput
  }


  /**
   * UserToOrganization updateMany
   */
  export type UserToOrganizationUpdateManyArgs = {
    /**
     * The data used to update UserToOrganizations.
     */
    data: XOR<UserToOrganizationUpdateManyMutationInput, UserToOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserToOrganizations to update
     */
    where?: UserToOrganizationWhereInput
  }


  /**
   * UserToOrganization upsert
   */
  export type UserToOrganizationUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * The filter to search for the UserToOrganization to update in case it exists.
     */
    where: UserToOrganizationWhereUniqueInput
    /**
     * In case the UserToOrganization found by the `where` argument doesn't exist, create a new UserToOrganization with this data.
     */
    create: XOR<UserToOrganizationCreateInput, UserToOrganizationUncheckedCreateInput>
    /**
     * In case the UserToOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToOrganizationUpdateInput, UserToOrganizationUncheckedUpdateInput>
  }


  /**
   * UserToOrganization delete
   */
  export type UserToOrganizationDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
    /**
     * Filter which UserToOrganization to delete.
     */
    where: UserToOrganizationWhereUniqueInput
  }


  /**
   * UserToOrganization deleteMany
   */
  export type UserToOrganizationDeleteManyArgs = {
    /**
     * Filter which UserToOrganizations to delete
     */
    where?: UserToOrganizationWhereInput
  }


  /**
   * UserToOrganization without action
   */
  export type UserToOrganizationArgs = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToOrganizationInclude | null
  }



  /**
   * Model OrganizationInvitation
   */


  export type AggregateOrganizationInvitation = {
    _count: OrganizationInvitationCountAggregateOutputType | null
    _avg: OrganizationInvitationAvgAggregateOutputType | null
    _sum: OrganizationInvitationSumAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  export type OrganizationInvitationAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationInvitationSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationInvitationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    email: string | null
    invitationId: string | null
    isAccepted: boolean | null
  }

  export type OrganizationInvitationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    email: string | null
    invitationId: string | null
    isAccepted: boolean | null
  }

  export type OrganizationInvitationCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    organizationId: number
    email: number
    invitationId: number
    isAccepted: number
    _all: number
  }


  export type OrganizationInvitationAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationInvitationSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationInvitationMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
  }

  export type OrganizationInvitationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
  }

  export type OrganizationInvitationCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
    _all?: true
  }

  export type OrganizationInvitationAggregateArgs = {
    /**
     * Filter which OrganizationInvitation to aggregate.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: Enumerable<OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationInvitations
    **/
    _count?: true | OrganizationInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationInvitationMaxAggregateInputType
  }

  export type GetOrganizationInvitationAggregateType<T extends OrganizationInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
      : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
  }




  export type OrganizationInvitationGroupByArgs = {
    where?: OrganizationInvitationWhereInput
    orderBy?: Enumerable<OrganizationInvitationOrderByWithAggregationInput>
    by: OrganizationInvitationScalarFieldEnum[]
    having?: OrganizationInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationInvitationCountAggregateInputType | true
    _avg?: OrganizationInvitationAvgAggregateInputType
    _sum?: OrganizationInvitationSumAggregateInputType
    _min?: OrganizationInvitationMinAggregateInputType
    _max?: OrganizationInvitationMaxAggregateInputType
  }


  export type OrganizationInvitationGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted: boolean
    _count: OrganizationInvitationCountAggregateOutputType | null
    _avg: OrganizationInvitationAvgAggregateOutputType | null
    _sum: OrganizationInvitationSumAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  type GetOrganizationInvitationGroupByPayload<T extends OrganizationInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationInvitationSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    email?: boolean
    invitationId?: boolean
    isAccepted?: boolean
    organization?: boolean | OrganizationArgs
  }


  export type OrganizationInvitationInclude = {
    organization?: boolean | OrganizationArgs
  }

  export type OrganizationInvitationGetPayload<S extends boolean | null | undefined | OrganizationInvitationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationInvitation :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationInvitationArgs | OrganizationInvitationFindManyArgs)
    ? OrganizationInvitation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrganizationInvitationArgs | OrganizationInvitationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :  P extends keyof OrganizationInvitation ? OrganizationInvitation[P] : never
  } 
      : OrganizationInvitation


  type OrganizationInvitationCountArgs = 
    Omit<OrganizationInvitationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationInvitationCountAggregateInputType | true
    }

  export interface OrganizationInvitationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OrganizationInvitation that matches the filter.
     * @param {OrganizationInvitationFindUniqueArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationInvitationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationInvitationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrganizationInvitation'> extends True ? Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>> : Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T> | null, null>

    /**
     * Find one OrganizationInvitation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationInvitationFindUniqueOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationInvitationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrganizationInvitationFindUniqueOrThrowArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Find the first OrganizationInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationInvitationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationInvitationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrganizationInvitation'> extends True ? Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>> : Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T> | null, null>

    /**
     * Find the first OrganizationInvitation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationInvitationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationInvitationFindFirstOrThrowArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Find zero or more OrganizationInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany()
     * 
     * // Get first 10 OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationInvitationFindManyArgs>(
      args?: SelectSubset<T, OrganizationInvitationFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrganizationInvitationGetPayload<T>>>

    /**
     * Create a OrganizationInvitation.
     * @param {OrganizationInvitationCreateArgs} args - Arguments to create a OrganizationInvitation.
     * @example
     * // Create one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.create({
     *   data: {
     *     // ... data to create a OrganizationInvitation
     *   }
     * })
     * 
    **/
    create<T extends OrganizationInvitationCreateArgs>(
      args: SelectSubset<T, OrganizationInvitationCreateArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Create many OrganizationInvitations.
     *     @param {OrganizationInvitationCreateManyArgs} args - Arguments to create many OrganizationInvitations.
     *     @example
     *     // Create many OrganizationInvitations
     *     const organizationInvitation = await prisma.organizationInvitation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationInvitationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationInvitationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationInvitation.
     * @param {OrganizationInvitationDeleteArgs} args - Arguments to delete one OrganizationInvitation.
     * @example
     * // Delete one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.delete({
     *   where: {
     *     // ... filter to delete one OrganizationInvitation
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationInvitationDeleteArgs>(
      args: SelectSubset<T, OrganizationInvitationDeleteArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Update one OrganizationInvitation.
     * @param {OrganizationInvitationUpdateArgs} args - Arguments to update one OrganizationInvitation.
     * @example
     * // Update one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationInvitationUpdateArgs>(
      args: SelectSubset<T, OrganizationInvitationUpdateArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Delete zero or more OrganizationInvitations.
     * @param {OrganizationInvitationDeleteManyArgs} args - Arguments to filter OrganizationInvitations to delete.
     * @example
     * // Delete a few OrganizationInvitations
     * const { count } = await prisma.organizationInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationInvitationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationInvitationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationInvitationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationInvitationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationInvitation.
     * @param {OrganizationInvitationUpsertArgs} args - Arguments to update or create a OrganizationInvitation.
     * @example
     * // Update or create a OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.upsert({
     *   create: {
     *     // ... data to create a OrganizationInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationInvitation we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationInvitationUpsertArgs>(
      args: SelectSubset<T, OrganizationInvitationUpsertArgs>
    ): Prisma__OrganizationInvitationClient<OrganizationInvitationGetPayload<T>>

    /**
     * Count the number of OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationCountArgs} args - Arguments to filter OrganizationInvitations to count.
     * @example
     * // Count the number of OrganizationInvitations
     * const count = await prisma.organizationInvitation.count({
     *   where: {
     *     // ... the filter for the OrganizationInvitations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationInvitationCountArgs>(
      args?: Subset<T, OrganizationInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationInvitationAggregateArgs>(args: Subset<T, OrganizationInvitationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationInvitationAggregateType<T>>

    /**
     * Group by OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationInvitationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationInvitationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrganizationInvitation base type for findUnique actions
   */
  export type OrganizationInvitationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation findUnique
   */
  export interface OrganizationInvitationFindUniqueArgs extends OrganizationInvitationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationInvitation findUniqueOrThrow
   */
  export type OrganizationInvitationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }


  /**
   * OrganizationInvitation base type for findFirst actions
   */
  export type OrganizationInvitationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: Enumerable<OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: Enumerable<OrganizationInvitationScalarFieldEnum>
  }

  /**
   * OrganizationInvitation findFirst
   */
  export interface OrganizationInvitationFindFirstArgs extends OrganizationInvitationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrganizationInvitation findFirstOrThrow
   */
  export type OrganizationInvitationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: Enumerable<OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: Enumerable<OrganizationInvitationScalarFieldEnum>
  }


  /**
   * OrganizationInvitation findMany
   */
  export type OrganizationInvitationFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter, which OrganizationInvitations to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: Enumerable<OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    distinct?: Enumerable<OrganizationInvitationScalarFieldEnum>
  }


  /**
   * OrganizationInvitation create
   */
  export type OrganizationInvitationCreateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * The data needed to create a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
  }


  /**
   * OrganizationInvitation createMany
   */
  export type OrganizationInvitationCreateManyArgs = {
    /**
     * The data used to create many OrganizationInvitations.
     */
    data: Enumerable<OrganizationInvitationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrganizationInvitation update
   */
  export type OrganizationInvitationUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * The data needed to update a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
    /**
     * Choose, which OrganizationInvitation to update.
     */
    where: OrganizationInvitationWhereUniqueInput
  }


  /**
   * OrganizationInvitation updateMany
   */
  export type OrganizationInvitationUpdateManyArgs = {
    /**
     * The data used to update OrganizationInvitations.
     */
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationInvitations to update
     */
    where?: OrganizationInvitationWhereInput
  }


  /**
   * OrganizationInvitation upsert
   */
  export type OrganizationInvitationUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * The filter to search for the OrganizationInvitation to update in case it exists.
     */
    where: OrganizationInvitationWhereUniqueInput
    /**
     * In case the OrganizationInvitation found by the `where` argument doesn't exist, create a new OrganizationInvitation with this data.
     */
    create: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
    /**
     * In case the OrganizationInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
  }


  /**
   * OrganizationInvitation delete
   */
  export type OrganizationInvitationDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
    /**
     * Filter which OrganizationInvitation to delete.
     */
    where: OrganizationInvitationWhereUniqueInput
  }


  /**
   * OrganizationInvitation deleteMany
   */
  export type OrganizationInvitationDeleteManyArgs = {
    /**
     * Filter which OrganizationInvitations to delete
     */
    where?: OrganizationInvitationWhereInput
  }


  /**
   * OrganizationInvitation without action
   */
  export type OrganizationInvitationArgs = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInvitationInclude | null
  }



  /**
   * Model UserToProject
   */


  export type AggregateUserToProject = {
    _count: UserToProjectCountAggregateOutputType | null
    _avg: UserToProjectAvgAggregateOutputType | null
    _sum: UserToProjectSumAggregateOutputType | null
    _min: UserToProjectMinAggregateOutputType | null
    _max: UserToProjectMaxAggregateOutputType | null
  }

  export type UserToProjectAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type UserToProjectSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type UserToProjectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    projectId: number | null
  }

  export type UserToProjectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    projectId: number | null
  }

  export type UserToProjectCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    projectId: number
    _all: number
  }


  export type UserToProjectAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type UserToProjectSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type UserToProjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
  }

  export type UserToProjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
  }

  export type UserToProjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
    _all?: true
  }

  export type UserToProjectAggregateArgs = {
    /**
     * Filter which UserToProject to aggregate.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToProjects
    **/
    _count?: true | UserToProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToProjectMaxAggregateInputType
  }

  export type GetUserToProjectAggregateType<T extends UserToProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToProject[P]>
      : GetScalarType<T[P], AggregateUserToProject[P]>
  }




  export type UserToProjectGroupByArgs = {
    where?: UserToProjectWhereInput
    orderBy?: Enumerable<UserToProjectOrderByWithAggregationInput>
    by: UserToProjectScalarFieldEnum[]
    having?: UserToProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToProjectCountAggregateInputType | true
    _avg?: UserToProjectAvgAggregateInputType
    _sum?: UserToProjectSumAggregateInputType
    _min?: UserToProjectMinAggregateInputType
    _max?: UserToProjectMaxAggregateInputType
  }


  export type UserToProjectGroupByOutputType = {
    id: number
    createdAt: Date
    userId: string
    projectId: number
    _count: UserToProjectCountAggregateOutputType | null
    _avg: UserToProjectAvgAggregateOutputType | null
    _sum: UserToProjectSumAggregateOutputType | null
    _min: UserToProjectMinAggregateOutputType | null
    _max: UserToProjectMaxAggregateOutputType | null
  }

  type GetUserToProjectGroupByPayload<T extends UserToProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToProjectGroupByOutputType[P]>
            : GetScalarType<T[P], UserToProjectGroupByOutputType[P]>
        }
      >
    >


  export type UserToProjectSelect = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
  }


  export type UserToProjectInclude = {
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
  }

  export type UserToProjectGetPayload<S extends boolean | null | undefined | UserToProjectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToProject :
    S extends undefined ? never :
    S extends { include: any } & (UserToProjectArgs | UserToProjectFindManyArgs)
    ? UserToProject  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToProjectArgs | UserToProjectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof UserToProject ? UserToProject[P] : never
  } 
      : UserToProject


  type UserToProjectCountArgs = 
    Omit<UserToProjectFindManyArgs, 'select' | 'include'> & {
      select?: UserToProjectCountAggregateInputType | true
    }

  export interface UserToProjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToProject that matches the filter.
     * @param {UserToProjectFindUniqueArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToProject'> extends True ? Prisma__UserToProjectClient<UserToProjectGetPayload<T>> : Prisma__UserToProjectClient<UserToProjectGetPayload<T> | null, null>

    /**
     * Find one UserToProject that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToProjectFindUniqueOrThrowArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToProjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToProjectFindUniqueOrThrowArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Find the first UserToProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindFirstArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToProject'> extends True ? Prisma__UserToProjectClient<UserToProjectGetPayload<T>> : Prisma__UserToProjectClient<UserToProjectGetPayload<T> | null, null>

    /**
     * Find the first UserToProject that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindFirstOrThrowArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToProjectFindFirstOrThrowArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Find zero or more UserToProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToProjects
     * const userToProjects = await prisma.userToProject.findMany()
     * 
     * // Get first 10 UserToProjects
     * const userToProjects = await prisma.userToProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToProjectWithIdOnly = await prisma.userToProject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToProjectFindManyArgs>(
      args?: SelectSubset<T, UserToProjectFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToProjectGetPayload<T>>>

    /**
     * Create a UserToProject.
     * @param {UserToProjectCreateArgs} args - Arguments to create a UserToProject.
     * @example
     * // Create one UserToProject
     * const UserToProject = await prisma.userToProject.create({
     *   data: {
     *     // ... data to create a UserToProject
     *   }
     * })
     * 
    **/
    create<T extends UserToProjectCreateArgs>(
      args: SelectSubset<T, UserToProjectCreateArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Create many UserToProjects.
     *     @param {UserToProjectCreateManyArgs} args - Arguments to create many UserToProjects.
     *     @example
     *     // Create many UserToProjects
     *     const userToProject = await prisma.userToProject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToProjectCreateManyArgs>(
      args?: SelectSubset<T, UserToProjectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToProject.
     * @param {UserToProjectDeleteArgs} args - Arguments to delete one UserToProject.
     * @example
     * // Delete one UserToProject
     * const UserToProject = await prisma.userToProject.delete({
     *   where: {
     *     // ... filter to delete one UserToProject
     *   }
     * })
     * 
    **/
    delete<T extends UserToProjectDeleteArgs>(
      args: SelectSubset<T, UserToProjectDeleteArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Update one UserToProject.
     * @param {UserToProjectUpdateArgs} args - Arguments to update one UserToProject.
     * @example
     * // Update one UserToProject
     * const userToProject = await prisma.userToProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToProjectUpdateArgs>(
      args: SelectSubset<T, UserToProjectUpdateArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Delete zero or more UserToProjects.
     * @param {UserToProjectDeleteManyArgs} args - Arguments to filter UserToProjects to delete.
     * @example
     * // Delete a few UserToProjects
     * const { count } = await prisma.userToProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToProjectDeleteManyArgs>(
      args?: SelectSubset<T, UserToProjectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToProjects
     * const userToProject = await prisma.userToProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToProjectUpdateManyArgs>(
      args: SelectSubset<T, UserToProjectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToProject.
     * @param {UserToProjectUpsertArgs} args - Arguments to update or create a UserToProject.
     * @example
     * // Update or create a UserToProject
     * const userToProject = await prisma.userToProject.upsert({
     *   create: {
     *     // ... data to create a UserToProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToProject we want to update
     *   }
     * })
    **/
    upsert<T extends UserToProjectUpsertArgs>(
      args: SelectSubset<T, UserToProjectUpsertArgs>
    ): Prisma__UserToProjectClient<UserToProjectGetPayload<T>>

    /**
     * Count the number of UserToProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectCountArgs} args - Arguments to filter UserToProjects to count.
     * @example
     * // Count the number of UserToProjects
     * const count = await prisma.userToProject.count({
     *   where: {
     *     // ... the filter for the UserToProjects we want to count
     *   }
     * })
    **/
    count<T extends UserToProjectCountArgs>(
      args?: Subset<T, UserToProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToProjectAggregateArgs>(args: Subset<T, UserToProjectAggregateArgs>): Prisma.PrismaPromise<GetUserToProjectAggregateType<T>>

    /**
     * Group by UserToProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToProjectGroupByArgs['orderBy'] }
        : { orderBy?: UserToProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToProjectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToProject base type for findUnique actions
   */
  export type UserToProjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where: UserToProjectWhereUniqueInput
  }

  /**
   * UserToProject findUnique
   */
  export interface UserToProjectFindUniqueArgs extends UserToProjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToProject findUniqueOrThrow
   */
  export type UserToProjectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where: UserToProjectWhereUniqueInput
  }


  /**
   * UserToProject base type for findFirst actions
   */
  export type UserToProjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToProjects.
     */
    distinct?: Enumerable<UserToProjectScalarFieldEnum>
  }

  /**
   * UserToProject findFirst
   */
  export interface UserToProjectFindFirstArgs extends UserToProjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToProject findFirstOrThrow
   */
  export type UserToProjectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToProjects.
     */
    distinct?: Enumerable<UserToProjectScalarFieldEnum>
  }


  /**
   * UserToProject findMany
   */
  export type UserToProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter, which UserToProjects to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    distinct?: Enumerable<UserToProjectScalarFieldEnum>
  }


  /**
   * UserToProject create
   */
  export type UserToProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * The data needed to create a UserToProject.
     */
    data: XOR<UserToProjectCreateInput, UserToProjectUncheckedCreateInput>
  }


  /**
   * UserToProject createMany
   */
  export type UserToProjectCreateManyArgs = {
    /**
     * The data used to create many UserToProjects.
     */
    data: Enumerable<UserToProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToProject update
   */
  export type UserToProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * The data needed to update a UserToProject.
     */
    data: XOR<UserToProjectUpdateInput, UserToProjectUncheckedUpdateInput>
    /**
     * Choose, which UserToProject to update.
     */
    where: UserToProjectWhereUniqueInput
  }


  /**
   * UserToProject updateMany
   */
  export type UserToProjectUpdateManyArgs = {
    /**
     * The data used to update UserToProjects.
     */
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyInput>
    /**
     * Filter which UserToProjects to update
     */
    where?: UserToProjectWhereInput
  }


  /**
   * UserToProject upsert
   */
  export type UserToProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * The filter to search for the UserToProject to update in case it exists.
     */
    where: UserToProjectWhereUniqueInput
    /**
     * In case the UserToProject found by the `where` argument doesn't exist, create a new UserToProject with this data.
     */
    create: XOR<UserToProjectCreateInput, UserToProjectUncheckedCreateInput>
    /**
     * In case the UserToProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToProjectUpdateInput, UserToProjectUncheckedUpdateInput>
  }


  /**
   * UserToProject delete
   */
  export type UserToProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    /**
     * Filter which UserToProject to delete.
     */
    where: UserToProjectWhereUniqueInput
  }


  /**
   * UserToProject deleteMany
   */
  export type UserToProjectDeleteManyArgs = {
    /**
     * Filter which UserToProjects to delete
     */
    where?: UserToProjectWhereInput
  }


  /**
   * UserToProject without action
   */
  export type UserToProjectArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    catCode: number | null
    rcvValue: number | null
    actualValue: number | null
    projectStatusValueId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    catCode: number | null
    rcvValue: number | null
    actualValue: number | null
    projectStatusValueId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    closedAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    assignmentNumber: string | null
    publicId: string | null
    name: string | null
    location: string | null
    clientName: string | null
    clientEmail: string | null
    clientPhoneNumber: string | null
    companyName: string | null
    managerName: string | null
    adjusterEmail: string | null
    adjusterName: string | null
    adjusterPhoneNumber: string | null
    insuranceCompanyName: string | null
    insuranceClaimId: string | null
    lossType: string | null
    catCode: number | null
    humidity: string | null
    lastTimeWeatherFetched: Date | null
    temperature: string | null
    wind: string | null
    lat: string | null
    lng: string | null
    forecast: string | null
    claimSummary: string | null
    rcvValue: number | null
    actualValue: number | null
    status: ProjectStatus | null
    projectStatusValueId: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    closedAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    assignmentNumber: string | null
    publicId: string | null
    name: string | null
    location: string | null
    clientName: string | null
    clientEmail: string | null
    clientPhoneNumber: string | null
    companyName: string | null
    managerName: string | null
    adjusterEmail: string | null
    adjusterName: string | null
    adjusterPhoneNumber: string | null
    insuranceCompanyName: string | null
    insuranceClaimId: string | null
    lossType: string | null
    catCode: number | null
    humidity: string | null
    lastTimeWeatherFetched: Date | null
    temperature: string | null
    wind: string | null
    lat: string | null
    lng: string | null
    forecast: string | null
    claimSummary: string | null
    rcvValue: number | null
    actualValue: number | null
    status: ProjectStatus | null
    projectStatusValueId: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    createdAt: number
    closedAt: number
    isDeleted: number
    organizationId: number
    assignmentNumber: number
    publicId: number
    name: number
    location: number
    clientName: number
    clientEmail: number
    clientPhoneNumber: number
    companyName: number
    managerName: number
    adjusterEmail: number
    adjusterName: number
    adjusterPhoneNumber: number
    insuranceCompanyName: number
    insuranceClaimId: number
    lossType: number
    catCode: number
    humidity: number
    lastTimeWeatherFetched: number
    temperature: number
    wind: number
    lat: number
    lng: number
    forecast: number
    claimSummary: number
    roofSegments: number
    roofSpecs: number
    rcvValue: number
    actualValue: number
    status: number
    projectStatusValueId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    organizationId?: true
    catCode?: true
    rcvValue?: true
    actualValue?: true
    projectStatusValueId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    organizationId?: true
    catCode?: true
    rcvValue?: true
    actualValue?: true
    projectStatusValueId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    roofSegments?: true
    roofSpecs?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
    by: ProjectScalarFieldEnum[]
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: number
    createdAt: Date
    closedAt: Date | null
    isDeleted: boolean
    organizationId: number
    assignmentNumber: string
    publicId: string
    name: string
    location: string
    clientName: string
    clientEmail: string
    clientPhoneNumber: string
    companyName: string
    managerName: string
    adjusterEmail: string
    adjusterName: string
    adjusterPhoneNumber: string
    insuranceCompanyName: string
    insuranceClaimId: string
    lossType: string
    catCode: number | null
    humidity: string
    lastTimeWeatherFetched: Date | null
    temperature: string
    wind: string
    lat: string
    lng: string
    forecast: string
    claimSummary: string
    roofSegments: JsonValue[]
    roofSpecs: JsonValue | null
    rcvValue: number | null
    actualValue: number | null
    status: ProjectStatus | null
    projectStatusValueId: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect = {
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    assignmentNumber?: boolean
    publicId?: boolean
    name?: boolean
    location?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientPhoneNumber?: boolean
    companyName?: boolean
    managerName?: boolean
    adjusterEmail?: boolean
    adjusterName?: boolean
    adjusterPhoneNumber?: boolean
    insuranceCompanyName?: boolean
    insuranceClaimId?: boolean
    lossType?: boolean
    catCode?: boolean
    humidity?: boolean
    lastTimeWeatherFetched?: boolean
    temperature?: boolean
    wind?: boolean
    lat?: boolean
    lng?: boolean
    forecast?: boolean
    claimSummary?: boolean
    roofSegments?: boolean
    roofSpecs?: boolean
    rcvValue?: boolean
    actualValue?: boolean
    status?: boolean
    projectStatusValueId?: boolean
    organization?: boolean | OrganizationArgs
    images?: boolean | Project$imagesArgs
    inferences?: boolean | Project$inferencesArgs
    rooms?: boolean | Project$roomsArgs
    events?: boolean | Project$eventsArgs
    projectAssignees?: boolean | Project$projectAssigneesArgs
    roomReadings?: boolean | Project$roomReadingsArgs
    propertyData?: boolean | PropertyDataArgs
    AreaAffected?: boolean | Project$AreaAffectedArgs
    photoAccessLinks?: boolean | Project$photoAccessLinksArgs
    notes?: boolean | Project$notesArgs
    costs?: boolean | Project$costsArgs
    projectEquipment?: boolean | Project$projectEquipmentArgs
    weatherReportItems?: boolean | Project$weatherReportItemsArgs
    currentStatus?: boolean | ProjectStatusValueArgs
    PendingRoofReports?: boolean | Project$PendingRoofReportsArgs
    ProjectNotes?: boolean | Project$ProjectNotesArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }


  export type ProjectInclude = {
    organization?: boolean | OrganizationArgs
    images?: boolean | Project$imagesArgs
    inferences?: boolean | Project$inferencesArgs
    rooms?: boolean | Project$roomsArgs
    events?: boolean | Project$eventsArgs
    projectAssignees?: boolean | Project$projectAssigneesArgs
    roomReadings?: boolean | Project$roomReadingsArgs
    propertyData?: boolean | PropertyDataArgs
    AreaAffected?: boolean | Project$AreaAffectedArgs
    photoAccessLinks?: boolean | Project$photoAccessLinksArgs
    notes?: boolean | Project$notesArgs
    costs?: boolean | Project$costsArgs
    projectEquipment?: boolean | Project$projectEquipmentArgs
    weatherReportItems?: boolean | Project$weatherReportItemsArgs
    currentStatus?: boolean | ProjectStatusValueArgs
    PendingRoofReports?: boolean | Project$PendingRoofReportsArgs
    ProjectNotes?: boolean | Project$ProjectNotesArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }

  export type ProjectGetPayload<S extends boolean | null | undefined | ProjectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Project :
    S extends undefined ? never :
    S extends { include: any } & (ProjectArgs | ProjectFindManyArgs)
    ? Project  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends 'images' ? Array < ImageGetPayload<S['include'][P]>>  :
        P extends 'inferences' ? Array < InferenceGetPayload<S['include'][P]>>  :
        P extends 'rooms' ? Array < RoomGetPayload<S['include'][P]>>  :
        P extends 'events' ? Array < CalendarEventGetPayload<S['include'][P]>>  :
        P extends 'projectAssignees' ? Array < UserToProjectGetPayload<S['include'][P]>>  :
        P extends 'roomReadings' ? Array < RoomReadingGetPayload<S['include'][P]>>  :
        P extends 'propertyData' ? PropertyDataGetPayload<S['include'][P]> | null :
        P extends 'AreaAffected' ? Array < AreaAffectedGetPayload<S['include'][P]>>  :
        P extends 'photoAccessLinks' ? Array < PhotoAccessLinkGetPayload<S['include'][P]>>  :
        P extends 'notes' ? Array < NotesGetPayload<S['include'][P]>>  :
        P extends 'costs' ? Array < CostGetPayload<S['include'][P]>>  :
        P extends 'projectEquipment' ? Array < ProjectEquipmentGetPayload<S['include'][P]>>  :
        P extends 'weatherReportItems' ? Array < WeatherReportItemGetPayload<S['include'][P]>>  :
        P extends 'currentStatus' ? ProjectStatusValueGetPayload<S['include'][P]> | null :
        P extends 'PendingRoofReports' ? Array < PendingRoofReportsGetPayload<S['include'][P]>>  :
        P extends 'ProjectNotes' ? Array < ProjectNotesGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectArgs | ProjectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends 'images' ? Array < ImageGetPayload<S['select'][P]>>  :
        P extends 'inferences' ? Array < InferenceGetPayload<S['select'][P]>>  :
        P extends 'rooms' ? Array < RoomGetPayload<S['select'][P]>>  :
        P extends 'events' ? Array < CalendarEventGetPayload<S['select'][P]>>  :
        P extends 'projectAssignees' ? Array < UserToProjectGetPayload<S['select'][P]>>  :
        P extends 'roomReadings' ? Array < RoomReadingGetPayload<S['select'][P]>>  :
        P extends 'propertyData' ? PropertyDataGetPayload<S['select'][P]> | null :
        P extends 'AreaAffected' ? Array < AreaAffectedGetPayload<S['select'][P]>>  :
        P extends 'photoAccessLinks' ? Array < PhotoAccessLinkGetPayload<S['select'][P]>>  :
        P extends 'notes' ? Array < NotesGetPayload<S['select'][P]>>  :
        P extends 'costs' ? Array < CostGetPayload<S['select'][P]>>  :
        P extends 'projectEquipment' ? Array < ProjectEquipmentGetPayload<S['select'][P]>>  :
        P extends 'weatherReportItems' ? Array < WeatherReportItemGetPayload<S['select'][P]>>  :
        P extends 'currentStatus' ? ProjectStatusValueGetPayload<S['select'][P]> | null :
        P extends 'PendingRoofReports' ? Array < PendingRoofReportsGetPayload<S['select'][P]>>  :
        P extends 'ProjectNotes' ? Array < ProjectNotesGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Project ? Project[P] : never
  } 
      : Project


  type ProjectCountArgs = 
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find one Project that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find the first Project that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectGetPayload<T>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    images<T extends Project$imagesArgs= {}>(args?: Subset<T, Project$imagesArgs>): Prisma.PrismaPromise<Array<ImageGetPayload<T>>| Null>;

    inferences<T extends Project$inferencesArgs= {}>(args?: Subset<T, Project$inferencesArgs>): Prisma.PrismaPromise<Array<InferenceGetPayload<T>>| Null>;

    rooms<T extends Project$roomsArgs= {}>(args?: Subset<T, Project$roomsArgs>): Prisma.PrismaPromise<Array<RoomGetPayload<T>>| Null>;

    events<T extends Project$eventsArgs= {}>(args?: Subset<T, Project$eventsArgs>): Prisma.PrismaPromise<Array<CalendarEventGetPayload<T>>| Null>;

    projectAssignees<T extends Project$projectAssigneesArgs= {}>(args?: Subset<T, Project$projectAssigneesArgs>): Prisma.PrismaPromise<Array<UserToProjectGetPayload<T>>| Null>;

    roomReadings<T extends Project$roomReadingsArgs= {}>(args?: Subset<T, Project$roomReadingsArgs>): Prisma.PrismaPromise<Array<RoomReadingGetPayload<T>>| Null>;

    propertyData<T extends PropertyDataArgs= {}>(args?: Subset<T, PropertyDataArgs>): Prisma__PropertyDataClient<PropertyDataGetPayload<T> | Null>;

    AreaAffected<T extends Project$AreaAffectedArgs= {}>(args?: Subset<T, Project$AreaAffectedArgs>): Prisma.PrismaPromise<Array<AreaAffectedGetPayload<T>>| Null>;

    photoAccessLinks<T extends Project$photoAccessLinksArgs= {}>(args?: Subset<T, Project$photoAccessLinksArgs>): Prisma.PrismaPromise<Array<PhotoAccessLinkGetPayload<T>>| Null>;

    notes<T extends Project$notesArgs= {}>(args?: Subset<T, Project$notesArgs>): Prisma.PrismaPromise<Array<NotesGetPayload<T>>| Null>;

    costs<T extends Project$costsArgs= {}>(args?: Subset<T, Project$costsArgs>): Prisma.PrismaPromise<Array<CostGetPayload<T>>| Null>;

    projectEquipment<T extends Project$projectEquipmentArgs= {}>(args?: Subset<T, Project$projectEquipmentArgs>): Prisma.PrismaPromise<Array<ProjectEquipmentGetPayload<T>>| Null>;

    weatherReportItems<T extends Project$weatherReportItemsArgs= {}>(args?: Subset<T, Project$weatherReportItemsArgs>): Prisma.PrismaPromise<Array<WeatherReportItemGetPayload<T>>| Null>;

    currentStatus<T extends ProjectStatusValueArgs= {}>(args?: Subset<T, ProjectStatusValueArgs>): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T> | Null>;

    PendingRoofReports<T extends Project$PendingRoofReportsArgs= {}>(args?: Subset<T, Project$PendingRoofReportsArgs>): Prisma.PrismaPromise<Array<PendingRoofReportsGetPayload<T>>| Null>;

    ProjectNotes<T extends Project$ProjectNotesArgs= {}>(args?: Subset<T, Project$ProjectNotesArgs>): Prisma.PrismaPromise<Array<ProjectNotesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Project base type for findUnique actions
   */
  export type ProjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUnique
   */
  export interface ProjectFindUniqueArgs extends ProjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project base type for findFirst actions
   */
  export type ProjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }

  /**
   * Project findFirst
   */
  export interface ProjectFindFirstArgs extends ProjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs = {
    /**
     * The data used to create many Projects.
     */
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }


  /**
   * Project.images
   */
  export type Project$imagesArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Project.inferences
   */
  export type Project$inferencesArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    where?: InferenceWhereInput
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InferenceScalarFieldEnum>
  }


  /**
   * Project.rooms
   */
  export type Project$roomsArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    where?: RoomWhereInput
    orderBy?: Enumerable<RoomOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoomScalarFieldEnum>
  }


  /**
   * Project.events
   */
  export type Project$eventsArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    where?: CalendarEventWhereInput
    orderBy?: Enumerable<CalendarEventOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarEventScalarFieldEnum>
  }


  /**
   * Project.projectAssignees
   */
  export type Project$projectAssigneesArgs = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToProjectInclude | null
    where?: UserToProjectWhereInput
    orderBy?: Enumerable<UserToProjectOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UserToProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToProjectScalarFieldEnum>
  }


  /**
   * Project.roomReadings
   */
  export type Project$roomReadingsArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    where?: RoomReadingWhereInput
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoomReadingScalarFieldEnum>
  }


  /**
   * Project.AreaAffected
   */
  export type Project$AreaAffectedArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    where?: AreaAffectedWhereInput
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AreaAffectedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AreaAffectedScalarFieldEnum>
  }


  /**
   * Project.photoAccessLinks
   */
  export type Project$photoAccessLinksArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    where?: PhotoAccessLinkWhereInput
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PhotoAccessLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PhotoAccessLinkScalarFieldEnum>
  }


  /**
   * Project.notes
   */
  export type Project$notesArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    where?: NotesWhereInput
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotesScalarFieldEnum>
  }


  /**
   * Project.costs
   */
  export type Project$costsArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    where?: CostWhereInput
    orderBy?: Enumerable<CostOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CostScalarFieldEnum>
  }


  /**
   * Project.projectEquipment
   */
  export type Project$projectEquipmentArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    where?: ProjectEquipmentWhereInput
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectEquipmentScalarFieldEnum>
  }


  /**
   * Project.weatherReportItems
   */
  export type Project$weatherReportItemsArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    where?: WeatherReportItemWhereInput
    orderBy?: Enumerable<WeatherReportItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: WeatherReportItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WeatherReportItemScalarFieldEnum>
  }


  /**
   * Project.PendingRoofReports
   */
  export type Project$PendingRoofReportsArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    where?: PendingRoofReportsWhereInput
    orderBy?: Enumerable<PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PendingRoofReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PendingRoofReportsScalarFieldEnum>
  }


  /**
   * Project.ProjectNotes
   */
  export type Project$ProjectNotesArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    where?: ProjectNotesWhereInput
    orderBy?: Enumerable<ProjectNotesOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectNotesScalarFieldEnum>
  }


  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
  }



  /**
   * Model ProjectNotes
   */


  export type AggregateProjectNotes = {
    _count: ProjectNotesCountAggregateOutputType | null
    _avg: ProjectNotesAvgAggregateOutputType | null
    _sum: ProjectNotesSumAggregateOutputType | null
    _min: ProjectNotesMinAggregateOutputType | null
    _max: ProjectNotesMaxAggregateOutputType | null
  }

  export type ProjectNotesAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectNotesSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectNotesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
    userId: string | null
  }

  export type ProjectNotesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
    userId: string | null
  }

  export type ProjectNotesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    isDeleted: number
    publicId: number
    projectId: number
    body: number
    mentions: number
    userId: number
    _all: number
  }


  export type ProjectNotesAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectNotesSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectNotesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    userId?: true
  }

  export type ProjectNotesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    userId?: true
  }

  export type ProjectNotesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    mentions?: true
    userId?: true
    _all?: true
  }

  export type ProjectNotesAggregateArgs = {
    /**
     * Filter which ProjectNotes to aggregate.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: Enumerable<ProjectNotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectNotes
    **/
    _count?: true | ProjectNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectNotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectNotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectNotesMaxAggregateInputType
  }

  export type GetProjectNotesAggregateType<T extends ProjectNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectNotes[P]>
      : GetScalarType<T[P], AggregateProjectNotes[P]>
  }




  export type ProjectNotesGroupByArgs = {
    where?: ProjectNotesWhereInput
    orderBy?: Enumerable<ProjectNotesOrderByWithAggregationInput>
    by: ProjectNotesScalarFieldEnum[]
    having?: ProjectNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectNotesCountAggregateInputType | true
    _avg?: ProjectNotesAvgAggregateInputType
    _sum?: ProjectNotesSumAggregateInputType
    _min?: ProjectNotesMinAggregateInputType
    _max?: ProjectNotesMaxAggregateInputType
  }


  export type ProjectNotesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    date: Date
    isDeleted: boolean
    publicId: string
    projectId: number
    body: string
    mentions: string[]
    userId: string
    _count: ProjectNotesCountAggregateOutputType | null
    _avg: ProjectNotesAvgAggregateOutputType | null
    _sum: ProjectNotesSumAggregateOutputType | null
    _min: ProjectNotesMinAggregateOutputType | null
    _max: ProjectNotesMaxAggregateOutputType | null
  }

  type GetProjectNotesGroupByPayload<T extends ProjectNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectNotesGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectNotesGroupByOutputType[P]>
        }
      >
    >


  export type ProjectNotesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    project?: boolean | ProjectArgs
  }


  export type ProjectNotesInclude = {
    project?: boolean | ProjectArgs
  }

  export type ProjectNotesGetPayload<S extends boolean | null | undefined | ProjectNotesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectNotes :
    S extends undefined ? never :
    S extends { include: any } & (ProjectNotesArgs | ProjectNotesFindManyArgs)
    ? ProjectNotes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectNotesArgs | ProjectNotesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof ProjectNotes ? ProjectNotes[P] : never
  } 
      : ProjectNotes


  type ProjectNotesCountArgs = 
    Omit<ProjectNotesFindManyArgs, 'select' | 'include'> & {
      select?: ProjectNotesCountAggregateInputType | true
    }

  export interface ProjectNotesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectNotes that matches the filter.
     * @param {ProjectNotesFindUniqueArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectNotesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectNotesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectNotes'> extends True ? Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>> : Prisma__ProjectNotesClient<ProjectNotesGetPayload<T> | null, null>

    /**
     * Find one ProjectNotes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectNotesFindUniqueOrThrowArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectNotesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectNotesFindUniqueOrThrowArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Find the first ProjectNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindFirstArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectNotesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectNotesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectNotes'> extends True ? Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>> : Prisma__ProjectNotesClient<ProjectNotesGetPayload<T> | null, null>

    /**
     * Find the first ProjectNotes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindFirstOrThrowArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectNotesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectNotesFindFirstOrThrowArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Find zero or more ProjectNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectNotes
     * const projectNotes = await prisma.projectNotes.findMany()
     * 
     * // Get first 10 ProjectNotes
     * const projectNotes = await prisma.projectNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectNotesWithIdOnly = await prisma.projectNotes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectNotesFindManyArgs>(
      args?: SelectSubset<T, ProjectNotesFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectNotesGetPayload<T>>>

    /**
     * Create a ProjectNotes.
     * @param {ProjectNotesCreateArgs} args - Arguments to create a ProjectNotes.
     * @example
     * // Create one ProjectNotes
     * const ProjectNotes = await prisma.projectNotes.create({
     *   data: {
     *     // ... data to create a ProjectNotes
     *   }
     * })
     * 
    **/
    create<T extends ProjectNotesCreateArgs>(
      args: SelectSubset<T, ProjectNotesCreateArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Create many ProjectNotes.
     *     @param {ProjectNotesCreateManyArgs} args - Arguments to create many ProjectNotes.
     *     @example
     *     // Create many ProjectNotes
     *     const projectNotes = await prisma.projectNotes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectNotesCreateManyArgs>(
      args?: SelectSubset<T, ProjectNotesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectNotes.
     * @param {ProjectNotesDeleteArgs} args - Arguments to delete one ProjectNotes.
     * @example
     * // Delete one ProjectNotes
     * const ProjectNotes = await prisma.projectNotes.delete({
     *   where: {
     *     // ... filter to delete one ProjectNotes
     *   }
     * })
     * 
    **/
    delete<T extends ProjectNotesDeleteArgs>(
      args: SelectSubset<T, ProjectNotesDeleteArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Update one ProjectNotes.
     * @param {ProjectNotesUpdateArgs} args - Arguments to update one ProjectNotes.
     * @example
     * // Update one ProjectNotes
     * const projectNotes = await prisma.projectNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectNotesUpdateArgs>(
      args: SelectSubset<T, ProjectNotesUpdateArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Delete zero or more ProjectNotes.
     * @param {ProjectNotesDeleteManyArgs} args - Arguments to filter ProjectNotes to delete.
     * @example
     * // Delete a few ProjectNotes
     * const { count } = await prisma.projectNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectNotesDeleteManyArgs>(
      args?: SelectSubset<T, ProjectNotesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectNotes
     * const projectNotes = await prisma.projectNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectNotesUpdateManyArgs>(
      args: SelectSubset<T, ProjectNotesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectNotes.
     * @param {ProjectNotesUpsertArgs} args - Arguments to update or create a ProjectNotes.
     * @example
     * // Update or create a ProjectNotes
     * const projectNotes = await prisma.projectNotes.upsert({
     *   create: {
     *     // ... data to create a ProjectNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectNotes we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectNotesUpsertArgs>(
      args: SelectSubset<T, ProjectNotesUpsertArgs>
    ): Prisma__ProjectNotesClient<ProjectNotesGetPayload<T>>

    /**
     * Count the number of ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesCountArgs} args - Arguments to filter ProjectNotes to count.
     * @example
     * // Count the number of ProjectNotes
     * const count = await prisma.projectNotes.count({
     *   where: {
     *     // ... the filter for the ProjectNotes we want to count
     *   }
     * })
    **/
    count<T extends ProjectNotesCountArgs>(
      args?: Subset<T, ProjectNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectNotesAggregateArgs>(args: Subset<T, ProjectNotesAggregateArgs>): Prisma.PrismaPromise<GetProjectNotesAggregateType<T>>

    /**
     * Group by ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectNotesGroupByArgs['orderBy'] }
        : { orderBy?: ProjectNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectNotesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectNotes base type for findUnique actions
   */
  export type ProjectNotesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where: ProjectNotesWhereUniqueInput
  }

  /**
   * ProjectNotes findUnique
   */
  export interface ProjectNotesFindUniqueArgs extends ProjectNotesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectNotes findUniqueOrThrow
   */
  export type ProjectNotesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where: ProjectNotesWhereUniqueInput
  }


  /**
   * ProjectNotes base type for findFirst actions
   */
  export type ProjectNotesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: Enumerable<ProjectNotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotes.
     */
    distinct?: Enumerable<ProjectNotesScalarFieldEnum>
  }

  /**
   * ProjectNotes findFirst
   */
  export interface ProjectNotesFindFirstArgs extends ProjectNotesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectNotes findFirstOrThrow
   */
  export type ProjectNotesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: Enumerable<ProjectNotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotes.
     */
    distinct?: Enumerable<ProjectNotesScalarFieldEnum>
  }


  /**
   * ProjectNotes findMany
   */
  export type ProjectNotesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: Enumerable<ProjectNotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    distinct?: Enumerable<ProjectNotesScalarFieldEnum>
  }


  /**
   * ProjectNotes create
   */
  export type ProjectNotesCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * The data needed to create a ProjectNotes.
     */
    data: XOR<ProjectNotesCreateInput, ProjectNotesUncheckedCreateInput>
  }


  /**
   * ProjectNotes createMany
   */
  export type ProjectNotesCreateManyArgs = {
    /**
     * The data used to create many ProjectNotes.
     */
    data: Enumerable<ProjectNotesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectNotes update
   */
  export type ProjectNotesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * The data needed to update a ProjectNotes.
     */
    data: XOR<ProjectNotesUpdateInput, ProjectNotesUncheckedUpdateInput>
    /**
     * Choose, which ProjectNotes to update.
     */
    where: ProjectNotesWhereUniqueInput
  }


  /**
   * ProjectNotes updateMany
   */
  export type ProjectNotesUpdateManyArgs = {
    /**
     * The data used to update ProjectNotes.
     */
    data: XOR<ProjectNotesUpdateManyMutationInput, ProjectNotesUncheckedUpdateManyInput>
    /**
     * Filter which ProjectNotes to update
     */
    where?: ProjectNotesWhereInput
  }


  /**
   * ProjectNotes upsert
   */
  export type ProjectNotesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * The filter to search for the ProjectNotes to update in case it exists.
     */
    where: ProjectNotesWhereUniqueInput
    /**
     * In case the ProjectNotes found by the `where` argument doesn't exist, create a new ProjectNotes with this data.
     */
    create: XOR<ProjectNotesCreateInput, ProjectNotesUncheckedCreateInput>
    /**
     * In case the ProjectNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectNotesUpdateInput, ProjectNotesUncheckedUpdateInput>
  }


  /**
   * ProjectNotes delete
   */
  export type ProjectNotesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
    /**
     * Filter which ProjectNotes to delete.
     */
    where: ProjectNotesWhereUniqueInput
  }


  /**
   * ProjectNotes deleteMany
   */
  export type ProjectNotesDeleteManyArgs = {
    /**
     * Filter which ProjectNotes to delete
     */
    where?: ProjectNotesWhereInput
  }


  /**
   * ProjectNotes without action
   */
  export type ProjectNotesArgs = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectNotesInclude | null
  }



  /**
   * Model ProjectStatusValue
   */


  export type AggregateProjectStatusValue = {
    _count: ProjectStatusValueCountAggregateOutputType | null
    _avg: ProjectStatusValueAvgAggregateOutputType | null
    _sum: ProjectStatusValueSumAggregateOutputType | null
    _min: ProjectStatusValueMinAggregateOutputType | null
    _max: ProjectStatusValueMaxAggregateOutputType | null
  }

  export type ProjectStatusValueAvgAggregateOutputType = {
    id: number | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueSumAggregateOutputType = {
    id: number | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    label: string | null
    description: string | null
    color: string | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    label: string | null
    description: string | null
    color: string | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    label: number
    description: number
    color: number
    order: number
    organizationId: number
    _all: number
  }


  export type ProjectStatusValueAvgAggregateInputType = {
    id?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueSumAggregateInputType = {
    id?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
    _all?: true
  }

  export type ProjectStatusValueAggregateArgs = {
    /**
     * Filter which ProjectStatusValue to aggregate.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: Enumerable<ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStatusValues
    **/
    _count?: true | ProjectStatusValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatusValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatusValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatusValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatusValueMaxAggregateInputType
  }

  export type GetProjectStatusValueAggregateType<T extends ProjectStatusValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStatusValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStatusValue[P]>
      : GetScalarType<T[P], AggregateProjectStatusValue[P]>
  }




  export type ProjectStatusValueGroupByArgs = {
    where?: ProjectStatusValueWhereInput
    orderBy?: Enumerable<ProjectStatusValueOrderByWithAggregationInput>
    by: ProjectStatusValueScalarFieldEnum[]
    having?: ProjectStatusValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatusValueCountAggregateInputType | true
    _avg?: ProjectStatusValueAvgAggregateInputType
    _sum?: ProjectStatusValueSumAggregateInputType
    _min?: ProjectStatusValueMinAggregateInputType
    _max?: ProjectStatusValueMaxAggregateInputType
  }


  export type ProjectStatusValueGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    label: string
    description: string
    color: string
    order: number | null
    organizationId: number
    _count: ProjectStatusValueCountAggregateOutputType | null
    _avg: ProjectStatusValueAvgAggregateOutputType | null
    _sum: ProjectStatusValueSumAggregateOutputType | null
    _min: ProjectStatusValueMinAggregateOutputType | null
    _max: ProjectStatusValueMaxAggregateOutputType | null
  }

  type GetProjectStatusValueGroupByPayload<T extends ProjectStatusValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectStatusValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatusValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatusValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatusValueGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatusValueSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    label?: boolean
    description?: boolean
    color?: boolean
    order?: boolean
    organizationId?: boolean
    projects?: boolean | ProjectStatusValue$projectsArgs
    organization?: boolean | OrganizationArgs
    _count?: boolean | ProjectStatusValueCountOutputTypeArgs
  }


  export type ProjectStatusValueInclude = {
    projects?: boolean | ProjectStatusValue$projectsArgs
    organization?: boolean | OrganizationArgs
    _count?: boolean | ProjectStatusValueCountOutputTypeArgs
  }

  export type ProjectStatusValueGetPayload<S extends boolean | null | undefined | ProjectStatusValueArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectStatusValue :
    S extends undefined ? never :
    S extends { include: any } & (ProjectStatusValueArgs | ProjectStatusValueFindManyArgs)
    ? ProjectStatusValue  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'projects' ? Array < ProjectGetPayload<S['include'][P]>>  :
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends '_count' ? ProjectStatusValueCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectStatusValueArgs | ProjectStatusValueFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'projects' ? Array < ProjectGetPayload<S['select'][P]>>  :
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends '_count' ? ProjectStatusValueCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProjectStatusValue ? ProjectStatusValue[P] : never
  } 
      : ProjectStatusValue


  type ProjectStatusValueCountArgs = 
    Omit<ProjectStatusValueFindManyArgs, 'select' | 'include'> & {
      select?: ProjectStatusValueCountAggregateInputType | true
    }

  export interface ProjectStatusValueDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectStatusValue that matches the filter.
     * @param {ProjectStatusValueFindUniqueArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectStatusValueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectStatusValueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectStatusValue'> extends True ? Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>> : Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T> | null, null>

    /**
     * Find one ProjectStatusValue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectStatusValueFindUniqueOrThrowArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectStatusValueFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectStatusValueFindUniqueOrThrowArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Find the first ProjectStatusValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindFirstArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectStatusValueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectStatusValueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectStatusValue'> extends True ? Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>> : Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T> | null, null>

    /**
     * Find the first ProjectStatusValue that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindFirstOrThrowArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectStatusValueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectStatusValueFindFirstOrThrowArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Find zero or more ProjectStatusValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStatusValues
     * const projectStatusValues = await prisma.projectStatusValue.findMany()
     * 
     * // Get first 10 ProjectStatusValues
     * const projectStatusValues = await prisma.projectStatusValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatusValueWithIdOnly = await prisma.projectStatusValue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectStatusValueFindManyArgs>(
      args?: SelectSubset<T, ProjectStatusValueFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectStatusValueGetPayload<T>>>

    /**
     * Create a ProjectStatusValue.
     * @param {ProjectStatusValueCreateArgs} args - Arguments to create a ProjectStatusValue.
     * @example
     * // Create one ProjectStatusValue
     * const ProjectStatusValue = await prisma.projectStatusValue.create({
     *   data: {
     *     // ... data to create a ProjectStatusValue
     *   }
     * })
     * 
    **/
    create<T extends ProjectStatusValueCreateArgs>(
      args: SelectSubset<T, ProjectStatusValueCreateArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Create many ProjectStatusValues.
     *     @param {ProjectStatusValueCreateManyArgs} args - Arguments to create many ProjectStatusValues.
     *     @example
     *     // Create many ProjectStatusValues
     *     const projectStatusValue = await prisma.projectStatusValue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectStatusValueCreateManyArgs>(
      args?: SelectSubset<T, ProjectStatusValueCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectStatusValue.
     * @param {ProjectStatusValueDeleteArgs} args - Arguments to delete one ProjectStatusValue.
     * @example
     * // Delete one ProjectStatusValue
     * const ProjectStatusValue = await prisma.projectStatusValue.delete({
     *   where: {
     *     // ... filter to delete one ProjectStatusValue
     *   }
     * })
     * 
    **/
    delete<T extends ProjectStatusValueDeleteArgs>(
      args: SelectSubset<T, ProjectStatusValueDeleteArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Update one ProjectStatusValue.
     * @param {ProjectStatusValueUpdateArgs} args - Arguments to update one ProjectStatusValue.
     * @example
     * // Update one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectStatusValueUpdateArgs>(
      args: SelectSubset<T, ProjectStatusValueUpdateArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Delete zero or more ProjectStatusValues.
     * @param {ProjectStatusValueDeleteManyArgs} args - Arguments to filter ProjectStatusValues to delete.
     * @example
     * // Delete a few ProjectStatusValues
     * const { count } = await prisma.projectStatusValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectStatusValueDeleteManyArgs>(
      args?: SelectSubset<T, ProjectStatusValueDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStatusValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStatusValues
     * const projectStatusValue = await prisma.projectStatusValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectStatusValueUpdateManyArgs>(
      args: SelectSubset<T, ProjectStatusValueUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectStatusValue.
     * @param {ProjectStatusValueUpsertArgs} args - Arguments to update or create a ProjectStatusValue.
     * @example
     * // Update or create a ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.upsert({
     *   create: {
     *     // ... data to create a ProjectStatusValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStatusValue we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectStatusValueUpsertArgs>(
      args: SelectSubset<T, ProjectStatusValueUpsertArgs>
    ): Prisma__ProjectStatusValueClient<ProjectStatusValueGetPayload<T>>

    /**
     * Count the number of ProjectStatusValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueCountArgs} args - Arguments to filter ProjectStatusValues to count.
     * @example
     * // Count the number of ProjectStatusValues
     * const count = await prisma.projectStatusValue.count({
     *   where: {
     *     // ... the filter for the ProjectStatusValues we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatusValueCountArgs>(
      args?: Subset<T, ProjectStatusValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatusValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStatusValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatusValueAggregateArgs>(args: Subset<T, ProjectStatusValueAggregateArgs>): Prisma.PrismaPromise<GetProjectStatusValueAggregateType<T>>

    /**
     * Group by ProjectStatusValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatusValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatusValueGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatusValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatusValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatusValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStatusValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectStatusValueClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    projects<T extends ProjectStatusValue$projectsArgs= {}>(args?: Subset<T, ProjectStatusValue$projectsArgs>): Prisma.PrismaPromise<Array<ProjectGetPayload<T>>| Null>;

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectStatusValue base type for findUnique actions
   */
  export type ProjectStatusValueFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where: ProjectStatusValueWhereUniqueInput
  }

  /**
   * ProjectStatusValue findUnique
   */
  export interface ProjectStatusValueFindUniqueArgs extends ProjectStatusValueFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectStatusValue findUniqueOrThrow
   */
  export type ProjectStatusValueFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where: ProjectStatusValueWhereUniqueInput
  }


  /**
   * ProjectStatusValue base type for findFirst actions
   */
  export type ProjectStatusValueFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: Enumerable<ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusValues.
     */
    distinct?: Enumerable<ProjectStatusValueScalarFieldEnum>
  }

  /**
   * ProjectStatusValue findFirst
   */
  export interface ProjectStatusValueFindFirstArgs extends ProjectStatusValueFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectStatusValue findFirstOrThrow
   */
  export type ProjectStatusValueFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: Enumerable<ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusValues.
     */
    distinct?: Enumerable<ProjectStatusValueScalarFieldEnum>
  }


  /**
   * ProjectStatusValue findMany
   */
  export type ProjectStatusValueFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter, which ProjectStatusValues to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: Enumerable<ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    distinct?: Enumerable<ProjectStatusValueScalarFieldEnum>
  }


  /**
   * ProjectStatusValue create
   */
  export type ProjectStatusValueCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * The data needed to create a ProjectStatusValue.
     */
    data: XOR<ProjectStatusValueCreateInput, ProjectStatusValueUncheckedCreateInput>
  }


  /**
   * ProjectStatusValue createMany
   */
  export type ProjectStatusValueCreateManyArgs = {
    /**
     * The data used to create many ProjectStatusValues.
     */
    data: Enumerable<ProjectStatusValueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectStatusValue update
   */
  export type ProjectStatusValueUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * The data needed to update a ProjectStatusValue.
     */
    data: XOR<ProjectStatusValueUpdateInput, ProjectStatusValueUncheckedUpdateInput>
    /**
     * Choose, which ProjectStatusValue to update.
     */
    where: ProjectStatusValueWhereUniqueInput
  }


  /**
   * ProjectStatusValue updateMany
   */
  export type ProjectStatusValueUpdateManyArgs = {
    /**
     * The data used to update ProjectStatusValues.
     */
    data: XOR<ProjectStatusValueUpdateManyMutationInput, ProjectStatusValueUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStatusValues to update
     */
    where?: ProjectStatusValueWhereInput
  }


  /**
   * ProjectStatusValue upsert
   */
  export type ProjectStatusValueUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * The filter to search for the ProjectStatusValue to update in case it exists.
     */
    where: ProjectStatusValueWhereUniqueInput
    /**
     * In case the ProjectStatusValue found by the `where` argument doesn't exist, create a new ProjectStatusValue with this data.
     */
    create: XOR<ProjectStatusValueCreateInput, ProjectStatusValueUncheckedCreateInput>
    /**
     * In case the ProjectStatusValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatusValueUpdateInput, ProjectStatusValueUncheckedUpdateInput>
  }


  /**
   * ProjectStatusValue delete
   */
  export type ProjectStatusValueDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
    /**
     * Filter which ProjectStatusValue to delete.
     */
    where: ProjectStatusValueWhereUniqueInput
  }


  /**
   * ProjectStatusValue deleteMany
   */
  export type ProjectStatusValueDeleteManyArgs = {
    /**
     * Filter which ProjectStatusValues to delete
     */
    where?: ProjectStatusValueWhereInput
  }


  /**
   * ProjectStatusValue.projects
   */
  export type ProjectStatusValue$projectsArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * ProjectStatusValue without action
   */
  export type ProjectStatusValueArgs = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectStatusValueInclude | null
  }



  /**
   * Model PendingRoofReports
   */


  export type AggregatePendingRoofReports = {
    _count: PendingRoofReportsCountAggregateOutputType | null
    _avg: PendingRoofReportsAvgAggregateOutputType | null
    _sum: PendingRoofReportsSumAggregateOutputType | null
    _min: PendingRoofReportsMinAggregateOutputType | null
    _max: PendingRoofReportsMaxAggregateOutputType | null
  }

  export type PendingRoofReportsAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PendingRoofReportsSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PendingRoofReportsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    isCompleted: boolean | null
  }

  export type PendingRoofReportsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    isCompleted: boolean | null
  }

  export type PendingRoofReportsCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    projectId: number
    isCompleted: number
    _all: number
  }


  export type PendingRoofReportsAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PendingRoofReportsSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PendingRoofReportsMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
  }

  export type PendingRoofReportsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
  }

  export type PendingRoofReportsCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
    _all?: true
  }

  export type PendingRoofReportsAggregateArgs = {
    /**
     * Filter which PendingRoofReports to aggregate.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: Enumerable<PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingRoofReports
    **/
    _count?: true | PendingRoofReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingRoofReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingRoofReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingRoofReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingRoofReportsMaxAggregateInputType
  }

  export type GetPendingRoofReportsAggregateType<T extends PendingRoofReportsAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingRoofReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingRoofReports[P]>
      : GetScalarType<T[P], AggregatePendingRoofReports[P]>
  }




  export type PendingRoofReportsGroupByArgs = {
    where?: PendingRoofReportsWhereInput
    orderBy?: Enumerable<PendingRoofReportsOrderByWithAggregationInput>
    by: PendingRoofReportsScalarFieldEnum[]
    having?: PendingRoofReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingRoofReportsCountAggregateInputType | true
    _avg?: PendingRoofReportsAvgAggregateInputType
    _sum?: PendingRoofReportsSumAggregateInputType
    _min?: PendingRoofReportsMinAggregateInputType
    _max?: PendingRoofReportsMaxAggregateInputType
  }


  export type PendingRoofReportsGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    projectId: number
    isCompleted: boolean
    _count: PendingRoofReportsCountAggregateOutputType | null
    _avg: PendingRoofReportsAvgAggregateOutputType | null
    _sum: PendingRoofReportsSumAggregateOutputType | null
    _min: PendingRoofReportsMinAggregateOutputType | null
    _max: PendingRoofReportsMaxAggregateOutputType | null
  }

  type GetPendingRoofReportsGroupByPayload<T extends PendingRoofReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PendingRoofReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingRoofReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingRoofReportsGroupByOutputType[P]>
            : GetScalarType<T[P], PendingRoofReportsGroupByOutputType[P]>
        }
      >
    >


  export type PendingRoofReportsSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    isCompleted?: boolean
    project?: boolean | ProjectArgs
  }


  export type PendingRoofReportsInclude = {
    project?: boolean | ProjectArgs
  }

  export type PendingRoofReportsGetPayload<S extends boolean | null | undefined | PendingRoofReportsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PendingRoofReports :
    S extends undefined ? never :
    S extends { include: any } & (PendingRoofReportsArgs | PendingRoofReportsFindManyArgs)
    ? PendingRoofReports  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PendingRoofReportsArgs | PendingRoofReportsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof PendingRoofReports ? PendingRoofReports[P] : never
  } 
      : PendingRoofReports


  type PendingRoofReportsCountArgs = 
    Omit<PendingRoofReportsFindManyArgs, 'select' | 'include'> & {
      select?: PendingRoofReportsCountAggregateInputType | true
    }

  export interface PendingRoofReportsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PendingRoofReports that matches the filter.
     * @param {PendingRoofReportsFindUniqueArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PendingRoofReportsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PendingRoofReportsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PendingRoofReports'> extends True ? Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>> : Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T> | null, null>

    /**
     * Find one PendingRoofReports that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PendingRoofReportsFindUniqueOrThrowArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PendingRoofReportsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PendingRoofReportsFindUniqueOrThrowArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Find the first PendingRoofReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindFirstArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PendingRoofReportsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PendingRoofReportsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PendingRoofReports'> extends True ? Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>> : Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T> | null, null>

    /**
     * Find the first PendingRoofReports that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindFirstOrThrowArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PendingRoofReportsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PendingRoofReportsFindFirstOrThrowArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Find zero or more PendingRoofReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findMany()
     * 
     * // Get first 10 PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingRoofReportsWithIdOnly = await prisma.pendingRoofReports.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PendingRoofReportsFindManyArgs>(
      args?: SelectSubset<T, PendingRoofReportsFindManyArgs>
    ): Prisma.PrismaPromise<Array<PendingRoofReportsGetPayload<T>>>

    /**
     * Create a PendingRoofReports.
     * @param {PendingRoofReportsCreateArgs} args - Arguments to create a PendingRoofReports.
     * @example
     * // Create one PendingRoofReports
     * const PendingRoofReports = await prisma.pendingRoofReports.create({
     *   data: {
     *     // ... data to create a PendingRoofReports
     *   }
     * })
     * 
    **/
    create<T extends PendingRoofReportsCreateArgs>(
      args: SelectSubset<T, PendingRoofReportsCreateArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Create many PendingRoofReports.
     *     @param {PendingRoofReportsCreateManyArgs} args - Arguments to create many PendingRoofReports.
     *     @example
     *     // Create many PendingRoofReports
     *     const pendingRoofReports = await prisma.pendingRoofReports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PendingRoofReportsCreateManyArgs>(
      args?: SelectSubset<T, PendingRoofReportsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PendingRoofReports.
     * @param {PendingRoofReportsDeleteArgs} args - Arguments to delete one PendingRoofReports.
     * @example
     * // Delete one PendingRoofReports
     * const PendingRoofReports = await prisma.pendingRoofReports.delete({
     *   where: {
     *     // ... filter to delete one PendingRoofReports
     *   }
     * })
     * 
    **/
    delete<T extends PendingRoofReportsDeleteArgs>(
      args: SelectSubset<T, PendingRoofReportsDeleteArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Update one PendingRoofReports.
     * @param {PendingRoofReportsUpdateArgs} args - Arguments to update one PendingRoofReports.
     * @example
     * // Update one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PendingRoofReportsUpdateArgs>(
      args: SelectSubset<T, PendingRoofReportsUpdateArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Delete zero or more PendingRoofReports.
     * @param {PendingRoofReportsDeleteManyArgs} args - Arguments to filter PendingRoofReports to delete.
     * @example
     * // Delete a few PendingRoofReports
     * const { count } = await prisma.pendingRoofReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PendingRoofReportsDeleteManyArgs>(
      args?: SelectSubset<T, PendingRoofReportsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PendingRoofReportsUpdateManyArgs>(
      args: SelectSubset<T, PendingRoofReportsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendingRoofReports.
     * @param {PendingRoofReportsUpsertArgs} args - Arguments to update or create a PendingRoofReports.
     * @example
     * // Update or create a PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.upsert({
     *   create: {
     *     // ... data to create a PendingRoofReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingRoofReports we want to update
     *   }
     * })
    **/
    upsert<T extends PendingRoofReportsUpsertArgs>(
      args: SelectSubset<T, PendingRoofReportsUpsertArgs>
    ): Prisma__PendingRoofReportsClient<PendingRoofReportsGetPayload<T>>

    /**
     * Count the number of PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsCountArgs} args - Arguments to filter PendingRoofReports to count.
     * @example
     * // Count the number of PendingRoofReports
     * const count = await prisma.pendingRoofReports.count({
     *   where: {
     *     // ... the filter for the PendingRoofReports we want to count
     *   }
     * })
    **/
    count<T extends PendingRoofReportsCountArgs>(
      args?: Subset<T, PendingRoofReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingRoofReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingRoofReportsAggregateArgs>(args: Subset<T, PendingRoofReportsAggregateArgs>): Prisma.PrismaPromise<GetPendingRoofReportsAggregateType<T>>

    /**
     * Group by PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingRoofReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingRoofReportsGroupByArgs['orderBy'] }
        : { orderBy?: PendingRoofReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingRoofReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingRoofReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingRoofReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PendingRoofReportsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PendingRoofReports base type for findUnique actions
   */
  export type PendingRoofReportsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where: PendingRoofReportsWhereUniqueInput
  }

  /**
   * PendingRoofReports findUnique
   */
  export interface PendingRoofReportsFindUniqueArgs extends PendingRoofReportsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PendingRoofReports findUniqueOrThrow
   */
  export type PendingRoofReportsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where: PendingRoofReportsWhereUniqueInput
  }


  /**
   * PendingRoofReports base type for findFirst actions
   */
  export type PendingRoofReportsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: Enumerable<PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingRoofReports.
     */
    distinct?: Enumerable<PendingRoofReportsScalarFieldEnum>
  }

  /**
   * PendingRoofReports findFirst
   */
  export interface PendingRoofReportsFindFirstArgs extends PendingRoofReportsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PendingRoofReports findFirstOrThrow
   */
  export type PendingRoofReportsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: Enumerable<PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingRoofReports.
     */
    distinct?: Enumerable<PendingRoofReportsScalarFieldEnum>
  }


  /**
   * PendingRoofReports findMany
   */
  export type PendingRoofReportsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: Enumerable<PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    distinct?: Enumerable<PendingRoofReportsScalarFieldEnum>
  }


  /**
   * PendingRoofReports create
   */
  export type PendingRoofReportsCreateArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * The data needed to create a PendingRoofReports.
     */
    data: XOR<PendingRoofReportsCreateInput, PendingRoofReportsUncheckedCreateInput>
  }


  /**
   * PendingRoofReports createMany
   */
  export type PendingRoofReportsCreateManyArgs = {
    /**
     * The data used to create many PendingRoofReports.
     */
    data: Enumerable<PendingRoofReportsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PendingRoofReports update
   */
  export type PendingRoofReportsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * The data needed to update a PendingRoofReports.
     */
    data: XOR<PendingRoofReportsUpdateInput, PendingRoofReportsUncheckedUpdateInput>
    /**
     * Choose, which PendingRoofReports to update.
     */
    where: PendingRoofReportsWhereUniqueInput
  }


  /**
   * PendingRoofReports updateMany
   */
  export type PendingRoofReportsUpdateManyArgs = {
    /**
     * The data used to update PendingRoofReports.
     */
    data: XOR<PendingRoofReportsUpdateManyMutationInput, PendingRoofReportsUncheckedUpdateManyInput>
    /**
     * Filter which PendingRoofReports to update
     */
    where?: PendingRoofReportsWhereInput
  }


  /**
   * PendingRoofReports upsert
   */
  export type PendingRoofReportsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * The filter to search for the PendingRoofReports to update in case it exists.
     */
    where: PendingRoofReportsWhereUniqueInput
    /**
     * In case the PendingRoofReports found by the `where` argument doesn't exist, create a new PendingRoofReports with this data.
     */
    create: XOR<PendingRoofReportsCreateInput, PendingRoofReportsUncheckedCreateInput>
    /**
     * In case the PendingRoofReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingRoofReportsUpdateInput, PendingRoofReportsUncheckedUpdateInput>
  }


  /**
   * PendingRoofReports delete
   */
  export type PendingRoofReportsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
    /**
     * Filter which PendingRoofReports to delete.
     */
    where: PendingRoofReportsWhereUniqueInput
  }


  /**
   * PendingRoofReports deleteMany
   */
  export type PendingRoofReportsDeleteManyArgs = {
    /**
     * Filter which PendingRoofReports to delete
     */
    where?: PendingRoofReportsWhereInput
  }


  /**
   * PendingRoofReports without action
   */
  export type PendingRoofReportsArgs = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PendingRoofReportsInclude | null
  }



  /**
   * Model WeatherReportItem
   */


  export type AggregateWeatherReportItem = {
    _count: WeatherReportItemCountAggregateOutputType | null
    _avg: WeatherReportItemAvgAggregateOutputType | null
    _sum: WeatherReportItemSumAggregateOutputType | null
    _min: WeatherReportItemMinAggregateOutputType | null
    _max: WeatherReportItemMaxAggregateOutputType | null
  }

  export type WeatherReportItemAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type WeatherReportItemSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type WeatherReportItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    date: Date | null
    time: string | null
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string | null
    county: string | null
    state: string | null
    lat: string | null
    lon: string | null
    comments: string | null
  }

  export type WeatherReportItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    date: Date | null
    time: string | null
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string | null
    county: string | null
    state: string | null
    lat: string | null
    lon: string | null
    comments: string | null
  }

  export type WeatherReportItemCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    projectId: number
    date: number
    time: number
    f_scale: number
    speed: number
    size: number
    location: number
    county: number
    state: number
    lat: number
    lon: number
    comments: number
    _all: number
  }


  export type WeatherReportItemAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type WeatherReportItemSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type WeatherReportItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
  }

  export type WeatherReportItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
  }

  export type WeatherReportItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
    _all?: true
  }

  export type WeatherReportItemAggregateArgs = {
    /**
     * Filter which WeatherReportItem to aggregate.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: Enumerable<WeatherReportItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherReportItems
    **/
    _count?: true | WeatherReportItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherReportItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherReportItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherReportItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherReportItemMaxAggregateInputType
  }

  export type GetWeatherReportItemAggregateType<T extends WeatherReportItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherReportItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherReportItem[P]>
      : GetScalarType<T[P], AggregateWeatherReportItem[P]>
  }




  export type WeatherReportItemGroupByArgs = {
    where?: WeatherReportItemWhereInput
    orderBy?: Enumerable<WeatherReportItemOrderByWithAggregationInput>
    by: WeatherReportItemScalarFieldEnum[]
    having?: WeatherReportItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherReportItemCountAggregateInputType | true
    _avg?: WeatherReportItemAvgAggregateInputType
    _sum?: WeatherReportItemSumAggregateInputType
    _min?: WeatherReportItemMinAggregateInputType
    _max?: WeatherReportItemMaxAggregateInputType
  }


  export type WeatherReportItemGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    projectId: number
    date: Date
    time: string
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
    _count: WeatherReportItemCountAggregateOutputType | null
    _avg: WeatherReportItemAvgAggregateOutputType | null
    _sum: WeatherReportItemSumAggregateOutputType | null
    _min: WeatherReportItemMinAggregateOutputType | null
    _max: WeatherReportItemMaxAggregateOutputType | null
  }

  type GetWeatherReportItemGroupByPayload<T extends WeatherReportItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WeatherReportItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherReportItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherReportItemGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherReportItemGroupByOutputType[P]>
        }
      >
    >


  export type WeatherReportItemSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    date?: boolean
    time?: boolean
    f_scale?: boolean
    speed?: boolean
    size?: boolean
    location?: boolean
    county?: boolean
    state?: boolean
    lat?: boolean
    lon?: boolean
    comments?: boolean
    project?: boolean | ProjectArgs
  }


  export type WeatherReportItemInclude = {
    project?: boolean | ProjectArgs
  }

  export type WeatherReportItemGetPayload<S extends boolean | null | undefined | WeatherReportItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WeatherReportItem :
    S extends undefined ? never :
    S extends { include: any } & (WeatherReportItemArgs | WeatherReportItemFindManyArgs)
    ? WeatherReportItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WeatherReportItemArgs | WeatherReportItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof WeatherReportItem ? WeatherReportItem[P] : never
  } 
      : WeatherReportItem


  type WeatherReportItemCountArgs = 
    Omit<WeatherReportItemFindManyArgs, 'select' | 'include'> & {
      select?: WeatherReportItemCountAggregateInputType | true
    }

  export interface WeatherReportItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WeatherReportItem that matches the filter.
     * @param {WeatherReportItemFindUniqueArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WeatherReportItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WeatherReportItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WeatherReportItem'> extends True ? Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>> : Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T> | null, null>

    /**
     * Find one WeatherReportItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WeatherReportItemFindUniqueOrThrowArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WeatherReportItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WeatherReportItemFindUniqueOrThrowArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Find the first WeatherReportItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindFirstArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WeatherReportItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WeatherReportItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WeatherReportItem'> extends True ? Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>> : Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T> | null, null>

    /**
     * Find the first WeatherReportItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindFirstOrThrowArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WeatherReportItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WeatherReportItemFindFirstOrThrowArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Find zero or more WeatherReportItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherReportItems
     * const weatherReportItems = await prisma.weatherReportItem.findMany()
     * 
     * // Get first 10 WeatherReportItems
     * const weatherReportItems = await prisma.weatherReportItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherReportItemWithIdOnly = await prisma.weatherReportItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WeatherReportItemFindManyArgs>(
      args?: SelectSubset<T, WeatherReportItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<WeatherReportItemGetPayload<T>>>

    /**
     * Create a WeatherReportItem.
     * @param {WeatherReportItemCreateArgs} args - Arguments to create a WeatherReportItem.
     * @example
     * // Create one WeatherReportItem
     * const WeatherReportItem = await prisma.weatherReportItem.create({
     *   data: {
     *     // ... data to create a WeatherReportItem
     *   }
     * })
     * 
    **/
    create<T extends WeatherReportItemCreateArgs>(
      args: SelectSubset<T, WeatherReportItemCreateArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Create many WeatherReportItems.
     *     @param {WeatherReportItemCreateManyArgs} args - Arguments to create many WeatherReportItems.
     *     @example
     *     // Create many WeatherReportItems
     *     const weatherReportItem = await prisma.weatherReportItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WeatherReportItemCreateManyArgs>(
      args?: SelectSubset<T, WeatherReportItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WeatherReportItem.
     * @param {WeatherReportItemDeleteArgs} args - Arguments to delete one WeatherReportItem.
     * @example
     * // Delete one WeatherReportItem
     * const WeatherReportItem = await prisma.weatherReportItem.delete({
     *   where: {
     *     // ... filter to delete one WeatherReportItem
     *   }
     * })
     * 
    **/
    delete<T extends WeatherReportItemDeleteArgs>(
      args: SelectSubset<T, WeatherReportItemDeleteArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Update one WeatherReportItem.
     * @param {WeatherReportItemUpdateArgs} args - Arguments to update one WeatherReportItem.
     * @example
     * // Update one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WeatherReportItemUpdateArgs>(
      args: SelectSubset<T, WeatherReportItemUpdateArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Delete zero or more WeatherReportItems.
     * @param {WeatherReportItemDeleteManyArgs} args - Arguments to filter WeatherReportItems to delete.
     * @example
     * // Delete a few WeatherReportItems
     * const { count } = await prisma.weatherReportItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WeatherReportItemDeleteManyArgs>(
      args?: SelectSubset<T, WeatherReportItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherReportItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherReportItems
     * const weatherReportItem = await prisma.weatherReportItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WeatherReportItemUpdateManyArgs>(
      args: SelectSubset<T, WeatherReportItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeatherReportItem.
     * @param {WeatherReportItemUpsertArgs} args - Arguments to update or create a WeatherReportItem.
     * @example
     * // Update or create a WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.upsert({
     *   create: {
     *     // ... data to create a WeatherReportItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherReportItem we want to update
     *   }
     * })
    **/
    upsert<T extends WeatherReportItemUpsertArgs>(
      args: SelectSubset<T, WeatherReportItemUpsertArgs>
    ): Prisma__WeatherReportItemClient<WeatherReportItemGetPayload<T>>

    /**
     * Count the number of WeatherReportItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemCountArgs} args - Arguments to filter WeatherReportItems to count.
     * @example
     * // Count the number of WeatherReportItems
     * const count = await prisma.weatherReportItem.count({
     *   where: {
     *     // ... the filter for the WeatherReportItems we want to count
     *   }
     * })
    **/
    count<T extends WeatherReportItemCountArgs>(
      args?: Subset<T, WeatherReportItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherReportItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherReportItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherReportItemAggregateArgs>(args: Subset<T, WeatherReportItemAggregateArgs>): Prisma.PrismaPromise<GetWeatherReportItemAggregateType<T>>

    /**
     * Group by WeatherReportItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherReportItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherReportItemGroupByArgs['orderBy'] }
        : { orderBy?: WeatherReportItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherReportItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherReportItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherReportItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WeatherReportItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WeatherReportItem base type for findUnique actions
   */
  export type WeatherReportItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where: WeatherReportItemWhereUniqueInput
  }

  /**
   * WeatherReportItem findUnique
   */
  export interface WeatherReportItemFindUniqueArgs extends WeatherReportItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WeatherReportItem findUniqueOrThrow
   */
  export type WeatherReportItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where: WeatherReportItemWhereUniqueInput
  }


  /**
   * WeatherReportItem base type for findFirst actions
   */
  export type WeatherReportItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: Enumerable<WeatherReportItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherReportItems.
     */
    distinct?: Enumerable<WeatherReportItemScalarFieldEnum>
  }

  /**
   * WeatherReportItem findFirst
   */
  export interface WeatherReportItemFindFirstArgs extends WeatherReportItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WeatherReportItem findFirstOrThrow
   */
  export type WeatherReportItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: Enumerable<WeatherReportItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherReportItems.
     */
    distinct?: Enumerable<WeatherReportItemScalarFieldEnum>
  }


  /**
   * WeatherReportItem findMany
   */
  export type WeatherReportItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter, which WeatherReportItems to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: Enumerable<WeatherReportItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    distinct?: Enumerable<WeatherReportItemScalarFieldEnum>
  }


  /**
   * WeatherReportItem create
   */
  export type WeatherReportItemCreateArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * The data needed to create a WeatherReportItem.
     */
    data: XOR<WeatherReportItemCreateInput, WeatherReportItemUncheckedCreateInput>
  }


  /**
   * WeatherReportItem createMany
   */
  export type WeatherReportItemCreateManyArgs = {
    /**
     * The data used to create many WeatherReportItems.
     */
    data: Enumerable<WeatherReportItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WeatherReportItem update
   */
  export type WeatherReportItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * The data needed to update a WeatherReportItem.
     */
    data: XOR<WeatherReportItemUpdateInput, WeatherReportItemUncheckedUpdateInput>
    /**
     * Choose, which WeatherReportItem to update.
     */
    where: WeatherReportItemWhereUniqueInput
  }


  /**
   * WeatherReportItem updateMany
   */
  export type WeatherReportItemUpdateManyArgs = {
    /**
     * The data used to update WeatherReportItems.
     */
    data: XOR<WeatherReportItemUpdateManyMutationInput, WeatherReportItemUncheckedUpdateManyInput>
    /**
     * Filter which WeatherReportItems to update
     */
    where?: WeatherReportItemWhereInput
  }


  /**
   * WeatherReportItem upsert
   */
  export type WeatherReportItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * The filter to search for the WeatherReportItem to update in case it exists.
     */
    where: WeatherReportItemWhereUniqueInput
    /**
     * In case the WeatherReportItem found by the `where` argument doesn't exist, create a new WeatherReportItem with this data.
     */
    create: XOR<WeatherReportItemCreateInput, WeatherReportItemUncheckedCreateInput>
    /**
     * In case the WeatherReportItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherReportItemUpdateInput, WeatherReportItemUncheckedUpdateInput>
  }


  /**
   * WeatherReportItem delete
   */
  export type WeatherReportItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
    /**
     * Filter which WeatherReportItem to delete.
     */
    where: WeatherReportItemWhereUniqueInput
  }


  /**
   * WeatherReportItem deleteMany
   */
  export type WeatherReportItemDeleteManyArgs = {
    /**
     * Filter which WeatherReportItems to delete
     */
    where?: WeatherReportItemWhereInput
  }


  /**
   * WeatherReportItem without action
   */
  export type WeatherReportItemArgs = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WeatherReportItemInclude | null
  }



  /**
   * Model ProjectEquipment
   */


  export type AggregateProjectEquipment = {
    _count: ProjectEquipmentCountAggregateOutputType | null
    _avg: ProjectEquipmentAvgAggregateOutputType | null
    _sum: ProjectEquipmentSumAggregateOutputType | null
    _min: ProjectEquipmentMinAggregateOutputType | null
    _max: ProjectEquipmentMaxAggregateOutputType | null
  }

  export type ProjectEquipmentAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    quantity: number
    projectId: number
    equipmentId: number
    _all: number
  }


  export type ProjectEquipmentAvgAggregateInputType = {
    id?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentSumAggregateInputType = {
    id?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
    _all?: true
  }

  export type ProjectEquipmentAggregateArgs = {
    /**
     * Filter which ProjectEquipment to aggregate.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectEquipments
    **/
    _count?: true | ProjectEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectEquipmentMaxAggregateInputType
  }

  export type GetProjectEquipmentAggregateType<T extends ProjectEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectEquipment[P]>
      : GetScalarType<T[P], AggregateProjectEquipment[P]>
  }




  export type ProjectEquipmentGroupByArgs = {
    where?: ProjectEquipmentWhereInput
    orderBy?: Enumerable<ProjectEquipmentOrderByWithAggregationInput>
    by: ProjectEquipmentScalarFieldEnum[]
    having?: ProjectEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectEquipmentCountAggregateInputType | true
    _avg?: ProjectEquipmentAvgAggregateInputType
    _sum?: ProjectEquipmentSumAggregateInputType
    _min?: ProjectEquipmentMinAggregateInputType
    _max?: ProjectEquipmentMaxAggregateInputType
  }


  export type ProjectEquipmentGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    quantity: number
    projectId: number
    equipmentId: number
    _count: ProjectEquipmentCountAggregateOutputType | null
    _avg: ProjectEquipmentAvgAggregateOutputType | null
    _sum: ProjectEquipmentSumAggregateOutputType | null
    _min: ProjectEquipmentMinAggregateOutputType | null
    _max: ProjectEquipmentMaxAggregateOutputType | null
  }

  type GetProjectEquipmentGroupByPayload<T extends ProjectEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectEquipmentSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    quantity?: boolean
    projectId?: boolean
    equipmentId?: boolean
    equipment?: boolean | EquipmentArgs
    project?: boolean | ProjectArgs
  }


  export type ProjectEquipmentInclude = {
    equipment?: boolean | EquipmentArgs
    project?: boolean | ProjectArgs
  }

  export type ProjectEquipmentGetPayload<S extends boolean | null | undefined | ProjectEquipmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectEquipment :
    S extends undefined ? never :
    S extends { include: any } & (ProjectEquipmentArgs | ProjectEquipmentFindManyArgs)
    ? ProjectEquipment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectEquipmentArgs | ProjectEquipmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof ProjectEquipment ? ProjectEquipment[P] : never
  } 
      : ProjectEquipment


  type ProjectEquipmentCountArgs = 
    Omit<ProjectEquipmentFindManyArgs, 'select' | 'include'> & {
      select?: ProjectEquipmentCountAggregateInputType | true
    }

  export interface ProjectEquipmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectEquipment that matches the filter.
     * @param {ProjectEquipmentFindUniqueArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectEquipmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectEquipmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectEquipment'> extends True ? Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>> : Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T> | null, null>

    /**
     * Find one ProjectEquipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectEquipmentFindUniqueOrThrowArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectEquipmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectEquipmentFindUniqueOrThrowArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Find the first ProjectEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindFirstArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectEquipmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectEquipmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectEquipment'> extends True ? Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>> : Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T> | null, null>

    /**
     * Find the first ProjectEquipment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindFirstOrThrowArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectEquipmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectEquipmentFindFirstOrThrowArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Find zero or more ProjectEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectEquipments
     * const projectEquipments = await prisma.projectEquipment.findMany()
     * 
     * // Get first 10 ProjectEquipments
     * const projectEquipments = await prisma.projectEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectEquipmentWithIdOnly = await prisma.projectEquipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectEquipmentFindManyArgs>(
      args?: SelectSubset<T, ProjectEquipmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectEquipmentGetPayload<T>>>

    /**
     * Create a ProjectEquipment.
     * @param {ProjectEquipmentCreateArgs} args - Arguments to create a ProjectEquipment.
     * @example
     * // Create one ProjectEquipment
     * const ProjectEquipment = await prisma.projectEquipment.create({
     *   data: {
     *     // ... data to create a ProjectEquipment
     *   }
     * })
     * 
    **/
    create<T extends ProjectEquipmentCreateArgs>(
      args: SelectSubset<T, ProjectEquipmentCreateArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Create many ProjectEquipments.
     *     @param {ProjectEquipmentCreateManyArgs} args - Arguments to create many ProjectEquipments.
     *     @example
     *     // Create many ProjectEquipments
     *     const projectEquipment = await prisma.projectEquipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectEquipmentCreateManyArgs>(
      args?: SelectSubset<T, ProjectEquipmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectEquipment.
     * @param {ProjectEquipmentDeleteArgs} args - Arguments to delete one ProjectEquipment.
     * @example
     * // Delete one ProjectEquipment
     * const ProjectEquipment = await prisma.projectEquipment.delete({
     *   where: {
     *     // ... filter to delete one ProjectEquipment
     *   }
     * })
     * 
    **/
    delete<T extends ProjectEquipmentDeleteArgs>(
      args: SelectSubset<T, ProjectEquipmentDeleteArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Update one ProjectEquipment.
     * @param {ProjectEquipmentUpdateArgs} args - Arguments to update one ProjectEquipment.
     * @example
     * // Update one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectEquipmentUpdateArgs>(
      args: SelectSubset<T, ProjectEquipmentUpdateArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Delete zero or more ProjectEquipments.
     * @param {ProjectEquipmentDeleteManyArgs} args - Arguments to filter ProjectEquipments to delete.
     * @example
     * // Delete a few ProjectEquipments
     * const { count } = await prisma.projectEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectEquipmentDeleteManyArgs>(
      args?: SelectSubset<T, ProjectEquipmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectEquipments
     * const projectEquipment = await prisma.projectEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectEquipmentUpdateManyArgs>(
      args: SelectSubset<T, ProjectEquipmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectEquipment.
     * @param {ProjectEquipmentUpsertArgs} args - Arguments to update or create a ProjectEquipment.
     * @example
     * // Update or create a ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.upsert({
     *   create: {
     *     // ... data to create a ProjectEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectEquipment we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectEquipmentUpsertArgs>(
      args: SelectSubset<T, ProjectEquipmentUpsertArgs>
    ): Prisma__ProjectEquipmentClient<ProjectEquipmentGetPayload<T>>

    /**
     * Count the number of ProjectEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentCountArgs} args - Arguments to filter ProjectEquipments to count.
     * @example
     * // Count the number of ProjectEquipments
     * const count = await prisma.projectEquipment.count({
     *   where: {
     *     // ... the filter for the ProjectEquipments we want to count
     *   }
     * })
    **/
    count<T extends ProjectEquipmentCountArgs>(
      args?: Subset<T, ProjectEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectEquipmentAggregateArgs>(args: Subset<T, ProjectEquipmentAggregateArgs>): Prisma.PrismaPromise<GetProjectEquipmentAggregateType<T>>

    /**
     * Group by ProjectEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectEquipmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentArgs= {}>(args?: Subset<T, EquipmentArgs>): Prisma__EquipmentClient<EquipmentGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectEquipment base type for findUnique actions
   */
  export type ProjectEquipmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where: ProjectEquipmentWhereUniqueInput
  }

  /**
   * ProjectEquipment findUnique
   */
  export interface ProjectEquipmentFindUniqueArgs extends ProjectEquipmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectEquipment findUniqueOrThrow
   */
  export type ProjectEquipmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where: ProjectEquipmentWhereUniqueInput
  }


  /**
   * ProjectEquipment base type for findFirst actions
   */
  export type ProjectEquipmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEquipments.
     */
    distinct?: Enumerable<ProjectEquipmentScalarFieldEnum>
  }

  /**
   * ProjectEquipment findFirst
   */
  export interface ProjectEquipmentFindFirstArgs extends ProjectEquipmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectEquipment findFirstOrThrow
   */
  export type ProjectEquipmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEquipments.
     */
    distinct?: Enumerable<ProjectEquipmentScalarFieldEnum>
  }


  /**
   * ProjectEquipment findMany
   */
  export type ProjectEquipmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter, which ProjectEquipments to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: Enumerable<ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    distinct?: Enumerable<ProjectEquipmentScalarFieldEnum>
  }


  /**
   * ProjectEquipment create
   */
  export type ProjectEquipmentCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * The data needed to create a ProjectEquipment.
     */
    data: XOR<ProjectEquipmentCreateInput, ProjectEquipmentUncheckedCreateInput>
  }


  /**
   * ProjectEquipment createMany
   */
  export type ProjectEquipmentCreateManyArgs = {
    /**
     * The data used to create many ProjectEquipments.
     */
    data: Enumerable<ProjectEquipmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectEquipment update
   */
  export type ProjectEquipmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * The data needed to update a ProjectEquipment.
     */
    data: XOR<ProjectEquipmentUpdateInput, ProjectEquipmentUncheckedUpdateInput>
    /**
     * Choose, which ProjectEquipment to update.
     */
    where: ProjectEquipmentWhereUniqueInput
  }


  /**
   * ProjectEquipment updateMany
   */
  export type ProjectEquipmentUpdateManyArgs = {
    /**
     * The data used to update ProjectEquipments.
     */
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectEquipments to update
     */
    where?: ProjectEquipmentWhereInput
  }


  /**
   * ProjectEquipment upsert
   */
  export type ProjectEquipmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * The filter to search for the ProjectEquipment to update in case it exists.
     */
    where: ProjectEquipmentWhereUniqueInput
    /**
     * In case the ProjectEquipment found by the `where` argument doesn't exist, create a new ProjectEquipment with this data.
     */
    create: XOR<ProjectEquipmentCreateInput, ProjectEquipmentUncheckedCreateInput>
    /**
     * In case the ProjectEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectEquipmentUpdateInput, ProjectEquipmentUncheckedUpdateInput>
  }


  /**
   * ProjectEquipment delete
   */
  export type ProjectEquipmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
    /**
     * Filter which ProjectEquipment to delete.
     */
    where: ProjectEquipmentWhereUniqueInput
  }


  /**
   * ProjectEquipment deleteMany
   */
  export type ProjectEquipmentDeleteManyArgs = {
    /**
     * Filter which ProjectEquipments to delete
     */
    where?: ProjectEquipmentWhereInput
  }


  /**
   * ProjectEquipment without action
   */
  export type ProjectEquipmentArgs = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectEquipmentInclude | null
  }



  /**
   * Model Cost
   */


  export type AggregateCost = {
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  export type CostAvgAggregateOutputType = {
    id: number | null
    estimatedCost: number | null
    actualCost: number | null
    projectId: number | null
  }

  export type CostSumAggregateOutputType = {
    id: number | null
    estimatedCost: number | null
    actualCost: number | null
    projectId: number | null
  }

  export type CostMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number | null
    isDeleted: boolean | null
    type: CostType | null
  }

  export type CostMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number | null
    isDeleted: boolean | null
    type: CostType | null
  }

  export type CostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    estimatedCost: number
    actualCost: number
    name: number
    projectId: number
    isDeleted: number
    type: number
    _all: number
  }


  export type CostAvgAggregateInputType = {
    id?: true
    estimatedCost?: true
    actualCost?: true
    projectId?: true
  }

  export type CostSumAggregateInputType = {
    id?: true
    estimatedCost?: true
    actualCost?: true
    projectId?: true
  }

  export type CostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
  }

  export type CostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
  }

  export type CostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
    _all?: true
  }

  export type CostAggregateArgs = {
    /**
     * Filter which Cost to aggregate.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: Enumerable<CostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Costs
    **/
    _count?: true | CostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostMaxAggregateInputType
  }

  export type GetCostAggregateType<T extends CostAggregateArgs> = {
        [P in keyof T & keyof AggregateCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCost[P]>
      : GetScalarType<T[P], AggregateCost[P]>
  }




  export type CostGroupByArgs = {
    where?: CostWhereInput
    orderBy?: Enumerable<CostOrderByWithAggregationInput>
    by: CostScalarFieldEnum[]
    having?: CostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCountAggregateInputType | true
    _avg?: CostAvgAggregateInputType
    _sum?: CostSumAggregateInputType
    _min?: CostMinAggregateInputType
    _max?: CostMaxAggregateInputType
  }


  export type CostGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number
    isDeleted: boolean
    type: CostType
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  type GetCostGroupByPayload<T extends CostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostGroupByOutputType[P]>
            : GetScalarType<T[P], CostGroupByOutputType[P]>
        }
      >
    >


  export type CostSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    name?: boolean
    projectId?: boolean
    isDeleted?: boolean
    type?: boolean
    project?: boolean | ProjectArgs
  }


  export type CostInclude = {
    project?: boolean | ProjectArgs
  }

  export type CostGetPayload<S extends boolean | null | undefined | CostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Cost :
    S extends undefined ? never :
    S extends { include: any } & (CostArgs | CostFindManyArgs)
    ? Cost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CostArgs | CostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof Cost ? Cost[P] : never
  } 
      : Cost


  type CostCountArgs = 
    Omit<CostFindManyArgs, 'select' | 'include'> & {
      select?: CostCountAggregateInputType | true
    }

  export interface CostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Cost that matches the filter.
     * @param {CostFindUniqueArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cost'> extends True ? Prisma__CostClient<CostGetPayload<T>> : Prisma__CostClient<CostGetPayload<T> | null, null>

    /**
     * Find one Cost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CostFindUniqueOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CostFindUniqueOrThrowArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Find the first Cost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cost'> extends True ? Prisma__CostClient<CostGetPayload<T>> : Prisma__CostClient<CostGetPayload<T> | null, null>

    /**
     * Find the first Cost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CostFindFirstOrThrowArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Find zero or more Costs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costs
     * const costs = await prisma.cost.findMany()
     * 
     * // Get first 10 Costs
     * const costs = await prisma.cost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costWithIdOnly = await prisma.cost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CostFindManyArgs>(
      args?: SelectSubset<T, CostFindManyArgs>
    ): Prisma.PrismaPromise<Array<CostGetPayload<T>>>

    /**
     * Create a Cost.
     * @param {CostCreateArgs} args - Arguments to create a Cost.
     * @example
     * // Create one Cost
     * const Cost = await prisma.cost.create({
     *   data: {
     *     // ... data to create a Cost
     *   }
     * })
     * 
    **/
    create<T extends CostCreateArgs>(
      args: SelectSubset<T, CostCreateArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Create many Costs.
     *     @param {CostCreateManyArgs} args - Arguments to create many Costs.
     *     @example
     *     // Create many Costs
     *     const cost = await prisma.cost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CostCreateManyArgs>(
      args?: SelectSubset<T, CostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cost.
     * @param {CostDeleteArgs} args - Arguments to delete one Cost.
     * @example
     * // Delete one Cost
     * const Cost = await prisma.cost.delete({
     *   where: {
     *     // ... filter to delete one Cost
     *   }
     * })
     * 
    **/
    delete<T extends CostDeleteArgs>(
      args: SelectSubset<T, CostDeleteArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Update one Cost.
     * @param {CostUpdateArgs} args - Arguments to update one Cost.
     * @example
     * // Update one Cost
     * const cost = await prisma.cost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CostUpdateArgs>(
      args: SelectSubset<T, CostUpdateArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Delete zero or more Costs.
     * @param {CostDeleteManyArgs} args - Arguments to filter Costs to delete.
     * @example
     * // Delete a few Costs
     * const { count } = await prisma.cost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CostDeleteManyArgs>(
      args?: SelectSubset<T, CostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CostUpdateManyArgs>(
      args: SelectSubset<T, CostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cost.
     * @param {CostUpsertArgs} args - Arguments to update or create a Cost.
     * @example
     * // Update or create a Cost
     * const cost = await prisma.cost.upsert({
     *   create: {
     *     // ... data to create a Cost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cost we want to update
     *   }
     * })
    **/
    upsert<T extends CostUpsertArgs>(
      args: SelectSubset<T, CostUpsertArgs>
    ): Prisma__CostClient<CostGetPayload<T>>

    /**
     * Count the number of Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCountArgs} args - Arguments to filter Costs to count.
     * @example
     * // Count the number of Costs
     * const count = await prisma.cost.count({
     *   where: {
     *     // ... the filter for the Costs we want to count
     *   }
     * })
    **/
    count<T extends CostCountArgs>(
      args?: Subset<T, CostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostAggregateArgs>(args: Subset<T, CostAggregateArgs>): Prisma.PrismaPromise<GetCostAggregateType<T>>

    /**
     * Group by Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostGroupByArgs['orderBy'] }
        : { orderBy?: CostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Cost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Cost base type for findUnique actions
   */
  export type CostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findUnique
   */
  export interface CostFindUniqueArgs extends CostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cost findUniqueOrThrow
   */
  export type CostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }


  /**
   * Cost base type for findFirst actions
   */
  export type CostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: Enumerable<CostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: Enumerable<CostScalarFieldEnum>
  }

  /**
   * Cost findFirst
   */
  export interface CostFindFirstArgs extends CostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cost findFirstOrThrow
   */
  export type CostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: Enumerable<CostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: Enumerable<CostScalarFieldEnum>
  }


  /**
   * Cost findMany
   */
  export type CostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter, which Costs to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: Enumerable<CostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    distinct?: Enumerable<CostScalarFieldEnum>
  }


  /**
   * Cost create
   */
  export type CostCreateArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * The data needed to create a Cost.
     */
    data: XOR<CostCreateInput, CostUncheckedCreateInput>
  }


  /**
   * Cost createMany
   */
  export type CostCreateManyArgs = {
    /**
     * The data used to create many Costs.
     */
    data: Enumerable<CostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Cost update
   */
  export type CostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * The data needed to update a Cost.
     */
    data: XOR<CostUpdateInput, CostUncheckedUpdateInput>
    /**
     * Choose, which Cost to update.
     */
    where: CostWhereUniqueInput
  }


  /**
   * Cost updateMany
   */
  export type CostUpdateManyArgs = {
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
  }


  /**
   * Cost upsert
   */
  export type CostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * The filter to search for the Cost to update in case it exists.
     */
    where: CostWhereUniqueInput
    /**
     * In case the Cost found by the `where` argument doesn't exist, create a new Cost with this data.
     */
    create: XOR<CostCreateInput, CostUncheckedCreateInput>
    /**
     * In case the Cost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostUpdateInput, CostUncheckedUpdateInput>
  }


  /**
   * Cost delete
   */
  export type CostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
    /**
     * Filter which Cost to delete.
     */
    where: CostWhereUniqueInput
  }


  /**
   * Cost deleteMany
   */
  export type CostDeleteManyArgs = {
    /**
     * Filter which Costs to delete
     */
    where?: CostWhereInput
  }


  /**
   * Cost without action
   */
  export type CostArgs = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CostInclude | null
  }



  /**
   * Model PropertyData
   */


  export type AggregatePropertyData = {
    _count: PropertyDataCountAggregateOutputType | null
    _avg: PropertyDataAvgAggregateOutputType | null
    _sum: PropertyDataSumAggregateOutputType | null
    _min: PropertyDataMinAggregateOutputType | null
    _max: PropertyDataMaxAggregateOutputType | null
  }

  export type PropertyDataAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
  }

  export type PropertyDataSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
  }

  export type PropertyDataMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
  }

  export type PropertyDataMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
  }

  export type PropertyDataCountAggregateOutputType = {
    id: number
    createdAt: number
    projectId: number
    bathrooms: number
    bedrooms: number
    squareFootage: number
    realtyMoleId: number
    data: number
    _all: number
  }


  export type PropertyDataAvgAggregateInputType = {
    id?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
  }

  export type PropertyDataSumAggregateInputType = {
    id?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
  }

  export type PropertyDataMinAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
  }

  export type PropertyDataMaxAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
  }

  export type PropertyDataCountAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
    data?: true
    _all?: true
  }

  export type PropertyDataAggregateArgs = {
    /**
     * Filter which PropertyData to aggregate.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: Enumerable<PropertyDataOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyData
    **/
    _count?: true | PropertyDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyDataMaxAggregateInputType
  }

  export type GetPropertyDataAggregateType<T extends PropertyDataAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyData[P]>
      : GetScalarType<T[P], AggregatePropertyData[P]>
  }




  export type PropertyDataGroupByArgs = {
    where?: PropertyDataWhereInput
    orderBy?: Enumerable<PropertyDataOrderByWithAggregationInput>
    by: PropertyDataScalarFieldEnum[]
    having?: PropertyDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyDataCountAggregateInputType | true
    _avg?: PropertyDataAvgAggregateInputType
    _sum?: PropertyDataSumAggregateInputType
    _min?: PropertyDataMinAggregateInputType
    _max?: PropertyDataMaxAggregateInputType
  }


  export type PropertyDataGroupByOutputType = {
    id: number
    createdAt: Date
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
    data: JsonValue | null
    _count: PropertyDataCountAggregateOutputType | null
    _avg: PropertyDataAvgAggregateOutputType | null
    _sum: PropertyDataSumAggregateOutputType | null
    _min: PropertyDataMinAggregateOutputType | null
    _max: PropertyDataMaxAggregateOutputType | null
  }

  type GetPropertyDataGroupByPayload<T extends PropertyDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PropertyDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyDataGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyDataGroupByOutputType[P]>
        }
      >
    >


  export type PropertyDataSelect = {
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    squareFootage?: boolean
    realtyMoleId?: boolean
    data?: boolean
    project?: boolean | ProjectArgs
  }


  export type PropertyDataInclude = {
    project?: boolean | ProjectArgs
  }

  export type PropertyDataGetPayload<S extends boolean | null | undefined | PropertyDataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PropertyData :
    S extends undefined ? never :
    S extends { include: any } & (PropertyDataArgs | PropertyDataFindManyArgs)
    ? PropertyData  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (PropertyDataArgs | PropertyDataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :  P extends keyof PropertyData ? PropertyData[P] : never
  } 
      : PropertyData


  type PropertyDataCountArgs = 
    Omit<PropertyDataFindManyArgs, 'select' | 'include'> & {
      select?: PropertyDataCountAggregateInputType | true
    }

  export interface PropertyDataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PropertyData that matches the filter.
     * @param {PropertyDataFindUniqueArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyData'> extends True ? Prisma__PropertyDataClient<PropertyDataGetPayload<T>> : Prisma__PropertyDataClient<PropertyDataGetPayload<T> | null, null>

    /**
     * Find one PropertyData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyDataFindUniqueOrThrowArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyDataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PropertyDataFindUniqueOrThrowArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Find the first PropertyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindFirstArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyData'> extends True ? Prisma__PropertyDataClient<PropertyDataGetPayload<T>> : Prisma__PropertyDataClient<PropertyDataGetPayload<T> | null, null>

    /**
     * Find the first PropertyData that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindFirstOrThrowArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyDataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PropertyDataFindFirstOrThrowArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Find zero or more PropertyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyData
     * const propertyData = await prisma.propertyData.findMany()
     * 
     * // Get first 10 PropertyData
     * const propertyData = await prisma.propertyData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyDataWithIdOnly = await prisma.propertyData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyDataFindManyArgs>(
      args?: SelectSubset<T, PropertyDataFindManyArgs>
    ): Prisma.PrismaPromise<Array<PropertyDataGetPayload<T>>>

    /**
     * Create a PropertyData.
     * @param {PropertyDataCreateArgs} args - Arguments to create a PropertyData.
     * @example
     * // Create one PropertyData
     * const PropertyData = await prisma.propertyData.create({
     *   data: {
     *     // ... data to create a PropertyData
     *   }
     * })
     * 
    **/
    create<T extends PropertyDataCreateArgs>(
      args: SelectSubset<T, PropertyDataCreateArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Create many PropertyData.
     *     @param {PropertyDataCreateManyArgs} args - Arguments to create many PropertyData.
     *     @example
     *     // Create many PropertyData
     *     const propertyData = await prisma.propertyData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyDataCreateManyArgs>(
      args?: SelectSubset<T, PropertyDataCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyData.
     * @param {PropertyDataDeleteArgs} args - Arguments to delete one PropertyData.
     * @example
     * // Delete one PropertyData
     * const PropertyData = await prisma.propertyData.delete({
     *   where: {
     *     // ... filter to delete one PropertyData
     *   }
     * })
     * 
    **/
    delete<T extends PropertyDataDeleteArgs>(
      args: SelectSubset<T, PropertyDataDeleteArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Update one PropertyData.
     * @param {PropertyDataUpdateArgs} args - Arguments to update one PropertyData.
     * @example
     * // Update one PropertyData
     * const propertyData = await prisma.propertyData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyDataUpdateArgs>(
      args: SelectSubset<T, PropertyDataUpdateArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Delete zero or more PropertyData.
     * @param {PropertyDataDeleteManyArgs} args - Arguments to filter PropertyData to delete.
     * @example
     * // Delete a few PropertyData
     * const { count } = await prisma.propertyData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyDataDeleteManyArgs>(
      args?: SelectSubset<T, PropertyDataDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyData
     * const propertyData = await prisma.propertyData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyDataUpdateManyArgs>(
      args: SelectSubset<T, PropertyDataUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyData.
     * @param {PropertyDataUpsertArgs} args - Arguments to update or create a PropertyData.
     * @example
     * // Update or create a PropertyData
     * const propertyData = await prisma.propertyData.upsert({
     *   create: {
     *     // ... data to create a PropertyData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyData we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyDataUpsertArgs>(
      args: SelectSubset<T, PropertyDataUpsertArgs>
    ): Prisma__PropertyDataClient<PropertyDataGetPayload<T>>

    /**
     * Count the number of PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataCountArgs} args - Arguments to filter PropertyData to count.
     * @example
     * // Count the number of PropertyData
     * const count = await prisma.propertyData.count({
     *   where: {
     *     // ... the filter for the PropertyData we want to count
     *   }
     * })
    **/
    count<T extends PropertyDataCountArgs>(
      args?: Subset<T, PropertyDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyDataAggregateArgs>(args: Subset<T, PropertyDataAggregateArgs>): Prisma.PrismaPromise<GetPropertyDataAggregateType<T>>

    /**
     * Group by PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyDataGroupByArgs['orderBy'] }
        : { orderBy?: PropertyDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyDataClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PropertyData base type for findUnique actions
   */
  export type PropertyDataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where: PropertyDataWhereUniqueInput
  }

  /**
   * PropertyData findUnique
   */
  export interface PropertyDataFindUniqueArgs extends PropertyDataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PropertyData findUniqueOrThrow
   */
  export type PropertyDataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where: PropertyDataWhereUniqueInput
  }


  /**
   * PropertyData base type for findFirst actions
   */
  export type PropertyDataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: Enumerable<PropertyDataOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyData.
     */
    distinct?: Enumerable<PropertyDataScalarFieldEnum>
  }

  /**
   * PropertyData findFirst
   */
  export interface PropertyDataFindFirstArgs extends PropertyDataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PropertyData findFirstOrThrow
   */
  export type PropertyDataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: Enumerable<PropertyDataOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyData.
     */
    distinct?: Enumerable<PropertyDataScalarFieldEnum>
  }


  /**
   * PropertyData findMany
   */
  export type PropertyDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: Enumerable<PropertyDataOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    distinct?: Enumerable<PropertyDataScalarFieldEnum>
  }


  /**
   * PropertyData create
   */
  export type PropertyDataCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * The data needed to create a PropertyData.
     */
    data: XOR<PropertyDataCreateInput, PropertyDataUncheckedCreateInput>
  }


  /**
   * PropertyData createMany
   */
  export type PropertyDataCreateManyArgs = {
    /**
     * The data used to create many PropertyData.
     */
    data: Enumerable<PropertyDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PropertyData update
   */
  export type PropertyDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * The data needed to update a PropertyData.
     */
    data: XOR<PropertyDataUpdateInput, PropertyDataUncheckedUpdateInput>
    /**
     * Choose, which PropertyData to update.
     */
    where: PropertyDataWhereUniqueInput
  }


  /**
   * PropertyData updateMany
   */
  export type PropertyDataUpdateManyArgs = {
    /**
     * The data used to update PropertyData.
     */
    data: XOR<PropertyDataUpdateManyMutationInput, PropertyDataUncheckedUpdateManyInput>
    /**
     * Filter which PropertyData to update
     */
    where?: PropertyDataWhereInput
  }


  /**
   * PropertyData upsert
   */
  export type PropertyDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * The filter to search for the PropertyData to update in case it exists.
     */
    where: PropertyDataWhereUniqueInput
    /**
     * In case the PropertyData found by the `where` argument doesn't exist, create a new PropertyData with this data.
     */
    create: XOR<PropertyDataCreateInput, PropertyDataUncheckedCreateInput>
    /**
     * In case the PropertyData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyDataUpdateInput, PropertyDataUncheckedUpdateInput>
  }


  /**
   * PropertyData delete
   */
  export type PropertyDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
    /**
     * Filter which PropertyData to delete.
     */
    where: PropertyDataWhereUniqueInput
  }


  /**
   * PropertyData deleteMany
   */
  export type PropertyDataDeleteManyArgs = {
    /**
     * Filter which PropertyData to delete
     */
    where?: PropertyDataWhereInput
  }


  /**
   * PropertyData without action
   */
  export type PropertyDataArgs = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyDataInclude | null
  }



  /**
   * Model DataDeletionRequest
   */


  export type AggregateDataDeletionRequest = {
    _count: DataDeletionRequestCountAggregateOutputType | null
    _avg: DataDeletionRequestAvgAggregateOutputType | null
    _sum: DataDeletionRequestSumAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  export type DataDeletionRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type DataDeletionRequestSumAggregateOutputType = {
    id: number | null
  }

  export type DataDeletionRequestMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    fullName: string | null
    email: string | null
    isVerified: boolean | null
  }

  export type DataDeletionRequestMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    fullName: string | null
    email: string | null
    isVerified: boolean | null
  }

  export type DataDeletionRequestCountAggregateOutputType = {
    id: number
    createdAt: number
    fullName: number
    email: number
    isVerified: number
    _all: number
  }


  export type DataDeletionRequestAvgAggregateInputType = {
    id?: true
  }

  export type DataDeletionRequestSumAggregateInputType = {
    id?: true
  }

  export type DataDeletionRequestMinAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
  }

  export type DataDeletionRequestMaxAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
  }

  export type DataDeletionRequestCountAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
    _all?: true
  }

  export type DataDeletionRequestAggregateArgs = {
    /**
     * Filter which DataDeletionRequest to aggregate.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: Enumerable<DataDeletionRequestOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataDeletionRequests
    **/
    _count?: true | DataDeletionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataDeletionRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataDeletionRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataDeletionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type GetDataDeletionRequestAggregateType<T extends DataDeletionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataDeletionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
      : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
  }




  export type DataDeletionRequestGroupByArgs = {
    where?: DataDeletionRequestWhereInput
    orderBy?: Enumerable<DataDeletionRequestOrderByWithAggregationInput>
    by: DataDeletionRequestScalarFieldEnum[]
    having?: DataDeletionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataDeletionRequestCountAggregateInputType | true
    _avg?: DataDeletionRequestAvgAggregateInputType
    _sum?: DataDeletionRequestSumAggregateInputType
    _min?: DataDeletionRequestMinAggregateInputType
    _max?: DataDeletionRequestMaxAggregateInputType
  }


  export type DataDeletionRequestGroupByOutputType = {
    id: number
    createdAt: Date
    fullName: string
    email: string
    isVerified: boolean
    _count: DataDeletionRequestCountAggregateOutputType | null
    _avg: DataDeletionRequestAvgAggregateOutputType | null
    _sum: DataDeletionRequestSumAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  type GetDataDeletionRequestGroupByPayload<T extends DataDeletionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DataDeletionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataDeletionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataDeletionRequestSelect = {
    id?: boolean
    createdAt?: boolean
    fullName?: boolean
    email?: boolean
    isVerified?: boolean
  }


  export type DataDeletionRequestGetPayload<S extends boolean | null | undefined | DataDeletionRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DataDeletionRequest :
    S extends undefined ? never :
    S extends { include: any } & (DataDeletionRequestArgs | DataDeletionRequestFindManyArgs)
    ? DataDeletionRequest 
    : S extends { select: any } & (DataDeletionRequestArgs | DataDeletionRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DataDeletionRequest ? DataDeletionRequest[P] : never
  } 
      : DataDeletionRequest


  type DataDeletionRequestCountArgs = 
    Omit<DataDeletionRequestFindManyArgs, 'select' | 'include'> & {
      select?: DataDeletionRequestCountAggregateInputType | true
    }

  export interface DataDeletionRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DataDeletionRequest that matches the filter.
     * @param {DataDeletionRequestFindUniqueArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DataDeletionRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DataDeletionRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DataDeletionRequest'> extends True ? Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>> : Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T> | null, null>

    /**
     * Find one DataDeletionRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DataDeletionRequestFindUniqueOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DataDeletionRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DataDeletionRequestFindUniqueOrThrowArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Find the first DataDeletionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DataDeletionRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DataDeletionRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DataDeletionRequest'> extends True ? Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>> : Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T> | null, null>

    /**
     * Find the first DataDeletionRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DataDeletionRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DataDeletionRequestFindFirstOrThrowArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Find zero or more DataDeletionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
     * 
     * // Get first 10 DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DataDeletionRequestFindManyArgs>(
      args?: SelectSubset<T, DataDeletionRequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<DataDeletionRequestGetPayload<T>>>

    /**
     * Create a DataDeletionRequest.
     * @param {DataDeletionRequestCreateArgs} args - Arguments to create a DataDeletionRequest.
     * @example
     * // Create one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.create({
     *   data: {
     *     // ... data to create a DataDeletionRequest
     *   }
     * })
     * 
    **/
    create<T extends DataDeletionRequestCreateArgs>(
      args: SelectSubset<T, DataDeletionRequestCreateArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Create many DataDeletionRequests.
     *     @param {DataDeletionRequestCreateManyArgs} args - Arguments to create many DataDeletionRequests.
     *     @example
     *     // Create many DataDeletionRequests
     *     const dataDeletionRequest = await prisma.dataDeletionRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DataDeletionRequestCreateManyArgs>(
      args?: SelectSubset<T, DataDeletionRequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataDeletionRequest.
     * @param {DataDeletionRequestDeleteArgs} args - Arguments to delete one DataDeletionRequest.
     * @example
     * // Delete one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.delete({
     *   where: {
     *     // ... filter to delete one DataDeletionRequest
     *   }
     * })
     * 
    **/
    delete<T extends DataDeletionRequestDeleteArgs>(
      args: SelectSubset<T, DataDeletionRequestDeleteArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Update one DataDeletionRequest.
     * @param {DataDeletionRequestUpdateArgs} args - Arguments to update one DataDeletionRequest.
     * @example
     * // Update one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DataDeletionRequestUpdateArgs>(
      args: SelectSubset<T, DataDeletionRequestUpdateArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Delete zero or more DataDeletionRequests.
     * @param {DataDeletionRequestDeleteManyArgs} args - Arguments to filter DataDeletionRequests to delete.
     * @example
     * // Delete a few DataDeletionRequests
     * const { count } = await prisma.dataDeletionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DataDeletionRequestDeleteManyArgs>(
      args?: SelectSubset<T, DataDeletionRequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DataDeletionRequestUpdateManyArgs>(
      args: SelectSubset<T, DataDeletionRequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataDeletionRequest.
     * @param {DataDeletionRequestUpsertArgs} args - Arguments to update or create a DataDeletionRequest.
     * @example
     * // Update or create a DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.upsert({
     *   create: {
     *     // ... data to create a DataDeletionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataDeletionRequest we want to update
     *   }
     * })
    **/
    upsert<T extends DataDeletionRequestUpsertArgs>(
      args: SelectSubset<T, DataDeletionRequestUpsertArgs>
    ): Prisma__DataDeletionRequestClient<DataDeletionRequestGetPayload<T>>

    /**
     * Count the number of DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestCountArgs} args - Arguments to filter DataDeletionRequests to count.
     * @example
     * // Count the number of DataDeletionRequests
     * const count = await prisma.dataDeletionRequest.count({
     *   where: {
     *     // ... the filter for the DataDeletionRequests we want to count
     *   }
     * })
    **/
    count<T extends DataDeletionRequestCountArgs>(
      args?: Subset<T, DataDeletionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataDeletionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataDeletionRequestAggregateArgs>(args: Subset<T, DataDeletionRequestAggregateArgs>): Prisma.PrismaPromise<GetDataDeletionRequestAggregateType<T>>

    /**
     * Group by DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataDeletionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataDeletionRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataDeletionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataDeletionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataDeletionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DataDeletionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DataDeletionRequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DataDeletionRequest base type for findUnique actions
   */
  export type DataDeletionRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findUnique
   */
  export interface DataDeletionRequestFindUniqueArgs extends DataDeletionRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DataDeletionRequest findUniqueOrThrow
   */
  export type DataDeletionRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }


  /**
   * DataDeletionRequest base type for findFirst actions
   */
  export type DataDeletionRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: Enumerable<DataDeletionRequestOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: Enumerable<DataDeletionRequestScalarFieldEnum>
  }

  /**
   * DataDeletionRequest findFirst
   */
  export interface DataDeletionRequestFindFirstArgs extends DataDeletionRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DataDeletionRequest findFirstOrThrow
   */
  export type DataDeletionRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: Enumerable<DataDeletionRequestOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: Enumerable<DataDeletionRequestScalarFieldEnum>
  }


  /**
   * DataDeletionRequest findMany
   */
  export type DataDeletionRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter, which DataDeletionRequests to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: Enumerable<DataDeletionRequestOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    distinct?: Enumerable<DataDeletionRequestScalarFieldEnum>
  }


  /**
   * DataDeletionRequest create
   */
  export type DataDeletionRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * The data needed to create a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
  }


  /**
   * DataDeletionRequest createMany
   */
  export type DataDeletionRequestCreateManyArgs = {
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: Enumerable<DataDeletionRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DataDeletionRequest update
   */
  export type DataDeletionRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * The data needed to update a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
    /**
     * Choose, which DataDeletionRequest to update.
     */
    where: DataDeletionRequestWhereUniqueInput
  }


  /**
   * DataDeletionRequest updateMany
   */
  export type DataDeletionRequestUpdateManyArgs = {
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
  }


  /**
   * DataDeletionRequest upsert
   */
  export type DataDeletionRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * The filter to search for the DataDeletionRequest to update in case it exists.
     */
    where: DataDeletionRequestWhereUniqueInput
    /**
     * In case the DataDeletionRequest found by the `where` argument doesn't exist, create a new DataDeletionRequest with this data.
     */
    create: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
    /**
     * In case the DataDeletionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
  }


  /**
   * DataDeletionRequest delete
   */
  export type DataDeletionRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
    /**
     * Filter which DataDeletionRequest to delete.
     */
    where: DataDeletionRequestWhereUniqueInput
  }


  /**
   * DataDeletionRequest deleteMany
   */
  export type DataDeletionRequestDeleteManyArgs = {
    /**
     * Filter which DataDeletionRequests to delete
     */
    where?: DataDeletionRequestWhereInput
  }


  /**
   * DataDeletionRequest without action
   */
  export type DataDeletionRequestArgs = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect | null
  }



  /**
   * Model PhotoAccessLink
   */


  export type AggregatePhotoAccessLink = {
    _count: PhotoAccessLinkCountAggregateOutputType | null
    _avg: PhotoAccessLinkAvgAggregateOutputType | null
    _sum: PhotoAccessLinkSumAggregateOutputType | null
    _min: PhotoAccessLinkMinAggregateOutputType | null
    _max: PhotoAccessLinkMaxAggregateOutputType | null
  }

  export type PhotoAccessLinkAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PhotoAccessLinkSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PhotoAccessLinkMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    expiresAt: Date | null
    accessId: string | null
    email: string | null
    phoneNumber: string | null
    projectId: number | null
  }

  export type PhotoAccessLinkMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    expiresAt: Date | null
    accessId: string | null
    email: string | null
    phoneNumber: string | null
    projectId: number | null
  }

  export type PhotoAccessLinkCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    accessId: number
    email: number
    phoneNumber: number
    projectId: number
    _all: number
  }


  export type PhotoAccessLinkAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PhotoAccessLinkSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PhotoAccessLinkMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
  }

  export type PhotoAccessLinkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
  }

  export type PhotoAccessLinkCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
    _all?: true
  }

  export type PhotoAccessLinkAggregateArgs = {
    /**
     * Filter which PhotoAccessLink to aggregate.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotoAccessLinks
    **/
    _count?: true | PhotoAccessLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAccessLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoAccessLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoAccessLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoAccessLinkMaxAggregateInputType
  }

  export type GetPhotoAccessLinkAggregateType<T extends PhotoAccessLinkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotoAccessLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotoAccessLink[P]>
      : GetScalarType<T[P], AggregatePhotoAccessLink[P]>
  }




  export type PhotoAccessLinkGroupByArgs = {
    where?: PhotoAccessLinkWhereInput
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithAggregationInput>
    by: PhotoAccessLinkScalarFieldEnum[]
    having?: PhotoAccessLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoAccessLinkCountAggregateInputType | true
    _avg?: PhotoAccessLinkAvgAggregateInputType
    _sum?: PhotoAccessLinkSumAggregateInputType
    _min?: PhotoAccessLinkMinAggregateInputType
    _max?: PhotoAccessLinkMaxAggregateInputType
  }


  export type PhotoAccessLinkGroupByOutputType = {
    id: number
    createdAt: Date
    expiresAt: Date | null
    accessId: string
    email: string | null
    phoneNumber: string | null
    projectId: number
    _count: PhotoAccessLinkCountAggregateOutputType | null
    _avg: PhotoAccessLinkAvgAggregateOutputType | null
    _sum: PhotoAccessLinkSumAggregateOutputType | null
    _min: PhotoAccessLinkMinAggregateOutputType | null
    _max: PhotoAccessLinkMaxAggregateOutputType | null
  }

  type GetPhotoAccessLinkGroupByPayload<T extends PhotoAccessLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PhotoAccessLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoAccessLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoAccessLinkGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoAccessLinkGroupByOutputType[P]>
        }
      >
    >


  export type PhotoAccessLinkSelect = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    accessId?: boolean
    email?: boolean
    phoneNumber?: boolean
    projectId?: boolean
    project?: boolean | ProjectArgs
  }


  export type PhotoAccessLinkInclude = {
    project?: boolean | ProjectArgs
  }

  export type PhotoAccessLinkGetPayload<S extends boolean | null | undefined | PhotoAccessLinkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PhotoAccessLink :
    S extends undefined ? never :
    S extends { include: any } & (PhotoAccessLinkArgs | PhotoAccessLinkFindManyArgs)
    ? PhotoAccessLink  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PhotoAccessLinkArgs | PhotoAccessLinkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof PhotoAccessLink ? PhotoAccessLink[P] : never
  } 
      : PhotoAccessLink


  type PhotoAccessLinkCountArgs = 
    Omit<PhotoAccessLinkFindManyArgs, 'select' | 'include'> & {
      select?: PhotoAccessLinkCountAggregateInputType | true
    }

  export interface PhotoAccessLinkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PhotoAccessLink that matches the filter.
     * @param {PhotoAccessLinkFindUniqueArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoAccessLinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhotoAccessLinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhotoAccessLink'> extends True ? Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>> : Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T> | null, null>

    /**
     * Find one PhotoAccessLink that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotoAccessLinkFindUniqueOrThrowArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotoAccessLinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PhotoAccessLinkFindUniqueOrThrowArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Find the first PhotoAccessLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindFirstArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoAccessLinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhotoAccessLinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhotoAccessLink'> extends True ? Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>> : Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T> | null, null>

    /**
     * Find the first PhotoAccessLink that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindFirstOrThrowArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotoAccessLinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PhotoAccessLinkFindFirstOrThrowArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Find zero or more PhotoAccessLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotoAccessLinks
     * const photoAccessLinks = await prisma.photoAccessLink.findMany()
     * 
     * // Get first 10 PhotoAccessLinks
     * const photoAccessLinks = await prisma.photoAccessLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoAccessLinkWithIdOnly = await prisma.photoAccessLink.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhotoAccessLinkFindManyArgs>(
      args?: SelectSubset<T, PhotoAccessLinkFindManyArgs>
    ): Prisma.PrismaPromise<Array<PhotoAccessLinkGetPayload<T>>>

    /**
     * Create a PhotoAccessLink.
     * @param {PhotoAccessLinkCreateArgs} args - Arguments to create a PhotoAccessLink.
     * @example
     * // Create one PhotoAccessLink
     * const PhotoAccessLink = await prisma.photoAccessLink.create({
     *   data: {
     *     // ... data to create a PhotoAccessLink
     *   }
     * })
     * 
    **/
    create<T extends PhotoAccessLinkCreateArgs>(
      args: SelectSubset<T, PhotoAccessLinkCreateArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Create many PhotoAccessLinks.
     *     @param {PhotoAccessLinkCreateManyArgs} args - Arguments to create many PhotoAccessLinks.
     *     @example
     *     // Create many PhotoAccessLinks
     *     const photoAccessLink = await prisma.photoAccessLink.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhotoAccessLinkCreateManyArgs>(
      args?: SelectSubset<T, PhotoAccessLinkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhotoAccessLink.
     * @param {PhotoAccessLinkDeleteArgs} args - Arguments to delete one PhotoAccessLink.
     * @example
     * // Delete one PhotoAccessLink
     * const PhotoAccessLink = await prisma.photoAccessLink.delete({
     *   where: {
     *     // ... filter to delete one PhotoAccessLink
     *   }
     * })
     * 
    **/
    delete<T extends PhotoAccessLinkDeleteArgs>(
      args: SelectSubset<T, PhotoAccessLinkDeleteArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Update one PhotoAccessLink.
     * @param {PhotoAccessLinkUpdateArgs} args - Arguments to update one PhotoAccessLink.
     * @example
     * // Update one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoAccessLinkUpdateArgs>(
      args: SelectSubset<T, PhotoAccessLinkUpdateArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Delete zero or more PhotoAccessLinks.
     * @param {PhotoAccessLinkDeleteManyArgs} args - Arguments to filter PhotoAccessLinks to delete.
     * @example
     * // Delete a few PhotoAccessLinks
     * const { count } = await prisma.photoAccessLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoAccessLinkDeleteManyArgs>(
      args?: SelectSubset<T, PhotoAccessLinkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoAccessLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotoAccessLinks
     * const photoAccessLink = await prisma.photoAccessLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoAccessLinkUpdateManyArgs>(
      args: SelectSubset<T, PhotoAccessLinkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotoAccessLink.
     * @param {PhotoAccessLinkUpsertArgs} args - Arguments to update or create a PhotoAccessLink.
     * @example
     * // Update or create a PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.upsert({
     *   create: {
     *     // ... data to create a PhotoAccessLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotoAccessLink we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoAccessLinkUpsertArgs>(
      args: SelectSubset<T, PhotoAccessLinkUpsertArgs>
    ): Prisma__PhotoAccessLinkClient<PhotoAccessLinkGetPayload<T>>

    /**
     * Count the number of PhotoAccessLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkCountArgs} args - Arguments to filter PhotoAccessLinks to count.
     * @example
     * // Count the number of PhotoAccessLinks
     * const count = await prisma.photoAccessLink.count({
     *   where: {
     *     // ... the filter for the PhotoAccessLinks we want to count
     *   }
     * })
    **/
    count<T extends PhotoAccessLinkCountArgs>(
      args?: Subset<T, PhotoAccessLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoAccessLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotoAccessLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAccessLinkAggregateArgs>(args: Subset<T, PhotoAccessLinkAggregateArgs>): Prisma.PrismaPromise<GetPhotoAccessLinkAggregateType<T>>

    /**
     * Group by PhotoAccessLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoAccessLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoAccessLinkGroupByArgs['orderBy'] }
        : { orderBy?: PhotoAccessLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoAccessLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoAccessLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotoAccessLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhotoAccessLinkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PhotoAccessLink base type for findUnique actions
   */
  export type PhotoAccessLinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }

  /**
   * PhotoAccessLink findUnique
   */
  export interface PhotoAccessLinkFindUniqueArgs extends PhotoAccessLinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoAccessLink findUniqueOrThrow
   */
  export type PhotoAccessLinkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }


  /**
   * PhotoAccessLink base type for findFirst actions
   */
  export type PhotoAccessLinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAccessLinks.
     */
    distinct?: Enumerable<PhotoAccessLinkScalarFieldEnum>
  }

  /**
   * PhotoAccessLink findFirst
   */
  export interface PhotoAccessLinkFindFirstArgs extends PhotoAccessLinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoAccessLink findFirstOrThrow
   */
  export type PhotoAccessLinkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAccessLinks.
     */
    distinct?: Enumerable<PhotoAccessLinkScalarFieldEnum>
  }


  /**
   * PhotoAccessLink findMany
   */
  export type PhotoAccessLinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter, which PhotoAccessLinks to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: Enumerable<PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    distinct?: Enumerable<PhotoAccessLinkScalarFieldEnum>
  }


  /**
   * PhotoAccessLink create
   */
  export type PhotoAccessLinkCreateArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * The data needed to create a PhotoAccessLink.
     */
    data: XOR<PhotoAccessLinkCreateInput, PhotoAccessLinkUncheckedCreateInput>
  }


  /**
   * PhotoAccessLink createMany
   */
  export type PhotoAccessLinkCreateManyArgs = {
    /**
     * The data used to create many PhotoAccessLinks.
     */
    data: Enumerable<PhotoAccessLinkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PhotoAccessLink update
   */
  export type PhotoAccessLinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * The data needed to update a PhotoAccessLink.
     */
    data: XOR<PhotoAccessLinkUpdateInput, PhotoAccessLinkUncheckedUpdateInput>
    /**
     * Choose, which PhotoAccessLink to update.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }


  /**
   * PhotoAccessLink updateMany
   */
  export type PhotoAccessLinkUpdateManyArgs = {
    /**
     * The data used to update PhotoAccessLinks.
     */
    data: XOR<PhotoAccessLinkUpdateManyMutationInput, PhotoAccessLinkUncheckedUpdateManyInput>
    /**
     * Filter which PhotoAccessLinks to update
     */
    where?: PhotoAccessLinkWhereInput
  }


  /**
   * PhotoAccessLink upsert
   */
  export type PhotoAccessLinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * The filter to search for the PhotoAccessLink to update in case it exists.
     */
    where: PhotoAccessLinkWhereUniqueInput
    /**
     * In case the PhotoAccessLink found by the `where` argument doesn't exist, create a new PhotoAccessLink with this data.
     */
    create: XOR<PhotoAccessLinkCreateInput, PhotoAccessLinkUncheckedCreateInput>
    /**
     * In case the PhotoAccessLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoAccessLinkUpdateInput, PhotoAccessLinkUncheckedUpdateInput>
  }


  /**
   * PhotoAccessLink delete
   */
  export type PhotoAccessLinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
    /**
     * Filter which PhotoAccessLink to delete.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }


  /**
   * PhotoAccessLink deleteMany
   */
  export type PhotoAccessLinkDeleteManyArgs = {
    /**
     * Filter which PhotoAccessLinks to delete
     */
    where?: PhotoAccessLinkWhereInput
  }


  /**
   * PhotoAccessLink without action
   */
  export type PhotoAccessLinkArgs = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAccessLinkInclude | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    organizationId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    organizationId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    key: string | null
    projectId: number | null
    organizationId: number | null
    includeInReport: boolean | null
    description: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    key: string | null
    projectId: number | null
    organizationId: number | null
    includeInReport: boolean | null
    description: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    key: number
    projectId: number
    organizationId: number
    includeInReport: number
    description: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    projectId?: true
    organizationId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    projectId?: true
    organizationId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs = {
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithAggregationInput>
    by: ImageScalarFieldEnum[]
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    key: string
    projectId: number
    organizationId: number | null
    includeInReport: boolean
    description: string | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    key?: boolean
    projectId?: boolean
    organizationId?: boolean
    includeInReport?: boolean
    description?: boolean
    organization?: boolean | OrganizationArgs
    project?: boolean | ProjectArgs
    inference?: boolean | InferenceArgs
    ImageNote?: boolean | Image$ImageNoteArgs
    Annotation?: boolean | Image$AnnotationArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }


  export type ImageInclude = {
    organization?: boolean | OrganizationArgs
    project?: boolean | ProjectArgs
    inference?: boolean | InferenceArgs
    ImageNote?: boolean | Image$ImageNoteArgs
    Annotation?: boolean | Image$AnnotationArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }

  export type ImageGetPayload<S extends boolean | null | undefined | ImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Image :
    S extends undefined ? never :
    S extends { include: any } & (ImageArgs | ImageFindManyArgs)
    ? Image  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> | null :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'inference' ? InferenceGetPayload<S['include'][P]> | null :
        P extends 'ImageNote' ? Array < ImageNoteGetPayload<S['include'][P]>>  :
        P extends 'Annotation' ? Array < AnnotationGetPayload<S['include'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ImageArgs | ImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> | null :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'inference' ? InferenceGetPayload<S['select'][P]> | null :
        P extends 'ImageNote' ? Array < ImageNoteGetPayload<S['select'][P]>>  :
        P extends 'Annotation' ? Array < AnnotationGetPayload<S['select'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Image ? Image[P] : never
  } 
      : Image


  type ImageCountArgs = 
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Image'> extends True ? Prisma__ImageClient<ImageGetPayload<T>> : Prisma__ImageClient<ImageGetPayload<T> | null, null>

    /**
     * Find one Image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageFindUniqueOrThrowArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Image'> extends True ? Prisma__ImageClient<ImageGetPayload<T>> : Prisma__ImageClient<ImageGetPayload<T> | null, null>

    /**
     * Find the first Image that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageFindFirstOrThrowArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs>
    ): Prisma.PrismaPromise<Array<ImageGetPayload<T>>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs>(
      args?: SelectSubset<T, ImageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    inference<T extends InferenceArgs= {}>(args?: Subset<T, InferenceArgs>): Prisma__InferenceClient<InferenceGetPayload<T> | Null>;

    ImageNote<T extends Image$ImageNoteArgs= {}>(args?: Subset<T, Image$ImageNoteArgs>): Prisma.PrismaPromise<Array<ImageNoteGetPayload<T>>| Null>;

    Annotation<T extends Image$AnnotationArgs= {}>(args?: Subset<T, Image$AnnotationArgs>): Prisma.PrismaPromise<Array<AnnotationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Image base type for findUnique actions
   */
  export type ImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUnique
   */
  export interface ImageFindUniqueArgs extends ImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image base type for findFirst actions
   */
  export type ImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }

  /**
   * Image findFirst
   */
  export interface ImageFindFirstArgs extends ImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs = {
    /**
     * The data used to create many Images.
     */
    data: Enumerable<ImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }


  /**
   * Image.ImageNote
   */
  export type Image$ImageNoteArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    where?: ImageNoteWhereInput
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ImageNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageNoteScalarFieldEnum>
  }


  /**
   * Image.Annotation
   */
  export type Image$AnnotationArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    where?: AnnotationWhereInput
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnnotationScalarFieldEnum>
  }


  /**
   * Image without action
   */
  export type ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
  }



  /**
   * Model Annotation
   */


  export type AggregateAnnotation = {
    _count: AnnotationCountAggregateOutputType | null
    _avg: AnnotationAvgAggregateOutputType | null
    _sum: AnnotationSumAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  export type AnnotationAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type AnnotationSumAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type AnnotationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type AnnotationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type AnnotationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    imageId: number
    coordinates: number
    userId: number
    isDeleted: number
    _all: number
  }


  export type AnnotationAvgAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type AnnotationSumAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type AnnotationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    userId?: true
    isDeleted?: true
  }

  export type AnnotationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    userId?: true
    isDeleted?: true
  }

  export type AnnotationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    coordinates?: true
    userId?: true
    isDeleted?: true
    _all?: true
  }

  export type AnnotationAggregateArgs = {
    /**
     * Filter which Annotation to aggregate.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annotations
    **/
    _count?: true | AnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationMaxAggregateInputType
  }

  export type GetAnnotationAggregateType<T extends AnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotation[P]>
      : GetScalarType<T[P], AggregateAnnotation[P]>
  }




  export type AnnotationGroupByArgs = {
    where?: AnnotationWhereInput
    orderBy?: Enumerable<AnnotationOrderByWithAggregationInput>
    by: AnnotationScalarFieldEnum[]
    having?: AnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationCountAggregateInputType | true
    _avg?: AnnotationAvgAggregateInputType
    _sum?: AnnotationSumAggregateInputType
    _min?: AnnotationMinAggregateInputType
    _max?: AnnotationMaxAggregateInputType
  }


  export type AnnotationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    imageId: number
    coordinates: JsonValue
    userId: string
    isDeleted: boolean
    _count: AnnotationCountAggregateOutputType | null
    _avg: AnnotationAvgAggregateOutputType | null
    _sum: AnnotationSumAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  type GetAnnotationGroupByPayload<T extends AnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    coordinates?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageArgs
    User?: boolean | UserArgs
  }


  export type AnnotationInclude = {
    Image?: boolean | ImageArgs
    User?: boolean | UserArgs
  }

  export type AnnotationGetPayload<S extends boolean | null | undefined | AnnotationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Annotation :
    S extends undefined ? never :
    S extends { include: any } & (AnnotationArgs | AnnotationFindManyArgs)
    ? Annotation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Image' ? ImageGetPayload<S['include'][P]> :
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AnnotationArgs | AnnotationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Image' ? ImageGetPayload<S['select'][P]> :
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof Annotation ? Annotation[P] : never
  } 
      : Annotation


  type AnnotationCountArgs = 
    Omit<AnnotationFindManyArgs, 'select' | 'include'> & {
      select?: AnnotationCountAggregateInputType | true
    }

  export interface AnnotationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Annotation that matches the filter.
     * @param {AnnotationFindUniqueArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnnotationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnnotationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Annotation'> extends True ? Prisma__AnnotationClient<AnnotationGetPayload<T>> : Prisma__AnnotationClient<AnnotationGetPayload<T> | null, null>

    /**
     * Find one Annotation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnnotationFindUniqueOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnnotationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AnnotationFindUniqueOrThrowArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Find the first Annotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnnotationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnnotationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Annotation'> extends True ? Prisma__AnnotationClient<AnnotationGetPayload<T>> : Prisma__AnnotationClient<AnnotationGetPayload<T> | null, null>

    /**
     * Find the first Annotation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnnotationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnotationFindFirstOrThrowArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Find zero or more Annotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annotations
     * const annotations = await prisma.annotation.findMany()
     * 
     * // Get first 10 Annotations
     * const annotations = await prisma.annotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationWithIdOnly = await prisma.annotation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnnotationFindManyArgs>(
      args?: SelectSubset<T, AnnotationFindManyArgs>
    ): Prisma.PrismaPromise<Array<AnnotationGetPayload<T>>>

    /**
     * Create a Annotation.
     * @param {AnnotationCreateArgs} args - Arguments to create a Annotation.
     * @example
     * // Create one Annotation
     * const Annotation = await prisma.annotation.create({
     *   data: {
     *     // ... data to create a Annotation
     *   }
     * })
     * 
    **/
    create<T extends AnnotationCreateArgs>(
      args: SelectSubset<T, AnnotationCreateArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Create many Annotations.
     *     @param {AnnotationCreateManyArgs} args - Arguments to create many Annotations.
     *     @example
     *     // Create many Annotations
     *     const annotation = await prisma.annotation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnnotationCreateManyArgs>(
      args?: SelectSubset<T, AnnotationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Annotation.
     * @param {AnnotationDeleteArgs} args - Arguments to delete one Annotation.
     * @example
     * // Delete one Annotation
     * const Annotation = await prisma.annotation.delete({
     *   where: {
     *     // ... filter to delete one Annotation
     *   }
     * })
     * 
    **/
    delete<T extends AnnotationDeleteArgs>(
      args: SelectSubset<T, AnnotationDeleteArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Update one Annotation.
     * @param {AnnotationUpdateArgs} args - Arguments to update one Annotation.
     * @example
     * // Update one Annotation
     * const annotation = await prisma.annotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnnotationUpdateArgs>(
      args: SelectSubset<T, AnnotationUpdateArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Delete zero or more Annotations.
     * @param {AnnotationDeleteManyArgs} args - Arguments to filter Annotations to delete.
     * @example
     * // Delete a few Annotations
     * const { count } = await prisma.annotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnnotationDeleteManyArgs>(
      args?: SelectSubset<T, AnnotationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnnotationUpdateManyArgs>(
      args: SelectSubset<T, AnnotationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Annotation.
     * @param {AnnotationUpsertArgs} args - Arguments to update or create a Annotation.
     * @example
     * // Update or create a Annotation
     * const annotation = await prisma.annotation.upsert({
     *   create: {
     *     // ... data to create a Annotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annotation we want to update
     *   }
     * })
    **/
    upsert<T extends AnnotationUpsertArgs>(
      args: SelectSubset<T, AnnotationUpsertArgs>
    ): Prisma__AnnotationClient<AnnotationGetPayload<T>>

    /**
     * Count the number of Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationCountArgs} args - Arguments to filter Annotations to count.
     * @example
     * // Count the number of Annotations
     * const count = await prisma.annotation.count({
     *   where: {
     *     // ... the filter for the Annotations we want to count
     *   }
     * })
    **/
    count<T extends AnnotationCountArgs>(
      args?: Subset<T, AnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationAggregateArgs>(args: Subset<T, AnnotationAggregateArgs>): Prisma.PrismaPromise<GetAnnotationAggregateType<T>>

    /**
     * Group by Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Annotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnnotationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Image<T extends ImageArgs= {}>(args?: Subset<T, ImageArgs>): Prisma__ImageClient<ImageGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Annotation base type for findUnique actions
   */
  export type AnnotationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findUnique
   */
  export interface AnnotationFindUniqueArgs extends AnnotationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Annotation findUniqueOrThrow
   */
  export type AnnotationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }


  /**
   * Annotation base type for findFirst actions
   */
  export type AnnotationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: Enumerable<AnnotationScalarFieldEnum>
  }

  /**
   * Annotation findFirst
   */
  export interface AnnotationFindFirstArgs extends AnnotationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Annotation findFirstOrThrow
   */
  export type AnnotationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: Enumerable<AnnotationScalarFieldEnum>
  }


  /**
   * Annotation findMany
   */
  export type AnnotationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter, which Annotations to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: Enumerable<AnnotationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    distinct?: Enumerable<AnnotationScalarFieldEnum>
  }


  /**
   * Annotation create
   */
  export type AnnotationCreateArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * The data needed to create a Annotation.
     */
    data: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
  }


  /**
   * Annotation createMany
   */
  export type AnnotationCreateManyArgs = {
    /**
     * The data used to create many Annotations.
     */
    data: Enumerable<AnnotationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Annotation update
   */
  export type AnnotationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * The data needed to update a Annotation.
     */
    data: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
    /**
     * Choose, which Annotation to update.
     */
    where: AnnotationWhereUniqueInput
  }


  /**
   * Annotation updateMany
   */
  export type AnnotationUpdateManyArgs = {
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
  }


  /**
   * Annotation upsert
   */
  export type AnnotationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * The filter to search for the Annotation to update in case it exists.
     */
    where: AnnotationWhereUniqueInput
    /**
     * In case the Annotation found by the `where` argument doesn't exist, create a new Annotation with this data.
     */
    create: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
    /**
     * In case the Annotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
  }


  /**
   * Annotation delete
   */
  export type AnnotationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
    /**
     * Filter which Annotation to delete.
     */
    where: AnnotationWhereUniqueInput
  }


  /**
   * Annotation deleteMany
   */
  export type AnnotationDeleteManyArgs = {
    /**
     * Filter which Annotations to delete
     */
    where?: AnnotationWhereInput
  }


  /**
   * Annotation without action
   */
  export type AnnotationArgs = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnotationInclude | null
  }



  /**
   * Model ImageNote
   */


  export type AggregateImageNote = {
    _count: ImageNoteCountAggregateOutputType | null
    _avg: ImageNoteAvgAggregateOutputType | null
    _sum: ImageNoteSumAggregateOutputType | null
    _min: ImageNoteMinAggregateOutputType | null
    _max: ImageNoteMaxAggregateOutputType | null
  }

  export type ImageNoteAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type ImageNoteSumAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type ImageNoteMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    body: string | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type ImageNoteMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    body: string | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type ImageNoteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    imageId: number
    body: number
    mentions: number
    userId: number
    isDeleted: number
    _all: number
  }


  export type ImageNoteAvgAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type ImageNoteSumAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type ImageNoteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    userId?: true
    isDeleted?: true
  }

  export type ImageNoteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    userId?: true
    isDeleted?: true
  }

  export type ImageNoteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    mentions?: true
    userId?: true
    isDeleted?: true
    _all?: true
  }

  export type ImageNoteAggregateArgs = {
    /**
     * Filter which ImageNote to aggregate.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageNotes
    **/
    _count?: true | ImageNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageNoteMaxAggregateInputType
  }

  export type GetImageNoteAggregateType<T extends ImageNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateImageNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageNote[P]>
      : GetScalarType<T[P], AggregateImageNote[P]>
  }




  export type ImageNoteGroupByArgs = {
    where?: ImageNoteWhereInput
    orderBy?: Enumerable<ImageNoteOrderByWithAggregationInput>
    by: ImageNoteScalarFieldEnum[]
    having?: ImageNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageNoteCountAggregateInputType | true
    _avg?: ImageNoteAvgAggregateInputType
    _sum?: ImageNoteSumAggregateInputType
    _min?: ImageNoteMinAggregateInputType
    _max?: ImageNoteMaxAggregateInputType
  }


  export type ImageNoteGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    imageId: number
    body: string
    mentions: string[]
    userId: string
    isDeleted: boolean
    _count: ImageNoteCountAggregateOutputType | null
    _avg: ImageNoteAvgAggregateOutputType | null
    _sum: ImageNoteSumAggregateOutputType | null
    _min: ImageNoteMinAggregateOutputType | null
    _max: ImageNoteMaxAggregateOutputType | null
  }

  type GetImageNoteGroupByPayload<T extends ImageNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImageNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ImageNoteGroupByOutputType[P]>
        }
      >
    >


  export type ImageNoteSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageArgs
    User?: boolean | UserArgs
  }


  export type ImageNoteInclude = {
    Image?: boolean | ImageArgs
    User?: boolean | UserArgs
  }

  export type ImageNoteGetPayload<S extends boolean | null | undefined | ImageNoteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImageNote :
    S extends undefined ? never :
    S extends { include: any } & (ImageNoteArgs | ImageNoteFindManyArgs)
    ? ImageNote  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Image' ? ImageGetPayload<S['include'][P]> :
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ImageNoteArgs | ImageNoteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Image' ? ImageGetPayload<S['select'][P]> :
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof ImageNote ? ImageNote[P] : never
  } 
      : ImageNote


  type ImageNoteCountArgs = 
    Omit<ImageNoteFindManyArgs, 'select' | 'include'> & {
      select?: ImageNoteCountAggregateInputType | true
    }

  export interface ImageNoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ImageNote that matches the filter.
     * @param {ImageNoteFindUniqueArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageNoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageNoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImageNote'> extends True ? Prisma__ImageNoteClient<ImageNoteGetPayload<T>> : Prisma__ImageNoteClient<ImageNoteGetPayload<T> | null, null>

    /**
     * Find one ImageNote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImageNoteFindUniqueOrThrowArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageNoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageNoteFindUniqueOrThrowArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Find the first ImageNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindFirstArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageNoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageNoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImageNote'> extends True ? Prisma__ImageNoteClient<ImageNoteGetPayload<T>> : Prisma__ImageNoteClient<ImageNoteGetPayload<T> | null, null>

    /**
     * Find the first ImageNote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindFirstOrThrowArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageNoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageNoteFindFirstOrThrowArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Find zero or more ImageNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageNotes
     * const imageNotes = await prisma.imageNote.findMany()
     * 
     * // Get first 10 ImageNotes
     * const imageNotes = await prisma.imageNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageNoteWithIdOnly = await prisma.imageNote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageNoteFindManyArgs>(
      args?: SelectSubset<T, ImageNoteFindManyArgs>
    ): Prisma.PrismaPromise<Array<ImageNoteGetPayload<T>>>

    /**
     * Create a ImageNote.
     * @param {ImageNoteCreateArgs} args - Arguments to create a ImageNote.
     * @example
     * // Create one ImageNote
     * const ImageNote = await prisma.imageNote.create({
     *   data: {
     *     // ... data to create a ImageNote
     *   }
     * })
     * 
    **/
    create<T extends ImageNoteCreateArgs>(
      args: SelectSubset<T, ImageNoteCreateArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Create many ImageNotes.
     *     @param {ImageNoteCreateManyArgs} args - Arguments to create many ImageNotes.
     *     @example
     *     // Create many ImageNotes
     *     const imageNote = await prisma.imageNote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageNoteCreateManyArgs>(
      args?: SelectSubset<T, ImageNoteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImageNote.
     * @param {ImageNoteDeleteArgs} args - Arguments to delete one ImageNote.
     * @example
     * // Delete one ImageNote
     * const ImageNote = await prisma.imageNote.delete({
     *   where: {
     *     // ... filter to delete one ImageNote
     *   }
     * })
     * 
    **/
    delete<T extends ImageNoteDeleteArgs>(
      args: SelectSubset<T, ImageNoteDeleteArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Update one ImageNote.
     * @param {ImageNoteUpdateArgs} args - Arguments to update one ImageNote.
     * @example
     * // Update one ImageNote
     * const imageNote = await prisma.imageNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageNoteUpdateArgs>(
      args: SelectSubset<T, ImageNoteUpdateArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Delete zero or more ImageNotes.
     * @param {ImageNoteDeleteManyArgs} args - Arguments to filter ImageNotes to delete.
     * @example
     * // Delete a few ImageNotes
     * const { count } = await prisma.imageNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageNoteDeleteManyArgs>(
      args?: SelectSubset<T, ImageNoteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageNotes
     * const imageNote = await prisma.imageNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageNoteUpdateManyArgs>(
      args: SelectSubset<T, ImageNoteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageNote.
     * @param {ImageNoteUpsertArgs} args - Arguments to update or create a ImageNote.
     * @example
     * // Update or create a ImageNote
     * const imageNote = await prisma.imageNote.upsert({
     *   create: {
     *     // ... data to create a ImageNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageNote we want to update
     *   }
     * })
    **/
    upsert<T extends ImageNoteUpsertArgs>(
      args: SelectSubset<T, ImageNoteUpsertArgs>
    ): Prisma__ImageNoteClient<ImageNoteGetPayload<T>>

    /**
     * Count the number of ImageNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteCountArgs} args - Arguments to filter ImageNotes to count.
     * @example
     * // Count the number of ImageNotes
     * const count = await prisma.imageNote.count({
     *   where: {
     *     // ... the filter for the ImageNotes we want to count
     *   }
     * })
    **/
    count<T extends ImageNoteCountArgs>(
      args?: Subset<T, ImageNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageNoteAggregateArgs>(args: Subset<T, ImageNoteAggregateArgs>): Prisma.PrismaPromise<GetImageNoteAggregateType<T>>

    /**
     * Group by ImageNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageNoteGroupByArgs['orderBy'] }
        : { orderBy?: ImageNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageNoteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Image<T extends ImageArgs= {}>(args?: Subset<T, ImageArgs>): Prisma__ImageClient<ImageGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImageNote base type for findUnique actions
   */
  export type ImageNoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where: ImageNoteWhereUniqueInput
  }

  /**
   * ImageNote findUnique
   */
  export interface ImageNoteFindUniqueArgs extends ImageNoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageNote findUniqueOrThrow
   */
  export type ImageNoteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where: ImageNoteWhereUniqueInput
  }


  /**
   * ImageNote base type for findFirst actions
   */
  export type ImageNoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageNotes.
     */
    distinct?: Enumerable<ImageNoteScalarFieldEnum>
  }

  /**
   * ImageNote findFirst
   */
  export interface ImageNoteFindFirstArgs extends ImageNoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImageNote findFirstOrThrow
   */
  export type ImageNoteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageNotes.
     */
    distinct?: Enumerable<ImageNoteScalarFieldEnum>
  }


  /**
   * ImageNote findMany
   */
  export type ImageNoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter, which ImageNotes to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: Enumerable<ImageNoteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    distinct?: Enumerable<ImageNoteScalarFieldEnum>
  }


  /**
   * ImageNote create
   */
  export type ImageNoteCreateArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * The data needed to create a ImageNote.
     */
    data: XOR<ImageNoteCreateInput, ImageNoteUncheckedCreateInput>
  }


  /**
   * ImageNote createMany
   */
  export type ImageNoteCreateManyArgs = {
    /**
     * The data used to create many ImageNotes.
     */
    data: Enumerable<ImageNoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImageNote update
   */
  export type ImageNoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * The data needed to update a ImageNote.
     */
    data: XOR<ImageNoteUpdateInput, ImageNoteUncheckedUpdateInput>
    /**
     * Choose, which ImageNote to update.
     */
    where: ImageNoteWhereUniqueInput
  }


  /**
   * ImageNote updateMany
   */
  export type ImageNoteUpdateManyArgs = {
    /**
     * The data used to update ImageNotes.
     */
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyInput>
    /**
     * Filter which ImageNotes to update
     */
    where?: ImageNoteWhereInput
  }


  /**
   * ImageNote upsert
   */
  export type ImageNoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * The filter to search for the ImageNote to update in case it exists.
     */
    where: ImageNoteWhereUniqueInput
    /**
     * In case the ImageNote found by the `where` argument doesn't exist, create a new ImageNote with this data.
     */
    create: XOR<ImageNoteCreateInput, ImageNoteUncheckedCreateInput>
    /**
     * In case the ImageNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageNoteUpdateInput, ImageNoteUncheckedUpdateInput>
  }


  /**
   * ImageNote delete
   */
  export type ImageNoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
    /**
     * Filter which ImageNote to delete.
     */
    where: ImageNoteWhereUniqueInput
  }


  /**
   * ImageNote deleteMany
   */
  export type ImageNoteDeleteManyArgs = {
    /**
     * Filter which ImageNotes to delete
     */
    where?: ImageNoteWhereInput
  }


  /**
   * ImageNote without action
   */
  export type ImageNoteArgs = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageNoteInclude | null
  }



  /**
   * Model Inference
   */


  export type AggregateInference = {
    _count: InferenceCountAggregateOutputType | null
    _avg: InferenceAvgAggregateOutputType | null
    _sum: InferenceSumAggregateOutputType | null
    _min: InferenceMinAggregateOutputType | null
    _max: InferenceMaxAggregateOutputType | null
  }

  export type InferenceAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceSumAggregateOutputType = {
    id: number | null
    imageId: number | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    imageId: number | null
    imageKey: string | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    imageId: number | null
    imageKey: string | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    imageId: number
    imageKey: number
    projectId: number
    roomId: number
    _all: number
  }


  export type InferenceAvgAggregateInputType = {
    id?: true
    imageId?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceSumAggregateInputType = {
    id?: true
    imageId?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
    _all?: true
  }

  export type InferenceAggregateArgs = {
    /**
     * Filter which Inference to aggregate.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inferences
    **/
    _count?: true | InferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InferenceMaxAggregateInputType
  }

  export type GetInferenceAggregateType<T extends InferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInference[P]>
      : GetScalarType<T[P], AggregateInference[P]>
  }




  export type InferenceGroupByArgs = {
    where?: InferenceWhereInput
    orderBy?: Enumerable<InferenceOrderByWithAggregationInput>
    by: InferenceScalarFieldEnum[]
    having?: InferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InferenceCountAggregateInputType | true
    _avg?: InferenceAvgAggregateInputType
    _sum?: InferenceSumAggregateInputType
    _min?: InferenceMinAggregateInputType
    _max?: InferenceMaxAggregateInputType
  }


  export type InferenceGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    imageId: number | null
    imageKey: string | null
    projectId: number
    roomId: number | null
    _count: InferenceCountAggregateOutputType | null
    _avg: InferenceAvgAggregateOutputType | null
    _sum: InferenceSumAggregateOutputType | null
    _min: InferenceMinAggregateOutputType | null
    _max: InferenceMaxAggregateOutputType | null
  }

  type GetInferenceGroupByPayload<T extends InferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InferenceGroupByOutputType[P]>
            : GetScalarType<T[P], InferenceGroupByOutputType[P]>
        }
      >
    >


  export type InferenceSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    imageId?: boolean
    imageKey?: boolean
    projectId?: boolean
    roomId?: boolean
    image?: boolean | ImageArgs
    Project?: boolean | ProjectArgs
    room?: boolean | RoomArgs
    detections?: boolean | Inference$detectionsArgs
    _count?: boolean | InferenceCountOutputTypeArgs
  }


  export type InferenceInclude = {
    image?: boolean | ImageArgs
    Project?: boolean | ProjectArgs
    room?: boolean | RoomArgs
    detections?: boolean | Inference$detectionsArgs
    _count?: boolean | InferenceCountOutputTypeArgs
  }

  export type InferenceGetPayload<S extends boolean | null | undefined | InferenceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Inference :
    S extends undefined ? never :
    S extends { include: any } & (InferenceArgs | InferenceFindManyArgs)
    ? Inference  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? ImageGetPayload<S['include'][P]> | null :
        P extends 'Project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'room' ? RoomGetPayload<S['include'][P]> | null :
        P extends 'detections' ? Array < DetectionGetPayload<S['include'][P]>>  :
        P extends '_count' ? InferenceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InferenceArgs | InferenceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? ImageGetPayload<S['select'][P]> | null :
        P extends 'Project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'room' ? RoomGetPayload<S['select'][P]> | null :
        P extends 'detections' ? Array < DetectionGetPayload<S['select'][P]>>  :
        P extends '_count' ? InferenceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Inference ? Inference[P] : never
  } 
      : Inference


  type InferenceCountArgs = 
    Omit<InferenceFindManyArgs, 'select' | 'include'> & {
      select?: InferenceCountAggregateInputType | true
    }

  export interface InferenceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Inference that matches the filter.
     * @param {InferenceFindUniqueArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InferenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InferenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Inference'> extends True ? Prisma__InferenceClient<InferenceGetPayload<T>> : Prisma__InferenceClient<InferenceGetPayload<T> | null, null>

    /**
     * Find one Inference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InferenceFindUniqueOrThrowArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InferenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InferenceFindUniqueOrThrowArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Find the first Inference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindFirstArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InferenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InferenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Inference'> extends True ? Prisma__InferenceClient<InferenceGetPayload<T>> : Prisma__InferenceClient<InferenceGetPayload<T> | null, null>

    /**
     * Find the first Inference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindFirstOrThrowArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InferenceFindFirstOrThrowArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Find zero or more Inferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inferences
     * const inferences = await prisma.inference.findMany()
     * 
     * // Get first 10 Inferences
     * const inferences = await prisma.inference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inferenceWithIdOnly = await prisma.inference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InferenceFindManyArgs>(
      args?: SelectSubset<T, InferenceFindManyArgs>
    ): Prisma.PrismaPromise<Array<InferenceGetPayload<T>>>

    /**
     * Create a Inference.
     * @param {InferenceCreateArgs} args - Arguments to create a Inference.
     * @example
     * // Create one Inference
     * const Inference = await prisma.inference.create({
     *   data: {
     *     // ... data to create a Inference
     *   }
     * })
     * 
    **/
    create<T extends InferenceCreateArgs>(
      args: SelectSubset<T, InferenceCreateArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Create many Inferences.
     *     @param {InferenceCreateManyArgs} args - Arguments to create many Inferences.
     *     @example
     *     // Create many Inferences
     *     const inference = await prisma.inference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InferenceCreateManyArgs>(
      args?: SelectSubset<T, InferenceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inference.
     * @param {InferenceDeleteArgs} args - Arguments to delete one Inference.
     * @example
     * // Delete one Inference
     * const Inference = await prisma.inference.delete({
     *   where: {
     *     // ... filter to delete one Inference
     *   }
     * })
     * 
    **/
    delete<T extends InferenceDeleteArgs>(
      args: SelectSubset<T, InferenceDeleteArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Update one Inference.
     * @param {InferenceUpdateArgs} args - Arguments to update one Inference.
     * @example
     * // Update one Inference
     * const inference = await prisma.inference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InferenceUpdateArgs>(
      args: SelectSubset<T, InferenceUpdateArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Delete zero or more Inferences.
     * @param {InferenceDeleteManyArgs} args - Arguments to filter Inferences to delete.
     * @example
     * // Delete a few Inferences
     * const { count } = await prisma.inference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InferenceDeleteManyArgs>(
      args?: SelectSubset<T, InferenceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inferences
     * const inference = await prisma.inference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InferenceUpdateManyArgs>(
      args: SelectSubset<T, InferenceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inference.
     * @param {InferenceUpsertArgs} args - Arguments to update or create a Inference.
     * @example
     * // Update or create a Inference
     * const inference = await prisma.inference.upsert({
     *   create: {
     *     // ... data to create a Inference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inference we want to update
     *   }
     * })
    **/
    upsert<T extends InferenceUpsertArgs>(
      args: SelectSubset<T, InferenceUpsertArgs>
    ): Prisma__InferenceClient<InferenceGetPayload<T>>

    /**
     * Count the number of Inferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceCountArgs} args - Arguments to filter Inferences to count.
     * @example
     * // Count the number of Inferences
     * const count = await prisma.inference.count({
     *   where: {
     *     // ... the filter for the Inferences we want to count
     *   }
     * })
    **/
    count<T extends InferenceCountArgs>(
      args?: Subset<T, InferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InferenceAggregateArgs>(args: Subset<T, InferenceAggregateArgs>): Prisma.PrismaPromise<GetInferenceAggregateType<T>>

    /**
     * Group by Inference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InferenceGroupByArgs['orderBy'] }
        : { orderBy?: InferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Inference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InferenceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends ImageArgs= {}>(args?: Subset<T, ImageArgs>): Prisma__ImageClient<ImageGetPayload<T> | Null>;

    Project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    detections<T extends Inference$detectionsArgs= {}>(args?: Subset<T, Inference$detectionsArgs>): Prisma.PrismaPromise<Array<DetectionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Inference base type for findUnique actions
   */
  export type InferenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter, which Inference to fetch.
     */
    where: InferenceWhereUniqueInput
  }

  /**
   * Inference findUnique
   */
  export interface InferenceFindUniqueArgs extends InferenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inference findUniqueOrThrow
   */
  export type InferenceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter, which Inference to fetch.
     */
    where: InferenceWhereUniqueInput
  }


  /**
   * Inference base type for findFirst actions
   */
  export type InferenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter, which Inference to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inferences.
     */
    distinct?: Enumerable<InferenceScalarFieldEnum>
  }

  /**
   * Inference findFirst
   */
  export interface InferenceFindFirstArgs extends InferenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inference findFirstOrThrow
   */
  export type InferenceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter, which Inference to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inferences.
     */
    distinct?: Enumerable<InferenceScalarFieldEnum>
  }


  /**
   * Inference findMany
   */
  export type InferenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter, which Inferences to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    distinct?: Enumerable<InferenceScalarFieldEnum>
  }


  /**
   * Inference create
   */
  export type InferenceCreateArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * The data needed to create a Inference.
     */
    data: XOR<InferenceCreateInput, InferenceUncheckedCreateInput>
  }


  /**
   * Inference createMany
   */
  export type InferenceCreateManyArgs = {
    /**
     * The data used to create many Inferences.
     */
    data: Enumerable<InferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Inference update
   */
  export type InferenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * The data needed to update a Inference.
     */
    data: XOR<InferenceUpdateInput, InferenceUncheckedUpdateInput>
    /**
     * Choose, which Inference to update.
     */
    where: InferenceWhereUniqueInput
  }


  /**
   * Inference updateMany
   */
  export type InferenceUpdateManyArgs = {
    /**
     * The data used to update Inferences.
     */
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyInput>
    /**
     * Filter which Inferences to update
     */
    where?: InferenceWhereInput
  }


  /**
   * Inference upsert
   */
  export type InferenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * The filter to search for the Inference to update in case it exists.
     */
    where: InferenceWhereUniqueInput
    /**
     * In case the Inference found by the `where` argument doesn't exist, create a new Inference with this data.
     */
    create: XOR<InferenceCreateInput, InferenceUncheckedCreateInput>
    /**
     * In case the Inference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InferenceUpdateInput, InferenceUncheckedUpdateInput>
  }


  /**
   * Inference delete
   */
  export type InferenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    /**
     * Filter which Inference to delete.
     */
    where: InferenceWhereUniqueInput
  }


  /**
   * Inference deleteMany
   */
  export type InferenceDeleteManyArgs = {
    /**
     * Filter which Inferences to delete
     */
    where?: InferenceWhereInput
  }


  /**
   * Inference.detections
   */
  export type Inference$detectionsArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    where?: DetectionWhereInput
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: DetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DetectionScalarFieldEnum>
  }


  /**
   * Inference without action
   */
  export type InferenceArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
  }



  /**
   * Model Room
   */


  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    windows: number | null
    doors: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    windows: number | null
    doors: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    name: string | null
    projectId: number | null
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    name: string | null
    projectId: number | null
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    name: number
    projectId: number
    gpp: number
    humidity: number
    dehuReading: number
    temperature: number
    length: number
    width: number
    height: number
    totalSqft: number
    windows: number
    doors: number
    equipmentUsed: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    projectId?: true
    windows?: true
    doors?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    projectId?: true
    windows?: true
    doors?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
    equipmentUsed?: true
    _all?: true
  }

  export type RoomAggregateArgs = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: Enumerable<RoomOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs = {
    where?: RoomWhereInput
    orderBy?: Enumerable<RoomOrderByWithAggregationInput>
    by: RoomScalarFieldEnum[]
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }


  export type RoomGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    name: string
    projectId: number
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
    equipmentUsed: string[]
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    name?: boolean
    projectId?: boolean
    gpp?: boolean
    humidity?: boolean
    dehuReading?: boolean
    temperature?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    totalSqft?: boolean
    windows?: boolean
    doors?: boolean
    equipmentUsed?: boolean
    project?: boolean | ProjectArgs
    detections?: boolean | Room$detectionsArgs
    inferences?: boolean | Room$inferencesArgs
    templates?: boolean | Room$templatesArgs
    roomReadings?: boolean | Room$roomReadingsArgs
    areasAffected?: boolean | Room$areasAffectedArgs
    notes?: boolean | Room$notesArgs
    _count?: boolean | RoomCountOutputTypeArgs
  }


  export type RoomInclude = {
    project?: boolean | ProjectArgs
    detections?: boolean | Room$detectionsArgs
    inferences?: boolean | Room$inferencesArgs
    templates?: boolean | Room$templatesArgs
    roomReadings?: boolean | Room$roomReadingsArgs
    areasAffected?: boolean | Room$areasAffectedArgs
    notes?: boolean | Room$notesArgs
    _count?: boolean | RoomCountOutputTypeArgs
  }

  export type RoomGetPayload<S extends boolean | null | undefined | RoomArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Room :
    S extends undefined ? never :
    S extends { include: any } & (RoomArgs | RoomFindManyArgs)
    ? Room  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'detections' ? Array < DetectionGetPayload<S['include'][P]>>  :
        P extends 'inferences' ? Array < InferenceGetPayload<S['include'][P]>>  :
        P extends 'templates' ? Array < TemplatesUsedGetPayload<S['include'][P]>>  :
        P extends 'roomReadings' ? Array < RoomReadingGetPayload<S['include'][P]>>  :
        P extends 'areasAffected' ? Array < AreaAffectedGetPayload<S['include'][P]>>  :
        P extends 'notes' ? Array < NotesGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoomCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoomArgs | RoomFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'detections' ? Array < DetectionGetPayload<S['select'][P]>>  :
        P extends 'inferences' ? Array < InferenceGetPayload<S['select'][P]>>  :
        P extends 'templates' ? Array < TemplatesUsedGetPayload<S['select'][P]>>  :
        P extends 'roomReadings' ? Array < RoomReadingGetPayload<S['select'][P]>>  :
        P extends 'areasAffected' ? Array < AreaAffectedGetPayload<S['select'][P]>>  :
        P extends 'notes' ? Array < NotesGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoomCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Room ? Room[P] : never
  } 
      : Room


  type RoomCountArgs = 
    Omit<RoomFindManyArgs, 'select' | 'include'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoomFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Room'> extends True ? Prisma__RoomClient<RoomGetPayload<T>> : Prisma__RoomClient<RoomGetPayload<T> | null, null>

    /**
     * Find one Room that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoomFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Room'> extends True ? Prisma__RoomClient<RoomGetPayload<T>> : Prisma__RoomClient<RoomGetPayload<T> | null, null>

    /**
     * Find the first Room that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs>(
      args?: SelectSubset<T, RoomFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoomGetPayload<T>>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs>(
      args: SelectSubset<T, RoomCreateArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Create many Rooms.
     *     @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     *     @example
     *     // Create many Rooms
     *     const room = await prisma.room.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomCreateManyArgs>(
      args?: SelectSubset<T, RoomCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs>(
      args: SelectSubset<T, RoomDeleteArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs>(
      args: SelectSubset<T, RoomUpdateArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs>(
      args?: SelectSubset<T, RoomDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs>(
      args: SelectSubset<T, RoomUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs>(
      args: SelectSubset<T, RoomUpsertArgs>
    ): Prisma__RoomClient<RoomGetPayload<T>>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoomClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    detections<T extends Room$detectionsArgs= {}>(args?: Subset<T, Room$detectionsArgs>): Prisma.PrismaPromise<Array<DetectionGetPayload<T>>| Null>;

    inferences<T extends Room$inferencesArgs= {}>(args?: Subset<T, Room$inferencesArgs>): Prisma.PrismaPromise<Array<InferenceGetPayload<T>>| Null>;

    templates<T extends Room$templatesArgs= {}>(args?: Subset<T, Room$templatesArgs>): Prisma.PrismaPromise<Array<TemplatesUsedGetPayload<T>>| Null>;

    roomReadings<T extends Room$roomReadingsArgs= {}>(args?: Subset<T, Room$roomReadingsArgs>): Prisma.PrismaPromise<Array<RoomReadingGetPayload<T>>| Null>;

    areasAffected<T extends Room$areasAffectedArgs= {}>(args?: Subset<T, Room$areasAffectedArgs>): Prisma.PrismaPromise<Array<AreaAffectedGetPayload<T>>| Null>;

    notes<T extends Room$notesArgs= {}>(args?: Subset<T, Room$notesArgs>): Prisma.PrismaPromise<Array<NotesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Room base type for findUnique actions
   */
  export type RoomFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUnique
   */
  export interface RoomFindUniqueArgs extends RoomFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room base type for findFirst actions
   */
  export type RoomFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: Enumerable<RoomOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: Enumerable<RoomScalarFieldEnum>
  }

  /**
   * Room findFirst
   */
  export interface RoomFindFirstArgs extends RoomFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: Enumerable<RoomOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: Enumerable<RoomScalarFieldEnum>
  }


  /**
   * Room findMany
   */
  export type RoomFindManyArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: Enumerable<RoomOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: Enumerable<RoomScalarFieldEnum>
  }


  /**
   * Room create
   */
  export type RoomCreateArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }


  /**
   * Room createMany
   */
  export type RoomCreateManyArgs = {
    /**
     * The data used to create many Rooms.
     */
    data: Enumerable<RoomCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Room update
   */
  export type RoomUpdateArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }


  /**
   * Room upsert
   */
  export type RoomUpsertArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }


  /**
   * Room delete
   */
  export type RoomDeleteArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }


  /**
   * Room.detections
   */
  export type Room$detectionsArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    where?: DetectionWhereInput
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: DetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DetectionScalarFieldEnum>
  }


  /**
   * Room.inferences
   */
  export type Room$inferencesArgs = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InferenceInclude | null
    where?: InferenceWhereInput
    orderBy?: Enumerable<InferenceOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InferenceScalarFieldEnum>
  }


  /**
   * Room.templates
   */
  export type Room$templatesArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    where?: TemplatesUsedWhereInput
    orderBy?: Enumerable<TemplatesUsedOrderByWithRelationAndSearchRelevanceInput>
    cursor?: TemplatesUsedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplatesUsedScalarFieldEnum>
  }


  /**
   * Room.roomReadings
   */
  export type Room$roomReadingsArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    where?: RoomReadingWhereInput
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoomReadingScalarFieldEnum>
  }


  /**
   * Room.areasAffected
   */
  export type Room$areasAffectedArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    where?: AreaAffectedWhereInput
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AreaAffectedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AreaAffectedScalarFieldEnum>
  }


  /**
   * Room.notes
   */
  export type Room$notesArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    where?: NotesWhereInput
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotesScalarFieldEnum>
  }


  /**
   * Room without action
   */
  export type RoomArgs = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude | null
  }



  /**
   * Model RoomReading
   */


  export type AggregateRoomReading = {
    _count: RoomReadingCountAggregateOutputType | null
    _avg: RoomReadingAvgAggregateOutputType | null
    _sum: RoomReadingSumAggregateOutputType | null
    _min: RoomReadingMinAggregateOutputType | null
    _max: RoomReadingMaxAggregateOutputType | null
  }

  export type RoomReadingAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type RoomReadingSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type RoomReadingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    gpp: string | null
  }

  export type RoomReadingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    gpp: string | null
  }

  export type RoomReadingCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    humidity: number
    temperature: number
    moistureContentWall: number
    moistureContentFloor: number
    equipmentUsed: number
    roomId: number
    isDeleted: number
    publicId: number
    projectId: number
    gpp: number
    _all: number
  }


  export type RoomReadingAvgAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type RoomReadingSumAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type RoomReadingMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
  }

  export type RoomReadingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
  }

  export type RoomReadingCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    equipmentUsed?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
    _all?: true
  }

  export type RoomReadingAggregateArgs = {
    /**
     * Filter which RoomReading to aggregate.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomReadings
    **/
    _count?: true | RoomReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomReadingMaxAggregateInputType
  }

  export type GetRoomReadingAggregateType<T extends RoomReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomReading[P]>
      : GetScalarType<T[P], AggregateRoomReading[P]>
  }




  export type RoomReadingGroupByArgs = {
    where?: RoomReadingWhereInput
    orderBy?: Enumerable<RoomReadingOrderByWithAggregationInput>
    by: RoomReadingScalarFieldEnum[]
    having?: RoomReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomReadingCountAggregateInputType | true
    _avg?: RoomReadingAvgAggregateInputType
    _sum?: RoomReadingSumAggregateInputType
    _min?: RoomReadingMinAggregateInputType
    _max?: RoomReadingMaxAggregateInputType
  }


  export type RoomReadingGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    equipmentUsed: string[]
    roomId: number
    isDeleted: boolean
    publicId: string
    projectId: number
    gpp: string | null
    _count: RoomReadingCountAggregateOutputType | null
    _avg: RoomReadingAvgAggregateOutputType | null
    _sum: RoomReadingSumAggregateOutputType | null
    _min: RoomReadingMinAggregateOutputType | null
    _max: RoomReadingMaxAggregateOutputType | null
  }

  type GetRoomReadingGroupByPayload<T extends RoomReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoomReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomReadingGroupByOutputType[P]>
            : GetScalarType<T[P], RoomReadingGroupByOutputType[P]>
        }
      >
    >


  export type RoomReadingSelect = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    humidity?: boolean
    temperature?: boolean
    moistureContentWall?: boolean
    moistureContentFloor?: boolean
    equipmentUsed?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    gpp?: boolean
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
    genericRoomReadings?: boolean | RoomReading$genericRoomReadingsArgs
    _count?: boolean | RoomReadingCountOutputTypeArgs
  }


  export type RoomReadingInclude = {
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
    genericRoomReadings?: boolean | RoomReading$genericRoomReadingsArgs
    _count?: boolean | RoomReadingCountOutputTypeArgs
  }

  export type RoomReadingGetPayload<S extends boolean | null | undefined | RoomReadingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoomReading :
    S extends undefined ? never :
    S extends { include: any } & (RoomReadingArgs | RoomReadingFindManyArgs)
    ? RoomReading  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'room' ? RoomGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'genericRoomReadings' ? Array < GenericRoomReadingGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoomReadingCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoomReadingArgs | RoomReadingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'room' ? RoomGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'genericRoomReadings' ? Array < GenericRoomReadingGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoomReadingCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RoomReading ? RoomReading[P] : never
  } 
      : RoomReading


  type RoomReadingCountArgs = 
    Omit<RoomReadingFindManyArgs, 'select' | 'include'> & {
      select?: RoomReadingCountAggregateInputType | true
    }

  export interface RoomReadingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RoomReading that matches the filter.
     * @param {RoomReadingFindUniqueArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomReadingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoomReadingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RoomReading'> extends True ? Prisma__RoomReadingClient<RoomReadingGetPayload<T>> : Prisma__RoomReadingClient<RoomReadingGetPayload<T> | null, null>

    /**
     * Find one RoomReading that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomReadingFindUniqueOrThrowArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomReadingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoomReadingFindUniqueOrThrowArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Find the first RoomReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindFirstArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomReadingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoomReadingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RoomReading'> extends True ? Prisma__RoomReadingClient<RoomReadingGetPayload<T>> : Prisma__RoomReadingClient<RoomReadingGetPayload<T> | null, null>

    /**
     * Find the first RoomReading that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindFirstOrThrowArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomReadingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoomReadingFindFirstOrThrowArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Find zero or more RoomReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomReadings
     * const roomReadings = await prisma.roomReading.findMany()
     * 
     * // Get first 10 RoomReadings
     * const roomReadings = await prisma.roomReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomReadingWithIdOnly = await prisma.roomReading.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomReadingFindManyArgs>(
      args?: SelectSubset<T, RoomReadingFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoomReadingGetPayload<T>>>

    /**
     * Create a RoomReading.
     * @param {RoomReadingCreateArgs} args - Arguments to create a RoomReading.
     * @example
     * // Create one RoomReading
     * const RoomReading = await prisma.roomReading.create({
     *   data: {
     *     // ... data to create a RoomReading
     *   }
     * })
     * 
    **/
    create<T extends RoomReadingCreateArgs>(
      args: SelectSubset<T, RoomReadingCreateArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Create many RoomReadings.
     *     @param {RoomReadingCreateManyArgs} args - Arguments to create many RoomReadings.
     *     @example
     *     // Create many RoomReadings
     *     const roomReading = await prisma.roomReading.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomReadingCreateManyArgs>(
      args?: SelectSubset<T, RoomReadingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomReading.
     * @param {RoomReadingDeleteArgs} args - Arguments to delete one RoomReading.
     * @example
     * // Delete one RoomReading
     * const RoomReading = await prisma.roomReading.delete({
     *   where: {
     *     // ... filter to delete one RoomReading
     *   }
     * })
     * 
    **/
    delete<T extends RoomReadingDeleteArgs>(
      args: SelectSubset<T, RoomReadingDeleteArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Update one RoomReading.
     * @param {RoomReadingUpdateArgs} args - Arguments to update one RoomReading.
     * @example
     * // Update one RoomReading
     * const roomReading = await prisma.roomReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomReadingUpdateArgs>(
      args: SelectSubset<T, RoomReadingUpdateArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Delete zero or more RoomReadings.
     * @param {RoomReadingDeleteManyArgs} args - Arguments to filter RoomReadings to delete.
     * @example
     * // Delete a few RoomReadings
     * const { count } = await prisma.roomReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomReadingDeleteManyArgs>(
      args?: SelectSubset<T, RoomReadingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomReadings
     * const roomReading = await prisma.roomReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomReadingUpdateManyArgs>(
      args: SelectSubset<T, RoomReadingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomReading.
     * @param {RoomReadingUpsertArgs} args - Arguments to update or create a RoomReading.
     * @example
     * // Update or create a RoomReading
     * const roomReading = await prisma.roomReading.upsert({
     *   create: {
     *     // ... data to create a RoomReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomReading we want to update
     *   }
     * })
    **/
    upsert<T extends RoomReadingUpsertArgs>(
      args: SelectSubset<T, RoomReadingUpsertArgs>
    ): Prisma__RoomReadingClient<RoomReadingGetPayload<T>>

    /**
     * Count the number of RoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingCountArgs} args - Arguments to filter RoomReadings to count.
     * @example
     * // Count the number of RoomReadings
     * const count = await prisma.roomReading.count({
     *   where: {
     *     // ... the filter for the RoomReadings we want to count
     *   }
     * })
    **/
    count<T extends RoomReadingCountArgs>(
      args?: Subset<T, RoomReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomReadingAggregateArgs>(args: Subset<T, RoomReadingAggregateArgs>): Prisma.PrismaPromise<GetRoomReadingAggregateType<T>>

    /**
     * Group by RoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomReadingGroupByArgs['orderBy'] }
        : { orderBy?: RoomReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoomReadingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    genericRoomReadings<T extends RoomReading$genericRoomReadingsArgs= {}>(args?: Subset<T, RoomReading$genericRoomReadingsArgs>): Prisma.PrismaPromise<Array<GenericRoomReadingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RoomReading base type for findUnique actions
   */
  export type RoomReadingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where: RoomReadingWhereUniqueInput
  }

  /**
   * RoomReading findUnique
   */
  export interface RoomReadingFindUniqueArgs extends RoomReadingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RoomReading findUniqueOrThrow
   */
  export type RoomReadingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where: RoomReadingWhereUniqueInput
  }


  /**
   * RoomReading base type for findFirst actions
   */
  export type RoomReadingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReadings.
     */
    distinct?: Enumerable<RoomReadingScalarFieldEnum>
  }

  /**
   * RoomReading findFirst
   */
  export interface RoomReadingFindFirstArgs extends RoomReadingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RoomReading findFirstOrThrow
   */
  export type RoomReadingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReadings.
     */
    distinct?: Enumerable<RoomReadingScalarFieldEnum>
  }


  /**
   * RoomReading findMany
   */
  export type RoomReadingFindManyArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter, which RoomReadings to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: Enumerable<RoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    distinct?: Enumerable<RoomReadingScalarFieldEnum>
  }


  /**
   * RoomReading create
   */
  export type RoomReadingCreateArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * The data needed to create a RoomReading.
     */
    data: XOR<RoomReadingCreateInput, RoomReadingUncheckedCreateInput>
  }


  /**
   * RoomReading createMany
   */
  export type RoomReadingCreateManyArgs = {
    /**
     * The data used to create many RoomReadings.
     */
    data: Enumerable<RoomReadingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RoomReading update
   */
  export type RoomReadingUpdateArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * The data needed to update a RoomReading.
     */
    data: XOR<RoomReadingUpdateInput, RoomReadingUncheckedUpdateInput>
    /**
     * Choose, which RoomReading to update.
     */
    where: RoomReadingWhereUniqueInput
  }


  /**
   * RoomReading updateMany
   */
  export type RoomReadingUpdateManyArgs = {
    /**
     * The data used to update RoomReadings.
     */
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which RoomReadings to update
     */
    where?: RoomReadingWhereInput
  }


  /**
   * RoomReading upsert
   */
  export type RoomReadingUpsertArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * The filter to search for the RoomReading to update in case it exists.
     */
    where: RoomReadingWhereUniqueInput
    /**
     * In case the RoomReading found by the `where` argument doesn't exist, create a new RoomReading with this data.
     */
    create: XOR<RoomReadingCreateInput, RoomReadingUncheckedCreateInput>
    /**
     * In case the RoomReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomReadingUpdateInput, RoomReadingUncheckedUpdateInput>
  }


  /**
   * RoomReading delete
   */
  export type RoomReadingDeleteArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
    /**
     * Filter which RoomReading to delete.
     */
    where: RoomReadingWhereUniqueInput
  }


  /**
   * RoomReading deleteMany
   */
  export type RoomReadingDeleteManyArgs = {
    /**
     * Filter which RoomReadings to delete
     */
    where?: RoomReadingWhereInput
  }


  /**
   * RoomReading.genericRoomReadings
   */
  export type RoomReading$genericRoomReadingsArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    where?: GenericRoomReadingWhereInput
    orderBy?: Enumerable<GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput>
    cursor?: GenericRoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GenericRoomReadingScalarFieldEnum>
  }


  /**
   * RoomReading without action
   */
  export type RoomReadingArgs = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomReadingInclude | null
  }



  /**
   * Model Notes
   */


  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    roomId: number
    isDeleted: number
    publicId: number
    projectId: number
    body: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    _all?: true
  }

  export type NotesAggregateArgs = {
    /**
     * Filter which Notes to aggregate.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type NotesGroupByArgs = {
    where?: NotesWhereInput
    orderBy?: Enumerable<NotesOrderByWithAggregationInput>
    by: NotesScalarFieldEnum[]
    having?: NotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }


  export type NotesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    date: Date
    roomId: number
    isDeleted: boolean
    publicId: string
    projectId: number
    body: string
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends NotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type NotesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
    notesAuditTrail?: boolean | Notes$notesAuditTrailArgs
    _count?: boolean | NotesCountOutputTypeArgs
  }


  export type NotesInclude = {
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
    notesAuditTrail?: boolean | Notes$notesAuditTrailArgs
    _count?: boolean | NotesCountOutputTypeArgs
  }

  export type NotesGetPayload<S extends boolean | null | undefined | NotesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notes :
    S extends undefined ? never :
    S extends { include: any } & (NotesArgs | NotesFindManyArgs)
    ? Notes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'room' ? RoomGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'notesAuditTrail' ? Array < NotesAuditTrailGetPayload<S['include'][P]>>  :
        P extends '_count' ? NotesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NotesArgs | NotesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'room' ? RoomGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'notesAuditTrail' ? Array < NotesAuditTrailGetPayload<S['select'][P]>>  :
        P extends '_count' ? NotesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Notes ? Notes[P] : never
  } 
      : Notes


  type NotesCountArgs = 
    Omit<NotesFindManyArgs, 'select' | 'include'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface NotesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Notes that matches the filter.
     * @param {NotesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notes'> extends True ? Prisma__NotesClient<NotesGetPayload<T>> : Prisma__NotesClient<NotesGetPayload<T> | null, null>

    /**
     * Find one Notes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotesFindUniqueOrThrowArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notes'> extends True ? Prisma__NotesClient<NotesGetPayload<T>> : Prisma__NotesClient<NotesGetPayload<T> | null, null>

    /**
     * Find the first Notes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotesFindFirstOrThrowArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotesFindManyArgs>(
      args?: SelectSubset<T, NotesFindManyArgs>
    ): Prisma.PrismaPromise<Array<NotesGetPayload<T>>>

    /**
     * Create a Notes.
     * @param {NotesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
    **/
    create<T extends NotesCreateArgs>(
      args: SelectSubset<T, NotesCreateArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Create many Notes.
     *     @param {NotesCreateManyArgs} args - Arguments to create many Notes.
     *     @example
     *     // Create many Notes
     *     const notes = await prisma.notes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotesCreateManyArgs>(
      args?: SelectSubset<T, NotesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notes.
     * @param {NotesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
    **/
    delete<T extends NotesDeleteArgs>(
      args: SelectSubset<T, NotesDeleteArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Update one Notes.
     * @param {NotesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotesUpdateArgs>(
      args: SelectSubset<T, NotesUpdateArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Delete zero or more Notes.
     * @param {NotesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotesDeleteManyArgs>(
      args?: SelectSubset<T, NotesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotesUpdateManyArgs>(
      args: SelectSubset<T, NotesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notes.
     * @param {NotesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
    **/
    upsert<T extends NotesUpsertArgs>(
      args: SelectSubset<T, NotesUpsertArgs>
    ): Prisma__NotesClient<NotesGetPayload<T>>

    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NotesCountArgs>(
      args?: Subset<T, NotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesGroupByArgs['orderBy'] }
        : { orderBy?: NotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    notesAuditTrail<T extends Notes$notesAuditTrailArgs= {}>(args?: Subset<T, Notes$notesAuditTrailArgs>): Prisma.PrismaPromise<Array<NotesAuditTrailGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notes base type for findUnique actions
   */
  export type NotesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findUnique
   */
  export interface NotesFindUniqueArgs extends NotesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notes findUniqueOrThrow
   */
  export type NotesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }


  /**
   * Notes base type for findFirst actions
   */
  export type NotesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: Enumerable<NotesScalarFieldEnum>
  }

  /**
   * Notes findFirst
   */
  export interface NotesFindFirstArgs extends NotesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notes findFirstOrThrow
   */
  export type NotesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: Enumerable<NotesScalarFieldEnum>
  }


  /**
   * Notes findMany
   */
  export type NotesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NotesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: Enumerable<NotesScalarFieldEnum>
  }


  /**
   * Notes create
   */
  export type NotesCreateArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * The data needed to create a Notes.
     */
    data: XOR<NotesCreateInput, NotesUncheckedCreateInput>
  }


  /**
   * Notes createMany
   */
  export type NotesCreateManyArgs = {
    /**
     * The data used to create many Notes.
     */
    data: Enumerable<NotesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notes update
   */
  export type NotesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * The data needed to update a Notes.
     */
    data: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
    /**
     * Choose, which Notes to update.
     */
    where: NotesWhereUniqueInput
  }


  /**
   * Notes updateMany
   */
  export type NotesUpdateManyArgs = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
  }


  /**
   * Notes upsert
   */
  export type NotesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * The filter to search for the Notes to update in case it exists.
     */
    where: NotesWhereUniqueInput
    /**
     * In case the Notes found by the `where` argument doesn't exist, create a new Notes with this data.
     */
    create: XOR<NotesCreateInput, NotesUncheckedCreateInput>
    /**
     * In case the Notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
  }


  /**
   * Notes delete
   */
  export type NotesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
    /**
     * Filter which Notes to delete.
     */
    where: NotesWhereUniqueInput
  }


  /**
   * Notes deleteMany
   */
  export type NotesDeleteManyArgs = {
    /**
     * Filter which Notes to delete
     */
    where?: NotesWhereInput
  }


  /**
   * Notes.notesAuditTrail
   */
  export type Notes$notesAuditTrailArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    where?: NotesAuditTrailWhereInput
    orderBy?: Enumerable<NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput>
    cursor?: NotesAuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotesAuditTrailScalarFieldEnum>
  }


  /**
   * Notes without action
   */
  export type NotesArgs = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesInclude | null
  }



  /**
   * Model NotesAuditTrail
   */


  export type AggregateNotesAuditTrail = {
    _count: NotesAuditTrailCountAggregateOutputType | null
    _avg: NotesAuditTrailAvgAggregateOutputType | null
    _sum: NotesAuditTrailSumAggregateOutputType | null
    _min: NotesAuditTrailMinAggregateOutputType | null
    _max: NotesAuditTrailMaxAggregateOutputType | null
  }

  export type NotesAuditTrailAvgAggregateOutputType = {
    id: number | null
    notesId: number | null
  }

  export type NotesAuditTrailSumAggregateOutputType = {
    id: number | null
    notesId: number | null
  }

  export type NotesAuditTrailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    notesId: number | null
    userId: string | null
    userName: string | null
    action: NotesAuditAction | null
    body: string | null
  }

  export type NotesAuditTrailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    notesId: number | null
    userId: string | null
    userName: string | null
    action: NotesAuditAction | null
    body: string | null
  }

  export type NotesAuditTrailCountAggregateOutputType = {
    id: number
    createdAt: number
    notesId: number
    userId: number
    userName: number
    action: number
    body: number
    _all: number
  }


  export type NotesAuditTrailAvgAggregateInputType = {
    id?: true
    notesId?: true
  }

  export type NotesAuditTrailSumAggregateInputType = {
    id?: true
    notesId?: true
  }

  export type NotesAuditTrailMinAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
  }

  export type NotesAuditTrailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
  }

  export type NotesAuditTrailCountAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
    _all?: true
  }

  export type NotesAuditTrailAggregateArgs = {
    /**
     * Filter which NotesAuditTrail to aggregate.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: Enumerable<NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotesAuditTrails
    **/
    _count?: true | NotesAuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAuditTrailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesAuditTrailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesAuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesAuditTrailMaxAggregateInputType
  }

  export type GetNotesAuditTrailAggregateType<T extends NotesAuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateNotesAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotesAuditTrail[P]>
      : GetScalarType<T[P], AggregateNotesAuditTrail[P]>
  }




  export type NotesAuditTrailGroupByArgs = {
    where?: NotesAuditTrailWhereInput
    orderBy?: Enumerable<NotesAuditTrailOrderByWithAggregationInput>
    by: NotesAuditTrailScalarFieldEnum[]
    having?: NotesAuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesAuditTrailCountAggregateInputType | true
    _avg?: NotesAuditTrailAvgAggregateInputType
    _sum?: NotesAuditTrailSumAggregateInputType
    _min?: NotesAuditTrailMinAggregateInputType
    _max?: NotesAuditTrailMaxAggregateInputType
  }


  export type NotesAuditTrailGroupByOutputType = {
    id: number
    createdAt: Date
    notesId: number
    userId: string
    userName: string | null
    action: NotesAuditAction
    body: string
    _count: NotesAuditTrailCountAggregateOutputType | null
    _avg: NotesAuditTrailAvgAggregateOutputType | null
    _sum: NotesAuditTrailSumAggregateOutputType | null
    _min: NotesAuditTrailMinAggregateOutputType | null
    _max: NotesAuditTrailMaxAggregateOutputType | null
  }

  type GetNotesAuditTrailGroupByPayload<T extends NotesAuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotesAuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesAuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesAuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], NotesAuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type NotesAuditTrailSelect = {
    id?: boolean
    createdAt?: boolean
    notesId?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    body?: boolean
    note?: boolean | NotesArgs
  }


  export type NotesAuditTrailInclude = {
    note?: boolean | NotesArgs
  }

  export type NotesAuditTrailGetPayload<S extends boolean | null | undefined | NotesAuditTrailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NotesAuditTrail :
    S extends undefined ? never :
    S extends { include: any } & (NotesAuditTrailArgs | NotesAuditTrailFindManyArgs)
    ? NotesAuditTrail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'note' ? NotesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NotesAuditTrailArgs | NotesAuditTrailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'note' ? NotesGetPayload<S['select'][P]> :  P extends keyof NotesAuditTrail ? NotesAuditTrail[P] : never
  } 
      : NotesAuditTrail


  type NotesAuditTrailCountArgs = 
    Omit<NotesAuditTrailFindManyArgs, 'select' | 'include'> & {
      select?: NotesAuditTrailCountAggregateInputType | true
    }

  export interface NotesAuditTrailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NotesAuditTrail that matches the filter.
     * @param {NotesAuditTrailFindUniqueArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotesAuditTrailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotesAuditTrailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NotesAuditTrail'> extends True ? Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>> : Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T> | null, null>

    /**
     * Find one NotesAuditTrail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotesAuditTrailFindUniqueOrThrowArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotesAuditTrailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotesAuditTrailFindUniqueOrThrowArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Find the first NotesAuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindFirstArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotesAuditTrailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotesAuditTrailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NotesAuditTrail'> extends True ? Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>> : Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T> | null, null>

    /**
     * Find the first NotesAuditTrail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindFirstOrThrowArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotesAuditTrailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotesAuditTrailFindFirstOrThrowArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Find zero or more NotesAuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotesAuditTrails
     * const notesAuditTrails = await prisma.notesAuditTrail.findMany()
     * 
     * // Get first 10 NotesAuditTrails
     * const notesAuditTrails = await prisma.notesAuditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesAuditTrailWithIdOnly = await prisma.notesAuditTrail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotesAuditTrailFindManyArgs>(
      args?: SelectSubset<T, NotesAuditTrailFindManyArgs>
    ): Prisma.PrismaPromise<Array<NotesAuditTrailGetPayload<T>>>

    /**
     * Create a NotesAuditTrail.
     * @param {NotesAuditTrailCreateArgs} args - Arguments to create a NotesAuditTrail.
     * @example
     * // Create one NotesAuditTrail
     * const NotesAuditTrail = await prisma.notesAuditTrail.create({
     *   data: {
     *     // ... data to create a NotesAuditTrail
     *   }
     * })
     * 
    **/
    create<T extends NotesAuditTrailCreateArgs>(
      args: SelectSubset<T, NotesAuditTrailCreateArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Create many NotesAuditTrails.
     *     @param {NotesAuditTrailCreateManyArgs} args - Arguments to create many NotesAuditTrails.
     *     @example
     *     // Create many NotesAuditTrails
     *     const notesAuditTrail = await prisma.notesAuditTrail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotesAuditTrailCreateManyArgs>(
      args?: SelectSubset<T, NotesAuditTrailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotesAuditTrail.
     * @param {NotesAuditTrailDeleteArgs} args - Arguments to delete one NotesAuditTrail.
     * @example
     * // Delete one NotesAuditTrail
     * const NotesAuditTrail = await prisma.notesAuditTrail.delete({
     *   where: {
     *     // ... filter to delete one NotesAuditTrail
     *   }
     * })
     * 
    **/
    delete<T extends NotesAuditTrailDeleteArgs>(
      args: SelectSubset<T, NotesAuditTrailDeleteArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Update one NotesAuditTrail.
     * @param {NotesAuditTrailUpdateArgs} args - Arguments to update one NotesAuditTrail.
     * @example
     * // Update one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotesAuditTrailUpdateArgs>(
      args: SelectSubset<T, NotesAuditTrailUpdateArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Delete zero or more NotesAuditTrails.
     * @param {NotesAuditTrailDeleteManyArgs} args - Arguments to filter NotesAuditTrails to delete.
     * @example
     * // Delete a few NotesAuditTrails
     * const { count } = await prisma.notesAuditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotesAuditTrailDeleteManyArgs>(
      args?: SelectSubset<T, NotesAuditTrailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesAuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotesAuditTrails
     * const notesAuditTrail = await prisma.notesAuditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotesAuditTrailUpdateManyArgs>(
      args: SelectSubset<T, NotesAuditTrailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotesAuditTrail.
     * @param {NotesAuditTrailUpsertArgs} args - Arguments to update or create a NotesAuditTrail.
     * @example
     * // Update or create a NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.upsert({
     *   create: {
     *     // ... data to create a NotesAuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotesAuditTrail we want to update
     *   }
     * })
    **/
    upsert<T extends NotesAuditTrailUpsertArgs>(
      args: SelectSubset<T, NotesAuditTrailUpsertArgs>
    ): Prisma__NotesAuditTrailClient<NotesAuditTrailGetPayload<T>>

    /**
     * Count the number of NotesAuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailCountArgs} args - Arguments to filter NotesAuditTrails to count.
     * @example
     * // Count the number of NotesAuditTrails
     * const count = await prisma.notesAuditTrail.count({
     *   where: {
     *     // ... the filter for the NotesAuditTrails we want to count
     *   }
     * })
    **/
    count<T extends NotesAuditTrailCountArgs>(
      args?: Subset<T, NotesAuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesAuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotesAuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAuditTrailAggregateArgs>(args: Subset<T, NotesAuditTrailAggregateArgs>): Prisma.PrismaPromise<GetNotesAuditTrailAggregateType<T>>

    /**
     * Group by NotesAuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesAuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesAuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: NotesAuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesAuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NotesAuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotesAuditTrailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    note<T extends NotesArgs= {}>(args?: Subset<T, NotesArgs>): Prisma__NotesClient<NotesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NotesAuditTrail base type for findUnique actions
   */
  export type NotesAuditTrailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where: NotesAuditTrailWhereUniqueInput
  }

  /**
   * NotesAuditTrail findUnique
   */
  export interface NotesAuditTrailFindUniqueArgs extends NotesAuditTrailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotesAuditTrail findUniqueOrThrow
   */
  export type NotesAuditTrailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where: NotesAuditTrailWhereUniqueInput
  }


  /**
   * NotesAuditTrail base type for findFirst actions
   */
  export type NotesAuditTrailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: Enumerable<NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesAuditTrails.
     */
    distinct?: Enumerable<NotesAuditTrailScalarFieldEnum>
  }

  /**
   * NotesAuditTrail findFirst
   */
  export interface NotesAuditTrailFindFirstArgs extends NotesAuditTrailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotesAuditTrail findFirstOrThrow
   */
  export type NotesAuditTrailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: Enumerable<NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesAuditTrails.
     */
    distinct?: Enumerable<NotesAuditTrailScalarFieldEnum>
  }


  /**
   * NotesAuditTrail findMany
   */
  export type NotesAuditTrailFindManyArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter, which NotesAuditTrails to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: Enumerable<NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    distinct?: Enumerable<NotesAuditTrailScalarFieldEnum>
  }


  /**
   * NotesAuditTrail create
   */
  export type NotesAuditTrailCreateArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * The data needed to create a NotesAuditTrail.
     */
    data: XOR<NotesAuditTrailCreateInput, NotesAuditTrailUncheckedCreateInput>
  }


  /**
   * NotesAuditTrail createMany
   */
  export type NotesAuditTrailCreateManyArgs = {
    /**
     * The data used to create many NotesAuditTrails.
     */
    data: Enumerable<NotesAuditTrailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NotesAuditTrail update
   */
  export type NotesAuditTrailUpdateArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * The data needed to update a NotesAuditTrail.
     */
    data: XOR<NotesAuditTrailUpdateInput, NotesAuditTrailUncheckedUpdateInput>
    /**
     * Choose, which NotesAuditTrail to update.
     */
    where: NotesAuditTrailWhereUniqueInput
  }


  /**
   * NotesAuditTrail updateMany
   */
  export type NotesAuditTrailUpdateManyArgs = {
    /**
     * The data used to update NotesAuditTrails.
     */
    data: XOR<NotesAuditTrailUpdateManyMutationInput, NotesAuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which NotesAuditTrails to update
     */
    where?: NotesAuditTrailWhereInput
  }


  /**
   * NotesAuditTrail upsert
   */
  export type NotesAuditTrailUpsertArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * The filter to search for the NotesAuditTrail to update in case it exists.
     */
    where: NotesAuditTrailWhereUniqueInput
    /**
     * In case the NotesAuditTrail found by the `where` argument doesn't exist, create a new NotesAuditTrail with this data.
     */
    create: XOR<NotesAuditTrailCreateInput, NotesAuditTrailUncheckedCreateInput>
    /**
     * In case the NotesAuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesAuditTrailUpdateInput, NotesAuditTrailUncheckedUpdateInput>
  }


  /**
   * NotesAuditTrail delete
   */
  export type NotesAuditTrailDeleteArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
    /**
     * Filter which NotesAuditTrail to delete.
     */
    where: NotesAuditTrailWhereUniqueInput
  }


  /**
   * NotesAuditTrail deleteMany
   */
  export type NotesAuditTrailDeleteManyArgs = {
    /**
     * Filter which NotesAuditTrails to delete
     */
    where?: NotesAuditTrailWhereInput
  }


  /**
   * NotesAuditTrail without action
   */
  export type NotesAuditTrailArgs = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotesAuditTrailInclude | null
  }



  /**
   * Model AreaAffected
   */


  export type AggregateAreaAffected = {
    _count: AreaAffectedCountAggregateOutputType | null
    _avg: AreaAffectedAvgAggregateOutputType | null
    _sum: AreaAffectedSumAggregateOutputType | null
    _min: AreaAffectedMinAggregateOutputType | null
    _max: AreaAffectedMaxAggregateOutputType | null
  }

  export type AreaAffectedAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    category: number | null
    projectId: number | null
  }

  export type AreaAffectedSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    category: number | null
    projectId: number | null
  }

  export type AreaAffectedMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    roomId: number | null
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    type: AreaAffectedType | null
  }

  export type AreaAffectedMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    roomId: number | null
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    type: AreaAffectedType | null
  }

  export type AreaAffectedCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    roomId: number
    material: number
    totalAreaRemoved: number
    totalAreaMicrobialApplied: number
    cause: number
    category: number
    cabinetryRemoved: number
    isDeleted: number
    publicId: number
    projectId: number
    type: number
    _all: number
  }


  export type AreaAffectedAvgAggregateInputType = {
    id?: true
    roomId?: true
    category?: true
    projectId?: true
  }

  export type AreaAffectedSumAggregateInputType = {
    id?: true
    roomId?: true
    category?: true
    projectId?: true
  }

  export type AreaAffectedMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
  }

  export type AreaAffectedMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
  }

  export type AreaAffectedCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
    _all?: true
  }

  export type AreaAffectedAggregateArgs = {
    /**
     * Filter which AreaAffected to aggregate.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaAffecteds
    **/
    _count?: true | AreaAffectedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAffectedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaAffectedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaAffectedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaAffectedMaxAggregateInputType
  }

  export type GetAreaAffectedAggregateType<T extends AreaAffectedAggregateArgs> = {
        [P in keyof T & keyof AggregateAreaAffected]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaAffected[P]>
      : GetScalarType<T[P], AggregateAreaAffected[P]>
  }




  export type AreaAffectedGroupByArgs = {
    where?: AreaAffectedWhereInput
    orderBy?: Enumerable<AreaAffectedOrderByWithAggregationInput>
    by: AreaAffectedScalarFieldEnum[]
    having?: AreaAffectedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaAffectedCountAggregateInputType | true
    _avg?: AreaAffectedAvgAggregateInputType
    _sum?: AreaAffectedSumAggregateInputType
    _min?: AreaAffectedMinAggregateInputType
    _max?: AreaAffectedMaxAggregateInputType
  }


  export type AreaAffectedGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    roomId: number
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean
    publicId: string
    projectId: number
    type: AreaAffectedType
    _count: AreaAffectedCountAggregateOutputType | null
    _avg: AreaAffectedAvgAggregateOutputType | null
    _sum: AreaAffectedSumAggregateOutputType | null
    _min: AreaAffectedMinAggregateOutputType | null
    _max: AreaAffectedMaxAggregateOutputType | null
  }

  type GetAreaAffectedGroupByPayload<T extends AreaAffectedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AreaAffectedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaAffectedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaAffectedGroupByOutputType[P]>
            : GetScalarType<T[P], AreaAffectedGroupByOutputType[P]>
        }
      >
    >


  export type AreaAffectedSelect = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    roomId?: boolean
    material?: boolean
    totalAreaRemoved?: boolean
    totalAreaMicrobialApplied?: boolean
    cause?: boolean
    category?: boolean
    cabinetryRemoved?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    type?: boolean
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
  }


  export type AreaAffectedInclude = {
    room?: boolean | RoomArgs
    project?: boolean | ProjectArgs
  }

  export type AreaAffectedGetPayload<S extends boolean | null | undefined | AreaAffectedArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AreaAffected :
    S extends undefined ? never :
    S extends { include: any } & (AreaAffectedArgs | AreaAffectedFindManyArgs)
    ? AreaAffected  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'room' ? RoomGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AreaAffectedArgs | AreaAffectedFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'room' ? RoomGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof AreaAffected ? AreaAffected[P] : never
  } 
      : AreaAffected


  type AreaAffectedCountArgs = 
    Omit<AreaAffectedFindManyArgs, 'select' | 'include'> & {
      select?: AreaAffectedCountAggregateInputType | true
    }

  export interface AreaAffectedDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AreaAffected that matches the filter.
     * @param {AreaAffectedFindUniqueArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaAffectedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AreaAffectedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AreaAffected'> extends True ? Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>> : Prisma__AreaAffectedClient<AreaAffectedGetPayload<T> | null, null>

    /**
     * Find one AreaAffected that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AreaAffectedFindUniqueOrThrowArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AreaAffectedFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AreaAffectedFindUniqueOrThrowArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Find the first AreaAffected that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindFirstArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaAffectedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AreaAffectedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AreaAffected'> extends True ? Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>> : Prisma__AreaAffectedClient<AreaAffectedGetPayload<T> | null, null>

    /**
     * Find the first AreaAffected that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindFirstOrThrowArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AreaAffectedFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AreaAffectedFindFirstOrThrowArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Find zero or more AreaAffecteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaAffecteds
     * const areaAffecteds = await prisma.areaAffected.findMany()
     * 
     * // Get first 10 AreaAffecteds
     * const areaAffecteds = await prisma.areaAffected.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaAffectedWithIdOnly = await prisma.areaAffected.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AreaAffectedFindManyArgs>(
      args?: SelectSubset<T, AreaAffectedFindManyArgs>
    ): Prisma.PrismaPromise<Array<AreaAffectedGetPayload<T>>>

    /**
     * Create a AreaAffected.
     * @param {AreaAffectedCreateArgs} args - Arguments to create a AreaAffected.
     * @example
     * // Create one AreaAffected
     * const AreaAffected = await prisma.areaAffected.create({
     *   data: {
     *     // ... data to create a AreaAffected
     *   }
     * })
     * 
    **/
    create<T extends AreaAffectedCreateArgs>(
      args: SelectSubset<T, AreaAffectedCreateArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Create many AreaAffecteds.
     *     @param {AreaAffectedCreateManyArgs} args - Arguments to create many AreaAffecteds.
     *     @example
     *     // Create many AreaAffecteds
     *     const areaAffected = await prisma.areaAffected.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AreaAffectedCreateManyArgs>(
      args?: SelectSubset<T, AreaAffectedCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AreaAffected.
     * @param {AreaAffectedDeleteArgs} args - Arguments to delete one AreaAffected.
     * @example
     * // Delete one AreaAffected
     * const AreaAffected = await prisma.areaAffected.delete({
     *   where: {
     *     // ... filter to delete one AreaAffected
     *   }
     * })
     * 
    **/
    delete<T extends AreaAffectedDeleteArgs>(
      args: SelectSubset<T, AreaAffectedDeleteArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Update one AreaAffected.
     * @param {AreaAffectedUpdateArgs} args - Arguments to update one AreaAffected.
     * @example
     * // Update one AreaAffected
     * const areaAffected = await prisma.areaAffected.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaAffectedUpdateArgs>(
      args: SelectSubset<T, AreaAffectedUpdateArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Delete zero or more AreaAffecteds.
     * @param {AreaAffectedDeleteManyArgs} args - Arguments to filter AreaAffecteds to delete.
     * @example
     * // Delete a few AreaAffecteds
     * const { count } = await prisma.areaAffected.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaAffectedDeleteManyArgs>(
      args?: SelectSubset<T, AreaAffectedDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaAffecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaAffecteds
     * const areaAffected = await prisma.areaAffected.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaAffectedUpdateManyArgs>(
      args: SelectSubset<T, AreaAffectedUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AreaAffected.
     * @param {AreaAffectedUpsertArgs} args - Arguments to update or create a AreaAffected.
     * @example
     * // Update or create a AreaAffected
     * const areaAffected = await prisma.areaAffected.upsert({
     *   create: {
     *     // ... data to create a AreaAffected
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaAffected we want to update
     *   }
     * })
    **/
    upsert<T extends AreaAffectedUpsertArgs>(
      args: SelectSubset<T, AreaAffectedUpsertArgs>
    ): Prisma__AreaAffectedClient<AreaAffectedGetPayload<T>>

    /**
     * Count the number of AreaAffecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedCountArgs} args - Arguments to filter AreaAffecteds to count.
     * @example
     * // Count the number of AreaAffecteds
     * const count = await prisma.areaAffected.count({
     *   where: {
     *     // ... the filter for the AreaAffecteds we want to count
     *   }
     * })
    **/
    count<T extends AreaAffectedCountArgs>(
      args?: Subset<T, AreaAffectedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaAffectedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaAffected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAffectedAggregateArgs>(args: Subset<T, AreaAffectedAggregateArgs>): Prisma.PrismaPromise<GetAreaAffectedAggregateType<T>>

    /**
     * Group by AreaAffected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaAffectedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaAffectedGroupByArgs['orderBy'] }
        : { orderBy?: AreaAffectedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaAffectedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaAffectedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaAffected.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AreaAffectedClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AreaAffected base type for findUnique actions
   */
  export type AreaAffectedFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where: AreaAffectedWhereUniqueInput
  }

  /**
   * AreaAffected findUnique
   */
  export interface AreaAffectedFindUniqueArgs extends AreaAffectedFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AreaAffected findUniqueOrThrow
   */
  export type AreaAffectedFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where: AreaAffectedWhereUniqueInput
  }


  /**
   * AreaAffected base type for findFirst actions
   */
  export type AreaAffectedFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaAffecteds.
     */
    distinct?: Enumerable<AreaAffectedScalarFieldEnum>
  }

  /**
   * AreaAffected findFirst
   */
  export interface AreaAffectedFindFirstArgs extends AreaAffectedFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AreaAffected findFirstOrThrow
   */
  export type AreaAffectedFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaAffecteds.
     */
    distinct?: Enumerable<AreaAffectedScalarFieldEnum>
  }


  /**
   * AreaAffected findMany
   */
  export type AreaAffectedFindManyArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter, which AreaAffecteds to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: Enumerable<AreaAffectedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    distinct?: Enumerable<AreaAffectedScalarFieldEnum>
  }


  /**
   * AreaAffected create
   */
  export type AreaAffectedCreateArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * The data needed to create a AreaAffected.
     */
    data: XOR<AreaAffectedCreateInput, AreaAffectedUncheckedCreateInput>
  }


  /**
   * AreaAffected createMany
   */
  export type AreaAffectedCreateManyArgs = {
    /**
     * The data used to create many AreaAffecteds.
     */
    data: Enumerable<AreaAffectedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AreaAffected update
   */
  export type AreaAffectedUpdateArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * The data needed to update a AreaAffected.
     */
    data: XOR<AreaAffectedUpdateInput, AreaAffectedUncheckedUpdateInput>
    /**
     * Choose, which AreaAffected to update.
     */
    where: AreaAffectedWhereUniqueInput
  }


  /**
   * AreaAffected updateMany
   */
  export type AreaAffectedUpdateManyArgs = {
    /**
     * The data used to update AreaAffecteds.
     */
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyInput>
    /**
     * Filter which AreaAffecteds to update
     */
    where?: AreaAffectedWhereInput
  }


  /**
   * AreaAffected upsert
   */
  export type AreaAffectedUpsertArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * The filter to search for the AreaAffected to update in case it exists.
     */
    where: AreaAffectedWhereUniqueInput
    /**
     * In case the AreaAffected found by the `where` argument doesn't exist, create a new AreaAffected with this data.
     */
    create: XOR<AreaAffectedCreateInput, AreaAffectedUncheckedCreateInput>
    /**
     * In case the AreaAffected was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaAffectedUpdateInput, AreaAffectedUncheckedUpdateInput>
  }


  /**
   * AreaAffected delete
   */
  export type AreaAffectedDeleteArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
    /**
     * Filter which AreaAffected to delete.
     */
    where: AreaAffectedWhereUniqueInput
  }


  /**
   * AreaAffected deleteMany
   */
  export type AreaAffectedDeleteManyArgs = {
    /**
     * Filter which AreaAffecteds to delete
     */
    where?: AreaAffectedWhereInput
  }


  /**
   * AreaAffected without action
   */
  export type AreaAffectedArgs = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaAffectedInclude | null
  }



  /**
   * Model GenericRoomReading
   */


  export type AggregateGenericRoomReading = {
    _count: GenericRoomReadingCountAggregateOutputType | null
    _avg: GenericRoomReadingAvgAggregateOutputType | null
    _sum: GenericRoomReadingSumAggregateOutputType | null
    _min: GenericRoomReadingMinAggregateOutputType | null
    _max: GenericRoomReadingMaxAggregateOutputType | null
  }

  export type GenericRoomReadingAvgAggregateOutputType = {
    id: number | null
    roomReadingId: number | null
  }

  export type GenericRoomReadingSumAggregateOutputType = {
    id: number | null
    roomReadingId: number | null
  }

  export type GenericRoomReadingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    publicId: string | null
    type: RoomReadingType | null
    value: string | null
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number | null
    isDeleted: boolean | null
  }

  export type GenericRoomReadingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    publicId: string | null
    type: RoomReadingType | null
    value: string | null
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number | null
    isDeleted: boolean | null
  }

  export type GenericRoomReadingCountAggregateOutputType = {
    id: number
    createdAt: number
    publicId: number
    type: number
    value: number
    humidity: number
    temperature: number
    gpp: number
    roomReadingId: number
    isDeleted: number
    _all: number
  }


  export type GenericRoomReadingAvgAggregateInputType = {
    id?: true
    roomReadingId?: true
  }

  export type GenericRoomReadingSumAggregateInputType = {
    id?: true
    roomReadingId?: true
  }

  export type GenericRoomReadingMinAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
  }

  export type GenericRoomReadingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
  }

  export type GenericRoomReadingCountAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
    _all?: true
  }

  export type GenericRoomReadingAggregateArgs = {
    /**
     * Filter which GenericRoomReading to aggregate.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: Enumerable<GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenericRoomReadings
    **/
    _count?: true | GenericRoomReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenericRoomReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenericRoomReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenericRoomReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenericRoomReadingMaxAggregateInputType
  }

  export type GetGenericRoomReadingAggregateType<T extends GenericRoomReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateGenericRoomReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenericRoomReading[P]>
      : GetScalarType<T[P], AggregateGenericRoomReading[P]>
  }




  export type GenericRoomReadingGroupByArgs = {
    where?: GenericRoomReadingWhereInput
    orderBy?: Enumerable<GenericRoomReadingOrderByWithAggregationInput>
    by: GenericRoomReadingScalarFieldEnum[]
    having?: GenericRoomReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenericRoomReadingCountAggregateInputType | true
    _avg?: GenericRoomReadingAvgAggregateInputType
    _sum?: GenericRoomReadingSumAggregateInputType
    _min?: GenericRoomReadingMinAggregateInputType
    _max?: GenericRoomReadingMaxAggregateInputType
  }


  export type GenericRoomReadingGroupByOutputType = {
    id: number
    createdAt: Date
    publicId: string
    type: RoomReadingType
    value: string
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number
    isDeleted: boolean
    _count: GenericRoomReadingCountAggregateOutputType | null
    _avg: GenericRoomReadingAvgAggregateOutputType | null
    _sum: GenericRoomReadingSumAggregateOutputType | null
    _min: GenericRoomReadingMinAggregateOutputType | null
    _max: GenericRoomReadingMaxAggregateOutputType | null
  }

  type GetGenericRoomReadingGroupByPayload<T extends GenericRoomReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GenericRoomReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenericRoomReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenericRoomReadingGroupByOutputType[P]>
            : GetScalarType<T[P], GenericRoomReadingGroupByOutputType[P]>
        }
      >
    >


  export type GenericRoomReadingSelect = {
    id?: boolean
    createdAt?: boolean
    publicId?: boolean
    type?: boolean
    value?: boolean
    humidity?: boolean
    temperature?: boolean
    gpp?: boolean
    roomReadingId?: boolean
    isDeleted?: boolean
    roomReading?: boolean | RoomReadingArgs
  }


  export type GenericRoomReadingInclude = {
    roomReading?: boolean | RoomReadingArgs
  }

  export type GenericRoomReadingGetPayload<S extends boolean | null | undefined | GenericRoomReadingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GenericRoomReading :
    S extends undefined ? never :
    S extends { include: any } & (GenericRoomReadingArgs | GenericRoomReadingFindManyArgs)
    ? GenericRoomReading  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'roomReading' ? RoomReadingGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GenericRoomReadingArgs | GenericRoomReadingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'roomReading' ? RoomReadingGetPayload<S['select'][P]> :  P extends keyof GenericRoomReading ? GenericRoomReading[P] : never
  } 
      : GenericRoomReading


  type GenericRoomReadingCountArgs = 
    Omit<GenericRoomReadingFindManyArgs, 'select' | 'include'> & {
      select?: GenericRoomReadingCountAggregateInputType | true
    }

  export interface GenericRoomReadingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one GenericRoomReading that matches the filter.
     * @param {GenericRoomReadingFindUniqueArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenericRoomReadingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GenericRoomReadingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GenericRoomReading'> extends True ? Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>> : Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T> | null, null>

    /**
     * Find one GenericRoomReading that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GenericRoomReadingFindUniqueOrThrowArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GenericRoomReadingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GenericRoomReadingFindUniqueOrThrowArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Find the first GenericRoomReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindFirstArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenericRoomReadingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GenericRoomReadingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GenericRoomReading'> extends True ? Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>> : Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T> | null, null>

    /**
     * Find the first GenericRoomReading that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindFirstOrThrowArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GenericRoomReadingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GenericRoomReadingFindFirstOrThrowArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Find zero or more GenericRoomReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenericRoomReadings
     * const genericRoomReadings = await prisma.genericRoomReading.findMany()
     * 
     * // Get first 10 GenericRoomReadings
     * const genericRoomReadings = await prisma.genericRoomReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genericRoomReadingWithIdOnly = await prisma.genericRoomReading.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenericRoomReadingFindManyArgs>(
      args?: SelectSubset<T, GenericRoomReadingFindManyArgs>
    ): Prisma.PrismaPromise<Array<GenericRoomReadingGetPayload<T>>>

    /**
     * Create a GenericRoomReading.
     * @param {GenericRoomReadingCreateArgs} args - Arguments to create a GenericRoomReading.
     * @example
     * // Create one GenericRoomReading
     * const GenericRoomReading = await prisma.genericRoomReading.create({
     *   data: {
     *     // ... data to create a GenericRoomReading
     *   }
     * })
     * 
    **/
    create<T extends GenericRoomReadingCreateArgs>(
      args: SelectSubset<T, GenericRoomReadingCreateArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Create many GenericRoomReadings.
     *     @param {GenericRoomReadingCreateManyArgs} args - Arguments to create many GenericRoomReadings.
     *     @example
     *     // Create many GenericRoomReadings
     *     const genericRoomReading = await prisma.genericRoomReading.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GenericRoomReadingCreateManyArgs>(
      args?: SelectSubset<T, GenericRoomReadingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GenericRoomReading.
     * @param {GenericRoomReadingDeleteArgs} args - Arguments to delete one GenericRoomReading.
     * @example
     * // Delete one GenericRoomReading
     * const GenericRoomReading = await prisma.genericRoomReading.delete({
     *   where: {
     *     // ... filter to delete one GenericRoomReading
     *   }
     * })
     * 
    **/
    delete<T extends GenericRoomReadingDeleteArgs>(
      args: SelectSubset<T, GenericRoomReadingDeleteArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Update one GenericRoomReading.
     * @param {GenericRoomReadingUpdateArgs} args - Arguments to update one GenericRoomReading.
     * @example
     * // Update one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenericRoomReadingUpdateArgs>(
      args: SelectSubset<T, GenericRoomReadingUpdateArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Delete zero or more GenericRoomReadings.
     * @param {GenericRoomReadingDeleteManyArgs} args - Arguments to filter GenericRoomReadings to delete.
     * @example
     * // Delete a few GenericRoomReadings
     * const { count } = await prisma.genericRoomReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenericRoomReadingDeleteManyArgs>(
      args?: SelectSubset<T, GenericRoomReadingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenericRoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenericRoomReadings
     * const genericRoomReading = await prisma.genericRoomReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenericRoomReadingUpdateManyArgs>(
      args: SelectSubset<T, GenericRoomReadingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GenericRoomReading.
     * @param {GenericRoomReadingUpsertArgs} args - Arguments to update or create a GenericRoomReading.
     * @example
     * // Update or create a GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.upsert({
     *   create: {
     *     // ... data to create a GenericRoomReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenericRoomReading we want to update
     *   }
     * })
    **/
    upsert<T extends GenericRoomReadingUpsertArgs>(
      args: SelectSubset<T, GenericRoomReadingUpsertArgs>
    ): Prisma__GenericRoomReadingClient<GenericRoomReadingGetPayload<T>>

    /**
     * Count the number of GenericRoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingCountArgs} args - Arguments to filter GenericRoomReadings to count.
     * @example
     * // Count the number of GenericRoomReadings
     * const count = await prisma.genericRoomReading.count({
     *   where: {
     *     // ... the filter for the GenericRoomReadings we want to count
     *   }
     * })
    **/
    count<T extends GenericRoomReadingCountArgs>(
      args?: Subset<T, GenericRoomReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenericRoomReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenericRoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenericRoomReadingAggregateArgs>(args: Subset<T, GenericRoomReadingAggregateArgs>): Prisma.PrismaPromise<GetGenericRoomReadingAggregateType<T>>

    /**
     * Group by GenericRoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenericRoomReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenericRoomReadingGroupByArgs['orderBy'] }
        : { orderBy?: GenericRoomReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenericRoomReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenericRoomReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GenericRoomReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GenericRoomReadingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    roomReading<T extends RoomReadingArgs= {}>(args?: Subset<T, RoomReadingArgs>): Prisma__RoomReadingClient<RoomReadingGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GenericRoomReading base type for findUnique actions
   */
  export type GenericRoomReadingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where: GenericRoomReadingWhereUniqueInput
  }

  /**
   * GenericRoomReading findUnique
   */
  export interface GenericRoomReadingFindUniqueArgs extends GenericRoomReadingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GenericRoomReading findUniqueOrThrow
   */
  export type GenericRoomReadingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where: GenericRoomReadingWhereUniqueInput
  }


  /**
   * GenericRoomReading base type for findFirst actions
   */
  export type GenericRoomReadingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: Enumerable<GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericRoomReadings.
     */
    distinct?: Enumerable<GenericRoomReadingScalarFieldEnum>
  }

  /**
   * GenericRoomReading findFirst
   */
  export interface GenericRoomReadingFindFirstArgs extends GenericRoomReadingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GenericRoomReading findFirstOrThrow
   */
  export type GenericRoomReadingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: Enumerable<GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericRoomReadings.
     */
    distinct?: Enumerable<GenericRoomReadingScalarFieldEnum>
  }


  /**
   * GenericRoomReading findMany
   */
  export type GenericRoomReadingFindManyArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter, which GenericRoomReadings to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: Enumerable<GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    distinct?: Enumerable<GenericRoomReadingScalarFieldEnum>
  }


  /**
   * GenericRoomReading create
   */
  export type GenericRoomReadingCreateArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * The data needed to create a GenericRoomReading.
     */
    data: XOR<GenericRoomReadingCreateInput, GenericRoomReadingUncheckedCreateInput>
  }


  /**
   * GenericRoomReading createMany
   */
  export type GenericRoomReadingCreateManyArgs = {
    /**
     * The data used to create many GenericRoomReadings.
     */
    data: Enumerable<GenericRoomReadingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GenericRoomReading update
   */
  export type GenericRoomReadingUpdateArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * The data needed to update a GenericRoomReading.
     */
    data: XOR<GenericRoomReadingUpdateInput, GenericRoomReadingUncheckedUpdateInput>
    /**
     * Choose, which GenericRoomReading to update.
     */
    where: GenericRoomReadingWhereUniqueInput
  }


  /**
   * GenericRoomReading updateMany
   */
  export type GenericRoomReadingUpdateManyArgs = {
    /**
     * The data used to update GenericRoomReadings.
     */
    data: XOR<GenericRoomReadingUpdateManyMutationInput, GenericRoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which GenericRoomReadings to update
     */
    where?: GenericRoomReadingWhereInput
  }


  /**
   * GenericRoomReading upsert
   */
  export type GenericRoomReadingUpsertArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * The filter to search for the GenericRoomReading to update in case it exists.
     */
    where: GenericRoomReadingWhereUniqueInput
    /**
     * In case the GenericRoomReading found by the `where` argument doesn't exist, create a new GenericRoomReading with this data.
     */
    create: XOR<GenericRoomReadingCreateInput, GenericRoomReadingUncheckedCreateInput>
    /**
     * In case the GenericRoomReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenericRoomReadingUpdateInput, GenericRoomReadingUncheckedUpdateInput>
  }


  /**
   * GenericRoomReading delete
   */
  export type GenericRoomReadingDeleteArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
    /**
     * Filter which GenericRoomReading to delete.
     */
    where: GenericRoomReadingWhereUniqueInput
  }


  /**
   * GenericRoomReading deleteMany
   */
  export type GenericRoomReadingDeleteManyArgs = {
    /**
     * Filter which GenericRoomReadings to delete
     */
    where?: GenericRoomReadingWhereInput
  }


  /**
   * GenericRoomReading without action
   */
  export type GenericRoomReadingArgs = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericRoomReadingInclude | null
  }



  /**
   * Model Detection
   */


  export type AggregateDetection = {
    _count: DetectionCountAggregateOutputType | null
    _avg: DetectionAvgAggregateOutputType | null
    _sum: DetectionSumAggregateOutputType | null
    _min: DetectionMinAggregateOutputType | null
    _max: DetectionMaxAggregateOutputType | null
  }

  export type DetectionAvgAggregateOutputType = {
    id: number | null
    inferenceId: number | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    roomId: number | null
    dimension: number | null
  }

  export type DetectionSumAggregateOutputType = {
    id: number | null
    inferenceId: number | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    roomId: number | null
    dimension: number | null
  }

  export type DetectionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    inferenceId: number | null
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    category: string | null
    code: string | null
    item: string | null
    quality: string | null
    roomId: number | null
    dimension: number | null
    unit: DimensionUnit | null
  }

  export type DetectionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    inferenceId: number | null
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    category: string | null
    code: string | null
    item: string | null
    quality: string | null
    roomId: number | null
    dimension: number | null
    unit: DimensionUnit | null
  }

  export type DetectionCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    inferenceId: number
    imageKey: number
    xMinCord: number
    yMinCord: number
    confidence: number
    xMaxCord: number
    yMaxCord: number
    projectId: number
    category: number
    code: number
    item: number
    quality: number
    roomId: number
    dimension: number
    unit: number
    _all: number
  }


  export type DetectionAvgAggregateInputType = {
    id?: true
    inferenceId?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    roomId?: true
    dimension?: true
  }

  export type DetectionSumAggregateInputType = {
    id?: true
    inferenceId?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    roomId?: true
    dimension?: true
  }

  export type DetectionMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
  }

  export type DetectionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
  }

  export type DetectionCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
    _all?: true
  }

  export type DetectionAggregateArgs = {
    /**
     * Filter which Detection to aggregate.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Detections
    **/
    _count?: true | DetectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectionMaxAggregateInputType
  }

  export type GetDetectionAggregateType<T extends DetectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDetection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetection[P]>
      : GetScalarType<T[P], AggregateDetection[P]>
  }




  export type DetectionGroupByArgs = {
    where?: DetectionWhereInput
    orderBy?: Enumerable<DetectionOrderByWithAggregationInput>
    by: DetectionScalarFieldEnum[]
    having?: DetectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectionCountAggregateInputType | true
    _avg?: DetectionAvgAggregateInputType
    _sum?: DetectionSumAggregateInputType
    _min?: DetectionMinAggregateInputType
    _max?: DetectionMaxAggregateInputType
  }


  export type DetectionGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    inferenceId: number
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId: number | null
    dimension: number | null
    unit: DimensionUnit | null
    _count: DetectionCountAggregateOutputType | null
    _avg: DetectionAvgAggregateOutputType | null
    _sum: DetectionSumAggregateOutputType | null
    _min: DetectionMinAggregateOutputType | null
    _max: DetectionMaxAggregateOutputType | null
  }

  type GetDetectionGroupByPayload<T extends DetectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DetectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectionGroupByOutputType[P]>
            : GetScalarType<T[P], DetectionGroupByOutputType[P]>
        }
      >
    >


  export type DetectionSelect = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    inferenceId?: boolean
    imageKey?: boolean
    xMinCord?: boolean
    yMinCord?: boolean
    confidence?: boolean
    xMaxCord?: boolean
    yMaxCord?: boolean
    projectId?: boolean
    category?: boolean
    code?: boolean
    item?: boolean
    quality?: boolean
    roomId?: boolean
    dimension?: boolean
    unit?: boolean
    inference?: boolean | InferenceArgs
    room?: boolean | RoomArgs
  }


  export type DetectionInclude = {
    inference?: boolean | InferenceArgs
    room?: boolean | RoomArgs
  }

  export type DetectionGetPayload<S extends boolean | null | undefined | DetectionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Detection :
    S extends undefined ? never :
    S extends { include: any } & (DetectionArgs | DetectionFindManyArgs)
    ? Detection  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'inference' ? InferenceGetPayload<S['include'][P]> :
        P extends 'room' ? RoomGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (DetectionArgs | DetectionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'inference' ? InferenceGetPayload<S['select'][P]> :
        P extends 'room' ? RoomGetPayload<S['select'][P]> | null :  P extends keyof Detection ? Detection[P] : never
  } 
      : Detection


  type DetectionCountArgs = 
    Omit<DetectionFindManyArgs, 'select' | 'include'> & {
      select?: DetectionCountAggregateInputType | true
    }

  export interface DetectionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Detection that matches the filter.
     * @param {DetectionFindUniqueArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DetectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Detection'> extends True ? Prisma__DetectionClient<DetectionGetPayload<T>> : Prisma__DetectionClient<DetectionGetPayload<T> | null, null>

    /**
     * Find one Detection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DetectionFindUniqueOrThrowArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetectionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DetectionFindUniqueOrThrowArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Find the first Detection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindFirstArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DetectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Detection'> extends True ? Prisma__DetectionClient<DetectionGetPayload<T>> : Prisma__DetectionClient<DetectionGetPayload<T> | null, null>

    /**
     * Find the first Detection that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindFirstOrThrowArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DetectionFindFirstOrThrowArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Find zero or more Detections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detections
     * const detections = await prisma.detection.findMany()
     * 
     * // Get first 10 Detections
     * const detections = await prisma.detection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectionWithIdOnly = await prisma.detection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DetectionFindManyArgs>(
      args?: SelectSubset<T, DetectionFindManyArgs>
    ): Prisma.PrismaPromise<Array<DetectionGetPayload<T>>>

    /**
     * Create a Detection.
     * @param {DetectionCreateArgs} args - Arguments to create a Detection.
     * @example
     * // Create one Detection
     * const Detection = await prisma.detection.create({
     *   data: {
     *     // ... data to create a Detection
     *   }
     * })
     * 
    **/
    create<T extends DetectionCreateArgs>(
      args: SelectSubset<T, DetectionCreateArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Create many Detections.
     *     @param {DetectionCreateManyArgs} args - Arguments to create many Detections.
     *     @example
     *     // Create many Detections
     *     const detection = await prisma.detection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetectionCreateManyArgs>(
      args?: SelectSubset<T, DetectionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detection.
     * @param {DetectionDeleteArgs} args - Arguments to delete one Detection.
     * @example
     * // Delete one Detection
     * const Detection = await prisma.detection.delete({
     *   where: {
     *     // ... filter to delete one Detection
     *   }
     * })
     * 
    **/
    delete<T extends DetectionDeleteArgs>(
      args: SelectSubset<T, DetectionDeleteArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Update one Detection.
     * @param {DetectionUpdateArgs} args - Arguments to update one Detection.
     * @example
     * // Update one Detection
     * const detection = await prisma.detection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetectionUpdateArgs>(
      args: SelectSubset<T, DetectionUpdateArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Delete zero or more Detections.
     * @param {DetectionDeleteManyArgs} args - Arguments to filter Detections to delete.
     * @example
     * // Delete a few Detections
     * const { count } = await prisma.detection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetectionDeleteManyArgs>(
      args?: SelectSubset<T, DetectionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detections
     * const detection = await prisma.detection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetectionUpdateManyArgs>(
      args: SelectSubset<T, DetectionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detection.
     * @param {DetectionUpsertArgs} args - Arguments to update or create a Detection.
     * @example
     * // Update or create a Detection
     * const detection = await prisma.detection.upsert({
     *   create: {
     *     // ... data to create a Detection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detection we want to update
     *   }
     * })
    **/
    upsert<T extends DetectionUpsertArgs>(
      args: SelectSubset<T, DetectionUpsertArgs>
    ): Prisma__DetectionClient<DetectionGetPayload<T>>

    /**
     * Count the number of Detections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionCountArgs} args - Arguments to filter Detections to count.
     * @example
     * // Count the number of Detections
     * const count = await prisma.detection.count({
     *   where: {
     *     // ... the filter for the Detections we want to count
     *   }
     * })
    **/
    count<T extends DetectionCountArgs>(
      args?: Subset<T, DetectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectionAggregateArgs>(args: Subset<T, DetectionAggregateArgs>): Prisma.PrismaPromise<GetDetectionAggregateType<T>>

    /**
     * Group by Detection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectionGroupByArgs['orderBy'] }
        : { orderBy?: DetectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Detection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DetectionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    inference<T extends InferenceArgs= {}>(args?: Subset<T, InferenceArgs>): Prisma__InferenceClient<InferenceGetPayload<T> | Null>;

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Detection base type for findUnique actions
   */
  export type DetectionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter, which Detection to fetch.
     */
    where: DetectionWhereUniqueInput
  }

  /**
   * Detection findUnique
   */
  export interface DetectionFindUniqueArgs extends DetectionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Detection findUniqueOrThrow
   */
  export type DetectionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter, which Detection to fetch.
     */
    where: DetectionWhereUniqueInput
  }


  /**
   * Detection base type for findFirst actions
   */
  export type DetectionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter, which Detection to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Detections.
     */
    distinct?: Enumerable<DetectionScalarFieldEnum>
  }

  /**
   * Detection findFirst
   */
  export interface DetectionFindFirstArgs extends DetectionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Detection findFirstOrThrow
   */
  export type DetectionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter, which Detection to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Detections.
     */
    distinct?: Enumerable<DetectionScalarFieldEnum>
  }


  /**
   * Detection findMany
   */
  export type DetectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter, which Detections to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: Enumerable<DetectionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    distinct?: Enumerable<DetectionScalarFieldEnum>
  }


  /**
   * Detection create
   */
  export type DetectionCreateArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * The data needed to create a Detection.
     */
    data: XOR<DetectionCreateInput, DetectionUncheckedCreateInput>
  }


  /**
   * Detection createMany
   */
  export type DetectionCreateManyArgs = {
    /**
     * The data used to create many Detections.
     */
    data: Enumerable<DetectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Detection update
   */
  export type DetectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * The data needed to update a Detection.
     */
    data: XOR<DetectionUpdateInput, DetectionUncheckedUpdateInput>
    /**
     * Choose, which Detection to update.
     */
    where: DetectionWhereUniqueInput
  }


  /**
   * Detection updateMany
   */
  export type DetectionUpdateManyArgs = {
    /**
     * The data used to update Detections.
     */
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyInput>
    /**
     * Filter which Detections to update
     */
    where?: DetectionWhereInput
  }


  /**
   * Detection upsert
   */
  export type DetectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * The filter to search for the Detection to update in case it exists.
     */
    where: DetectionWhereUniqueInput
    /**
     * In case the Detection found by the `where` argument doesn't exist, create a new Detection with this data.
     */
    create: XOR<DetectionCreateInput, DetectionUncheckedCreateInput>
    /**
     * In case the Detection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectionUpdateInput, DetectionUncheckedUpdateInput>
  }


  /**
   * Detection delete
   */
  export type DetectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
    /**
     * Filter which Detection to delete.
     */
    where: DetectionWhereUniqueInput
  }


  /**
   * Detection deleteMany
   */
  export type DetectionDeleteManyArgs = {
    /**
     * Filter which Detections to delete
     */
    where?: DetectionWhereInput
  }


  /**
   * Detection without action
   */
  export type DetectionArgs = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetectionInclude | null
  }



  /**
   * Model TemplatesUsed
   */


  export type AggregateTemplatesUsed = {
    _count: TemplatesUsedCountAggregateOutputType | null
    _avg: TemplatesUsedAvgAggregateOutputType | null
    _sum: TemplatesUsedSumAggregateOutputType | null
    _min: TemplatesUsedMinAggregateOutputType | null
    _max: TemplatesUsedMaxAggregateOutputType | null
  }

  export type TemplatesUsedAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
  }

  export type TemplatesUsedSumAggregateOutputType = {
    id: number | null
    roomId: number | null
  }

  export type TemplatesUsedMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    templateCode: string | null
    roomId: number | null
  }

  export type TemplatesUsedMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    templateCode: string | null
    roomId: number | null
  }

  export type TemplatesUsedCountAggregateOutputType = {
    id: number
    createdAt: number
    templateCode: number
    roomId: number
    _all: number
  }


  export type TemplatesUsedAvgAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type TemplatesUsedSumAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type TemplatesUsedMinAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
  }

  export type TemplatesUsedMaxAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
  }

  export type TemplatesUsedCountAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
    _all?: true
  }

  export type TemplatesUsedAggregateArgs = {
    /**
     * Filter which TemplatesUsed to aggregate.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: Enumerable<TemplatesUsedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplatesUseds
    **/
    _count?: true | TemplatesUsedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplatesUsedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplatesUsedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplatesUsedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplatesUsedMaxAggregateInputType
  }

  export type GetTemplatesUsedAggregateType<T extends TemplatesUsedAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplatesUsed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplatesUsed[P]>
      : GetScalarType<T[P], AggregateTemplatesUsed[P]>
  }




  export type TemplatesUsedGroupByArgs = {
    where?: TemplatesUsedWhereInput
    orderBy?: Enumerable<TemplatesUsedOrderByWithAggregationInput>
    by: TemplatesUsedScalarFieldEnum[]
    having?: TemplatesUsedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplatesUsedCountAggregateInputType | true
    _avg?: TemplatesUsedAvgAggregateInputType
    _sum?: TemplatesUsedSumAggregateInputType
    _min?: TemplatesUsedMinAggregateInputType
    _max?: TemplatesUsedMaxAggregateInputType
  }


  export type TemplatesUsedGroupByOutputType = {
    id: number
    createdAt: Date
    templateCode: string
    roomId: number | null
    _count: TemplatesUsedCountAggregateOutputType | null
    _avg: TemplatesUsedAvgAggregateOutputType | null
    _sum: TemplatesUsedSumAggregateOutputType | null
    _min: TemplatesUsedMinAggregateOutputType | null
    _max: TemplatesUsedMaxAggregateOutputType | null
  }

  type GetTemplatesUsedGroupByPayload<T extends TemplatesUsedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplatesUsedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplatesUsedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplatesUsedGroupByOutputType[P]>
            : GetScalarType<T[P], TemplatesUsedGroupByOutputType[P]>
        }
      >
    >


  export type TemplatesUsedSelect = {
    id?: boolean
    createdAt?: boolean
    templateCode?: boolean
    roomId?: boolean
    room?: boolean | RoomArgs
  }


  export type TemplatesUsedInclude = {
    room?: boolean | RoomArgs
  }

  export type TemplatesUsedGetPayload<S extends boolean | null | undefined | TemplatesUsedArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplatesUsed :
    S extends undefined ? never :
    S extends { include: any } & (TemplatesUsedArgs | TemplatesUsedFindManyArgs)
    ? TemplatesUsed  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'room' ? RoomGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (TemplatesUsedArgs | TemplatesUsedFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'room' ? RoomGetPayload<S['select'][P]> | null :  P extends keyof TemplatesUsed ? TemplatesUsed[P] : never
  } 
      : TemplatesUsed


  type TemplatesUsedCountArgs = 
    Omit<TemplatesUsedFindManyArgs, 'select' | 'include'> & {
      select?: TemplatesUsedCountAggregateInputType | true
    }

  export interface TemplatesUsedDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplatesUsed that matches the filter.
     * @param {TemplatesUsedFindUniqueArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplatesUsedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplatesUsedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplatesUsed'> extends True ? Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>> : Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T> | null, null>

    /**
     * Find one TemplatesUsed that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplatesUsedFindUniqueOrThrowArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplatesUsedFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplatesUsedFindUniqueOrThrowArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Find the first TemplatesUsed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindFirstArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplatesUsedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplatesUsedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplatesUsed'> extends True ? Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>> : Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T> | null, null>

    /**
     * Find the first TemplatesUsed that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindFirstOrThrowArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplatesUsedFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplatesUsedFindFirstOrThrowArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Find zero or more TemplatesUseds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplatesUseds
     * const templatesUseds = await prisma.templatesUsed.findMany()
     * 
     * // Get first 10 TemplatesUseds
     * const templatesUseds = await prisma.templatesUsed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templatesUsedWithIdOnly = await prisma.templatesUsed.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplatesUsedFindManyArgs>(
      args?: SelectSubset<T, TemplatesUsedFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplatesUsedGetPayload<T>>>

    /**
     * Create a TemplatesUsed.
     * @param {TemplatesUsedCreateArgs} args - Arguments to create a TemplatesUsed.
     * @example
     * // Create one TemplatesUsed
     * const TemplatesUsed = await prisma.templatesUsed.create({
     *   data: {
     *     // ... data to create a TemplatesUsed
     *   }
     * })
     * 
    **/
    create<T extends TemplatesUsedCreateArgs>(
      args: SelectSubset<T, TemplatesUsedCreateArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Create many TemplatesUseds.
     *     @param {TemplatesUsedCreateManyArgs} args - Arguments to create many TemplatesUseds.
     *     @example
     *     // Create many TemplatesUseds
     *     const templatesUsed = await prisma.templatesUsed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplatesUsedCreateManyArgs>(
      args?: SelectSubset<T, TemplatesUsedCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplatesUsed.
     * @param {TemplatesUsedDeleteArgs} args - Arguments to delete one TemplatesUsed.
     * @example
     * // Delete one TemplatesUsed
     * const TemplatesUsed = await prisma.templatesUsed.delete({
     *   where: {
     *     // ... filter to delete one TemplatesUsed
     *   }
     * })
     * 
    **/
    delete<T extends TemplatesUsedDeleteArgs>(
      args: SelectSubset<T, TemplatesUsedDeleteArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Update one TemplatesUsed.
     * @param {TemplatesUsedUpdateArgs} args - Arguments to update one TemplatesUsed.
     * @example
     * // Update one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplatesUsedUpdateArgs>(
      args: SelectSubset<T, TemplatesUsedUpdateArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Delete zero or more TemplatesUseds.
     * @param {TemplatesUsedDeleteManyArgs} args - Arguments to filter TemplatesUseds to delete.
     * @example
     * // Delete a few TemplatesUseds
     * const { count } = await prisma.templatesUsed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplatesUsedDeleteManyArgs>(
      args?: SelectSubset<T, TemplatesUsedDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplatesUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplatesUseds
     * const templatesUsed = await prisma.templatesUsed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplatesUsedUpdateManyArgs>(
      args: SelectSubset<T, TemplatesUsedUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplatesUsed.
     * @param {TemplatesUsedUpsertArgs} args - Arguments to update or create a TemplatesUsed.
     * @example
     * // Update or create a TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.upsert({
     *   create: {
     *     // ... data to create a TemplatesUsed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplatesUsed we want to update
     *   }
     * })
    **/
    upsert<T extends TemplatesUsedUpsertArgs>(
      args: SelectSubset<T, TemplatesUsedUpsertArgs>
    ): Prisma__TemplatesUsedClient<TemplatesUsedGetPayload<T>>

    /**
     * Count the number of TemplatesUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedCountArgs} args - Arguments to filter TemplatesUseds to count.
     * @example
     * // Count the number of TemplatesUseds
     * const count = await prisma.templatesUsed.count({
     *   where: {
     *     // ... the filter for the TemplatesUseds we want to count
     *   }
     * })
    **/
    count<T extends TemplatesUsedCountArgs>(
      args?: Subset<T, TemplatesUsedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplatesUsedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplatesUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplatesUsedAggregateArgs>(args: Subset<T, TemplatesUsedAggregateArgs>): Prisma.PrismaPromise<GetTemplatesUsedAggregateType<T>>

    /**
     * Group by TemplatesUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplatesUsedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplatesUsedGroupByArgs['orderBy'] }
        : { orderBy?: TemplatesUsedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplatesUsedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplatesUsedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplatesUsed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplatesUsedClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    room<T extends RoomArgs= {}>(args?: Subset<T, RoomArgs>): Prisma__RoomClient<RoomGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplatesUsed base type for findUnique actions
   */
  export type TemplatesUsedFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where: TemplatesUsedWhereUniqueInput
  }

  /**
   * TemplatesUsed findUnique
   */
  export interface TemplatesUsedFindUniqueArgs extends TemplatesUsedFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplatesUsed findUniqueOrThrow
   */
  export type TemplatesUsedFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where: TemplatesUsedWhereUniqueInput
  }


  /**
   * TemplatesUsed base type for findFirst actions
   */
  export type TemplatesUsedFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: Enumerable<TemplatesUsedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatesUseds.
     */
    distinct?: Enumerable<TemplatesUsedScalarFieldEnum>
  }

  /**
   * TemplatesUsed findFirst
   */
  export interface TemplatesUsedFindFirstArgs extends TemplatesUsedFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplatesUsed findFirstOrThrow
   */
  export type TemplatesUsedFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: Enumerable<TemplatesUsedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatesUseds.
     */
    distinct?: Enumerable<TemplatesUsedScalarFieldEnum>
  }


  /**
   * TemplatesUsed findMany
   */
  export type TemplatesUsedFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter, which TemplatesUseds to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: Enumerable<TemplatesUsedOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    distinct?: Enumerable<TemplatesUsedScalarFieldEnum>
  }


  /**
   * TemplatesUsed create
   */
  export type TemplatesUsedCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * The data needed to create a TemplatesUsed.
     */
    data: XOR<TemplatesUsedCreateInput, TemplatesUsedUncheckedCreateInput>
  }


  /**
   * TemplatesUsed createMany
   */
  export type TemplatesUsedCreateManyArgs = {
    /**
     * The data used to create many TemplatesUseds.
     */
    data: Enumerable<TemplatesUsedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TemplatesUsed update
   */
  export type TemplatesUsedUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * The data needed to update a TemplatesUsed.
     */
    data: XOR<TemplatesUsedUpdateInput, TemplatesUsedUncheckedUpdateInput>
    /**
     * Choose, which TemplatesUsed to update.
     */
    where: TemplatesUsedWhereUniqueInput
  }


  /**
   * TemplatesUsed updateMany
   */
  export type TemplatesUsedUpdateManyArgs = {
    /**
     * The data used to update TemplatesUseds.
     */
    data: XOR<TemplatesUsedUpdateManyMutationInput, TemplatesUsedUncheckedUpdateManyInput>
    /**
     * Filter which TemplatesUseds to update
     */
    where?: TemplatesUsedWhereInput
  }


  /**
   * TemplatesUsed upsert
   */
  export type TemplatesUsedUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * The filter to search for the TemplatesUsed to update in case it exists.
     */
    where: TemplatesUsedWhereUniqueInput
    /**
     * In case the TemplatesUsed found by the `where` argument doesn't exist, create a new TemplatesUsed with this data.
     */
    create: XOR<TemplatesUsedCreateInput, TemplatesUsedUncheckedCreateInput>
    /**
     * In case the TemplatesUsed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplatesUsedUpdateInput, TemplatesUsedUncheckedUpdateInput>
  }


  /**
   * TemplatesUsed delete
   */
  export type TemplatesUsedDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
    /**
     * Filter which TemplatesUsed to delete.
     */
    where: TemplatesUsedWhereUniqueInput
  }


  /**
   * TemplatesUsed deleteMany
   */
  export type TemplatesUsedDeleteManyArgs = {
    /**
     * Filter which TemplatesUseds to delete
     */
    where?: TemplatesUsedWhereInput
  }


  /**
   * TemplatesUsed without action
   */
  export type TemplatesUsedArgs = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatesUsedInclude | null
  }



  /**
   * Model WaitList
   */


  export type AggregateWaitList = {
    _count: WaitListCountAggregateOutputType | null
    _avg: WaitListAvgAggregateOutputType | null
    _sum: WaitListSumAggregateOutputType | null
    _min: WaitListMinAggregateOutputType | null
    _max: WaitListMaxAggregateOutputType | null
  }

  export type WaitListAvgAggregateOutputType = {
    id: number | null
  }

  export type WaitListSumAggregateOutputType = {
    id: number | null
  }

  export type WaitListMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
  }

  export type WaitListMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
  }

  export type WaitListCountAggregateOutputType = {
    id: number
    createdAt: number
    email: number
    _all: number
  }


  export type WaitListAvgAggregateInputType = {
    id?: true
  }

  export type WaitListSumAggregateInputType = {
    id?: true
  }

  export type WaitListMinAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
  }

  export type WaitListMaxAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
  }

  export type WaitListCountAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
    _all?: true
  }

  export type WaitListAggregateArgs = {
    /**
     * Filter which WaitList to aggregate.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: Enumerable<WaitListOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaitLists
    **/
    _count?: true | WaitListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaitListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaitListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitListMaxAggregateInputType
  }

  export type GetWaitListAggregateType<T extends WaitListAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitList[P]>
      : GetScalarType<T[P], AggregateWaitList[P]>
  }




  export type WaitListGroupByArgs = {
    where?: WaitListWhereInput
    orderBy?: Enumerable<WaitListOrderByWithAggregationInput>
    by: WaitListScalarFieldEnum[]
    having?: WaitListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitListCountAggregateInputType | true
    _avg?: WaitListAvgAggregateInputType
    _sum?: WaitListSumAggregateInputType
    _min?: WaitListMinAggregateInputType
    _max?: WaitListMaxAggregateInputType
  }


  export type WaitListGroupByOutputType = {
    id: number
    createdAt: Date
    email: string
    _count: WaitListCountAggregateOutputType | null
    _avg: WaitListAvgAggregateOutputType | null
    _sum: WaitListSumAggregateOutputType | null
    _min: WaitListMinAggregateOutputType | null
    _max: WaitListMaxAggregateOutputType | null
  }

  type GetWaitListGroupByPayload<T extends WaitListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WaitListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitListGroupByOutputType[P]>
            : GetScalarType<T[P], WaitListGroupByOutputType[P]>
        }
      >
    >


  export type WaitListSelect = {
    id?: boolean
    createdAt?: boolean
    email?: boolean
  }


  export type WaitListGetPayload<S extends boolean | null | undefined | WaitListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WaitList :
    S extends undefined ? never :
    S extends { include: any } & (WaitListArgs | WaitListFindManyArgs)
    ? WaitList 
    : S extends { select: any } & (WaitListArgs | WaitListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WaitList ? WaitList[P] : never
  } 
      : WaitList


  type WaitListCountArgs = 
    Omit<WaitListFindManyArgs, 'select' | 'include'> & {
      select?: WaitListCountAggregateInputType | true
    }

  export interface WaitListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WaitList that matches the filter.
     * @param {WaitListFindUniqueArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WaitListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WaitListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WaitList'> extends True ? Prisma__WaitListClient<WaitListGetPayload<T>> : Prisma__WaitListClient<WaitListGetPayload<T> | null, null>

    /**
     * Find one WaitList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WaitListFindUniqueOrThrowArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WaitListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WaitListFindUniqueOrThrowArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Find the first WaitList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindFirstArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WaitListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WaitListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WaitList'> extends True ? Prisma__WaitListClient<WaitListGetPayload<T>> : Prisma__WaitListClient<WaitListGetPayload<T> | null, null>

    /**
     * Find the first WaitList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindFirstOrThrowArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WaitListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WaitListFindFirstOrThrowArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Find zero or more WaitLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaitLists
     * const waitLists = await prisma.waitList.findMany()
     * 
     * // Get first 10 WaitLists
     * const waitLists = await prisma.waitList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitListWithIdOnly = await prisma.waitList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WaitListFindManyArgs>(
      args?: SelectSubset<T, WaitListFindManyArgs>
    ): Prisma.PrismaPromise<Array<WaitListGetPayload<T>>>

    /**
     * Create a WaitList.
     * @param {WaitListCreateArgs} args - Arguments to create a WaitList.
     * @example
     * // Create one WaitList
     * const WaitList = await prisma.waitList.create({
     *   data: {
     *     // ... data to create a WaitList
     *   }
     * })
     * 
    **/
    create<T extends WaitListCreateArgs>(
      args: SelectSubset<T, WaitListCreateArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Create many WaitLists.
     *     @param {WaitListCreateManyArgs} args - Arguments to create many WaitLists.
     *     @example
     *     // Create many WaitLists
     *     const waitList = await prisma.waitList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WaitListCreateManyArgs>(
      args?: SelectSubset<T, WaitListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WaitList.
     * @param {WaitListDeleteArgs} args - Arguments to delete one WaitList.
     * @example
     * // Delete one WaitList
     * const WaitList = await prisma.waitList.delete({
     *   where: {
     *     // ... filter to delete one WaitList
     *   }
     * })
     * 
    **/
    delete<T extends WaitListDeleteArgs>(
      args: SelectSubset<T, WaitListDeleteArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Update one WaitList.
     * @param {WaitListUpdateArgs} args - Arguments to update one WaitList.
     * @example
     * // Update one WaitList
     * const waitList = await prisma.waitList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WaitListUpdateArgs>(
      args: SelectSubset<T, WaitListUpdateArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Delete zero or more WaitLists.
     * @param {WaitListDeleteManyArgs} args - Arguments to filter WaitLists to delete.
     * @example
     * // Delete a few WaitLists
     * const { count } = await prisma.waitList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WaitListDeleteManyArgs>(
      args?: SelectSubset<T, WaitListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaitLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaitLists
     * const waitList = await prisma.waitList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WaitListUpdateManyArgs>(
      args: SelectSubset<T, WaitListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WaitList.
     * @param {WaitListUpsertArgs} args - Arguments to update or create a WaitList.
     * @example
     * // Update or create a WaitList
     * const waitList = await prisma.waitList.upsert({
     *   create: {
     *     // ... data to create a WaitList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaitList we want to update
     *   }
     * })
    **/
    upsert<T extends WaitListUpsertArgs>(
      args: SelectSubset<T, WaitListUpsertArgs>
    ): Prisma__WaitListClient<WaitListGetPayload<T>>

    /**
     * Count the number of WaitLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListCountArgs} args - Arguments to filter WaitLists to count.
     * @example
     * // Count the number of WaitLists
     * const count = await prisma.waitList.count({
     *   where: {
     *     // ... the filter for the WaitLists we want to count
     *   }
     * })
    **/
    count<T extends WaitListCountArgs>(
      args?: Subset<T, WaitListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaitList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitListAggregateArgs>(args: Subset<T, WaitListAggregateArgs>): Prisma.PrismaPromise<GetWaitListAggregateType<T>>

    /**
     * Group by WaitList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitListGroupByArgs['orderBy'] }
        : { orderBy?: WaitListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WaitList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WaitListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WaitList base type for findUnique actions
   */
  export type WaitListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter, which WaitList to fetch.
     */
    where: WaitListWhereUniqueInput
  }

  /**
   * WaitList findUnique
   */
  export interface WaitListFindUniqueArgs extends WaitListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WaitList findUniqueOrThrow
   */
  export type WaitListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter, which WaitList to fetch.
     */
    where: WaitListWhereUniqueInput
  }


  /**
   * WaitList base type for findFirst actions
   */
  export type WaitListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter, which WaitList to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: Enumerable<WaitListOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitLists.
     */
    distinct?: Enumerable<WaitListScalarFieldEnum>
  }

  /**
   * WaitList findFirst
   */
  export interface WaitListFindFirstArgs extends WaitListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WaitList findFirstOrThrow
   */
  export type WaitListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter, which WaitList to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: Enumerable<WaitListOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitLists.
     */
    distinct?: Enumerable<WaitListScalarFieldEnum>
  }


  /**
   * WaitList findMany
   */
  export type WaitListFindManyArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter, which WaitLists to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: Enumerable<WaitListOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    distinct?: Enumerable<WaitListScalarFieldEnum>
  }


  /**
   * WaitList create
   */
  export type WaitListCreateArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * The data needed to create a WaitList.
     */
    data: XOR<WaitListCreateInput, WaitListUncheckedCreateInput>
  }


  /**
   * WaitList createMany
   */
  export type WaitListCreateManyArgs = {
    /**
     * The data used to create many WaitLists.
     */
    data: Enumerable<WaitListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WaitList update
   */
  export type WaitListUpdateArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * The data needed to update a WaitList.
     */
    data: XOR<WaitListUpdateInput, WaitListUncheckedUpdateInput>
    /**
     * Choose, which WaitList to update.
     */
    where: WaitListWhereUniqueInput
  }


  /**
   * WaitList updateMany
   */
  export type WaitListUpdateManyArgs = {
    /**
     * The data used to update WaitLists.
     */
    data: XOR<WaitListUpdateManyMutationInput, WaitListUncheckedUpdateManyInput>
    /**
     * Filter which WaitLists to update
     */
    where?: WaitListWhereInput
  }


  /**
   * WaitList upsert
   */
  export type WaitListUpsertArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * The filter to search for the WaitList to update in case it exists.
     */
    where: WaitListWhereUniqueInput
    /**
     * In case the WaitList found by the `where` argument doesn't exist, create a new WaitList with this data.
     */
    create: XOR<WaitListCreateInput, WaitListUncheckedCreateInput>
    /**
     * In case the WaitList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitListUpdateInput, WaitListUncheckedUpdateInput>
  }


  /**
   * WaitList delete
   */
  export type WaitListDeleteArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
    /**
     * Filter which WaitList to delete.
     */
    where: WaitListWhereUniqueInput
  }


  /**
   * WaitList deleteMany
   */
  export type WaitListDeleteManyArgs = {
    /**
     * Filter which WaitLists to delete
     */
    where?: WaitListWhereInput
  }


  /**
   * WaitList without action
   */
  export type WaitListArgs = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect | null
  }



  /**
   * Model RekognitionRuns
   */


  export type AggregateRekognitionRuns = {
    _count: RekognitionRunsCountAggregateOutputType | null
    _avg: RekognitionRunsAvgAggregateOutputType | null
    _sum: RekognitionRunsSumAggregateOutputType | null
    _min: RekognitionRunsMinAggregateOutputType | null
    _max: RekognitionRunsMaxAggregateOutputType | null
  }

  export type RekognitionRunsAvgAggregateOutputType = {
    id: number | null
  }

  export type RekognitionRunsSumAggregateOutputType = {
    id: number | null
  }

  export type RekognitionRunsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type RekognitionRunsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type RekognitionRunsCountAggregateOutputType = {
    id: number
    createdAt: number
    _all: number
  }


  export type RekognitionRunsAvgAggregateInputType = {
    id?: true
  }

  export type RekognitionRunsSumAggregateInputType = {
    id?: true
  }

  export type RekognitionRunsMinAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type RekognitionRunsMaxAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type RekognitionRunsCountAggregateInputType = {
    id?: true
    createdAt?: true
    _all?: true
  }

  export type RekognitionRunsAggregateArgs = {
    /**
     * Filter which RekognitionRuns to aggregate.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: Enumerable<RekognitionRunsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RekognitionRuns
    **/
    _count?: true | RekognitionRunsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RekognitionRunsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RekognitionRunsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RekognitionRunsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RekognitionRunsMaxAggregateInputType
  }

  export type GetRekognitionRunsAggregateType<T extends RekognitionRunsAggregateArgs> = {
        [P in keyof T & keyof AggregateRekognitionRuns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRekognitionRuns[P]>
      : GetScalarType<T[P], AggregateRekognitionRuns[P]>
  }




  export type RekognitionRunsGroupByArgs = {
    where?: RekognitionRunsWhereInput
    orderBy?: Enumerable<RekognitionRunsOrderByWithAggregationInput>
    by: RekognitionRunsScalarFieldEnum[]
    having?: RekognitionRunsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RekognitionRunsCountAggregateInputType | true
    _avg?: RekognitionRunsAvgAggregateInputType
    _sum?: RekognitionRunsSumAggregateInputType
    _min?: RekognitionRunsMinAggregateInputType
    _max?: RekognitionRunsMaxAggregateInputType
  }


  export type RekognitionRunsGroupByOutputType = {
    id: number
    createdAt: Date
    _count: RekognitionRunsCountAggregateOutputType | null
    _avg: RekognitionRunsAvgAggregateOutputType | null
    _sum: RekognitionRunsSumAggregateOutputType | null
    _min: RekognitionRunsMinAggregateOutputType | null
    _max: RekognitionRunsMaxAggregateOutputType | null
  }

  type GetRekognitionRunsGroupByPayload<T extends RekognitionRunsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RekognitionRunsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RekognitionRunsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RekognitionRunsGroupByOutputType[P]>
            : GetScalarType<T[P], RekognitionRunsGroupByOutputType[P]>
        }
      >
    >


  export type RekognitionRunsSelect = {
    id?: boolean
    createdAt?: boolean
  }


  export type RekognitionRunsGetPayload<S extends boolean | null | undefined | RekognitionRunsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RekognitionRuns :
    S extends undefined ? never :
    S extends { include: any } & (RekognitionRunsArgs | RekognitionRunsFindManyArgs)
    ? RekognitionRuns 
    : S extends { select: any } & (RekognitionRunsArgs | RekognitionRunsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RekognitionRuns ? RekognitionRuns[P] : never
  } 
      : RekognitionRuns


  type RekognitionRunsCountArgs = 
    Omit<RekognitionRunsFindManyArgs, 'select' | 'include'> & {
      select?: RekognitionRunsCountAggregateInputType | true
    }

  export interface RekognitionRunsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RekognitionRuns that matches the filter.
     * @param {RekognitionRunsFindUniqueArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RekognitionRunsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RekognitionRunsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RekognitionRuns'> extends True ? Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>> : Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T> | null, null>

    /**
     * Find one RekognitionRuns that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RekognitionRunsFindUniqueOrThrowArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RekognitionRunsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RekognitionRunsFindUniqueOrThrowArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Find the first RekognitionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindFirstArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RekognitionRunsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RekognitionRunsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RekognitionRuns'> extends True ? Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>> : Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T> | null, null>

    /**
     * Find the first RekognitionRuns that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindFirstOrThrowArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RekognitionRunsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RekognitionRunsFindFirstOrThrowArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Find zero or more RekognitionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findMany()
     * 
     * // Get first 10 RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rekognitionRunsWithIdOnly = await prisma.rekognitionRuns.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RekognitionRunsFindManyArgs>(
      args?: SelectSubset<T, RekognitionRunsFindManyArgs>
    ): Prisma.PrismaPromise<Array<RekognitionRunsGetPayload<T>>>

    /**
     * Create a RekognitionRuns.
     * @param {RekognitionRunsCreateArgs} args - Arguments to create a RekognitionRuns.
     * @example
     * // Create one RekognitionRuns
     * const RekognitionRuns = await prisma.rekognitionRuns.create({
     *   data: {
     *     // ... data to create a RekognitionRuns
     *   }
     * })
     * 
    **/
    create<T extends RekognitionRunsCreateArgs>(
      args: SelectSubset<T, RekognitionRunsCreateArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Create many RekognitionRuns.
     *     @param {RekognitionRunsCreateManyArgs} args - Arguments to create many RekognitionRuns.
     *     @example
     *     // Create many RekognitionRuns
     *     const rekognitionRuns = await prisma.rekognitionRuns.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RekognitionRunsCreateManyArgs>(
      args?: SelectSubset<T, RekognitionRunsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RekognitionRuns.
     * @param {RekognitionRunsDeleteArgs} args - Arguments to delete one RekognitionRuns.
     * @example
     * // Delete one RekognitionRuns
     * const RekognitionRuns = await prisma.rekognitionRuns.delete({
     *   where: {
     *     // ... filter to delete one RekognitionRuns
     *   }
     * })
     * 
    **/
    delete<T extends RekognitionRunsDeleteArgs>(
      args: SelectSubset<T, RekognitionRunsDeleteArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Update one RekognitionRuns.
     * @param {RekognitionRunsUpdateArgs} args - Arguments to update one RekognitionRuns.
     * @example
     * // Update one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RekognitionRunsUpdateArgs>(
      args: SelectSubset<T, RekognitionRunsUpdateArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Delete zero or more RekognitionRuns.
     * @param {RekognitionRunsDeleteManyArgs} args - Arguments to filter RekognitionRuns to delete.
     * @example
     * // Delete a few RekognitionRuns
     * const { count } = await prisma.rekognitionRuns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RekognitionRunsDeleteManyArgs>(
      args?: SelectSubset<T, RekognitionRunsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RekognitionRunsUpdateManyArgs>(
      args: SelectSubset<T, RekognitionRunsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RekognitionRuns.
     * @param {RekognitionRunsUpsertArgs} args - Arguments to update or create a RekognitionRuns.
     * @example
     * // Update or create a RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.upsert({
     *   create: {
     *     // ... data to create a RekognitionRuns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RekognitionRuns we want to update
     *   }
     * })
    **/
    upsert<T extends RekognitionRunsUpsertArgs>(
      args: SelectSubset<T, RekognitionRunsUpsertArgs>
    ): Prisma__RekognitionRunsClient<RekognitionRunsGetPayload<T>>

    /**
     * Count the number of RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsCountArgs} args - Arguments to filter RekognitionRuns to count.
     * @example
     * // Count the number of RekognitionRuns
     * const count = await prisma.rekognitionRuns.count({
     *   where: {
     *     // ... the filter for the RekognitionRuns we want to count
     *   }
     * })
    **/
    count<T extends RekognitionRunsCountArgs>(
      args?: Subset<T, RekognitionRunsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RekognitionRunsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RekognitionRunsAggregateArgs>(args: Subset<T, RekognitionRunsAggregateArgs>): Prisma.PrismaPromise<GetRekognitionRunsAggregateType<T>>

    /**
     * Group by RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RekognitionRunsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RekognitionRunsGroupByArgs['orderBy'] }
        : { orderBy?: RekognitionRunsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RekognitionRunsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRekognitionRunsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RekognitionRuns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RekognitionRunsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RekognitionRuns base type for findUnique actions
   */
  export type RekognitionRunsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where: RekognitionRunsWhereUniqueInput
  }

  /**
   * RekognitionRuns findUnique
   */
  export interface RekognitionRunsFindUniqueArgs extends RekognitionRunsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RekognitionRuns findUniqueOrThrow
   */
  export type RekognitionRunsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where: RekognitionRunsWhereUniqueInput
  }


  /**
   * RekognitionRuns base type for findFirst actions
   */
  export type RekognitionRunsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: Enumerable<RekognitionRunsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RekognitionRuns.
     */
    distinct?: Enumerable<RekognitionRunsScalarFieldEnum>
  }

  /**
   * RekognitionRuns findFirst
   */
  export interface RekognitionRunsFindFirstArgs extends RekognitionRunsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RekognitionRuns findFirstOrThrow
   */
  export type RekognitionRunsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: Enumerable<RekognitionRunsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RekognitionRuns.
     */
    distinct?: Enumerable<RekognitionRunsScalarFieldEnum>
  }


  /**
   * RekognitionRuns findMany
   */
  export type RekognitionRunsFindManyArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: Enumerable<RekognitionRunsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    distinct?: Enumerable<RekognitionRunsScalarFieldEnum>
  }


  /**
   * RekognitionRuns create
   */
  export type RekognitionRunsCreateArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * The data needed to create a RekognitionRuns.
     */
    data: XOR<RekognitionRunsCreateInput, RekognitionRunsUncheckedCreateInput>
  }


  /**
   * RekognitionRuns createMany
   */
  export type RekognitionRunsCreateManyArgs = {
    /**
     * The data used to create many RekognitionRuns.
     */
    data: Enumerable<RekognitionRunsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RekognitionRuns update
   */
  export type RekognitionRunsUpdateArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * The data needed to update a RekognitionRuns.
     */
    data: XOR<RekognitionRunsUpdateInput, RekognitionRunsUncheckedUpdateInput>
    /**
     * Choose, which RekognitionRuns to update.
     */
    where: RekognitionRunsWhereUniqueInput
  }


  /**
   * RekognitionRuns updateMany
   */
  export type RekognitionRunsUpdateManyArgs = {
    /**
     * The data used to update RekognitionRuns.
     */
    data: XOR<RekognitionRunsUpdateManyMutationInput, RekognitionRunsUncheckedUpdateManyInput>
    /**
     * Filter which RekognitionRuns to update
     */
    where?: RekognitionRunsWhereInput
  }


  /**
   * RekognitionRuns upsert
   */
  export type RekognitionRunsUpsertArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * The filter to search for the RekognitionRuns to update in case it exists.
     */
    where: RekognitionRunsWhereUniqueInput
    /**
     * In case the RekognitionRuns found by the `where` argument doesn't exist, create a new RekognitionRuns with this data.
     */
    create: XOR<RekognitionRunsCreateInput, RekognitionRunsUncheckedCreateInput>
    /**
     * In case the RekognitionRuns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RekognitionRunsUpdateInput, RekognitionRunsUncheckedUpdateInput>
  }


  /**
   * RekognitionRuns delete
   */
  export type RekognitionRunsDeleteArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
    /**
     * Filter which RekognitionRuns to delete.
     */
    where: RekognitionRunsWhereUniqueInput
  }


  /**
   * RekognitionRuns deleteMany
   */
  export type RekognitionRunsDeleteManyArgs = {
    /**
     * Filter which RekognitionRuns to delete
     */
    where?: RekognitionRunsWhereInput
  }


  /**
   * RekognitionRuns without action
   */
  export type RekognitionRunsArgs = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect | null
  }



  /**
   * Model CalendarEvent
   */


  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CalendarEventSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    payload: string | null
    projectId: number | null
    date: Date | null
    dynamicId: string | null
    isDeleted: boolean | null
    remindClient: boolean | null
    remindProjectOwners: boolean | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    payload: string | null
    projectId: number | null
    date: Date | null
    dynamicId: string | null
    isDeleted: boolean | null
    remindClient: boolean | null
    remindProjectOwners: boolean | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    updatedAt: number
    subject: number
    payload: number
    projectId: number
    date: number
    dynamicId: number
    isDeleted: number
    remindClient: number
    remindProjectOwners: number
    _all: number
  }


  export type CalendarEventAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CalendarEventSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CalendarEventMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: Enumerable<CalendarEventOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs = {
    where?: CalendarEventWhereInput
    orderBy?: Enumerable<CalendarEventOrderByWithAggregationInput>
    by: CalendarEventScalarFieldEnum[]
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _avg?: CalendarEventAvgAggregateInputType
    _sum?: CalendarEventSumAggregateInputType
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }


  export type CalendarEventGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    updatedAt: Date
    subject: string
    payload: string
    projectId: number | null
    date: Date
    dynamicId: string
    isDeleted: boolean
    remindClient: boolean
    remindProjectOwners: boolean
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    payload?: boolean
    projectId?: boolean
    date?: boolean
    dynamicId?: boolean
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: boolean | CalendarEvent$remindersArgs
    project?: boolean | ProjectArgs
    _count?: boolean | CalendarEventCountOutputTypeArgs
  }


  export type CalendarEventInclude = {
    reminders?: boolean | CalendarEvent$remindersArgs
    project?: boolean | ProjectArgs
    _count?: boolean | CalendarEventCountOutputTypeArgs
  }

  export type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CalendarEvent :
    S extends undefined ? never :
    S extends { include: any } & (CalendarEventArgs | CalendarEventFindManyArgs)
    ? CalendarEvent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reminders' ? Array < CalendarEventReminderGetPayload<S['include'][P]>>  :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :
        P extends '_count' ? CalendarEventCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CalendarEventArgs | CalendarEventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reminders' ? Array < CalendarEventReminderGetPayload<S['select'][P]>>  :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :
        P extends '_count' ? CalendarEventCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CalendarEvent ? CalendarEvent[P] : never
  } 
      : CalendarEvent


  type CalendarEventCountArgs = 
    Omit<CalendarEventFindManyArgs, 'select' | 'include'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CalendarEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CalendarEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CalendarEvent'> extends True ? Prisma__CalendarEventClient<CalendarEventGetPayload<T>> : Prisma__CalendarEventClient<CalendarEventGetPayload<T> | null, null>

    /**
     * Find one CalendarEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CalendarEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CalendarEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CalendarEvent'> extends True ? Prisma__CalendarEventClient<CalendarEventGetPayload<T>> : Prisma__CalendarEventClient<CalendarEventGetPayload<T> | null, null>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CalendarEventFindManyArgs>(
      args?: SelectSubset<T, CalendarEventFindManyArgs>
    ): Prisma.PrismaPromise<Array<CalendarEventGetPayload<T>>>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
    **/
    create<T extends CalendarEventCreateArgs>(
      args: SelectSubset<T, CalendarEventCreateArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Create many CalendarEvents.
     *     @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     *     @example
     *     // Create many CalendarEvents
     *     const calendarEvent = await prisma.calendarEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CalendarEventCreateManyArgs>(
      args?: SelectSubset<T, CalendarEventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
    **/
    delete<T extends CalendarEventDeleteArgs>(
      args: SelectSubset<T, CalendarEventDeleteArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CalendarEventUpdateArgs>(
      args: SelectSubset<T, CalendarEventUpdateArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CalendarEventDeleteManyArgs>(
      args?: SelectSubset<T, CalendarEventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CalendarEventUpdateManyArgs>(
      args: SelectSubset<T, CalendarEventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
    **/
    upsert<T extends CalendarEventUpsertArgs>(
      args: SelectSubset<T, CalendarEventUpsertArgs>
    ): Prisma__CalendarEventClient<CalendarEventGetPayload<T>>

    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CalendarEventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reminders<T extends CalendarEvent$remindersArgs= {}>(args?: Subset<T, CalendarEvent$remindersArgs>): Prisma.PrismaPromise<Array<CalendarEventReminderGetPayload<T>>| Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CalendarEvent base type for findUnique actions
   */
  export type CalendarEventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUnique
   */
  export interface CalendarEventFindUniqueArgs extends CalendarEventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }


  /**
   * CalendarEvent base type for findFirst actions
   */
  export type CalendarEventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: Enumerable<CalendarEventOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: Enumerable<CalendarEventScalarFieldEnum>
  }

  /**
   * CalendarEvent findFirst
   */
  export interface CalendarEventFindFirstArgs extends CalendarEventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: Enumerable<CalendarEventOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: Enumerable<CalendarEventScalarFieldEnum>
  }


  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: Enumerable<CalendarEventOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: Enumerable<CalendarEventScalarFieldEnum>
  }


  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }


  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: Enumerable<CalendarEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }


  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }


  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }


  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }


  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }


  /**
   * CalendarEvent.reminders
   */
  export type CalendarEvent$remindersArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    where?: CalendarEventReminderWhereInput
    orderBy?: Enumerable<CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput>
    cursor?: CalendarEventReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarEventReminderScalarFieldEnum>
  }


  /**
   * CalendarEvent without action
   */
  export type CalendarEventArgs = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventInclude | null
  }



  /**
   * Model CalendarEventReminder
   */


  export type AggregateCalendarEventReminder = {
    _count: CalendarEventReminderCountAggregateOutputType | null
    _avg: CalendarEventReminderAvgAggregateOutputType | null
    _sum: CalendarEventReminderSumAggregateOutputType | null
    _min: CalendarEventReminderMinAggregateOutputType | null
    _max: CalendarEventReminderMaxAggregateOutputType | null
  }

  export type CalendarEventReminderAvgAggregateOutputType = {
    id: number | null
    calendarEventId: number | null
  }

  export type CalendarEventReminderSumAggregateOutputType = {
    id: number | null
    calendarEventId: number | null
  }

  export type CalendarEventReminderMinAggregateOutputType = {
    id: number | null
    reminderTarget: ReminderTarget | null
    createdAt: Date | null
    updatedAt: Date | null
    sendText: boolean | null
    sendEmail: boolean | null
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date | null
  }

  export type CalendarEventReminderMaxAggregateOutputType = {
    id: number | null
    reminderTarget: ReminderTarget | null
    createdAt: Date | null
    updatedAt: Date | null
    sendText: boolean | null
    sendEmail: boolean | null
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date | null
  }

  export type CalendarEventReminderCountAggregateOutputType = {
    id: number
    reminderTarget: number
    createdAt: number
    updatedAt: number
    sendText: number
    sendEmail: number
    textSentAt: number
    emailSentAt: number
    calendarEventId: number
    date: number
    _all: number
  }


  export type CalendarEventReminderAvgAggregateInputType = {
    id?: true
    calendarEventId?: true
  }

  export type CalendarEventReminderSumAggregateInputType = {
    id?: true
    calendarEventId?: true
  }

  export type CalendarEventReminderMinAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
  }

  export type CalendarEventReminderMaxAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
  }

  export type CalendarEventReminderCountAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
    _all?: true
  }

  export type CalendarEventReminderAggregateArgs = {
    /**
     * Filter which CalendarEventReminder to aggregate.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: Enumerable<CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEventReminders
    **/
    _count?: true | CalendarEventReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEventReminderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEventReminderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventReminderMaxAggregateInputType
  }

  export type GetCalendarEventReminderAggregateType<T extends CalendarEventReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEventReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEventReminder[P]>
      : GetScalarType<T[P], AggregateCalendarEventReminder[P]>
  }




  export type CalendarEventReminderGroupByArgs = {
    where?: CalendarEventReminderWhereInput
    orderBy?: Enumerable<CalendarEventReminderOrderByWithAggregationInput>
    by: CalendarEventReminderScalarFieldEnum[]
    having?: CalendarEventReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventReminderCountAggregateInputType | true
    _avg?: CalendarEventReminderAvgAggregateInputType
    _sum?: CalendarEventReminderSumAggregateInputType
    _min?: CalendarEventReminderMinAggregateInputType
    _max?: CalendarEventReminderMaxAggregateInputType
  }


  export type CalendarEventReminderGroupByOutputType = {
    id: number
    reminderTarget: ReminderTarget
    createdAt: Date
    updatedAt: Date
    sendText: boolean
    sendEmail: boolean
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date
    _count: CalendarEventReminderCountAggregateOutputType | null
    _avg: CalendarEventReminderAvgAggregateOutputType | null
    _sum: CalendarEventReminderSumAggregateOutputType | null
    _min: CalendarEventReminderMinAggregateOutputType | null
    _max: CalendarEventReminderMaxAggregateOutputType | null
  }

  type GetCalendarEventReminderGroupByPayload<T extends CalendarEventReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CalendarEventReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventReminderGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventReminderGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventReminderSelect = {
    id?: boolean
    reminderTarget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: boolean
    emailSentAt?: boolean
    calendarEventId?: boolean
    date?: boolean
    calendarEvent?: boolean | CalendarEventArgs
  }


  export type CalendarEventReminderInclude = {
    calendarEvent?: boolean | CalendarEventArgs
  }

  export type CalendarEventReminderGetPayload<S extends boolean | null | undefined | CalendarEventReminderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CalendarEventReminder :
    S extends undefined ? never :
    S extends { include: any } & (CalendarEventReminderArgs | CalendarEventReminderFindManyArgs)
    ? CalendarEventReminder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'calendarEvent' ? CalendarEventGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CalendarEventReminderArgs | CalendarEventReminderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'calendarEvent' ? CalendarEventGetPayload<S['select'][P]> | null :  P extends keyof CalendarEventReminder ? CalendarEventReminder[P] : never
  } 
      : CalendarEventReminder


  type CalendarEventReminderCountArgs = 
    Omit<CalendarEventReminderFindManyArgs, 'select' | 'include'> & {
      select?: CalendarEventReminderCountAggregateInputType | true
    }

  export interface CalendarEventReminderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CalendarEventReminder that matches the filter.
     * @param {CalendarEventReminderFindUniqueArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CalendarEventReminderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CalendarEventReminderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CalendarEventReminder'> extends True ? Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>> : Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T> | null, null>

    /**
     * Find one CalendarEventReminder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CalendarEventReminderFindUniqueOrThrowArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CalendarEventReminderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CalendarEventReminderFindUniqueOrThrowArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Find the first CalendarEventReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindFirstArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CalendarEventReminderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CalendarEventReminderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CalendarEventReminder'> extends True ? Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>> : Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T> | null, null>

    /**
     * Find the first CalendarEventReminder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindFirstOrThrowArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CalendarEventReminderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CalendarEventReminderFindFirstOrThrowArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Find zero or more CalendarEventReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEventReminders
     * const calendarEventReminders = await prisma.calendarEventReminder.findMany()
     * 
     * // Get first 10 CalendarEventReminders
     * const calendarEventReminders = await prisma.calendarEventReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventReminderWithIdOnly = await prisma.calendarEventReminder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CalendarEventReminderFindManyArgs>(
      args?: SelectSubset<T, CalendarEventReminderFindManyArgs>
    ): Prisma.PrismaPromise<Array<CalendarEventReminderGetPayload<T>>>

    /**
     * Create a CalendarEventReminder.
     * @param {CalendarEventReminderCreateArgs} args - Arguments to create a CalendarEventReminder.
     * @example
     * // Create one CalendarEventReminder
     * const CalendarEventReminder = await prisma.calendarEventReminder.create({
     *   data: {
     *     // ... data to create a CalendarEventReminder
     *   }
     * })
     * 
    **/
    create<T extends CalendarEventReminderCreateArgs>(
      args: SelectSubset<T, CalendarEventReminderCreateArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Create many CalendarEventReminders.
     *     @param {CalendarEventReminderCreateManyArgs} args - Arguments to create many CalendarEventReminders.
     *     @example
     *     // Create many CalendarEventReminders
     *     const calendarEventReminder = await prisma.calendarEventReminder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CalendarEventReminderCreateManyArgs>(
      args?: SelectSubset<T, CalendarEventReminderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalendarEventReminder.
     * @param {CalendarEventReminderDeleteArgs} args - Arguments to delete one CalendarEventReminder.
     * @example
     * // Delete one CalendarEventReminder
     * const CalendarEventReminder = await prisma.calendarEventReminder.delete({
     *   where: {
     *     // ... filter to delete one CalendarEventReminder
     *   }
     * })
     * 
    **/
    delete<T extends CalendarEventReminderDeleteArgs>(
      args: SelectSubset<T, CalendarEventReminderDeleteArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Update one CalendarEventReminder.
     * @param {CalendarEventReminderUpdateArgs} args - Arguments to update one CalendarEventReminder.
     * @example
     * // Update one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CalendarEventReminderUpdateArgs>(
      args: SelectSubset<T, CalendarEventReminderUpdateArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Delete zero or more CalendarEventReminders.
     * @param {CalendarEventReminderDeleteManyArgs} args - Arguments to filter CalendarEventReminders to delete.
     * @example
     * // Delete a few CalendarEventReminders
     * const { count } = await prisma.calendarEventReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CalendarEventReminderDeleteManyArgs>(
      args?: SelectSubset<T, CalendarEventReminderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEventReminders
     * const calendarEventReminder = await prisma.calendarEventReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CalendarEventReminderUpdateManyArgs>(
      args: SelectSubset<T, CalendarEventReminderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEventReminder.
     * @param {CalendarEventReminderUpsertArgs} args - Arguments to update or create a CalendarEventReminder.
     * @example
     * // Update or create a CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.upsert({
     *   create: {
     *     // ... data to create a CalendarEventReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEventReminder we want to update
     *   }
     * })
    **/
    upsert<T extends CalendarEventReminderUpsertArgs>(
      args: SelectSubset<T, CalendarEventReminderUpsertArgs>
    ): Prisma__CalendarEventReminderClient<CalendarEventReminderGetPayload<T>>

    /**
     * Count the number of CalendarEventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderCountArgs} args - Arguments to filter CalendarEventReminders to count.
     * @example
     * // Count the number of CalendarEventReminders
     * const count = await prisma.calendarEventReminder.count({
     *   where: {
     *     // ... the filter for the CalendarEventReminders we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventReminderCountArgs>(
      args?: Subset<T, CalendarEventReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventReminderAggregateArgs>(args: Subset<T, CalendarEventReminderAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventReminderAggregateType<T>>

    /**
     * Group by CalendarEventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventReminderGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEventReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CalendarEventReminderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    calendarEvent<T extends CalendarEventArgs= {}>(args?: Subset<T, CalendarEventArgs>): Prisma__CalendarEventClient<CalendarEventGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CalendarEventReminder base type for findUnique actions
   */
  export type CalendarEventReminderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where: CalendarEventReminderWhereUniqueInput
  }

  /**
   * CalendarEventReminder findUnique
   */
  export interface CalendarEventReminderFindUniqueArgs extends CalendarEventReminderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CalendarEventReminder findUniqueOrThrow
   */
  export type CalendarEventReminderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where: CalendarEventReminderWhereUniqueInput
  }


  /**
   * CalendarEventReminder base type for findFirst actions
   */
  export type CalendarEventReminderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: Enumerable<CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventReminders.
     */
    distinct?: Enumerable<CalendarEventReminderScalarFieldEnum>
  }

  /**
   * CalendarEventReminder findFirst
   */
  export interface CalendarEventReminderFindFirstArgs extends CalendarEventReminderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CalendarEventReminder findFirstOrThrow
   */
  export type CalendarEventReminderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: Enumerable<CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventReminders.
     */
    distinct?: Enumerable<CalendarEventReminderScalarFieldEnum>
  }


  /**
   * CalendarEventReminder findMany
   */
  export type CalendarEventReminderFindManyArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter, which CalendarEventReminders to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: Enumerable<CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    distinct?: Enumerable<CalendarEventReminderScalarFieldEnum>
  }


  /**
   * CalendarEventReminder create
   */
  export type CalendarEventReminderCreateArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * The data needed to create a CalendarEventReminder.
     */
    data: XOR<CalendarEventReminderCreateInput, CalendarEventReminderUncheckedCreateInput>
  }


  /**
   * CalendarEventReminder createMany
   */
  export type CalendarEventReminderCreateManyArgs = {
    /**
     * The data used to create many CalendarEventReminders.
     */
    data: Enumerable<CalendarEventReminderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CalendarEventReminder update
   */
  export type CalendarEventReminderUpdateArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * The data needed to update a CalendarEventReminder.
     */
    data: XOR<CalendarEventReminderUpdateInput, CalendarEventReminderUncheckedUpdateInput>
    /**
     * Choose, which CalendarEventReminder to update.
     */
    where: CalendarEventReminderWhereUniqueInput
  }


  /**
   * CalendarEventReminder updateMany
   */
  export type CalendarEventReminderUpdateManyArgs = {
    /**
     * The data used to update CalendarEventReminders.
     */
    data: XOR<CalendarEventReminderUpdateManyMutationInput, CalendarEventReminderUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventReminders to update
     */
    where?: CalendarEventReminderWhereInput
  }


  /**
   * CalendarEventReminder upsert
   */
  export type CalendarEventReminderUpsertArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * The filter to search for the CalendarEventReminder to update in case it exists.
     */
    where: CalendarEventReminderWhereUniqueInput
    /**
     * In case the CalendarEventReminder found by the `where` argument doesn't exist, create a new CalendarEventReminder with this data.
     */
    create: XOR<CalendarEventReminderCreateInput, CalendarEventReminderUncheckedCreateInput>
    /**
     * In case the CalendarEventReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventReminderUpdateInput, CalendarEventReminderUncheckedUpdateInput>
  }


  /**
   * CalendarEventReminder delete
   */
  export type CalendarEventReminderDeleteArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
    /**
     * Filter which CalendarEventReminder to delete.
     */
    where: CalendarEventReminderWhereUniqueInput
  }


  /**
   * CalendarEventReminder deleteMany
   */
  export type CalendarEventReminderDeleteManyArgs = {
    /**
     * Filter which CalendarEventReminders to delete
     */
    where?: CalendarEventReminderWhereInput
  }


  /**
   * CalendarEventReminder without action
   */
  export type CalendarEventReminderArgs = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarEventReminderInclude | null
  }



  /**
   * Model ItemCategory
   */


  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: number | null
    xactimateKey: string | null
    xactimateDescription: string | null
    hasItems: boolean | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: number | null
    xactimateKey: string | null
    xactimateDescription: string | null
    hasItems: boolean | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    xactimateKey: number
    xactimateDescription: number
    hasItems: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ItemCategorySumAggregateInputType = {
    id?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: Enumerable<ItemCategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs = {
    where?: ItemCategoryWhereInput
    orderBy?: Enumerable<ItemCategoryOrderByWithAggregationInput>
    by: ItemCategoryScalarFieldEnum[]
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }


  export type ItemCategoryGroupByOutputType = {
    id: number
    xactimateKey: string
    xactimateDescription: string
    hasItems: boolean
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect = {
    id?: boolean
    xactimateKey?: boolean
    xactimateDescription?: boolean
    hasItems?: boolean
    LineItem?: boolean | ItemCategory$LineItemArgs
    _count?: boolean | ItemCategoryCountOutputTypeArgs
  }


  export type ItemCategoryInclude = {
    LineItem?: boolean | ItemCategory$LineItemArgs
    _count?: boolean | ItemCategoryCountOutputTypeArgs
  }

  export type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ItemCategory :
    S extends undefined ? never :
    S extends { include: any } & (ItemCategoryArgs | ItemCategoryFindManyArgs)
    ? ItemCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'LineItem' ? Array < LineItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? ItemCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ItemCategoryArgs | ItemCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'LineItem' ? Array < LineItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? ItemCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ItemCategory ? ItemCategory[P] : never
  } 
      : ItemCategory


  type ItemCategoryCountArgs = 
    Omit<ItemCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ItemCategory'> extends True ? Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>> : Prisma__ItemCategoryClient<ItemCategoryGetPayload<T> | null, null>

    /**
     * Find one ItemCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ItemCategory'> extends True ? Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>> : Prisma__ItemCategoryClient<ItemCategoryGetPayload<T> | null, null>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemCategoryFindManyArgs>(
      args?: SelectSubset<T, ItemCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<ItemCategoryGetPayload<T>>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
    **/
    create<T extends ItemCategoryCreateArgs>(
      args: SelectSubset<T, ItemCategoryCreateArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Create many ItemCategories.
     *     @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     *     @example
     *     // Create many ItemCategories
     *     const itemCategory = await prisma.itemCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCategoryCreateManyArgs>(
      args?: SelectSubset<T, ItemCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
    **/
    delete<T extends ItemCategoryDeleteArgs>(
      args: SelectSubset<T, ItemCategoryDeleteArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemCategoryUpdateArgs>(
      args: SelectSubset<T, ItemCategoryUpdateArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ItemCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemCategoryUpdateManyArgs>(
      args: SelectSubset<T, ItemCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ItemCategoryUpsertArgs>(
      args: SelectSubset<T, ItemCategoryUpsertArgs>
    ): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T>>

    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    LineItem<T extends ItemCategory$LineItemArgs= {}>(args?: Subset<T, ItemCategory$LineItemArgs>): Prisma.PrismaPromise<Array<LineItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ItemCategory base type for findUnique actions
   */
  export type ItemCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUnique
   */
  export interface ItemCategoryFindUniqueArgs extends ItemCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }


  /**
   * ItemCategory base type for findFirst actions
   */
  export type ItemCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: Enumerable<ItemCategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: Enumerable<ItemCategoryScalarFieldEnum>
  }

  /**
   * ItemCategory findFirst
   */
  export interface ItemCategoryFindFirstArgs extends ItemCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: Enumerable<ItemCategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: Enumerable<ItemCategoryScalarFieldEnum>
  }


  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: Enumerable<ItemCategoryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: Enumerable<ItemCategoryScalarFieldEnum>
  }


  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }


  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs = {
    /**
     * The data used to create many ItemCategories.
     */
    data: Enumerable<ItemCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }


  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
  }


  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }


  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }


  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
  }


  /**
   * ItemCategory.LineItem
   */
  export type ItemCategory$LineItemArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    where?: LineItemWhereInput
    orderBy?: Enumerable<LineItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LineItemScalarFieldEnum>
  }


  /**
   * ItemCategory without action
   */
  export type ItemCategoryArgs = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemCategoryInclude | null
  }



  /**
   * Model LineItem
   */


  export type AggregateLineItem = {
    _count: LineItemCountAggregateOutputType | null
    _avg: LineItemAvgAggregateOutputType | null
    _sum: LineItemSumAggregateOutputType | null
    _min: LineItemMinAggregateOutputType | null
    _max: LineItemMaxAggregateOutputType | null
  }

  export type LineItemAvgAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
  }

  export type LineItemSumAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
  }

  export type LineItemMinAggregateOutputType = {
    id: number | null
    xactimateCode: string | null
    xactimateDescription: string | null
    unit: string | null
    itemCategoryId: number | null
  }

  export type LineItemMaxAggregateOutputType = {
    id: number | null
    xactimateCode: string | null
    xactimateDescription: string | null
    unit: string | null
    itemCategoryId: number | null
  }

  export type LineItemCountAggregateOutputType = {
    id: number
    xactimateCode: number
    xactimateDescription: number
    unit: number
    itemCategoryId: number
    _all: number
  }


  export type LineItemAvgAggregateInputType = {
    id?: true
    itemCategoryId?: true
  }

  export type LineItemSumAggregateInputType = {
    id?: true
    itemCategoryId?: true
  }

  export type LineItemMinAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
  }

  export type LineItemMaxAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
  }

  export type LineItemCountAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
    _all?: true
  }

  export type LineItemAggregateArgs = {
    /**
     * Filter which LineItem to aggregate.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: Enumerable<LineItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineItems
    **/
    _count?: true | LineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineItemMaxAggregateInputType
  }

  export type GetLineItemAggregateType<T extends LineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineItem[P]>
      : GetScalarType<T[P], AggregateLineItem[P]>
  }




  export type LineItemGroupByArgs = {
    where?: LineItemWhereInput
    orderBy?: Enumerable<LineItemOrderByWithAggregationInput>
    by: LineItemScalarFieldEnum[]
    having?: LineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineItemCountAggregateInputType | true
    _avg?: LineItemAvgAggregateInputType
    _sum?: LineItemSumAggregateInputType
    _min?: LineItemMinAggregateInputType
    _max?: LineItemMaxAggregateInputType
  }


  export type LineItemGroupByOutputType = {
    id: number
    xactimateCode: string
    xactimateDescription: string
    unit: string | null
    itemCategoryId: number
    _count: LineItemCountAggregateOutputType | null
    _avg: LineItemAvgAggregateOutputType | null
    _sum: LineItemSumAggregateOutputType | null
    _min: LineItemMinAggregateOutputType | null
    _max: LineItemMaxAggregateOutputType | null
  }

  type GetLineItemGroupByPayload<T extends LineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemGroupByOutputType[P]>
        }
      >
    >


  export type LineItemSelect = {
    id?: boolean
    xactimateCode?: boolean
    xactimateDescription?: boolean
    unit?: boolean
    itemCategoryId?: boolean
    xactimateCategory?: boolean | ItemCategoryArgs
    alternateItem?: boolean | LineItem$alternateItemArgs
    relatedItem?: boolean | LineItem$relatedItemArgs
    _count?: boolean | LineItemCountOutputTypeArgs
  }


  export type LineItemInclude = {
    xactimateCategory?: boolean | ItemCategoryArgs
    alternateItem?: boolean | LineItem$alternateItemArgs
    relatedItem?: boolean | LineItem$relatedItemArgs
    _count?: boolean | LineItemCountOutputTypeArgs
  }

  export type LineItemGetPayload<S extends boolean | null | undefined | LineItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LineItem :
    S extends undefined ? never :
    S extends { include: any } & (LineItemArgs | LineItemFindManyArgs)
    ? LineItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'xactimateCategory' ? ItemCategoryGetPayload<S['include'][P]> :
        P extends 'alternateItem' ? Array < AlternateItemGetPayload<S['include'][P]>>  :
        P extends 'relatedItem' ? Array < RelatedItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? LineItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LineItemArgs | LineItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'xactimateCategory' ? ItemCategoryGetPayload<S['select'][P]> :
        P extends 'alternateItem' ? Array < AlternateItemGetPayload<S['select'][P]>>  :
        P extends 'relatedItem' ? Array < RelatedItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? LineItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LineItem ? LineItem[P] : never
  } 
      : LineItem


  type LineItemCountArgs = 
    Omit<LineItemFindManyArgs, 'select' | 'include'> & {
      select?: LineItemCountAggregateInputType | true
    }

  export interface LineItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LineItem that matches the filter.
     * @param {LineItemFindUniqueArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LineItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LineItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LineItem'> extends True ? Prisma__LineItemClient<LineItemGetPayload<T>> : Prisma__LineItemClient<LineItemGetPayload<T> | null, null>

    /**
     * Find one LineItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LineItemFindUniqueOrThrowArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LineItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LineItemFindUniqueOrThrowArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Find the first LineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindFirstArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LineItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LineItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LineItem'> extends True ? Prisma__LineItemClient<LineItemGetPayload<T>> : Prisma__LineItemClient<LineItemGetPayload<T> | null, null>

    /**
     * Find the first LineItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindFirstOrThrowArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LineItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LineItemFindFirstOrThrowArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Find zero or more LineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItems
     * const lineItems = await prisma.lineItem.findMany()
     * 
     * // Get first 10 LineItems
     * const lineItems = await prisma.lineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineItemWithIdOnly = await prisma.lineItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LineItemFindManyArgs>(
      args?: SelectSubset<T, LineItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<LineItemGetPayload<T>>>

    /**
     * Create a LineItem.
     * @param {LineItemCreateArgs} args - Arguments to create a LineItem.
     * @example
     * // Create one LineItem
     * const LineItem = await prisma.lineItem.create({
     *   data: {
     *     // ... data to create a LineItem
     *   }
     * })
     * 
    **/
    create<T extends LineItemCreateArgs>(
      args: SelectSubset<T, LineItemCreateArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Create many LineItems.
     *     @param {LineItemCreateManyArgs} args - Arguments to create many LineItems.
     *     @example
     *     // Create many LineItems
     *     const lineItem = await prisma.lineItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LineItemCreateManyArgs>(
      args?: SelectSubset<T, LineItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LineItem.
     * @param {LineItemDeleteArgs} args - Arguments to delete one LineItem.
     * @example
     * // Delete one LineItem
     * const LineItem = await prisma.lineItem.delete({
     *   where: {
     *     // ... filter to delete one LineItem
     *   }
     * })
     * 
    **/
    delete<T extends LineItemDeleteArgs>(
      args: SelectSubset<T, LineItemDeleteArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Update one LineItem.
     * @param {LineItemUpdateArgs} args - Arguments to update one LineItem.
     * @example
     * // Update one LineItem
     * const lineItem = await prisma.lineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LineItemUpdateArgs>(
      args: SelectSubset<T, LineItemUpdateArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Delete zero or more LineItems.
     * @param {LineItemDeleteManyArgs} args - Arguments to filter LineItems to delete.
     * @example
     * // Delete a few LineItems
     * const { count } = await prisma.lineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LineItemDeleteManyArgs>(
      args?: SelectSubset<T, LineItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItems
     * const lineItem = await prisma.lineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LineItemUpdateManyArgs>(
      args: SelectSubset<T, LineItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LineItem.
     * @param {LineItemUpsertArgs} args - Arguments to update or create a LineItem.
     * @example
     * // Update or create a LineItem
     * const lineItem = await prisma.lineItem.upsert({
     *   create: {
     *     // ... data to create a LineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItem we want to update
     *   }
     * })
    **/
    upsert<T extends LineItemUpsertArgs>(
      args: SelectSubset<T, LineItemUpsertArgs>
    ): Prisma__LineItemClient<LineItemGetPayload<T>>

    /**
     * Count the number of LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemCountArgs} args - Arguments to filter LineItems to count.
     * @example
     * // Count the number of LineItems
     * const count = await prisma.lineItem.count({
     *   where: {
     *     // ... the filter for the LineItems we want to count
     *   }
     * })
    **/
    count<T extends LineItemCountArgs>(
      args?: Subset<T, LineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineItemAggregateArgs>(args: Subset<T, LineItemAggregateArgs>): Prisma.PrismaPromise<GetLineItemAggregateType<T>>

    /**
     * Group by LineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemGroupByArgs['orderBy'] }
        : { orderBy?: LineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LineItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    xactimateCategory<T extends ItemCategoryArgs= {}>(args?: Subset<T, ItemCategoryArgs>): Prisma__ItemCategoryClient<ItemCategoryGetPayload<T> | Null>;

    alternateItem<T extends LineItem$alternateItemArgs= {}>(args?: Subset<T, LineItem$alternateItemArgs>): Prisma.PrismaPromise<Array<AlternateItemGetPayload<T>>| Null>;

    relatedItem<T extends LineItem$relatedItemArgs= {}>(args?: Subset<T, LineItem$relatedItemArgs>): Prisma.PrismaPromise<Array<RelatedItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LineItem base type for findUnique actions
   */
  export type LineItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter, which LineItem to fetch.
     */
    where: LineItemWhereUniqueInput
  }

  /**
   * LineItem findUnique
   */
  export interface LineItemFindUniqueArgs extends LineItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LineItem findUniqueOrThrow
   */
  export type LineItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter, which LineItem to fetch.
     */
    where: LineItemWhereUniqueInput
  }


  /**
   * LineItem base type for findFirst actions
   */
  export type LineItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter, which LineItem to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: Enumerable<LineItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineItems.
     */
    distinct?: Enumerable<LineItemScalarFieldEnum>
  }

  /**
   * LineItem findFirst
   */
  export interface LineItemFindFirstArgs extends LineItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LineItem findFirstOrThrow
   */
  export type LineItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter, which LineItem to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: Enumerable<LineItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineItems.
     */
    distinct?: Enumerable<LineItemScalarFieldEnum>
  }


  /**
   * LineItem findMany
   */
  export type LineItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter, which LineItems to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: Enumerable<LineItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    distinct?: Enumerable<LineItemScalarFieldEnum>
  }


  /**
   * LineItem create
   */
  export type LineItemCreateArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * The data needed to create a LineItem.
     */
    data: XOR<LineItemCreateInput, LineItemUncheckedCreateInput>
  }


  /**
   * LineItem createMany
   */
  export type LineItemCreateManyArgs = {
    /**
     * The data used to create many LineItems.
     */
    data: Enumerable<LineItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LineItem update
   */
  export type LineItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * The data needed to update a LineItem.
     */
    data: XOR<LineItemUpdateInput, LineItemUncheckedUpdateInput>
    /**
     * Choose, which LineItem to update.
     */
    where: LineItemWhereUniqueInput
  }


  /**
   * LineItem updateMany
   */
  export type LineItemUpdateManyArgs = {
    /**
     * The data used to update LineItems.
     */
    data: XOR<LineItemUpdateManyMutationInput, LineItemUncheckedUpdateManyInput>
    /**
     * Filter which LineItems to update
     */
    where?: LineItemWhereInput
  }


  /**
   * LineItem upsert
   */
  export type LineItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * The filter to search for the LineItem to update in case it exists.
     */
    where: LineItemWhereUniqueInput
    /**
     * In case the LineItem found by the `where` argument doesn't exist, create a new LineItem with this data.
     */
    create: XOR<LineItemCreateInput, LineItemUncheckedCreateInput>
    /**
     * In case the LineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineItemUpdateInput, LineItemUncheckedUpdateInput>
  }


  /**
   * LineItem delete
   */
  export type LineItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
    /**
     * Filter which LineItem to delete.
     */
    where: LineItemWhereUniqueInput
  }


  /**
   * LineItem deleteMany
   */
  export type LineItemDeleteManyArgs = {
    /**
     * Filter which LineItems to delete
     */
    where?: LineItemWhereInput
  }


  /**
   * LineItem.alternateItem
   */
  export type LineItem$alternateItemArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    where?: AlternateItemWhereInput
    orderBy?: Enumerable<AlternateItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AlternateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlternateItemScalarFieldEnum>
  }


  /**
   * LineItem.relatedItem
   */
  export type LineItem$relatedItemArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    where?: RelatedItemWhereInput
    orderBy?: Enumerable<RelatedItemOrderByWithRelationAndSearchRelevanceInput>
    cursor?: RelatedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RelatedItemScalarFieldEnum>
  }


  /**
   * LineItem without action
   */
  export type LineItemArgs = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInclude | null
  }



  /**
   * Model RelatedItem
   */


  export type AggregateRelatedItem = {
    _count: RelatedItemCountAggregateOutputType | null
    _avg: RelatedItemAvgAggregateOutputType | null
    _sum: RelatedItemSumAggregateOutputType | null
    _min: RelatedItemMinAggregateOutputType | null
    _max: RelatedItemMaxAggregateOutputType | null
  }

  export type RelatedItemAvgAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type RelatedItemSumAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type RelatedItemMinAggregateOutputType = {
    id: number | null
    relationId: string | null
    lineItemId: number | null
  }

  export type RelatedItemMaxAggregateOutputType = {
    id: number | null
    relationId: string | null
    lineItemId: number | null
  }

  export type RelatedItemCountAggregateOutputType = {
    id: number
    relationId: number
    lineItemId: number
    _all: number
  }


  export type RelatedItemAvgAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type RelatedItemSumAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type RelatedItemMinAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
  }

  export type RelatedItemMaxAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
  }

  export type RelatedItemCountAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
    _all?: true
  }

  export type RelatedItemAggregateArgs = {
    /**
     * Filter which RelatedItem to aggregate.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: Enumerable<RelatedItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelatedItems
    **/
    _count?: true | RelatedItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelatedItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelatedItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatedItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatedItemMaxAggregateInputType
  }

  export type GetRelatedItemAggregateType<T extends RelatedItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatedItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatedItem[P]>
      : GetScalarType<T[P], AggregateRelatedItem[P]>
  }




  export type RelatedItemGroupByArgs = {
    where?: RelatedItemWhereInput
    orderBy?: Enumerable<RelatedItemOrderByWithAggregationInput>
    by: RelatedItemScalarFieldEnum[]
    having?: RelatedItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatedItemCountAggregateInputType | true
    _avg?: RelatedItemAvgAggregateInputType
    _sum?: RelatedItemSumAggregateInputType
    _min?: RelatedItemMinAggregateInputType
    _max?: RelatedItemMaxAggregateInputType
  }


  export type RelatedItemGroupByOutputType = {
    id: number
    relationId: string
    lineItemId: number
    _count: RelatedItemCountAggregateOutputType | null
    _avg: RelatedItemAvgAggregateOutputType | null
    _sum: RelatedItemSumAggregateOutputType | null
    _min: RelatedItemMinAggregateOutputType | null
    _max: RelatedItemMaxAggregateOutputType | null
  }

  type GetRelatedItemGroupByPayload<T extends RelatedItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RelatedItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatedItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatedItemGroupByOutputType[P]>
            : GetScalarType<T[P], RelatedItemGroupByOutputType[P]>
        }
      >
    >


  export type RelatedItemSelect = {
    id?: boolean
    relationId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemArgs
  }


  export type RelatedItemInclude = {
    lineItem?: boolean | LineItemArgs
  }

  export type RelatedItemGetPayload<S extends boolean | null | undefined | RelatedItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RelatedItem :
    S extends undefined ? never :
    S extends { include: any } & (RelatedItemArgs | RelatedItemFindManyArgs)
    ? RelatedItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'lineItem' ? LineItemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RelatedItemArgs | RelatedItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'lineItem' ? LineItemGetPayload<S['select'][P]> :  P extends keyof RelatedItem ? RelatedItem[P] : never
  } 
      : RelatedItem


  type RelatedItemCountArgs = 
    Omit<RelatedItemFindManyArgs, 'select' | 'include'> & {
      select?: RelatedItemCountAggregateInputType | true
    }

  export interface RelatedItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RelatedItem that matches the filter.
     * @param {RelatedItemFindUniqueArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RelatedItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RelatedItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RelatedItem'> extends True ? Prisma__RelatedItemClient<RelatedItemGetPayload<T>> : Prisma__RelatedItemClient<RelatedItemGetPayload<T> | null, null>

    /**
     * Find one RelatedItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RelatedItemFindUniqueOrThrowArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RelatedItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RelatedItemFindUniqueOrThrowArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Find the first RelatedItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindFirstArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RelatedItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RelatedItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RelatedItem'> extends True ? Prisma__RelatedItemClient<RelatedItemGetPayload<T>> : Prisma__RelatedItemClient<RelatedItemGetPayload<T> | null, null>

    /**
     * Find the first RelatedItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindFirstOrThrowArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RelatedItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RelatedItemFindFirstOrThrowArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Find zero or more RelatedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelatedItems
     * const relatedItems = await prisma.relatedItem.findMany()
     * 
     * // Get first 10 RelatedItems
     * const relatedItems = await prisma.relatedItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatedItemWithIdOnly = await prisma.relatedItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RelatedItemFindManyArgs>(
      args?: SelectSubset<T, RelatedItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<RelatedItemGetPayload<T>>>

    /**
     * Create a RelatedItem.
     * @param {RelatedItemCreateArgs} args - Arguments to create a RelatedItem.
     * @example
     * // Create one RelatedItem
     * const RelatedItem = await prisma.relatedItem.create({
     *   data: {
     *     // ... data to create a RelatedItem
     *   }
     * })
     * 
    **/
    create<T extends RelatedItemCreateArgs>(
      args: SelectSubset<T, RelatedItemCreateArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Create many RelatedItems.
     *     @param {RelatedItemCreateManyArgs} args - Arguments to create many RelatedItems.
     *     @example
     *     // Create many RelatedItems
     *     const relatedItem = await prisma.relatedItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RelatedItemCreateManyArgs>(
      args?: SelectSubset<T, RelatedItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RelatedItem.
     * @param {RelatedItemDeleteArgs} args - Arguments to delete one RelatedItem.
     * @example
     * // Delete one RelatedItem
     * const RelatedItem = await prisma.relatedItem.delete({
     *   where: {
     *     // ... filter to delete one RelatedItem
     *   }
     * })
     * 
    **/
    delete<T extends RelatedItemDeleteArgs>(
      args: SelectSubset<T, RelatedItemDeleteArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Update one RelatedItem.
     * @param {RelatedItemUpdateArgs} args - Arguments to update one RelatedItem.
     * @example
     * // Update one RelatedItem
     * const relatedItem = await prisma.relatedItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RelatedItemUpdateArgs>(
      args: SelectSubset<T, RelatedItemUpdateArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Delete zero or more RelatedItems.
     * @param {RelatedItemDeleteManyArgs} args - Arguments to filter RelatedItems to delete.
     * @example
     * // Delete a few RelatedItems
     * const { count } = await prisma.relatedItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RelatedItemDeleteManyArgs>(
      args?: SelectSubset<T, RelatedItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelatedItems
     * const relatedItem = await prisma.relatedItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RelatedItemUpdateManyArgs>(
      args: SelectSubset<T, RelatedItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelatedItem.
     * @param {RelatedItemUpsertArgs} args - Arguments to update or create a RelatedItem.
     * @example
     * // Update or create a RelatedItem
     * const relatedItem = await prisma.relatedItem.upsert({
     *   create: {
     *     // ... data to create a RelatedItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelatedItem we want to update
     *   }
     * })
    **/
    upsert<T extends RelatedItemUpsertArgs>(
      args: SelectSubset<T, RelatedItemUpsertArgs>
    ): Prisma__RelatedItemClient<RelatedItemGetPayload<T>>

    /**
     * Count the number of RelatedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemCountArgs} args - Arguments to filter RelatedItems to count.
     * @example
     * // Count the number of RelatedItems
     * const count = await prisma.relatedItem.count({
     *   where: {
     *     // ... the filter for the RelatedItems we want to count
     *   }
     * })
    **/
    count<T extends RelatedItemCountArgs>(
      args?: Subset<T, RelatedItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatedItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelatedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatedItemAggregateArgs>(args: Subset<T, RelatedItemAggregateArgs>): Prisma.PrismaPromise<GetRelatedItemAggregateType<T>>

    /**
     * Group by RelatedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatedItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatedItemGroupByArgs['orderBy'] }
        : { orderBy?: RelatedItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatedItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatedItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RelatedItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RelatedItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lineItem<T extends LineItemArgs= {}>(args?: Subset<T, LineItemArgs>): Prisma__LineItemClient<LineItemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RelatedItem base type for findUnique actions
   */
  export type RelatedItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where: RelatedItemWhereUniqueInput
  }

  /**
   * RelatedItem findUnique
   */
  export interface RelatedItemFindUniqueArgs extends RelatedItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RelatedItem findUniqueOrThrow
   */
  export type RelatedItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where: RelatedItemWhereUniqueInput
  }


  /**
   * RelatedItem base type for findFirst actions
   */
  export type RelatedItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: Enumerable<RelatedItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedItems.
     */
    distinct?: Enumerable<RelatedItemScalarFieldEnum>
  }

  /**
   * RelatedItem findFirst
   */
  export interface RelatedItemFindFirstArgs extends RelatedItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RelatedItem findFirstOrThrow
   */
  export type RelatedItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: Enumerable<RelatedItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedItems.
     */
    distinct?: Enumerable<RelatedItemScalarFieldEnum>
  }


  /**
   * RelatedItem findMany
   */
  export type RelatedItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter, which RelatedItems to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: Enumerable<RelatedItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    distinct?: Enumerable<RelatedItemScalarFieldEnum>
  }


  /**
   * RelatedItem create
   */
  export type RelatedItemCreateArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * The data needed to create a RelatedItem.
     */
    data: XOR<RelatedItemCreateInput, RelatedItemUncheckedCreateInput>
  }


  /**
   * RelatedItem createMany
   */
  export type RelatedItemCreateManyArgs = {
    /**
     * The data used to create many RelatedItems.
     */
    data: Enumerable<RelatedItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RelatedItem update
   */
  export type RelatedItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * The data needed to update a RelatedItem.
     */
    data: XOR<RelatedItemUpdateInput, RelatedItemUncheckedUpdateInput>
    /**
     * Choose, which RelatedItem to update.
     */
    where: RelatedItemWhereUniqueInput
  }


  /**
   * RelatedItem updateMany
   */
  export type RelatedItemUpdateManyArgs = {
    /**
     * The data used to update RelatedItems.
     */
    data: XOR<RelatedItemUpdateManyMutationInput, RelatedItemUncheckedUpdateManyInput>
    /**
     * Filter which RelatedItems to update
     */
    where?: RelatedItemWhereInput
  }


  /**
   * RelatedItem upsert
   */
  export type RelatedItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * The filter to search for the RelatedItem to update in case it exists.
     */
    where: RelatedItemWhereUniqueInput
    /**
     * In case the RelatedItem found by the `where` argument doesn't exist, create a new RelatedItem with this data.
     */
    create: XOR<RelatedItemCreateInput, RelatedItemUncheckedCreateInput>
    /**
     * In case the RelatedItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatedItemUpdateInput, RelatedItemUncheckedUpdateInput>
  }


  /**
   * RelatedItem delete
   */
  export type RelatedItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
    /**
     * Filter which RelatedItem to delete.
     */
    where: RelatedItemWhereUniqueInput
  }


  /**
   * RelatedItem deleteMany
   */
  export type RelatedItemDeleteManyArgs = {
    /**
     * Filter which RelatedItems to delete
     */
    where?: RelatedItemWhereInput
  }


  /**
   * RelatedItem without action
   */
  export type RelatedItemArgs = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RelatedItemInclude | null
  }



  /**
   * Model AlternateItem
   */


  export type AggregateAlternateItem = {
    _count: AlternateItemCountAggregateOutputType | null
    _avg: AlternateItemAvgAggregateOutputType | null
    _sum: AlternateItemSumAggregateOutputType | null
    _min: AlternateItemMinAggregateOutputType | null
    _max: AlternateItemMaxAggregateOutputType | null
  }

  export type AlternateItemAvgAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type AlternateItemSumAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type AlternateItemMinAggregateOutputType = {
    id: number | null
    alternateId: string | null
    lineItemId: number | null
  }

  export type AlternateItemMaxAggregateOutputType = {
    id: number | null
    alternateId: string | null
    lineItemId: number | null
  }

  export type AlternateItemCountAggregateOutputType = {
    id: number
    alternateId: number
    lineItemId: number
    _all: number
  }


  export type AlternateItemAvgAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type AlternateItemSumAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type AlternateItemMinAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
  }

  export type AlternateItemMaxAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
  }

  export type AlternateItemCountAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
    _all?: true
  }

  export type AlternateItemAggregateArgs = {
    /**
     * Filter which AlternateItem to aggregate.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: Enumerable<AlternateItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlternateItems
    **/
    _count?: true | AlternateItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlternateItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlternateItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlternateItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlternateItemMaxAggregateInputType
  }

  export type GetAlternateItemAggregateType<T extends AlternateItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAlternateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlternateItem[P]>
      : GetScalarType<T[P], AggregateAlternateItem[P]>
  }




  export type AlternateItemGroupByArgs = {
    where?: AlternateItemWhereInput
    orderBy?: Enumerable<AlternateItemOrderByWithAggregationInput>
    by: AlternateItemScalarFieldEnum[]
    having?: AlternateItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlternateItemCountAggregateInputType | true
    _avg?: AlternateItemAvgAggregateInputType
    _sum?: AlternateItemSumAggregateInputType
    _min?: AlternateItemMinAggregateInputType
    _max?: AlternateItemMaxAggregateInputType
  }


  export type AlternateItemGroupByOutputType = {
    id: number
    alternateId: string
    lineItemId: number
    _count: AlternateItemCountAggregateOutputType | null
    _avg: AlternateItemAvgAggregateOutputType | null
    _sum: AlternateItemSumAggregateOutputType | null
    _min: AlternateItemMinAggregateOutputType | null
    _max: AlternateItemMaxAggregateOutputType | null
  }

  type GetAlternateItemGroupByPayload<T extends AlternateItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlternateItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlternateItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlternateItemGroupByOutputType[P]>
            : GetScalarType<T[P], AlternateItemGroupByOutputType[P]>
        }
      >
    >


  export type AlternateItemSelect = {
    id?: boolean
    alternateId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemArgs
  }


  export type AlternateItemInclude = {
    lineItem?: boolean | LineItemArgs
  }

  export type AlternateItemGetPayload<S extends boolean | null | undefined | AlternateItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AlternateItem :
    S extends undefined ? never :
    S extends { include: any } & (AlternateItemArgs | AlternateItemFindManyArgs)
    ? AlternateItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'lineItem' ? LineItemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AlternateItemArgs | AlternateItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'lineItem' ? LineItemGetPayload<S['select'][P]> :  P extends keyof AlternateItem ? AlternateItem[P] : never
  } 
      : AlternateItem


  type AlternateItemCountArgs = 
    Omit<AlternateItemFindManyArgs, 'select' | 'include'> & {
      select?: AlternateItemCountAggregateInputType | true
    }

  export interface AlternateItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AlternateItem that matches the filter.
     * @param {AlternateItemFindUniqueArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlternateItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlternateItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AlternateItem'> extends True ? Prisma__AlternateItemClient<AlternateItemGetPayload<T>> : Prisma__AlternateItemClient<AlternateItemGetPayload<T> | null, null>

    /**
     * Find one AlternateItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlternateItemFindUniqueOrThrowArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlternateItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AlternateItemFindUniqueOrThrowArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Find the first AlternateItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindFirstArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlternateItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlternateItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AlternateItem'> extends True ? Prisma__AlternateItemClient<AlternateItemGetPayload<T>> : Prisma__AlternateItemClient<AlternateItemGetPayload<T> | null, null>

    /**
     * Find the first AlternateItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindFirstOrThrowArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlternateItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AlternateItemFindFirstOrThrowArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Find zero or more AlternateItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlternateItems
     * const alternateItems = await prisma.alternateItem.findMany()
     * 
     * // Get first 10 AlternateItems
     * const alternateItems = await prisma.alternateItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alternateItemWithIdOnly = await prisma.alternateItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlternateItemFindManyArgs>(
      args?: SelectSubset<T, AlternateItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<AlternateItemGetPayload<T>>>

    /**
     * Create a AlternateItem.
     * @param {AlternateItemCreateArgs} args - Arguments to create a AlternateItem.
     * @example
     * // Create one AlternateItem
     * const AlternateItem = await prisma.alternateItem.create({
     *   data: {
     *     // ... data to create a AlternateItem
     *   }
     * })
     * 
    **/
    create<T extends AlternateItemCreateArgs>(
      args: SelectSubset<T, AlternateItemCreateArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Create many AlternateItems.
     *     @param {AlternateItemCreateManyArgs} args - Arguments to create many AlternateItems.
     *     @example
     *     // Create many AlternateItems
     *     const alternateItem = await prisma.alternateItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlternateItemCreateManyArgs>(
      args?: SelectSubset<T, AlternateItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AlternateItem.
     * @param {AlternateItemDeleteArgs} args - Arguments to delete one AlternateItem.
     * @example
     * // Delete one AlternateItem
     * const AlternateItem = await prisma.alternateItem.delete({
     *   where: {
     *     // ... filter to delete one AlternateItem
     *   }
     * })
     * 
    **/
    delete<T extends AlternateItemDeleteArgs>(
      args: SelectSubset<T, AlternateItemDeleteArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Update one AlternateItem.
     * @param {AlternateItemUpdateArgs} args - Arguments to update one AlternateItem.
     * @example
     * // Update one AlternateItem
     * const alternateItem = await prisma.alternateItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlternateItemUpdateArgs>(
      args: SelectSubset<T, AlternateItemUpdateArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Delete zero or more AlternateItems.
     * @param {AlternateItemDeleteManyArgs} args - Arguments to filter AlternateItems to delete.
     * @example
     * // Delete a few AlternateItems
     * const { count } = await prisma.alternateItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlternateItemDeleteManyArgs>(
      args?: SelectSubset<T, AlternateItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlternateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlternateItems
     * const alternateItem = await prisma.alternateItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlternateItemUpdateManyArgs>(
      args: SelectSubset<T, AlternateItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlternateItem.
     * @param {AlternateItemUpsertArgs} args - Arguments to update or create a AlternateItem.
     * @example
     * // Update or create a AlternateItem
     * const alternateItem = await prisma.alternateItem.upsert({
     *   create: {
     *     // ... data to create a AlternateItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlternateItem we want to update
     *   }
     * })
    **/
    upsert<T extends AlternateItemUpsertArgs>(
      args: SelectSubset<T, AlternateItemUpsertArgs>
    ): Prisma__AlternateItemClient<AlternateItemGetPayload<T>>

    /**
     * Count the number of AlternateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemCountArgs} args - Arguments to filter AlternateItems to count.
     * @example
     * // Count the number of AlternateItems
     * const count = await prisma.alternateItem.count({
     *   where: {
     *     // ... the filter for the AlternateItems we want to count
     *   }
     * })
    **/
    count<T extends AlternateItemCountArgs>(
      args?: Subset<T, AlternateItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlternateItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlternateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlternateItemAggregateArgs>(args: Subset<T, AlternateItemAggregateArgs>): Prisma.PrismaPromise<GetAlternateItemAggregateType<T>>

    /**
     * Group by AlternateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlternateItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlternateItemGroupByArgs['orderBy'] }
        : { orderBy?: AlternateItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlternateItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlternateItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AlternateItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlternateItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lineItem<T extends LineItemArgs= {}>(args?: Subset<T, LineItemArgs>): Prisma__LineItemClient<LineItemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AlternateItem base type for findUnique actions
   */
  export type AlternateItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where: AlternateItemWhereUniqueInput
  }

  /**
   * AlternateItem findUnique
   */
  export interface AlternateItemFindUniqueArgs extends AlternateItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AlternateItem findUniqueOrThrow
   */
  export type AlternateItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where: AlternateItemWhereUniqueInput
  }


  /**
   * AlternateItem base type for findFirst actions
   */
  export type AlternateItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: Enumerable<AlternateItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternateItems.
     */
    distinct?: Enumerable<AlternateItemScalarFieldEnum>
  }

  /**
   * AlternateItem findFirst
   */
  export interface AlternateItemFindFirstArgs extends AlternateItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AlternateItem findFirstOrThrow
   */
  export type AlternateItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: Enumerable<AlternateItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternateItems.
     */
    distinct?: Enumerable<AlternateItemScalarFieldEnum>
  }


  /**
   * AlternateItem findMany
   */
  export type AlternateItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter, which AlternateItems to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: Enumerable<AlternateItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    distinct?: Enumerable<AlternateItemScalarFieldEnum>
  }


  /**
   * AlternateItem create
   */
  export type AlternateItemCreateArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * The data needed to create a AlternateItem.
     */
    data: XOR<AlternateItemCreateInput, AlternateItemUncheckedCreateInput>
  }


  /**
   * AlternateItem createMany
   */
  export type AlternateItemCreateManyArgs = {
    /**
     * The data used to create many AlternateItems.
     */
    data: Enumerable<AlternateItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AlternateItem update
   */
  export type AlternateItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * The data needed to update a AlternateItem.
     */
    data: XOR<AlternateItemUpdateInput, AlternateItemUncheckedUpdateInput>
    /**
     * Choose, which AlternateItem to update.
     */
    where: AlternateItemWhereUniqueInput
  }


  /**
   * AlternateItem updateMany
   */
  export type AlternateItemUpdateManyArgs = {
    /**
     * The data used to update AlternateItems.
     */
    data: XOR<AlternateItemUpdateManyMutationInput, AlternateItemUncheckedUpdateManyInput>
    /**
     * Filter which AlternateItems to update
     */
    where?: AlternateItemWhereInput
  }


  /**
   * AlternateItem upsert
   */
  export type AlternateItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * The filter to search for the AlternateItem to update in case it exists.
     */
    where: AlternateItemWhereUniqueInput
    /**
     * In case the AlternateItem found by the `where` argument doesn't exist, create a new AlternateItem with this data.
     */
    create: XOR<AlternateItemCreateInput, AlternateItemUncheckedCreateInput>
    /**
     * In case the AlternateItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlternateItemUpdateInput, AlternateItemUncheckedUpdateInput>
  }


  /**
   * AlternateItem delete
   */
  export type AlternateItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
    /**
     * Filter which AlternateItem to delete.
     */
    where: AlternateItemWhereUniqueInput
  }


  /**
   * AlternateItem deleteMany
   */
  export type AlternateItemDeleteManyArgs = {
    /**
     * Filter which AlternateItems to delete
     */
    where?: AlternateItemWhereInput
  }


  /**
   * AlternateItem without action
   */
  export type AlternateItemArgs = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlternateItemInclude | null
  }



  /**
   * Model PlanEntitlements
   */


  export type AggregatePlanEntitlements = {
    _count: PlanEntitlementsCountAggregateOutputType | null
    _avg: PlanEntitlementsAvgAggregateOutputType | null
    _sum: PlanEntitlementsSumAggregateOutputType | null
    _min: PlanEntitlementsMinAggregateOutputType | null
    _max: PlanEntitlementsMaxAggregateOutputType | null
  }

  export type PlanEntitlementsAvgAggregateOutputType = {
    id: number | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    price: number | null
  }

  export type PlanEntitlementsSumAggregateOutputType = {
    id: number | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    price: number | null
  }

  export type PlanEntitlementsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    extPlanId: string | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    description: string | null
    period: string | null
    price: number | null
  }

  export type PlanEntitlementsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    extPlanId: string | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    description: string | null
    period: string | null
    price: number | null
  }

  export type PlanEntitlementsCountAggregateOutputType = {
    id: number
    createdAt: number
    extPlanId: number
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: number
    period: number
    price: number
    _all: number
  }


  export type PlanEntitlementsAvgAggregateInputType = {
    id?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    price?: true
  }

  export type PlanEntitlementsSumAggregateInputType = {
    id?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    price?: true
  }

  export type PlanEntitlementsMinAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
  }

  export type PlanEntitlementsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
  }

  export type PlanEntitlementsCountAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
    _all?: true
  }

  export type PlanEntitlementsAggregateArgs = {
    /**
     * Filter which PlanEntitlements to aggregate.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: Enumerable<PlanEntitlementsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanEntitlements
    **/
    _count?: true | PlanEntitlementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanEntitlementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanEntitlementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanEntitlementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanEntitlementsMaxAggregateInputType
  }

  export type GetPlanEntitlementsAggregateType<T extends PlanEntitlementsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanEntitlements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanEntitlements[P]>
      : GetScalarType<T[P], AggregatePlanEntitlements[P]>
  }




  export type PlanEntitlementsGroupByArgs = {
    where?: PlanEntitlementsWhereInput
    orderBy?: Enumerable<PlanEntitlementsOrderByWithAggregationInput>
    by: PlanEntitlementsScalarFieldEnum[]
    having?: PlanEntitlementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanEntitlementsCountAggregateInputType | true
    _avg?: PlanEntitlementsAvgAggregateInputType
    _sum?: PlanEntitlementsSumAggregateInputType
    _min?: PlanEntitlementsMinAggregateInputType
    _max?: PlanEntitlementsMaxAggregateInputType
  }


  export type PlanEntitlementsGroupByOutputType = {
    id: number
    createdAt: Date
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
    _count: PlanEntitlementsCountAggregateOutputType | null
    _avg: PlanEntitlementsAvgAggregateOutputType | null
    _sum: PlanEntitlementsSumAggregateOutputType | null
    _min: PlanEntitlementsMinAggregateOutputType | null
    _max: PlanEntitlementsMaxAggregateOutputType | null
  }

  type GetPlanEntitlementsGroupByPayload<T extends PlanEntitlementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PlanEntitlementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanEntitlementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanEntitlementsGroupByOutputType[P]>
            : GetScalarType<T[P], PlanEntitlementsGroupByOutputType[P]>
        }
      >
    >


  export type PlanEntitlementsSelect = {
    id?: boolean
    createdAt?: boolean
    extPlanId?: boolean
    maxImages?: boolean
    maxProjects?: boolean
    maxSeats?: boolean
    description?: boolean
    period?: boolean
    price?: boolean
  }


  export type PlanEntitlementsGetPayload<S extends boolean | null | undefined | PlanEntitlementsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PlanEntitlements :
    S extends undefined ? never :
    S extends { include: any } & (PlanEntitlementsArgs | PlanEntitlementsFindManyArgs)
    ? PlanEntitlements 
    : S extends { select: any } & (PlanEntitlementsArgs | PlanEntitlementsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PlanEntitlements ? PlanEntitlements[P] : never
  } 
      : PlanEntitlements


  type PlanEntitlementsCountArgs = 
    Omit<PlanEntitlementsFindManyArgs, 'select' | 'include'> & {
      select?: PlanEntitlementsCountAggregateInputType | true
    }

  export interface PlanEntitlementsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PlanEntitlements that matches the filter.
     * @param {PlanEntitlementsFindUniqueArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanEntitlementsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlanEntitlementsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlanEntitlements'> extends True ? Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>> : Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T> | null, null>

    /**
     * Find one PlanEntitlements that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlanEntitlementsFindUniqueOrThrowArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanEntitlementsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PlanEntitlementsFindUniqueOrThrowArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Find the first PlanEntitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindFirstArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanEntitlementsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlanEntitlementsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlanEntitlements'> extends True ? Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>> : Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T> | null, null>

    /**
     * Find the first PlanEntitlements that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindFirstOrThrowArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanEntitlementsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlanEntitlementsFindFirstOrThrowArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Find zero or more PlanEntitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findMany()
     * 
     * // Get first 10 PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planEntitlementsWithIdOnly = await prisma.planEntitlements.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlanEntitlementsFindManyArgs>(
      args?: SelectSubset<T, PlanEntitlementsFindManyArgs>
    ): Prisma.PrismaPromise<Array<PlanEntitlementsGetPayload<T>>>

    /**
     * Create a PlanEntitlements.
     * @param {PlanEntitlementsCreateArgs} args - Arguments to create a PlanEntitlements.
     * @example
     * // Create one PlanEntitlements
     * const PlanEntitlements = await prisma.planEntitlements.create({
     *   data: {
     *     // ... data to create a PlanEntitlements
     *   }
     * })
     * 
    **/
    create<T extends PlanEntitlementsCreateArgs>(
      args: SelectSubset<T, PlanEntitlementsCreateArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Create many PlanEntitlements.
     *     @param {PlanEntitlementsCreateManyArgs} args - Arguments to create many PlanEntitlements.
     *     @example
     *     // Create many PlanEntitlements
     *     const planEntitlements = await prisma.planEntitlements.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlanEntitlementsCreateManyArgs>(
      args?: SelectSubset<T, PlanEntitlementsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanEntitlements.
     * @param {PlanEntitlementsDeleteArgs} args - Arguments to delete one PlanEntitlements.
     * @example
     * // Delete one PlanEntitlements
     * const PlanEntitlements = await prisma.planEntitlements.delete({
     *   where: {
     *     // ... filter to delete one PlanEntitlements
     *   }
     * })
     * 
    **/
    delete<T extends PlanEntitlementsDeleteArgs>(
      args: SelectSubset<T, PlanEntitlementsDeleteArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Update one PlanEntitlements.
     * @param {PlanEntitlementsUpdateArgs} args - Arguments to update one PlanEntitlements.
     * @example
     * // Update one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanEntitlementsUpdateArgs>(
      args: SelectSubset<T, PlanEntitlementsUpdateArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Delete zero or more PlanEntitlements.
     * @param {PlanEntitlementsDeleteManyArgs} args - Arguments to filter PlanEntitlements to delete.
     * @example
     * // Delete a few PlanEntitlements
     * const { count } = await prisma.planEntitlements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanEntitlementsDeleteManyArgs>(
      args?: SelectSubset<T, PlanEntitlementsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanEntitlementsUpdateManyArgs>(
      args: SelectSubset<T, PlanEntitlementsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanEntitlements.
     * @param {PlanEntitlementsUpsertArgs} args - Arguments to update or create a PlanEntitlements.
     * @example
     * // Update or create a PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.upsert({
     *   create: {
     *     // ... data to create a PlanEntitlements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanEntitlements we want to update
     *   }
     * })
    **/
    upsert<T extends PlanEntitlementsUpsertArgs>(
      args: SelectSubset<T, PlanEntitlementsUpsertArgs>
    ): Prisma__PlanEntitlementsClient<PlanEntitlementsGetPayload<T>>

    /**
     * Count the number of PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsCountArgs} args - Arguments to filter PlanEntitlements to count.
     * @example
     * // Count the number of PlanEntitlements
     * const count = await prisma.planEntitlements.count({
     *   where: {
     *     // ... the filter for the PlanEntitlements we want to count
     *   }
     * })
    **/
    count<T extends PlanEntitlementsCountArgs>(
      args?: Subset<T, PlanEntitlementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanEntitlementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanEntitlementsAggregateArgs>(args: Subset<T, PlanEntitlementsAggregateArgs>): Prisma.PrismaPromise<GetPlanEntitlementsAggregateType<T>>

    /**
     * Group by PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanEntitlementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanEntitlementsGroupByArgs['orderBy'] }
        : { orderBy?: PlanEntitlementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanEntitlementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanEntitlementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanEntitlements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlanEntitlementsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PlanEntitlements base type for findUnique actions
   */
  export type PlanEntitlementsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where: PlanEntitlementsWhereUniqueInput
  }

  /**
   * PlanEntitlements findUnique
   */
  export interface PlanEntitlementsFindUniqueArgs extends PlanEntitlementsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PlanEntitlements findUniqueOrThrow
   */
  export type PlanEntitlementsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where: PlanEntitlementsWhereUniqueInput
  }


  /**
   * PlanEntitlements base type for findFirst actions
   */
  export type PlanEntitlementsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: Enumerable<PlanEntitlementsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEntitlements.
     */
    distinct?: Enumerable<PlanEntitlementsScalarFieldEnum>
  }

  /**
   * PlanEntitlements findFirst
   */
  export interface PlanEntitlementsFindFirstArgs extends PlanEntitlementsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PlanEntitlements findFirstOrThrow
   */
  export type PlanEntitlementsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: Enumerable<PlanEntitlementsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEntitlements.
     */
    distinct?: Enumerable<PlanEntitlementsScalarFieldEnum>
  }


  /**
   * PlanEntitlements findMany
   */
  export type PlanEntitlementsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: Enumerable<PlanEntitlementsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    distinct?: Enumerable<PlanEntitlementsScalarFieldEnum>
  }


  /**
   * PlanEntitlements create
   */
  export type PlanEntitlementsCreateArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * The data needed to create a PlanEntitlements.
     */
    data: XOR<PlanEntitlementsCreateInput, PlanEntitlementsUncheckedCreateInput>
  }


  /**
   * PlanEntitlements createMany
   */
  export type PlanEntitlementsCreateManyArgs = {
    /**
     * The data used to create many PlanEntitlements.
     */
    data: Enumerable<PlanEntitlementsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlanEntitlements update
   */
  export type PlanEntitlementsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * The data needed to update a PlanEntitlements.
     */
    data: XOR<PlanEntitlementsUpdateInput, PlanEntitlementsUncheckedUpdateInput>
    /**
     * Choose, which PlanEntitlements to update.
     */
    where: PlanEntitlementsWhereUniqueInput
  }


  /**
   * PlanEntitlements updateMany
   */
  export type PlanEntitlementsUpdateManyArgs = {
    /**
     * The data used to update PlanEntitlements.
     */
    data: XOR<PlanEntitlementsUpdateManyMutationInput, PlanEntitlementsUncheckedUpdateManyInput>
    /**
     * Filter which PlanEntitlements to update
     */
    where?: PlanEntitlementsWhereInput
  }


  /**
   * PlanEntitlements upsert
   */
  export type PlanEntitlementsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * The filter to search for the PlanEntitlements to update in case it exists.
     */
    where: PlanEntitlementsWhereUniqueInput
    /**
     * In case the PlanEntitlements found by the `where` argument doesn't exist, create a new PlanEntitlements with this data.
     */
    create: XOR<PlanEntitlementsCreateInput, PlanEntitlementsUncheckedCreateInput>
    /**
     * In case the PlanEntitlements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanEntitlementsUpdateInput, PlanEntitlementsUncheckedUpdateInput>
  }


  /**
   * PlanEntitlements delete
   */
  export type PlanEntitlementsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
    /**
     * Filter which PlanEntitlements to delete.
     */
    where: PlanEntitlementsWhereUniqueInput
  }


  /**
   * PlanEntitlements deleteMany
   */
  export type PlanEntitlementsDeleteManyArgs = {
    /**
     * Filter which PlanEntitlements to delete
     */
    where?: PlanEntitlementsWhereInput
  }


  /**
   * PlanEntitlements without action
   */
  export type PlanEntitlementsArgs = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect | null
  }



  /**
   * Model Customers
   */


  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    customerId: string | null
    organizationId: number | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    customerId: string | null
    organizationId: number | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    customerId: number
    billingAddress: number
    paymentMethod: number
    organizationId: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    customerId?: true
    organizationId?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    customerId?: true
    organizationId?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    customerId?: true
    billingAddress?: true
    paymentMethod?: true
    organizationId?: true
    _all?: true
  }

  export type CustomersAggregateArgs = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs = {
    where?: CustomersWhereInput
    orderBy?: Enumerable<CustomersOrderByWithAggregationInput>
    by: CustomersScalarFieldEnum[]
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }


  export type CustomersGroupByOutputType = {
    id: number
    customerId: string
    billingAddress: JsonValue | null
    paymentMethod: JsonValue | null
    organizationId: number
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect = {
    id?: boolean
    customerId?: boolean
    billingAddress?: boolean
    paymentMethod?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationArgs
  }


  export type CustomersInclude = {
    organization?: boolean | OrganizationArgs
  }

  export type CustomersGetPayload<S extends boolean | null | undefined | CustomersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Customers :
    S extends undefined ? never :
    S extends { include: any } & (CustomersArgs | CustomersFindManyArgs)
    ? Customers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomersArgs | CustomersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :  P extends keyof Customers ? Customers[P] : never
  } 
      : Customers


  type CustomersCountArgs = 
    Omit<CustomersFindManyArgs, 'select' | 'include'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customers'> extends True ? Prisma__CustomersClient<CustomersGetPayload<T>> : Prisma__CustomersClient<CustomersGetPayload<T> | null, null>

    /**
     * Find one Customers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindUniqueOrThrowArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customers'> extends True ? Prisma__CustomersClient<CustomersGetPayload<T>> : Prisma__CustomersClient<CustomersGetPayload<T> | null, null>

    /**
     * Find the first Customers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindFirstOrThrowArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomersFindManyArgs>(
      args?: SelectSubset<T, CustomersFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomersGetPayload<T>>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends CustomersCreateArgs>(
      args: SelectSubset<T, CustomersCreateArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Create many Customers.
     *     @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customers = await prisma.customers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomersCreateManyArgs>(
      args?: SelectSubset<T, CustomersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends CustomersDeleteArgs>(
      args: SelectSubset<T, CustomersDeleteArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomersUpdateArgs>(
      args: SelectSubset<T, CustomersUpdateArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomersDeleteManyArgs>(
      args?: SelectSubset<T, CustomersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomersUpdateManyArgs>(
      args: SelectSubset<T, CustomersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends CustomersUpsertArgs>(
      args: SelectSubset<T, CustomersUpsertArgs>
    ): Prisma__CustomersClient<CustomersGetPayload<T>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customers base type for findUnique actions
   */
  export type CustomersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUnique
   */
  export interface CustomersFindUniqueArgs extends CustomersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers base type for findFirst actions
   */
  export type CustomersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }

  /**
   * Customers findFirst
   */
  export interface CustomersFindFirstArgs extends CustomersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers create
   */
  export type CustomersCreateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }


  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs = {
    /**
     * The data used to create many Customers.
     */
    data: Enumerable<CustomersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customers update
   */
  export type CustomersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
  }


  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }


  /**
   * Customers delete
   */
  export type CustomersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
  }


  /**
   * Customers without action
   */
  export type CustomersArgs = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude | null
  }



  /**
   * Model Products
   */


  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    active: number
    name: number
    description: number
    image: number
    metadata: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
    metadata?: true
    _all?: true
  }

  export type ProductsAggregateArgs = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs = {
    where?: ProductsWhereInput
    orderBy?: Enumerable<ProductsOrderByWithAggregationInput>
    by: ProductsScalarFieldEnum[]
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }


  export type ProductsGroupByOutputType = {
    id: string
    active: boolean
    name: string
    description: string | null
    image: string | null
    metadata: JsonValue | null
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect = {
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
    prices?: boolean | Products$pricesArgs
    _count?: boolean | ProductsCountOutputTypeArgs
  }


  export type ProductsInclude = {
    prices?: boolean | Products$pricesArgs
    _count?: boolean | ProductsCountOutputTypeArgs
  }

  export type ProductsGetPayload<S extends boolean | null | undefined | ProductsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Products :
    S extends undefined ? never :
    S extends { include: any } & (ProductsArgs | ProductsFindManyArgs)
    ? Products  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'prices' ? Array < PricesGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductsArgs | ProductsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'prices' ? Array < PricesGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Products ? Products[P] : never
  } 
      : Products


  type ProductsCountArgs = 
    Omit<ProductsFindManyArgs, 'select' | 'include'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Products'> extends True ? Prisma__ProductsClient<ProductsGetPayload<T>> : Prisma__ProductsClient<ProductsGetPayload<T> | null, null>

    /**
     * Find one Products that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductsFindUniqueOrThrowArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Products'> extends True ? Prisma__ProductsClient<ProductsGetPayload<T>> : Prisma__ProductsClient<ProductsGetPayload<T> | null, null>

    /**
     * Find the first Products that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductsFindFirstOrThrowArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsFindManyArgs>(
      args?: SelectSubset<T, ProductsFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductsGetPayload<T>>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
    **/
    create<T extends ProductsCreateArgs>(
      args: SelectSubset<T, ProductsCreateArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const products = await prisma.products.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductsCreateManyArgs>(
      args?: SelectSubset<T, ProductsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
    **/
    delete<T extends ProductsDeleteArgs>(
      args: SelectSubset<T, ProductsDeleteArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsUpdateArgs>(
      args: SelectSubset<T, ProductsUpdateArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsDeleteManyArgs>(
      args?: SelectSubset<T, ProductsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsUpdateManyArgs>(
      args: SelectSubset<T, ProductsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsUpsertArgs>(
      args: SelectSubset<T, ProductsUpsertArgs>
    ): Prisma__ProductsClient<ProductsGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    prices<T extends Products$pricesArgs= {}>(args?: Subset<T, Products$pricesArgs>): Prisma.PrismaPromise<Array<PricesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Products base type for findUnique actions
   */
  export type ProductsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUnique
   */
  export interface ProductsFindUniqueArgs extends ProductsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }


  /**
   * Products base type for findFirst actions
   */
  export type ProductsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }

  /**
   * Products findFirst
   */
  export interface ProductsFindFirstArgs extends ProductsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * Products findMany
   */
  export type ProductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * Products create
   */
  export type ProductsCreateArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }


  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Products update
   */
  export type ProductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }


  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
  }


  /**
   * Products upsert
   */
  export type ProductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }


  /**
   * Products delete
   */
  export type ProductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }


  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
  }


  /**
   * Products.prices
   */
  export type Products$pricesArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    where?: PricesWhereInput
    orderBy?: Enumerable<PricesOrderByWithRelationAndSearchRelevanceInput>
    cursor?: PricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PricesScalarFieldEnum>
  }


  /**
   * Products without action
   */
  export type ProductsArgs = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductsInclude | null
  }



  /**
   * Model Prices
   */


  export type AggregatePrices = {
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  export type PricesAvgAggregateOutputType = {
    unitAmount: number | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PricesSumAggregateOutputType = {
    unitAmount: bigint | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PricesMinAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    unitAmount: bigint | null
    currency: string | null
    type: PricingType | null
    interval: PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    description: string | null
  }

  export type PricesMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    unitAmount: bigint | null
    currency: string | null
    type: PricingType | null
    interval: PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    description: string | null
  }

  export type PricesCountAggregateOutputType = {
    id: number
    productId: number
    active: number
    unitAmount: number
    currency: number
    type: number
    interval: number
    intervalCount: number
    trialPeriodDays: number
    metadata: number
    description: number
    _all: number
  }


  export type PricesAvgAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PricesSumAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PricesMinAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    description?: true
  }

  export type PricesMaxAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    description?: true
  }

  export type PricesCountAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    metadata?: true
    description?: true
    _all?: true
  }

  export type PricesAggregateArgs = {
    /**
     * Filter which Prices to aggregate.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PricesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricesMaxAggregateInputType
  }

  export type GetPricesAggregateType<T extends PricesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrices[P]>
      : GetScalarType<T[P], AggregatePrices[P]>
  }




  export type PricesGroupByArgs = {
    where?: PricesWhereInput
    orderBy?: Enumerable<PricesOrderByWithAggregationInput>
    by: PricesScalarFieldEnum[]
    having?: PricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricesCountAggregateInputType | true
    _avg?: PricesAvgAggregateInputType
    _sum?: PricesSumAggregateInputType
    _min?: PricesMinAggregateInputType
    _max?: PricesMaxAggregateInputType
  }


  export type PricesGroupByOutputType = {
    id: string
    productId: string
    active: boolean
    unitAmount: bigint | null
    currency: string
    type: PricingType
    interval: PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    metadata: JsonValue | null
    description: string
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  type GetPricesGroupByPayload<T extends PricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricesGroupByOutputType[P]>
            : GetScalarType<T[P], PricesGroupByOutputType[P]>
        }
      >
    >


  export type PricesSelect = {
    id?: boolean
    productId?: boolean
    active?: boolean
    unitAmount?: boolean
    currency?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    metadata?: boolean
    description?: boolean
    product?: boolean | ProductsArgs
    Subscriptions?: boolean | Prices$SubscriptionsArgs
    _count?: boolean | PricesCountOutputTypeArgs
  }


  export type PricesInclude = {
    product?: boolean | ProductsArgs
    Subscriptions?: boolean | Prices$SubscriptionsArgs
    _count?: boolean | PricesCountOutputTypeArgs
  }

  export type PricesGetPayload<S extends boolean | null | undefined | PricesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Prices :
    S extends undefined ? never :
    S extends { include: any } & (PricesArgs | PricesFindManyArgs)
    ? Prices  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? ProductsGetPayload<S['include'][P]> :
        P extends 'Subscriptions' ? Array < SubscriptionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? PricesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PricesArgs | PricesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? ProductsGetPayload<S['select'][P]> :
        P extends 'Subscriptions' ? Array < SubscriptionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? PricesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Prices ? Prices[P] : never
  } 
      : Prices


  type PricesCountArgs = 
    Omit<PricesFindManyArgs, 'select' | 'include'> & {
      select?: PricesCountAggregateInputType | true
    }

  export interface PricesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Prices that matches the filter.
     * @param {PricesFindUniqueArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PricesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PricesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prices'> extends True ? Prisma__PricesClient<PricesGetPayload<T>> : Prisma__PricesClient<PricesGetPayload<T> | null, null>

    /**
     * Find one Prices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PricesFindUniqueOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PricesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PricesFindUniqueOrThrowArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Find the first Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PricesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PricesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prices'> extends True ? Prisma__PricesClient<PricesGetPayload<T>> : Prisma__PricesClient<PricesGetPayload<T> | null, null>

    /**
     * Find the first Prices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PricesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PricesFindFirstOrThrowArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.prices.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricesWithIdOnly = await prisma.prices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PricesFindManyArgs>(
      args?: SelectSubset<T, PricesFindManyArgs>
    ): Prisma.PrismaPromise<Array<PricesGetPayload<T>>>

    /**
     * Create a Prices.
     * @param {PricesCreateArgs} args - Arguments to create a Prices.
     * @example
     * // Create one Prices
     * const Prices = await prisma.prices.create({
     *   data: {
     *     // ... data to create a Prices
     *   }
     * })
     * 
    **/
    create<T extends PricesCreateArgs>(
      args: SelectSubset<T, PricesCreateArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Create many Prices.
     *     @param {PricesCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const prices = await prisma.prices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PricesCreateManyArgs>(
      args?: SelectSubset<T, PricesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prices.
     * @param {PricesDeleteArgs} args - Arguments to delete one Prices.
     * @example
     * // Delete one Prices
     * const Prices = await prisma.prices.delete({
     *   where: {
     *     // ... filter to delete one Prices
     *   }
     * })
     * 
    **/
    delete<T extends PricesDeleteArgs>(
      args: SelectSubset<T, PricesDeleteArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Update one Prices.
     * @param {PricesUpdateArgs} args - Arguments to update one Prices.
     * @example
     * // Update one Prices
     * const prices = await prisma.prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PricesUpdateArgs>(
      args: SelectSubset<T, PricesUpdateArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Delete zero or more Prices.
     * @param {PricesDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PricesDeleteManyArgs>(
      args?: SelectSubset<T, PricesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const prices = await prisma.prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PricesUpdateManyArgs>(
      args: SelectSubset<T, PricesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prices.
     * @param {PricesUpsertArgs} args - Arguments to update or create a Prices.
     * @example
     * // Update or create a Prices
     * const prices = await prisma.prices.upsert({
     *   create: {
     *     // ... data to create a Prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prices we want to update
     *   }
     * })
    **/
    upsert<T extends PricesUpsertArgs>(
      args: SelectSubset<T, PricesUpsertArgs>
    ): Prisma__PricesClient<PricesGetPayload<T>>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.prices.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PricesCountArgs>(
      args?: Subset<T, PricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricesAggregateArgs>(args: Subset<T, PricesAggregateArgs>): Prisma.PrismaPromise<GetPricesAggregateType<T>>

    /**
     * Group by Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricesGroupByArgs['orderBy'] }
        : { orderBy?: PricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PricesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductsArgs= {}>(args?: Subset<T, ProductsArgs>): Prisma__ProductsClient<ProductsGetPayload<T> | Null>;

    Subscriptions<T extends Prices$SubscriptionsArgs= {}>(args?: Subset<T, Prices$SubscriptionsArgs>): Prisma.PrismaPromise<Array<SubscriptionsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Prices base type for findUnique actions
   */
  export type PricesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where: PricesWhereUniqueInput
  }

  /**
   * Prices findUnique
   */
  export interface PricesFindUniqueArgs extends PricesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prices findUniqueOrThrow
   */
  export type PricesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where: PricesWhereUniqueInput
  }


  /**
   * Prices base type for findFirst actions
   */
  export type PricesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PricesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PricesScalarFieldEnum>
  }

  /**
   * Prices findFirst
   */
  export interface PricesFindFirstArgs extends PricesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prices findFirstOrThrow
   */
  export type PricesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PricesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PricesScalarFieldEnum>
  }


  /**
   * Prices findMany
   */
  export type PricesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PricesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: Enumerable<PricesScalarFieldEnum>
  }


  /**
   * Prices create
   */
  export type PricesCreateArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * The data needed to create a Prices.
     */
    data: XOR<PricesCreateInput, PricesUncheckedCreateInput>
  }


  /**
   * Prices createMany
   */
  export type PricesCreateManyArgs = {
    /**
     * The data used to create many Prices.
     */
    data: Enumerable<PricesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prices update
   */
  export type PricesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * The data needed to update a Prices.
     */
    data: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
    /**
     * Choose, which Prices to update.
     */
    where: PricesWhereUniqueInput
  }


  /**
   * Prices updateMany
   */
  export type PricesUpdateManyArgs = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PricesWhereInput
  }


  /**
   * Prices upsert
   */
  export type PricesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * The filter to search for the Prices to update in case it exists.
     */
    where: PricesWhereUniqueInput
    /**
     * In case the Prices found by the `where` argument doesn't exist, create a new Prices with this data.
     */
    create: XOR<PricesCreateInput, PricesUncheckedCreateInput>
    /**
     * In case the Prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
  }


  /**
   * Prices delete
   */
  export type PricesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
    /**
     * Filter which Prices to delete.
     */
    where: PricesWhereUniqueInput
  }


  /**
   * Prices deleteMany
   */
  export type PricesDeleteManyArgs = {
    /**
     * Filter which Prices to delete
     */
    where?: PricesWhereInput
  }


  /**
   * Prices.Subscriptions
   */
  export type Prices$SubscriptionsArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    where?: SubscriptionsWhereInput
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionsScalarFieldEnum>
  }


  /**
   * Prices without action
   */
  export type PricesArgs = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PricesInclude | null
  }



  /**
   * Model Subscriptions
   */


  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    organizationId: number | null
    quantity: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    organizationId: number | null
    quantity: number | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    status: SubscriptionStatus | null
    pricesId: string | null
    quantity: number | null
    cancelAtPeriodEnd: boolean | null
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    status: SubscriptionStatus | null
    pricesId: string | null
    quantity: number | null
    cancelAtPeriodEnd: boolean | null
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    organizationId: number
    status: number
    metadata: number
    pricesId: number
    quantity: number
    cancelAtPeriodEnd: number
    created: number
    currentPeriodStart: number
    currentPeriodEnd: number
    endedAt: number
    cancelAt: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    organizationId?: true
    quantity?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    organizationId?: true
    quantity?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    metadata?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs = {
    /**
     * Filter which Subscriptions to aggregate.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type SubscriptionsGroupByArgs = {
    where?: SubscriptionsWhereInput
    orderBy?: Enumerable<SubscriptionsOrderByWithAggregationInput>
    by: SubscriptionsScalarFieldEnum[]
    having?: SubscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }


  export type SubscriptionsGroupByOutputType = {
    id: string
    organizationId: number
    status: SubscriptionStatus
    metadata: JsonValue | null
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends SubscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionsSelect = {
    id?: boolean
    organizationId?: boolean
    status?: boolean
    metadata?: boolean
    pricesId?: boolean
    quantity?: boolean
    cancelAtPeriodEnd?: boolean
    created?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    endedAt?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    price?: boolean | PricesArgs
    organization?: boolean | OrganizationArgs
  }


  export type SubscriptionsInclude = {
    price?: boolean | PricesArgs
    organization?: boolean | OrganizationArgs
  }

  export type SubscriptionsGetPayload<S extends boolean | null | undefined | SubscriptionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Subscriptions :
    S extends undefined ? never :
    S extends { include: any } & (SubscriptionsArgs | SubscriptionsFindManyArgs)
    ? Subscriptions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'price' ? PricesGetPayload<S['include'][P]> :
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubscriptionsArgs | SubscriptionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'price' ? PricesGetPayload<S['select'][P]> :
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :  P extends keyof Subscriptions ? Subscriptions[P] : never
  } 
      : Subscriptions


  type SubscriptionsCountArgs = 
    Omit<SubscriptionsFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface SubscriptionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {SubscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscriptions'> extends True ? Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>> : Prisma__SubscriptionsClient<SubscriptionsGetPayload<T> | null, null>

    /**
     * Find one Subscriptions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionsFindUniqueOrThrowArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscriptions'> extends True ? Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>> : Prisma__SubscriptionsClient<SubscriptionsGetPayload<T> | null, null>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionsFindFirstOrThrowArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionsFindManyArgs>(
      args?: SelectSubset<T, SubscriptionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubscriptionsGetPayload<T>>>

    /**
     * Create a Subscriptions.
     * @param {SubscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionsCreateArgs>(
      args: SelectSubset<T, SubscriptionsCreateArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscriptions = await prisma.subscriptions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionsCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriptions.
     * @param {SubscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionsDeleteArgs>(
      args: SelectSubset<T, SubscriptionsDeleteArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Update one Subscriptions.
     * @param {SubscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionsUpdateArgs>(
      args: SelectSubset<T, SubscriptionsUpdateArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionsDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionsUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {SubscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionsUpsertArgs>(
      args: SelectSubset<T, SubscriptionsUpsertArgs>
    ): Prisma__SubscriptionsClient<SubscriptionsGetPayload<T>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionsCountArgs>(
      args?: Subset<T, SubscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    price<T extends PricesArgs= {}>(args?: Subset<T, PricesArgs>): Prisma__PricesClient<PricesGetPayload<T> | Null>;

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma__OrganizationClient<OrganizationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscriptions base type for findUnique actions
   */
  export type SubscriptionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findUnique
   */
  export interface SubscriptionsFindUniqueArgs extends SubscriptionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscriptions findUniqueOrThrow
   */
  export type SubscriptionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }


  /**
   * Subscriptions base type for findFirst actions
   */
  export type SubscriptionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionsScalarFieldEnum>
  }

  /**
   * Subscriptions findFirst
   */
  export interface SubscriptionsFindFirstArgs extends SubscriptionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscriptions findFirstOrThrow
   */
  export type SubscriptionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionsScalarFieldEnum>
  }


  /**
   * Subscriptions findMany
   */
  export type SubscriptionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: Enumerable<SubscriptionsScalarFieldEnum>
  }


  /**
   * Subscriptions create
   */
  export type SubscriptionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * The data needed to create a Subscriptions.
     */
    data: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
  }


  /**
   * Subscriptions createMany
   */
  export type SubscriptionsCreateManyArgs = {
    /**
     * The data used to create many Subscriptions.
     */
    data: Enumerable<SubscriptionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscriptions update
   */
  export type SubscriptionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * The data needed to update a Subscriptions.
     */
    data: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
    /**
     * Choose, which Subscriptions to update.
     */
    where: SubscriptionsWhereUniqueInput
  }


  /**
   * Subscriptions updateMany
   */
  export type SubscriptionsUpdateManyArgs = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
  }


  /**
   * Subscriptions upsert
   */
  export type SubscriptionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * The filter to search for the Subscriptions to update in case it exists.
     */
    where: SubscriptionsWhereUniqueInput
    /**
     * In case the Subscriptions found by the `where` argument doesn't exist, create a new Subscriptions with this data.
     */
    create: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
    /**
     * In case the Subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
  }


  /**
   * Subscriptions delete
   */
  export type SubscriptionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
    /**
     * Filter which Subscriptions to delete.
     */
    where: SubscriptionsWhereUniqueInput
  }


  /**
   * Subscriptions deleteMany
   */
  export type SubscriptionsDeleteManyArgs = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionsWhereInput
  }


  /**
   * Subscriptions without action
   */
  export type SubscriptionsArgs = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AlternateItemOrderByRelevanceFieldEnum: {
    alternateId: 'alternateId'
  };

  export type AlternateItemOrderByRelevanceFieldEnum = (typeof AlternateItemOrderByRelevanceFieldEnum)[keyof typeof AlternateItemOrderByRelevanceFieldEnum]


  export const AlternateItemScalarFieldEnum: {
    id: 'id',
    alternateId: 'alternateId',
    lineItemId: 'lineItemId'
  };

  export type AlternateItemScalarFieldEnum = (typeof AlternateItemScalarFieldEnum)[keyof typeof AlternateItemScalarFieldEnum]


  export const AnnotationOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type AnnotationOrderByRelevanceFieldEnum = (typeof AnnotationOrderByRelevanceFieldEnum)[keyof typeof AnnotationOrderByRelevanceFieldEnum]


  export const AnnotationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageId: 'imageId',
    coordinates: 'coordinates',
    userId: 'userId',
    isDeleted: 'isDeleted'
  };

  export type AnnotationScalarFieldEnum = (typeof AnnotationScalarFieldEnum)[keyof typeof AnnotationScalarFieldEnum]


  export const AreaAffectedOrderByRelevanceFieldEnum: {
    material: 'material',
    totalAreaRemoved: 'totalAreaRemoved',
    totalAreaMicrobialApplied: 'totalAreaMicrobialApplied',
    cause: 'cause',
    cabinetryRemoved: 'cabinetryRemoved',
    publicId: 'publicId'
  };

  export type AreaAffectedOrderByRelevanceFieldEnum = (typeof AreaAffectedOrderByRelevanceFieldEnum)[keyof typeof AreaAffectedOrderByRelevanceFieldEnum]


  export const AreaAffectedScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    roomId: 'roomId',
    material: 'material',
    totalAreaRemoved: 'totalAreaRemoved',
    totalAreaMicrobialApplied: 'totalAreaMicrobialApplied',
    cause: 'cause',
    category: 'category',
    cabinetryRemoved: 'cabinetryRemoved',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    type: 'type'
  };

  export type AreaAffectedScalarFieldEnum = (typeof AreaAffectedScalarFieldEnum)[keyof typeof AreaAffectedScalarFieldEnum]


  export const CalendarEventOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    subject: 'subject',
    payload: 'payload',
    dynamicId: 'dynamicId'
  };

  export type CalendarEventOrderByRelevanceFieldEnum = (typeof CalendarEventOrderByRelevanceFieldEnum)[keyof typeof CalendarEventOrderByRelevanceFieldEnum]


  export const CalendarEventReminderScalarFieldEnum: {
    id: 'id',
    reminderTarget: 'reminderTarget',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sendText: 'sendText',
    sendEmail: 'sendEmail',
    textSentAt: 'textSentAt',
    emailSentAt: 'emailSentAt',
    calendarEventId: 'calendarEventId',
    date: 'date'
  };

  export type CalendarEventReminderScalarFieldEnum = (typeof CalendarEventReminderScalarFieldEnum)[keyof typeof CalendarEventReminderScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subject: 'subject',
    payload: 'payload',
    projectId: 'projectId',
    date: 'date',
    dynamicId: 'dynamicId',
    isDeleted: 'isDeleted',
    remindClient: 'remindClient',
    remindProjectOwners: 'remindProjectOwners'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const CostOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CostOrderByRelevanceFieldEnum = (typeof CostOrderByRelevanceFieldEnum)[keyof typeof CostOrderByRelevanceFieldEnum]


  export const CostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    estimatedCost: 'estimatedCost',
    actualCost: 'actualCost',
    name: 'name',
    projectId: 'projectId',
    isDeleted: 'isDeleted',
    type: 'type'
  };

  export type CostScalarFieldEnum = (typeof CostScalarFieldEnum)[keyof typeof CostScalarFieldEnum]


  export const CustomersOrderByRelevanceFieldEnum: {
    customerId: 'customerId'
  };

  export type CustomersOrderByRelevanceFieldEnum = (typeof CustomersOrderByRelevanceFieldEnum)[keyof typeof CustomersOrderByRelevanceFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    billingAddress: 'billingAddress',
    paymentMethod: 'paymentMethod',
    organizationId: 'organizationId'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const DataDeletionRequestOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    email: 'email'
  };

  export type DataDeletionRequestOrderByRelevanceFieldEnum = (typeof DataDeletionRequestOrderByRelevanceFieldEnum)[keyof typeof DataDeletionRequestOrderByRelevanceFieldEnum]


  export const DataDeletionRequestScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    fullName: 'fullName',
    email: 'email',
    isVerified: 'isVerified'
  };

  export type DataDeletionRequestScalarFieldEnum = (typeof DataDeletionRequestScalarFieldEnum)[keyof typeof DataDeletionRequestScalarFieldEnum]


  export const DetectionOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    imageKey: 'imageKey',
    category: 'category',
    code: 'code',
    item: 'item',
    quality: 'quality'
  };

  export type DetectionOrderByRelevanceFieldEnum = (typeof DetectionOrderByRelevanceFieldEnum)[keyof typeof DetectionOrderByRelevanceFieldEnum]


  export const DetectionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    inferenceId: 'inferenceId',
    imageKey: 'imageKey',
    xMinCord: 'xMinCord',
    yMinCord: 'yMinCord',
    confidence: 'confidence',
    xMaxCord: 'xMaxCord',
    yMaxCord: 'yMaxCord',
    projectId: 'projectId',
    category: 'category',
    code: 'code',
    item: 'item',
    quality: 'quality',
    roomId: 'roomId',
    dimension: 'dimension',
    unit: 'unit'
  };

  export type DetectionScalarFieldEnum = (typeof DetectionScalarFieldEnum)[keyof typeof DetectionScalarFieldEnum]


  export const EquipmentOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name'
  };

  export type EquipmentOrderByRelevanceFieldEnum = (typeof EquipmentOrderByRelevanceFieldEnum)[keyof typeof EquipmentOrderByRelevanceFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    name: 'name',
    quantity: 'quantity',
    organizationId: 'organizationId'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const GenericRoomReadingOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    value: 'value',
    humidity: 'humidity',
    temperature: 'temperature',
    gpp: 'gpp'
  };

  export type GenericRoomReadingOrderByRelevanceFieldEnum = (typeof GenericRoomReadingOrderByRelevanceFieldEnum)[keyof typeof GenericRoomReadingOrderByRelevanceFieldEnum]


  export const GenericRoomReadingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    publicId: 'publicId',
    type: 'type',
    value: 'value',
    humidity: 'humidity',
    temperature: 'temperature',
    gpp: 'gpp',
    roomReadingId: 'roomReadingId',
    isDeleted: 'isDeleted'
  };

  export type GenericRoomReadingScalarFieldEnum = (typeof GenericRoomReadingScalarFieldEnum)[keyof typeof GenericRoomReadingScalarFieldEnum]


  export const ImageNoteOrderByRelevanceFieldEnum: {
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ImageNoteOrderByRelevanceFieldEnum = (typeof ImageNoteOrderByRelevanceFieldEnum)[keyof typeof ImageNoteOrderByRelevanceFieldEnum]


  export const ImageNoteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageId: 'imageId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId',
    isDeleted: 'isDeleted'
  };

  export type ImageNoteScalarFieldEnum = (typeof ImageNoteScalarFieldEnum)[keyof typeof ImageNoteScalarFieldEnum]


  export const ImageOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    key: 'key',
    description: 'description'
  };

  export type ImageOrderByRelevanceFieldEnum = (typeof ImageOrderByRelevanceFieldEnum)[keyof typeof ImageOrderByRelevanceFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    key: 'key',
    projectId: 'projectId',
    organizationId: 'organizationId',
    includeInReport: 'includeInReport',
    description: 'description'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const InferenceOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    imageKey: 'imageKey'
  };

  export type InferenceOrderByRelevanceFieldEnum = (typeof InferenceOrderByRelevanceFieldEnum)[keyof typeof InferenceOrderByRelevanceFieldEnum]


  export const InferenceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    imageId: 'imageId',
    imageKey: 'imageKey',
    projectId: 'projectId',
    roomId: 'roomId'
  };

  export type InferenceScalarFieldEnum = (typeof InferenceScalarFieldEnum)[keyof typeof InferenceScalarFieldEnum]


  export const ItemCategoryOrderByRelevanceFieldEnum: {
    xactimateKey: 'xactimateKey',
    xactimateDescription: 'xactimateDescription'
  };

  export type ItemCategoryOrderByRelevanceFieldEnum = (typeof ItemCategoryOrderByRelevanceFieldEnum)[keyof typeof ItemCategoryOrderByRelevanceFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    xactimateKey: 'xactimateKey',
    xactimateDescription: 'xactimateDescription',
    hasItems: 'hasItems'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const LineItemOrderByRelevanceFieldEnum: {
    xactimateCode: 'xactimateCode',
    xactimateDescription: 'xactimateDescription',
    unit: 'unit'
  };

  export type LineItemOrderByRelevanceFieldEnum = (typeof LineItemOrderByRelevanceFieldEnum)[keyof typeof LineItemOrderByRelevanceFieldEnum]


  export const LineItemScalarFieldEnum: {
    id: 'id',
    xactimateCode: 'xactimateCode',
    xactimateDescription: 'xactimateDescription',
    unit: 'unit',
    itemCategoryId: 'itemCategoryId'
  };

  export type LineItemScalarFieldEnum = (typeof LineItemScalarFieldEnum)[keyof typeof LineItemScalarFieldEnum]


  export const NotesAuditTrailOrderByRelevanceFieldEnum: {
    userId: 'userId',
    userName: 'userName',
    body: 'body'
  };

  export type NotesAuditTrailOrderByRelevanceFieldEnum = (typeof NotesAuditTrailOrderByRelevanceFieldEnum)[keyof typeof NotesAuditTrailOrderByRelevanceFieldEnum]


  export const NotesAuditTrailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    notesId: 'notesId',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    body: 'body'
  };

  export type NotesAuditTrailScalarFieldEnum = (typeof NotesAuditTrailScalarFieldEnum)[keyof typeof NotesAuditTrailScalarFieldEnum]


  export const NotesOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    body: 'body'
  };

  export type NotesOrderByRelevanceFieldEnum = (typeof NotesOrderByRelevanceFieldEnum)[keyof typeof NotesOrderByRelevanceFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    roomId: 'roomId',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    body: 'body'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    title: 'title',
    content: 'content',
    link: 'link',
    linkText: 'linkText',
    userId: 'userId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    title: 'title',
    content: 'content',
    isSeen: 'isSeen',
    link: 'link',
    linkText: 'linkText',
    type: 'type',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const OrganizationInvitationOrderByRelevanceFieldEnum: {
    email: 'email',
    invitationId: 'invitationId'
  };

  export type OrganizationInvitationOrderByRelevanceFieldEnum = (typeof OrganizationInvitationOrderByRelevanceFieldEnum)[keyof typeof OrganizationInvitationOrderByRelevanceFieldEnum]


  export const OrganizationInvitationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    email: 'email',
    invitationId: 'invitationId',
    isAccepted: 'isAccepted'
  };

  export type OrganizationInvitationScalarFieldEnum = (typeof OrganizationInvitationScalarFieldEnum)[keyof typeof OrganizationInvitationScalarFieldEnum]


  export const OrganizationOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name',
    address: 'address',
    faxNumber: 'faxNumber',
    size: 'size',
    logoId: 'logoId'
  };

  export type OrganizationOrderByRelevanceFieldEnum = (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum]


  export const OrganizationSavedOptionOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    label: 'label',
    value: 'value'
  };

  export type OrganizationSavedOptionOrderByRelevanceFieldEnum = (typeof OrganizationSavedOptionOrderByRelevanceFieldEnum)[keyof typeof OrganizationSavedOptionOrderByRelevanceFieldEnum]


  export const OrganizationSavedOptionScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    label: 'label',
    value: 'value',
    isDeleted: 'isDeleted',
    type: 'type',
    organizationId: 'organizationId'
  };

  export type OrganizationSavedOptionScalarFieldEnum = (typeof OrganizationSavedOptionScalarFieldEnum)[keyof typeof OrganizationSavedOptionScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    name: 'name',
    address: 'address',
    faxNumber: 'faxNumber',
    size: 'size',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    logoId: 'logoId'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const PendingRoofReportsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    projectId: 'projectId',
    isCompleted: 'isCompleted'
  };

  export type PendingRoofReportsScalarFieldEnum = (typeof PendingRoofReportsScalarFieldEnum)[keyof typeof PendingRoofReportsScalarFieldEnum]


  export const PhotoAccessLinkOrderByRelevanceFieldEnum: {
    accessId: 'accessId',
    email: 'email',
    phoneNumber: 'phoneNumber'
  };

  export type PhotoAccessLinkOrderByRelevanceFieldEnum = (typeof PhotoAccessLinkOrderByRelevanceFieldEnum)[keyof typeof PhotoAccessLinkOrderByRelevanceFieldEnum]


  export const PhotoAccessLinkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    accessId: 'accessId',
    email: 'email',
    phoneNumber: 'phoneNumber',
    projectId: 'projectId'
  };

  export type PhotoAccessLinkScalarFieldEnum = (typeof PhotoAccessLinkScalarFieldEnum)[keyof typeof PhotoAccessLinkScalarFieldEnum]


  export const PlanEntitlementsOrderByRelevanceFieldEnum: {
    extPlanId: 'extPlanId',
    description: 'description',
    period: 'period'
  };

  export type PlanEntitlementsOrderByRelevanceFieldEnum = (typeof PlanEntitlementsOrderByRelevanceFieldEnum)[keyof typeof PlanEntitlementsOrderByRelevanceFieldEnum]


  export const PlanEntitlementsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    extPlanId: 'extPlanId',
    maxImages: 'maxImages',
    maxProjects: 'maxProjects',
    maxSeats: 'maxSeats',
    description: 'description',
    period: 'period',
    price: 'price'
  };

  export type PlanEntitlementsScalarFieldEnum = (typeof PlanEntitlementsScalarFieldEnum)[keyof typeof PlanEntitlementsScalarFieldEnum]


  export const PricesOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    currency: 'currency',
    description: 'description'
  };

  export type PricesOrderByRelevanceFieldEnum = (typeof PricesOrderByRelevanceFieldEnum)[keyof typeof PricesOrderByRelevanceFieldEnum]


  export const PricesScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    active: 'active',
    unitAmount: 'unitAmount',
    currency: 'currency',
    type: 'type',
    interval: 'interval',
    intervalCount: 'intervalCount',
    trialPeriodDays: 'trialPeriodDays',
    metadata: 'metadata',
    description: 'description'
  };

  export type PricesScalarFieldEnum = (typeof PricesScalarFieldEnum)[keyof typeof PricesScalarFieldEnum]


  export const ProductsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image'
  };

  export type ProductsOrderByRelevanceFieldEnum = (typeof ProductsOrderByRelevanceFieldEnum)[keyof typeof ProductsOrderByRelevanceFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    active: 'active',
    name: 'name',
    description: 'description',
    image: 'image',
    metadata: 'metadata'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const ProjectEquipmentOrderByRelevanceFieldEnum: {
    publicId: 'publicId'
  };

  export type ProjectEquipmentOrderByRelevanceFieldEnum = (typeof ProjectEquipmentOrderByRelevanceFieldEnum)[keyof typeof ProjectEquipmentOrderByRelevanceFieldEnum]


  export const ProjectEquipmentScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    quantity: 'quantity',
    projectId: 'projectId',
    equipmentId: 'equipmentId'
  };

  export type ProjectEquipmentScalarFieldEnum = (typeof ProjectEquipmentScalarFieldEnum)[keyof typeof ProjectEquipmentScalarFieldEnum]


  export const ProjectNotesOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ProjectNotesOrderByRelevanceFieldEnum = (typeof ProjectNotesOrderByRelevanceFieldEnum)[keyof typeof ProjectNotesOrderByRelevanceFieldEnum]


  export const ProjectNotesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ProjectNotesScalarFieldEnum = (typeof ProjectNotesScalarFieldEnum)[keyof typeof ProjectNotesScalarFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    assignmentNumber: 'assignmentNumber',
    publicId: 'publicId',
    name: 'name',
    location: 'location',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    clientPhoneNumber: 'clientPhoneNumber',
    companyName: 'companyName',
    managerName: 'managerName',
    adjusterEmail: 'adjusterEmail',
    adjusterName: 'adjusterName',
    adjusterPhoneNumber: 'adjusterPhoneNumber',
    insuranceCompanyName: 'insuranceCompanyName',
    insuranceClaimId: 'insuranceClaimId',
    lossType: 'lossType',
    humidity: 'humidity',
    temperature: 'temperature',
    wind: 'wind',
    lat: 'lat',
    lng: 'lng',
    forecast: 'forecast',
    claimSummary: 'claimSummary'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    closedAt: 'closedAt',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    assignmentNumber: 'assignmentNumber',
    publicId: 'publicId',
    name: 'name',
    location: 'location',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    clientPhoneNumber: 'clientPhoneNumber',
    companyName: 'companyName',
    managerName: 'managerName',
    adjusterEmail: 'adjusterEmail',
    adjusterName: 'adjusterName',
    adjusterPhoneNumber: 'adjusterPhoneNumber',
    insuranceCompanyName: 'insuranceCompanyName',
    insuranceClaimId: 'insuranceClaimId',
    lossType: 'lossType',
    catCode: 'catCode',
    humidity: 'humidity',
    lastTimeWeatherFetched: 'lastTimeWeatherFetched',
    temperature: 'temperature',
    wind: 'wind',
    lat: 'lat',
    lng: 'lng',
    forecast: 'forecast',
    claimSummary: 'claimSummary',
    roofSegments: 'roofSegments',
    roofSpecs: 'roofSpecs',
    rcvValue: 'rcvValue',
    actualValue: 'actualValue',
    status: 'status',
    projectStatusValueId: 'projectStatusValueId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectStatusValueOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    label: 'label',
    description: 'description',
    color: 'color'
  };

  export type ProjectStatusValueOrderByRelevanceFieldEnum = (typeof ProjectStatusValueOrderByRelevanceFieldEnum)[keyof typeof ProjectStatusValueOrderByRelevanceFieldEnum]


  export const ProjectStatusValueScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    label: 'label',
    description: 'description',
    color: 'color',
    order: 'order',
    organizationId: 'organizationId'
  };

  export type ProjectStatusValueScalarFieldEnum = (typeof ProjectStatusValueScalarFieldEnum)[keyof typeof ProjectStatusValueScalarFieldEnum]


  export const PropertyDataOrderByRelevanceFieldEnum: {
    realtyMoleId: 'realtyMoleId'
  };

  export type PropertyDataOrderByRelevanceFieldEnum = (typeof PropertyDataOrderByRelevanceFieldEnum)[keyof typeof PropertyDataOrderByRelevanceFieldEnum]


  export const PropertyDataScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    projectId: 'projectId',
    bathrooms: 'bathrooms',
    bedrooms: 'bedrooms',
    squareFootage: 'squareFootage',
    realtyMoleId: 'realtyMoleId',
    data: 'data'
  };

  export type PropertyDataScalarFieldEnum = (typeof PropertyDataScalarFieldEnum)[keyof typeof PropertyDataScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RekognitionRunsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt'
  };

  export type RekognitionRunsScalarFieldEnum = (typeof RekognitionRunsScalarFieldEnum)[keyof typeof RekognitionRunsScalarFieldEnum]


  export const RelatedItemOrderByRelevanceFieldEnum: {
    relationId: 'relationId'
  };

  export type RelatedItemOrderByRelevanceFieldEnum = (typeof RelatedItemOrderByRelevanceFieldEnum)[keyof typeof RelatedItemOrderByRelevanceFieldEnum]


  export const RelatedItemScalarFieldEnum: {
    id: 'id',
    relationId: 'relationId',
    lineItemId: 'lineItemId'
  };

  export type RelatedItemScalarFieldEnum = (typeof RelatedItemScalarFieldEnum)[keyof typeof RelatedItemScalarFieldEnum]


  export const RoomOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name',
    gpp: 'gpp',
    humidity: 'humidity',
    dehuReading: 'dehuReading',
    temperature: 'temperature',
    length: 'length',
    width: 'width',
    height: 'height',
    totalSqft: 'totalSqft',
    equipmentUsed: 'equipmentUsed'
  };

  export type RoomOrderByRelevanceFieldEnum = (typeof RoomOrderByRelevanceFieldEnum)[keyof typeof RoomOrderByRelevanceFieldEnum]


  export const RoomReadingOrderByRelevanceFieldEnum: {
    humidity: 'humidity',
    temperature: 'temperature',
    moistureContentWall: 'moistureContentWall',
    moistureContentFloor: 'moistureContentFloor',
    equipmentUsed: 'equipmentUsed',
    publicId: 'publicId',
    gpp: 'gpp'
  };

  export type RoomReadingOrderByRelevanceFieldEnum = (typeof RoomReadingOrderByRelevanceFieldEnum)[keyof typeof RoomReadingOrderByRelevanceFieldEnum]


  export const RoomReadingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    humidity: 'humidity',
    temperature: 'temperature',
    moistureContentWall: 'moistureContentWall',
    moistureContentFloor: 'moistureContentFloor',
    equipmentUsed: 'equipmentUsed',
    roomId: 'roomId',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    gpp: 'gpp'
  };

  export type RoomReadingScalarFieldEnum = (typeof RoomReadingScalarFieldEnum)[keyof typeof RoomReadingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    name: 'name',
    projectId: 'projectId',
    gpp: 'gpp',
    humidity: 'humidity',
    dehuReading: 'dehuReading',
    temperature: 'temperature',
    length: 'length',
    width: 'width',
    height: 'height',
    totalSqft: 'totalSqft',
    windows: 'windows',
    doors: 'doors',
    equipmentUsed: 'equipmentUsed'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubscriptionsOrderByRelevanceFieldEnum: {
    id: 'id',
    pricesId: 'pricesId'
  };

  export type SubscriptionsOrderByRelevanceFieldEnum = (typeof SubscriptionsOrderByRelevanceFieldEnum)[keyof typeof SubscriptionsOrderByRelevanceFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    status: 'status',
    metadata: 'metadata',
    pricesId: 'pricesId',
    quantity: 'quantity',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    created: 'created',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    endedAt: 'endedAt',
    cancelAt: 'cancelAt',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const TemplatesUsedOrderByRelevanceFieldEnum: {
    templateCode: 'templateCode'
  };

  export type TemplatesUsedOrderByRelevanceFieldEnum = (typeof TemplatesUsedOrderByRelevanceFieldEnum)[keyof typeof TemplatesUsedOrderByRelevanceFieldEnum]


  export const TemplatesUsedScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    templateCode: 'templateCode',
    roomId: 'roomId'
  };

  export type TemplatesUsedScalarFieldEnum = (typeof TemplatesUsedScalarFieldEnum)[keyof typeof TemplatesUsedScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    inviteId: 'inviteId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    email: 'email',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    inviteId: 'inviteId',
    isSupportUser: 'isSupportUser',
    hasSeenProductTour: 'hasSeenProductTour',
    productTourData: 'productTourData',
    savedDashboardView: 'savedDashboardView',
    photoView: 'photoView',
    groupView: 'groupView',
    onboardingStatus: 'onboardingStatus'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserToOrganizationOrderByRelevanceFieldEnum: {
    role: 'role',
    userId: 'userId'
  };

  export type UserToOrganizationOrderByRelevanceFieldEnum = (typeof UserToOrganizationOrderByRelevanceFieldEnum)[keyof typeof UserToOrganizationOrderByRelevanceFieldEnum]


  export const UserToOrganizationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isAdmin: 'isAdmin',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    role: 'role',
    accessLevel: 'accessLevel',
    userId: 'userId'
  };

  export type UserToOrganizationScalarFieldEnum = (typeof UserToOrganizationScalarFieldEnum)[keyof typeof UserToOrganizationScalarFieldEnum]


  export const UserToProjectOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type UserToProjectOrderByRelevanceFieldEnum = (typeof UserToProjectOrderByRelevanceFieldEnum)[keyof typeof UserToProjectOrderByRelevanceFieldEnum]


  export const UserToProjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    projectId: 'projectId'
  };

  export type UserToProjectScalarFieldEnum = (typeof UserToProjectScalarFieldEnum)[keyof typeof UserToProjectScalarFieldEnum]


  export const WaitListOrderByRelevanceFieldEnum: {
    email: 'email'
  };

  export type WaitListOrderByRelevanceFieldEnum = (typeof WaitListOrderByRelevanceFieldEnum)[keyof typeof WaitListOrderByRelevanceFieldEnum]


  export const WaitListScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    email: 'email'
  };

  export type WaitListScalarFieldEnum = (typeof WaitListScalarFieldEnum)[keyof typeof WaitListScalarFieldEnum]


  export const WeatherReportItemOrderByRelevanceFieldEnum: {
    time: 'time',
    f_scale: 'f_scale',
    speed: 'speed',
    size: 'size',
    location: 'location',
    county: 'county',
    state: 'state',
    lat: 'lat',
    lon: 'lon',
    comments: 'comments'
  };

  export type WeatherReportItemOrderByRelevanceFieldEnum = (typeof WeatherReportItemOrderByRelevanceFieldEnum)[keyof typeof WeatherReportItemOrderByRelevanceFieldEnum]


  export const WeatherReportItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    projectId: 'projectId',
    date: 'date',
    time: 'time',
    f_scale: 'f_scale',
    speed: 'speed',
    size: 'size',
    location: 'location',
    county: 'county',
    state: 'state',
    lat: 'lat',
    lon: 'lon',
    comments: 'comments'
  };

  export type WeatherReportItemScalarFieldEnum = (typeof WeatherReportItemScalarFieldEnum)[keyof typeof WeatherReportItemScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    token?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    email?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    phone?: StringFilter | string
    inviteId?: StringNullableFilter | string | null
    isSupportUser?: BoolFilter | boolean
    hasSeenProductTour?: BoolFilter | boolean
    productTourData?: JsonNullableFilter
    savedDashboardView?: EnumDashboardViewsFilter | DashboardViews
    photoView?: EnumPhotoViewsFilter | PhotoViews
    groupView?: EnumGroupByViewsFilter | GroupByViews
    onboardingStatus?: JsonNullableFilter
    org?: XOR<UserToOrganizationRelationFilter, UserToOrganizationWhereInput> | null
    UserToProject?: UserToProjectListRelationFilter
    Notification?: NotificationListRelationFilter
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrder
    org?: UserToOrganizationOrderByWithRelationAndSearchRelevanceInput
    UserToProject?: UserToProjectOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    ImageNote?: ImageNoteOrderByRelationAggregateInput
    Annotation?: AnnotationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    token?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    token?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    inviteId?: StringNullableWithAggregatesFilter | string | null
    isSupportUser?: BoolWithAggregatesFilter | boolean
    hasSeenProductTour?: BoolWithAggregatesFilter | boolean
    productTourData?: JsonNullableWithAggregatesFilter
    savedDashboardView?: EnumDashboardViewsWithAggregatesFilter | DashboardViews
    photoView?: EnumPhotoViewsWithAggregatesFilter | PhotoViews
    groupView?: EnumGroupByViewsWithAggregatesFilter | GroupByViews
    onboardingStatus?: JsonNullableWithAggregatesFilter
  }

  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    address?: StringFilter | string
    faxNumber?: StringFilter | string
    size?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    logoId?: StringNullableFilter | string | null
    Image?: ImageListRelationFilter
    invitations?: OrganizationInvitationListRelationFilter
    projects?: ProjectListRelationFilter
    users?: UserToOrganizationListRelationFilter
    Customers?: CustomersListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
    OrganizationSavedOption?: OrganizationSavedOptionListRelationFilter
    equipment?: EquipmentListRelationFilter
    ProjectStatusValue?: ProjectStatusValueListRelationFilter
  }

  export type OrganizationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
    Image?: ImageOrderByRelationAggregateInput
    invitations?: OrganizationInvitationOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    users?: UserToOrganizationOrderByRelationAggregateInput
    Customers?: CustomersOrderByRelationAggregateInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
    OrganizationSavedOption?: OrganizationSavedOptionOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    ProjectStatusValue?: ProjectStatusValueOrderByRelationAggregateInput
    _relevance?: OrganizationOrderByRelevanceInput
  }

  export type OrganizationWhereUniqueInput = {
    id?: number
    publicId?: string
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    faxNumber?: StringWithAggregatesFilter | string
    size?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    logoId?: StringNullableWithAggregatesFilter | string | null
  }

  export type EquipmentWhereInput = {
    AND?: Enumerable<EquipmentWhereInput>
    OR?: Enumerable<EquipmentWhereInput>
    NOT?: Enumerable<EquipmentWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    quantity?: IntFilter | number
    organizationId?: IntFilter | number
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    ProjectEquipment?: ProjectEquipmentListRelationFilter
  }

  export type EquipmentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    ProjectEquipment?: ProjectEquipmentOrderByRelationAggregateInput
    _relevance?: EquipmentOrderByRelevanceInput
  }

  export type EquipmentWhereUniqueInput = {
    id?: number
    publicId?: string
  }

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    organizationId?: IntWithAggregatesFilter | number
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    title?: StringFilter | string
    content?: StringFilter | string
    isSeen?: BoolFilter | boolean
    link?: StringNullableFilter | string | null
    linkText?: StringNullableFilter | string | null
    type?: EnumNotificationTypeFilter | NotificationType
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = {
    id?: number
    publicId?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    isSeen?: BoolWithAggregatesFilter | boolean
    link?: StringNullableWithAggregatesFilter | string | null
    linkText?: StringNullableWithAggregatesFilter | string | null
    type?: EnumNotificationTypeWithAggregatesFilter | NotificationType
    userId?: StringWithAggregatesFilter | string
  }

  export type OrganizationSavedOptionWhereInput = {
    AND?: Enumerable<OrganizationSavedOptionWhereInput>
    OR?: Enumerable<OrganizationSavedOptionWhereInput>
    NOT?: Enumerable<OrganizationSavedOptionWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    label?: StringFilter | string
    value?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    type?: EnumSavedOptionTypeFilter | SavedOptionType
    organizationId?: IntFilter | number
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationSavedOptionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: OrganizationSavedOptionOrderByRelevanceInput
  }

  export type OrganizationSavedOptionWhereUniqueInput = {
    id?: number
    publicId?: string
  }

  export type OrganizationSavedOptionOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    _count?: OrganizationSavedOptionCountOrderByAggregateInput
    _avg?: OrganizationSavedOptionAvgOrderByAggregateInput
    _max?: OrganizationSavedOptionMaxOrderByAggregateInput
    _min?: OrganizationSavedOptionMinOrderByAggregateInput
    _sum?: OrganizationSavedOptionSumOrderByAggregateInput
  }

  export type OrganizationSavedOptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationSavedOptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationSavedOptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationSavedOptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    label?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    type?: EnumSavedOptionTypeWithAggregatesFilter | SavedOptionType
    organizationId?: IntWithAggregatesFilter | number
  }

  export type UserToOrganizationWhereInput = {
    AND?: Enumerable<UserToOrganizationWhereInput>
    OR?: Enumerable<UserToOrganizationWhereInput>
    NOT?: Enumerable<UserToOrganizationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isAdmin?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    role?: StringNullableFilter | string | null
    accessLevel?: EnumAccessLevelNullableFilter | AccessLevel | null
    userId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserToOrganizationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: UserToOrganizationOrderByRelevanceInput
  }

  export type UserToOrganizationWhereUniqueInput = {
    id?: number
    userId?: string
  }

  export type UserToOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
    _count?: UserToOrganizationCountOrderByAggregateInput
    _avg?: UserToOrganizationAvgOrderByAggregateInput
    _max?: UserToOrganizationMaxOrderByAggregateInput
    _min?: UserToOrganizationMinOrderByAggregateInput
    _sum?: UserToOrganizationSumOrderByAggregateInput
  }

  export type UserToOrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToOrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToOrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToOrganizationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isAdmin?: BoolWithAggregatesFilter | boolean
    isDeleted?: BoolWithAggregatesFilter | boolean
    organizationId?: IntWithAggregatesFilter | number
    role?: StringNullableWithAggregatesFilter | string | null
    accessLevel?: EnumAccessLevelNullableWithAggregatesFilter | AccessLevel | null
    userId?: StringWithAggregatesFilter | string
  }

  export type OrganizationInvitationWhereInput = {
    AND?: Enumerable<OrganizationInvitationWhereInput>
    OR?: Enumerable<OrganizationInvitationWhereInput>
    NOT?: Enumerable<OrganizationInvitationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    email?: StringFilter | string
    invitationId?: StringFilter | string
    isAccepted?: BoolFilter | boolean
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationInvitationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: OrganizationInvitationOrderByRelevanceInput
  }

  export type OrganizationInvitationWhereUniqueInput = {
    id?: number
    invitationId?: string
  }

  export type OrganizationInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
    _count?: OrganizationInvitationCountOrderByAggregateInput
    _avg?: OrganizationInvitationAvgOrderByAggregateInput
    _max?: OrganizationInvitationMaxOrderByAggregateInput
    _min?: OrganizationInvitationMinOrderByAggregateInput
    _sum?: OrganizationInvitationSumOrderByAggregateInput
  }

  export type OrganizationInvitationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationInvitationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationInvitationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationInvitationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    organizationId?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    invitationId?: StringWithAggregatesFilter | string
    isAccepted?: BoolWithAggregatesFilter | boolean
  }

  export type UserToProjectWhereInput = {
    AND?: Enumerable<UserToProjectWhereInput>
    OR?: Enumerable<UserToProjectWhereInput>
    NOT?: Enumerable<UserToProjectWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    projectId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type UserToProjectOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: UserToProjectOrderByRelevanceInput
  }

  export type UserToProjectWhereUniqueInput = {
    id?: number
    userId_projectId?: UserToProjectUserIdProjectIdCompoundUniqueInput
  }

  export type UserToProjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    _count?: UserToProjectCountOrderByAggregateInput
    _avg?: UserToProjectAvgOrderByAggregateInput
    _max?: UserToProjectMaxOrderByAggregateInput
    _min?: UserToProjectMinOrderByAggregateInput
    _sum?: UserToProjectSumOrderByAggregateInput
  }

  export type UserToProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToProjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    closedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    assignmentNumber?: StringFilter | string
    publicId?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    clientName?: StringFilter | string
    clientEmail?: StringFilter | string
    clientPhoneNumber?: StringFilter | string
    companyName?: StringFilter | string
    managerName?: StringFilter | string
    adjusterEmail?: StringFilter | string
    adjusterName?: StringFilter | string
    adjusterPhoneNumber?: StringFilter | string
    insuranceCompanyName?: StringFilter | string
    insuranceClaimId?: StringFilter | string
    lossType?: StringFilter | string
    catCode?: IntNullableFilter | number | null
    humidity?: StringFilter | string
    lastTimeWeatherFetched?: DateTimeNullableFilter | Date | string | null
    temperature?: StringFilter | string
    wind?: StringFilter | string
    lat?: StringFilter | string
    lng?: StringFilter | string
    forecast?: StringFilter | string
    claimSummary?: StringFilter | string
    roofSegments?: JsonNullableListFilter
    roofSpecs?: JsonNullableFilter
    rcvValue?: FloatNullableFilter | number | null
    actualValue?: FloatNullableFilter | number | null
    status?: EnumProjectStatusNullableFilter | ProjectStatus | null
    projectStatusValueId?: IntNullableFilter | number | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    images?: ImageListRelationFilter
    inferences?: InferenceListRelationFilter
    rooms?: RoomListRelationFilter
    events?: CalendarEventListRelationFilter
    projectAssignees?: UserToProjectListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    propertyData?: XOR<PropertyDataRelationFilter, PropertyDataWhereInput> | null
    AreaAffected?: AreaAffectedListRelationFilter
    photoAccessLinks?: PhotoAccessLinkListRelationFilter
    notes?: NotesListRelationFilter
    costs?: CostListRelationFilter
    projectEquipment?: ProjectEquipmentListRelationFilter
    weatherReportItems?: WeatherReportItemListRelationFilter
    currentStatus?: XOR<ProjectStatusValueRelationFilter, ProjectStatusValueWhereInput> | null
    PendingRoofReports?: PendingRoofReportsListRelationFilter
    ProjectNotes?: ProjectNotesListRelationFilter
  }

  export type ProjectOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    images?: ImageOrderByRelationAggregateInput
    inferences?: InferenceOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    events?: CalendarEventOrderByRelationAggregateInput
    projectAssignees?: UserToProjectOrderByRelationAggregateInput
    roomReadings?: RoomReadingOrderByRelationAggregateInput
    propertyData?: PropertyDataOrderByWithRelationAndSearchRelevanceInput
    AreaAffected?: AreaAffectedOrderByRelationAggregateInput
    photoAccessLinks?: PhotoAccessLinkOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    costs?: CostOrderByRelationAggregateInput
    projectEquipment?: ProjectEquipmentOrderByRelationAggregateInput
    weatherReportItems?: WeatherReportItemOrderByRelationAggregateInput
    currentStatus?: ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput
    PendingRoofReports?: PendingRoofReportsOrderByRelationAggregateInput
    ProjectNotes?: ProjectNotesOrderByRelationAggregateInput
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = {
    id?: number
    publicId?: string
  }

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    organizationId?: IntWithAggregatesFilter | number
    assignmentNumber?: StringWithAggregatesFilter | string
    publicId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    clientName?: StringWithAggregatesFilter | string
    clientEmail?: StringWithAggregatesFilter | string
    clientPhoneNumber?: StringWithAggregatesFilter | string
    companyName?: StringWithAggregatesFilter | string
    managerName?: StringWithAggregatesFilter | string
    adjusterEmail?: StringWithAggregatesFilter | string
    adjusterName?: StringWithAggregatesFilter | string
    adjusterPhoneNumber?: StringWithAggregatesFilter | string
    insuranceCompanyName?: StringWithAggregatesFilter | string
    insuranceClaimId?: StringWithAggregatesFilter | string
    lossType?: StringWithAggregatesFilter | string
    catCode?: IntNullableWithAggregatesFilter | number | null
    humidity?: StringWithAggregatesFilter | string
    lastTimeWeatherFetched?: DateTimeNullableWithAggregatesFilter | Date | string | null
    temperature?: StringWithAggregatesFilter | string
    wind?: StringWithAggregatesFilter | string
    lat?: StringWithAggregatesFilter | string
    lng?: StringWithAggregatesFilter | string
    forecast?: StringWithAggregatesFilter | string
    claimSummary?: StringWithAggregatesFilter | string
    roofSegments?: JsonNullableListFilter
    roofSpecs?: JsonNullableWithAggregatesFilter
    rcvValue?: FloatNullableWithAggregatesFilter | number | null
    actualValue?: FloatNullableWithAggregatesFilter | number | null
    status?: EnumProjectStatusNullableWithAggregatesFilter | ProjectStatus | null
    projectStatusValueId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ProjectNotesWhereInput = {
    AND?: Enumerable<ProjectNotesWhereInput>
    OR?: Enumerable<ProjectNotesWhereInput>
    NOT?: Enumerable<ProjectNotesWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    date?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    body?: StringFilter | string
    mentions?: StringNullableListFilter
    userId?: StringFilter | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectNotesOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProjectNotesOrderByRelevanceInput
  }

  export type ProjectNotesWhereUniqueInput = {
    id?: number
  }

  export type ProjectNotesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    _count?: ProjectNotesCountOrderByAggregateInput
    _avg?: ProjectNotesAvgOrderByAggregateInput
    _max?: ProjectNotesMaxOrderByAggregateInput
    _min?: ProjectNotesMinOrderByAggregateInput
    _sum?: ProjectNotesSumOrderByAggregateInput
  }

  export type ProjectNotesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectNotesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectNotesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectNotesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    body?: StringWithAggregatesFilter | string
    mentions?: StringNullableListFilter
    userId?: StringWithAggregatesFilter | string
  }

  export type ProjectStatusValueWhereInput = {
    AND?: Enumerable<ProjectStatusValueWhereInput>
    OR?: Enumerable<ProjectStatusValueWhereInput>
    NOT?: Enumerable<ProjectStatusValueWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: UuidFilter | string
    label?: StringFilter | string
    description?: StringFilter | string
    color?: StringFilter | string
    order?: IntNullableFilter | number | null
    organizationId?: IntFilter | number
    projects?: ProjectListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type ProjectStatusValueOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProjectStatusValueOrderByRelevanceInput
  }

  export type ProjectStatusValueWhereUniqueInput = {
    id?: number
    publicId?: string
    organizationId_label?: ProjectStatusValueOrganizationIdLabelCompoundUniqueInput
  }

  export type ProjectStatusValueOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
    _count?: ProjectStatusValueCountOrderByAggregateInput
    _avg?: ProjectStatusValueAvgOrderByAggregateInput
    _max?: ProjectStatusValueMaxOrderByAggregateInput
    _min?: ProjectStatusValueMinOrderByAggregateInput
    _sum?: ProjectStatusValueSumOrderByAggregateInput
  }

  export type ProjectStatusValueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectStatusValueScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectStatusValueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectStatusValueScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: UuidWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    color?: StringWithAggregatesFilter | string
    order?: IntNullableWithAggregatesFilter | number | null
    organizationId?: IntWithAggregatesFilter | number
  }

  export type PendingRoofReportsWhereInput = {
    AND?: Enumerable<PendingRoofReportsWhereInput>
    OR?: Enumerable<PendingRoofReportsWhereInput>
    NOT?: Enumerable<PendingRoofReportsWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    projectId?: IntFilter | number
    isCompleted?: BoolFilter | boolean
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type PendingRoofReportsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
  }

  export type PendingRoofReportsWhereUniqueInput = {
    id?: number
  }

  export type PendingRoofReportsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
    _count?: PendingRoofReportsCountOrderByAggregateInput
    _avg?: PendingRoofReportsAvgOrderByAggregateInput
    _max?: PendingRoofReportsMaxOrderByAggregateInput
    _min?: PendingRoofReportsMinOrderByAggregateInput
    _sum?: PendingRoofReportsSumOrderByAggregateInput
  }

  export type PendingRoofReportsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PendingRoofReportsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PendingRoofReportsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PendingRoofReportsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    projectId?: IntWithAggregatesFilter | number
    isCompleted?: BoolWithAggregatesFilter | boolean
  }

  export type WeatherReportItemWhereInput = {
    AND?: Enumerable<WeatherReportItemWhereInput>
    OR?: Enumerable<WeatherReportItemWhereInput>
    NOT?: Enumerable<WeatherReportItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    projectId?: IntFilter | number
    date?: DateTimeFilter | Date | string
    time?: StringFilter | string
    f_scale?: StringNullableFilter | string | null
    speed?: StringNullableFilter | string | null
    size?: StringNullableFilter | string | null
    location?: StringFilter | string
    county?: StringFilter | string
    state?: StringFilter | string
    lat?: StringFilter | string
    lon?: StringFilter | string
    comments?: StringFilter | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type WeatherReportItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: WeatherReportItemOrderByRelevanceInput
  }

  export type WeatherReportItemWhereUniqueInput = {
    id?: number
  }

  export type WeatherReportItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
    _count?: WeatherReportItemCountOrderByAggregateInput
    _avg?: WeatherReportItemAvgOrderByAggregateInput
    _max?: WeatherReportItemMaxOrderByAggregateInput
    _min?: WeatherReportItemMinOrderByAggregateInput
    _sum?: WeatherReportItemSumOrderByAggregateInput
  }

  export type WeatherReportItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WeatherReportItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<WeatherReportItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WeatherReportItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    projectId?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    time?: StringWithAggregatesFilter | string
    f_scale?: StringNullableWithAggregatesFilter | string | null
    speed?: StringNullableWithAggregatesFilter | string | null
    size?: StringNullableWithAggregatesFilter | string | null
    location?: StringWithAggregatesFilter | string
    county?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    lat?: StringWithAggregatesFilter | string
    lon?: StringWithAggregatesFilter | string
    comments?: StringWithAggregatesFilter | string
  }

  export type ProjectEquipmentWhereInput = {
    AND?: Enumerable<ProjectEquipmentWhereInput>
    OR?: Enumerable<ProjectEquipmentWhereInput>
    NOT?: Enumerable<ProjectEquipmentWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    quantity?: IntFilter | number
    projectId?: IntFilter | number
    equipmentId?: IntFilter | number
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectEquipmentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
    equipment?: EquipmentOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProjectEquipmentOrderByRelevanceInput
  }

  export type ProjectEquipmentWhereUniqueInput = {
    id?: number
    publicId?: string
    equipmentId_projectId?: ProjectEquipmentEquipmentIdProjectIdCompoundUniqueInput
  }

  export type ProjectEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
    _count?: ProjectEquipmentCountOrderByAggregateInput
    _avg?: ProjectEquipmentAvgOrderByAggregateInput
    _max?: ProjectEquipmentMaxOrderByAggregateInput
    _min?: ProjectEquipmentMinOrderByAggregateInput
    _sum?: ProjectEquipmentSumOrderByAggregateInput
  }

  export type ProjectEquipmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectEquipmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectEquipmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectEquipmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    quantity?: IntWithAggregatesFilter | number
    projectId?: IntWithAggregatesFilter | number
    equipmentId?: IntWithAggregatesFilter | number
  }

  export type CostWhereInput = {
    AND?: Enumerable<CostWhereInput>
    OR?: Enumerable<CostWhereInput>
    NOT?: Enumerable<CostWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    estimatedCost?: FloatNullableFilter | number | null
    actualCost?: FloatNullableFilter | number | null
    name?: StringNullableFilter | string | null
    projectId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    type?: EnumCostTypeFilter | CostType
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type CostOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CostOrderByRelevanceInput
  }

  export type CostWhereUniqueInput = {
    id?: number
  }

  export type CostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    _count?: CostCountOrderByAggregateInput
    _avg?: CostAvgOrderByAggregateInput
    _max?: CostMaxOrderByAggregateInput
    _min?: CostMinOrderByAggregateInput
    _sum?: CostSumOrderByAggregateInput
  }

  export type CostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CostScalarWhereWithAggregatesInput>
    OR?: Enumerable<CostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    estimatedCost?: FloatNullableWithAggregatesFilter | number | null
    actualCost?: FloatNullableWithAggregatesFilter | number | null
    name?: StringNullableWithAggregatesFilter | string | null
    projectId?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    type?: EnumCostTypeWithAggregatesFilter | CostType
  }

  export type PropertyDataWhereInput = {
    AND?: Enumerable<PropertyDataWhereInput>
    OR?: Enumerable<PropertyDataWhereInput>
    NOT?: Enumerable<PropertyDataWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    projectId?: IntNullableFilter | number | null
    bathrooms?: FloatNullableFilter | number | null
    bedrooms?: IntNullableFilter | number | null
    squareFootage?: IntNullableFilter | number | null
    realtyMoleId?: StringNullableFilter | string | null
    data?: JsonNullableFilter
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
  }

  export type PropertyDataOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
    data?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PropertyDataOrderByRelevanceInput
  }

  export type PropertyDataWhereUniqueInput = {
    id?: number
    projectId?: number
  }

  export type PropertyDataOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
    data?: SortOrder
    _count?: PropertyDataCountOrderByAggregateInput
    _avg?: PropertyDataAvgOrderByAggregateInput
    _max?: PropertyDataMaxOrderByAggregateInput
    _min?: PropertyDataMinOrderByAggregateInput
    _sum?: PropertyDataSumOrderByAggregateInput
  }

  export type PropertyDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PropertyDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<PropertyDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PropertyDataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    projectId?: IntNullableWithAggregatesFilter | number | null
    bathrooms?: FloatNullableWithAggregatesFilter | number | null
    bedrooms?: IntNullableWithAggregatesFilter | number | null
    squareFootage?: IntNullableWithAggregatesFilter | number | null
    realtyMoleId?: StringNullableWithAggregatesFilter | string | null
    data?: JsonNullableWithAggregatesFilter
  }

  export type DataDeletionRequestWhereInput = {
    AND?: Enumerable<DataDeletionRequestWhereInput>
    OR?: Enumerable<DataDeletionRequestWhereInput>
    NOT?: Enumerable<DataDeletionRequestWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    fullName?: StringFilter | string
    email?: StringFilter | string
    isVerified?: BoolFilter | boolean
  }

  export type DataDeletionRequestOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    _relevance?: DataDeletionRequestOrderByRelevanceInput
  }

  export type DataDeletionRequestWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type DataDeletionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    _count?: DataDeletionRequestCountOrderByAggregateInput
    _avg?: DataDeletionRequestAvgOrderByAggregateInput
    _max?: DataDeletionRequestMaxOrderByAggregateInput
    _min?: DataDeletionRequestMinOrderByAggregateInput
    _sum?: DataDeletionRequestSumOrderByAggregateInput
  }

  export type DataDeletionRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DataDeletionRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<DataDeletionRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DataDeletionRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    fullName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    isVerified?: BoolWithAggregatesFilter | boolean
  }

  export type PhotoAccessLinkWhereInput = {
    AND?: Enumerable<PhotoAccessLinkWhereInput>
    OR?: Enumerable<PhotoAccessLinkWhereInput>
    NOT?: Enumerable<PhotoAccessLinkWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    accessId?: StringFilter | string
    email?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    projectId?: IntFilter | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type PhotoAccessLinkOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PhotoAccessLinkOrderByRelevanceInput
  }

  export type PhotoAccessLinkWhereUniqueInput = {
    id?: number
    accessId?: string
  }

  export type PhotoAccessLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
    _count?: PhotoAccessLinkCountOrderByAggregateInput
    _avg?: PhotoAccessLinkAvgOrderByAggregateInput
    _max?: PhotoAccessLinkMaxOrderByAggregateInput
    _min?: PhotoAccessLinkMinOrderByAggregateInput
    _sum?: PhotoAccessLinkSumOrderByAggregateInput
  }

  export type PhotoAccessLinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhotoAccessLinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhotoAccessLinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhotoAccessLinkScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    accessId?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    projectId?: IntWithAggregatesFilter | number
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    key?: StringFilter | string
    projectId?: IntFilter | number
    organizationId?: IntNullableFilter | number | null
    includeInReport?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    inference?: XOR<InferenceRelationFilter, InferenceWhereInput> | null
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
  }

  export type ImageOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    inference?: InferenceOrderByWithRelationAndSearchRelevanceInput
    ImageNote?: ImageNoteOrderByRelationAggregateInput
    Annotation?: AnnotationOrderByRelationAggregateInput
    _relevance?: ImageOrderByRelevanceInput
  }

  export type ImageWhereUniqueInput = {
    id?: number
    publicId?: string
    key?: string
  }

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    organizationId?: IntNullableWithAggregatesFilter | number | null
    includeInReport?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type AnnotationWhereInput = {
    AND?: Enumerable<AnnotationWhereInput>
    OR?: Enumerable<AnnotationWhereInput>
    NOT?: Enumerable<AnnotationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    imageId?: IntFilter | number
    coordinates?: JsonFilter
    userId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    Image?: XOR<ImageRelationFilter, ImageWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AnnotationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    Image?: ImageOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AnnotationOrderByRelevanceInput
  }

  export type AnnotationWhereUniqueInput = {
    id?: number
  }

  export type AnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    _count?: AnnotationCountOrderByAggregateInput
    _avg?: AnnotationAvgOrderByAggregateInput
    _max?: AnnotationMaxOrderByAggregateInput
    _min?: AnnotationMinOrderByAggregateInput
    _sum?: AnnotationSumOrderByAggregateInput
  }

  export type AnnotationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnnotationScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnnotationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnnotationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    imageId?: IntWithAggregatesFilter | number
    coordinates?: JsonWithAggregatesFilter
    userId?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type ImageNoteWhereInput = {
    AND?: Enumerable<ImageNoteWhereInput>
    OR?: Enumerable<ImageNoteWhereInput>
    NOT?: Enumerable<ImageNoteWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    imageId?: IntFilter | number
    body?: StringFilter | string
    mentions?: StringNullableListFilter
    userId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    Image?: XOR<ImageRelationFilter, ImageWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ImageNoteOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    Image?: ImageOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ImageNoteOrderByRelevanceInput
  }

  export type ImageNoteWhereUniqueInput = {
    id?: number
  }

  export type ImageNoteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    _count?: ImageNoteCountOrderByAggregateInput
    _avg?: ImageNoteAvgOrderByAggregateInput
    _max?: ImageNoteMaxOrderByAggregateInput
    _min?: ImageNoteMinOrderByAggregateInput
    _sum?: ImageNoteSumOrderByAggregateInput
  }

  export type ImageNoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageNoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageNoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageNoteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    imageId?: IntWithAggregatesFilter | number
    body?: StringWithAggregatesFilter | string
    mentions?: StringNullableListFilter
    userId?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type InferenceWhereInput = {
    AND?: Enumerable<InferenceWhereInput>
    OR?: Enumerable<InferenceWhereInput>
    NOT?: Enumerable<InferenceWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    imageId?: IntNullableFilter | number | null
    imageKey?: StringNullableFilter | string | null
    projectId?: IntFilter | number
    roomId?: IntNullableFilter | number | null
    image?: XOR<ImageRelationFilter, ImageWhereInput> | null
    Project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput> | null
    detections?: DetectionListRelationFilter
  }

  export type InferenceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    image?: ImageOrderByWithRelationAndSearchRelevanceInput
    Project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    detections?: DetectionOrderByRelationAggregateInput
    _relevance?: InferenceOrderByRelevanceInput
  }

  export type InferenceWhereUniqueInput = {
    id?: number
    publicId?: string
    imageId?: number
    imageKey?: string
  }

  export type InferenceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    _count?: InferenceCountOrderByAggregateInput
    _avg?: InferenceAvgOrderByAggregateInput
    _max?: InferenceMaxOrderByAggregateInput
    _min?: InferenceMinOrderByAggregateInput
    _sum?: InferenceSumOrderByAggregateInput
  }

  export type InferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InferenceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    imageId?: IntNullableWithAggregatesFilter | number | null
    imageKey?: StringNullableWithAggregatesFilter | string | null
    projectId?: IntWithAggregatesFilter | number
    roomId?: IntNullableWithAggregatesFilter | number | null
  }

  export type RoomWhereInput = {
    AND?: Enumerable<RoomWhereInput>
    OR?: Enumerable<RoomWhereInput>
    NOT?: Enumerable<RoomWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    name?: StringFilter | string
    projectId?: IntFilter | number
    gpp?: StringNullableFilter | string | null
    humidity?: StringNullableFilter | string | null
    dehuReading?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    totalSqft?: StringNullableFilter | string | null
    windows?: IntNullableFilter | number | null
    doors?: IntNullableFilter | number | null
    equipmentUsed?: StringNullableListFilter
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    detections?: DetectionListRelationFilter
    inferences?: InferenceListRelationFilter
    templates?: TemplatesUsedListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    areasAffected?: AreaAffectedListRelationFilter
    notes?: NotesListRelationFilter
  }

  export type RoomOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
    equipmentUsed?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    detections?: DetectionOrderByRelationAggregateInput
    inferences?: InferenceOrderByRelationAggregateInput
    templates?: TemplatesUsedOrderByRelationAggregateInput
    roomReadings?: RoomReadingOrderByRelationAggregateInput
    areasAffected?: AreaAffectedOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    _relevance?: RoomOrderByRelevanceInput
  }

  export type RoomWhereUniqueInput = {
    id?: number
    publicId?: string
    projectId_name?: RoomProjectIdNameCompoundUniqueInput
  }

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
    equipmentUsed?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoomScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoomScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoomScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    gpp?: StringNullableWithAggregatesFilter | string | null
    humidity?: StringNullableWithAggregatesFilter | string | null
    dehuReading?: StringNullableWithAggregatesFilter | string | null
    temperature?: StringNullableWithAggregatesFilter | string | null
    length?: StringNullableWithAggregatesFilter | string | null
    width?: StringNullableWithAggregatesFilter | string | null
    height?: StringNullableWithAggregatesFilter | string | null
    totalSqft?: StringNullableWithAggregatesFilter | string | null
    windows?: IntNullableWithAggregatesFilter | number | null
    doors?: IntNullableWithAggregatesFilter | number | null
    equipmentUsed?: StringNullableListFilter
  }

  export type RoomReadingWhereInput = {
    AND?: Enumerable<RoomReadingWhereInput>
    OR?: Enumerable<RoomReadingWhereInput>
    NOT?: Enumerable<RoomReadingWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    date?: DateTimeFilter | Date | string
    humidity?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    moistureContentWall?: StringNullableFilter | string | null
    moistureContentFloor?: StringNullableFilter | string | null
    equipmentUsed?: StringNullableListFilter
    roomId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    gpp?: StringNullableFilter | string | null
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    genericRoomReadings?: GenericRoomReadingListRelationFilter
  }

  export type RoomReadingOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    genericRoomReadings?: GenericRoomReadingOrderByRelationAggregateInput
    _relevance?: RoomReadingOrderByRelevanceInput
  }

  export type RoomReadingWhereUniqueInput = {
    id?: number
  }

  export type RoomReadingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    _count?: RoomReadingCountOrderByAggregateInput
    _avg?: RoomReadingAvgOrderByAggregateInput
    _max?: RoomReadingMaxOrderByAggregateInput
    _min?: RoomReadingMinOrderByAggregateInput
    _sum?: RoomReadingSumOrderByAggregateInput
  }

  export type RoomReadingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoomReadingScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoomReadingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoomReadingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    date?: DateTimeWithAggregatesFilter | Date | string
    humidity?: StringNullableWithAggregatesFilter | string | null
    temperature?: StringNullableWithAggregatesFilter | string | null
    moistureContentWall?: StringNullableWithAggregatesFilter | string | null
    moistureContentFloor?: StringNullableWithAggregatesFilter | string | null
    equipmentUsed?: StringNullableListFilter
    roomId?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    gpp?: StringNullableWithAggregatesFilter | string | null
  }

  export type NotesWhereInput = {
    AND?: Enumerable<NotesWhereInput>
    OR?: Enumerable<NotesWhereInput>
    NOT?: Enumerable<NotesWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    date?: DateTimeFilter | Date | string
    roomId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    body?: StringFilter | string
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    notesAuditTrail?: NotesAuditTrailListRelationFilter
  }

  export type NotesOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    notesAuditTrail?: NotesAuditTrailOrderByRelationAggregateInput
    _relevance?: NotesOrderByRelevanceInput
  }

  export type NotesWhereUniqueInput = {
    id?: number
  }

  export type NotesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    _count?: NotesCountOrderByAggregateInput
    _avg?: NotesAvgOrderByAggregateInput
    _max?: NotesMaxOrderByAggregateInput
    _min?: NotesMinOrderByAggregateInput
    _sum?: NotesSumOrderByAggregateInput
  }

  export type NotesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotesScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    roomId?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    body?: StringWithAggregatesFilter | string
  }

  export type NotesAuditTrailWhereInput = {
    AND?: Enumerable<NotesAuditTrailWhereInput>
    OR?: Enumerable<NotesAuditTrailWhereInput>
    NOT?: Enumerable<NotesAuditTrailWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    notesId?: IntFilter | number
    userId?: StringFilter | string
    userName?: StringNullableFilter | string | null
    action?: EnumNotesAuditActionFilter | NotesAuditAction
    body?: StringFilter | string
    note?: XOR<NotesRelationFilter, NotesWhereInput>
  }

  export type NotesAuditTrailOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
    note?: NotesOrderByWithRelationAndSearchRelevanceInput
    _relevance?: NotesAuditTrailOrderByRelevanceInput
  }

  export type NotesAuditTrailWhereUniqueInput = {
    id?: number
  }

  export type NotesAuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
    _count?: NotesAuditTrailCountOrderByAggregateInput
    _avg?: NotesAuditTrailAvgOrderByAggregateInput
    _max?: NotesAuditTrailMaxOrderByAggregateInput
    _min?: NotesAuditTrailMinOrderByAggregateInput
    _sum?: NotesAuditTrailSumOrderByAggregateInput
  }

  export type NotesAuditTrailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotesAuditTrailScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotesAuditTrailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotesAuditTrailScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    notesId?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    userName?: StringNullableWithAggregatesFilter | string | null
    action?: EnumNotesAuditActionWithAggregatesFilter | NotesAuditAction
    body?: StringWithAggregatesFilter | string
  }

  export type AreaAffectedWhereInput = {
    AND?: Enumerable<AreaAffectedWhereInput>
    OR?: Enumerable<AreaAffectedWhereInput>
    NOT?: Enumerable<AreaAffectedWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    date?: DateTimeFilter | Date | string
    roomId?: IntFilter | number
    material?: StringNullableFilter | string | null
    totalAreaRemoved?: StringNullableFilter | string | null
    totalAreaMicrobialApplied?: StringNullableFilter | string | null
    cause?: StringNullableFilter | string | null
    category?: IntNullableFilter | number | null
    cabinetryRemoved?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    type?: EnumAreaAffectedTypeFilter | AreaAffectedType
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type AreaAffectedOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AreaAffectedOrderByRelevanceInput
  }

  export type AreaAffectedWhereUniqueInput = {
    id?: number
    type_roomId?: AreaAffectedTypeRoomIdCompoundUniqueInput
  }

  export type AreaAffectedOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    _count?: AreaAffectedCountOrderByAggregateInput
    _avg?: AreaAffectedAvgOrderByAggregateInput
    _max?: AreaAffectedMaxOrderByAggregateInput
    _min?: AreaAffectedMinOrderByAggregateInput
    _sum?: AreaAffectedSumOrderByAggregateInput
  }

  export type AreaAffectedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AreaAffectedScalarWhereWithAggregatesInput>
    OR?: Enumerable<AreaAffectedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AreaAffectedScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    date?: DateTimeWithAggregatesFilter | Date | string
    roomId?: IntWithAggregatesFilter | number
    material?: StringNullableWithAggregatesFilter | string | null
    totalAreaRemoved?: StringNullableWithAggregatesFilter | string | null
    totalAreaMicrobialApplied?: StringNullableWithAggregatesFilter | string | null
    cause?: StringNullableWithAggregatesFilter | string | null
    category?: IntNullableWithAggregatesFilter | number | null
    cabinetryRemoved?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    projectId?: IntWithAggregatesFilter | number
    type?: EnumAreaAffectedTypeWithAggregatesFilter | AreaAffectedType
  }

  export type GenericRoomReadingWhereInput = {
    AND?: Enumerable<GenericRoomReadingWhereInput>
    OR?: Enumerable<GenericRoomReadingWhereInput>
    NOT?: Enumerable<GenericRoomReadingWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    publicId?: StringFilter | string
    type?: EnumRoomReadingTypeFilter | RoomReadingType
    value?: StringFilter | string
    humidity?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    gpp?: StringNullableFilter | string | null
    roomReadingId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    roomReading?: XOR<RoomReadingRelationFilter, RoomReadingWhereInput>
  }

  export type GenericRoomReadingOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
    roomReading?: RoomReadingOrderByWithRelationAndSearchRelevanceInput
    _relevance?: GenericRoomReadingOrderByRelevanceInput
  }

  export type GenericRoomReadingWhereUniqueInput = {
    id?: number
  }

  export type GenericRoomReadingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
    _count?: GenericRoomReadingCountOrderByAggregateInput
    _avg?: GenericRoomReadingAvgOrderByAggregateInput
    _max?: GenericRoomReadingMaxOrderByAggregateInput
    _min?: GenericRoomReadingMinOrderByAggregateInput
    _sum?: GenericRoomReadingSumOrderByAggregateInput
  }

  export type GenericRoomReadingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GenericRoomReadingScalarWhereWithAggregatesInput>
    OR?: Enumerable<GenericRoomReadingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GenericRoomReadingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    publicId?: StringWithAggregatesFilter | string
    type?: EnumRoomReadingTypeWithAggregatesFilter | RoomReadingType
    value?: StringWithAggregatesFilter | string
    humidity?: StringNullableWithAggregatesFilter | string | null
    temperature?: StringNullableWithAggregatesFilter | string | null
    gpp?: StringNullableWithAggregatesFilter | string | null
    roomReadingId?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type DetectionWhereInput = {
    AND?: Enumerable<DetectionWhereInput>
    OR?: Enumerable<DetectionWhereInput>
    NOT?: Enumerable<DetectionWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    inferenceId?: IntFilter | number
    imageKey?: StringNullableFilter | string | null
    xMinCord?: FloatNullableFilter | number | null
    yMinCord?: FloatNullableFilter | number | null
    confidence?: FloatNullableFilter | number | null
    xMaxCord?: FloatNullableFilter | number | null
    yMaxCord?: FloatNullableFilter | number | null
    projectId?: IntFilter | number
    category?: StringFilter | string
    code?: StringFilter | string
    item?: StringFilter | string
    quality?: StringFilter | string
    roomId?: IntNullableFilter | number | null
    dimension?: IntNullableFilter | number | null
    unit?: EnumDimensionUnitNullableFilter | DimensionUnit | null
    inference?: XOR<InferenceRelationFilter, InferenceWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput> | null
  }

  export type DetectionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
    inference?: InferenceOrderByWithRelationAndSearchRelevanceInput
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    _relevance?: DetectionOrderByRelevanceInput
  }

  export type DetectionWhereUniqueInput = {
    id?: number
    publicId?: string
    projectId_category_code_roomId?: DetectionProjectIdCategoryCodeRoomIdCompoundUniqueInput
  }

  export type DetectionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
    _count?: DetectionCountOrderByAggregateInput
    _avg?: DetectionAvgOrderByAggregateInput
    _max?: DetectionMaxOrderByAggregateInput
    _min?: DetectionMinOrderByAggregateInput
    _sum?: DetectionSumOrderByAggregateInput
  }

  export type DetectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DetectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DetectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DetectionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    publicId?: StringWithAggregatesFilter | string
    inferenceId?: IntWithAggregatesFilter | number
    imageKey?: StringNullableWithAggregatesFilter | string | null
    xMinCord?: FloatNullableWithAggregatesFilter | number | null
    yMinCord?: FloatNullableWithAggregatesFilter | number | null
    confidence?: FloatNullableWithAggregatesFilter | number | null
    xMaxCord?: FloatNullableWithAggregatesFilter | number | null
    yMaxCord?: FloatNullableWithAggregatesFilter | number | null
    projectId?: IntWithAggregatesFilter | number
    category?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    item?: StringWithAggregatesFilter | string
    quality?: StringWithAggregatesFilter | string
    roomId?: IntNullableWithAggregatesFilter | number | null
    dimension?: IntNullableWithAggregatesFilter | number | null
    unit?: EnumDimensionUnitNullableWithAggregatesFilter | DimensionUnit | null
  }

  export type TemplatesUsedWhereInput = {
    AND?: Enumerable<TemplatesUsedWhereInput>
    OR?: Enumerable<TemplatesUsedWhereInput>
    NOT?: Enumerable<TemplatesUsedWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    templateCode?: StringFilter | string
    roomId?: IntNullableFilter | number | null
    room?: XOR<RoomRelationFilter, RoomWhereInput> | null
  }

  export type TemplatesUsedOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
    room?: RoomOrderByWithRelationAndSearchRelevanceInput
    _relevance?: TemplatesUsedOrderByRelevanceInput
  }

  export type TemplatesUsedWhereUniqueInput = {
    id?: number
  }

  export type TemplatesUsedOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
    _count?: TemplatesUsedCountOrderByAggregateInput
    _avg?: TemplatesUsedAvgOrderByAggregateInput
    _max?: TemplatesUsedMaxOrderByAggregateInput
    _min?: TemplatesUsedMinOrderByAggregateInput
    _sum?: TemplatesUsedSumOrderByAggregateInput
  }

  export type TemplatesUsedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplatesUsedScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplatesUsedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplatesUsedScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    templateCode?: StringWithAggregatesFilter | string
    roomId?: IntNullableWithAggregatesFilter | number | null
  }

  export type WaitListWhereInput = {
    AND?: Enumerable<WaitListWhereInput>
    OR?: Enumerable<WaitListWhereInput>
    NOT?: Enumerable<WaitListWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    email?: StringFilter | string
  }

  export type WaitListOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    _relevance?: WaitListOrderByRelevanceInput
  }

  export type WaitListWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type WaitListOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    _count?: WaitListCountOrderByAggregateInput
    _avg?: WaitListAvgOrderByAggregateInput
    _max?: WaitListMaxOrderByAggregateInput
    _min?: WaitListMinOrderByAggregateInput
    _sum?: WaitListSumOrderByAggregateInput
  }

  export type WaitListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WaitListScalarWhereWithAggregatesInput>
    OR?: Enumerable<WaitListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WaitListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
  }

  export type RekognitionRunsWhereInput = {
    AND?: Enumerable<RekognitionRunsWhereInput>
    OR?: Enumerable<RekognitionRunsWhereInput>
    NOT?: Enumerable<RekognitionRunsWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RekognitionRunsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsWhereUniqueInput = {
    id?: number
  }

  export type RekognitionRunsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    _count?: RekognitionRunsCountOrderByAggregateInput
    _avg?: RekognitionRunsAvgOrderByAggregateInput
    _max?: RekognitionRunsMaxOrderByAggregateInput
    _min?: RekognitionRunsMinOrderByAggregateInput
    _sum?: RekognitionRunsSumOrderByAggregateInput
  }

  export type RekognitionRunsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RekognitionRunsScalarWhereWithAggregatesInput>
    OR?: Enumerable<RekognitionRunsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RekognitionRunsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: Enumerable<CalendarEventWhereInput>
    OR?: Enumerable<CalendarEventWhereInput>
    NOT?: Enumerable<CalendarEventWhereInput>
    id?: IntFilter | number
    publicId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subject?: StringFilter | string
    payload?: StringFilter | string
    projectId?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    dynamicId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    remindClient?: BoolFilter | boolean
    remindProjectOwners?: BoolFilter | boolean
    reminders?: CalendarEventReminderListRelationFilter
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
  }

  export type CalendarEventOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
    reminders?: CalendarEventReminderOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CalendarEventOrderByRelevanceInput
  }

  export type CalendarEventWhereUniqueInput = {
    id?: number
    publicId?: string
    dynamicId?: string
  }

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _avg?: CalendarEventAvgOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
    _sum?: CalendarEventSumOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CalendarEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<CalendarEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CalendarEventScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    publicId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    subject?: StringWithAggregatesFilter | string
    payload?: StringWithAggregatesFilter | string
    projectId?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
    dynamicId?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    remindClient?: BoolWithAggregatesFilter | boolean
    remindProjectOwners?: BoolWithAggregatesFilter | boolean
  }

  export type CalendarEventReminderWhereInput = {
    AND?: Enumerable<CalendarEventReminderWhereInput>
    OR?: Enumerable<CalendarEventReminderWhereInput>
    NOT?: Enumerable<CalendarEventReminderWhereInput>
    id?: IntFilter | number
    reminderTarget?: EnumReminderTargetFilter | ReminderTarget
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sendText?: BoolFilter | boolean
    sendEmail?: BoolFilter | boolean
    textSentAt?: DateTimeNullableFilter | Date | string | null
    emailSentAt?: DateTimeNullableFilter | Date | string | null
    calendarEventId?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    calendarEvent?: XOR<CalendarEventRelationFilter, CalendarEventWhereInput> | null
  }

  export type CalendarEventReminderOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
    calendarEvent?: CalendarEventOrderByWithRelationAndSearchRelevanceInput
  }

  export type CalendarEventReminderWhereUniqueInput = {
    id?: number
  }

  export type CalendarEventReminderOrderByWithAggregationInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
    _count?: CalendarEventReminderCountOrderByAggregateInput
    _avg?: CalendarEventReminderAvgOrderByAggregateInput
    _max?: CalendarEventReminderMaxOrderByAggregateInput
    _min?: CalendarEventReminderMinOrderByAggregateInput
    _sum?: CalendarEventReminderSumOrderByAggregateInput
  }

  export type CalendarEventReminderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CalendarEventReminderScalarWhereWithAggregatesInput>
    OR?: Enumerable<CalendarEventReminderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CalendarEventReminderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reminderTarget?: EnumReminderTargetWithAggregatesFilter | ReminderTarget
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    sendText?: BoolWithAggregatesFilter | boolean
    sendEmail?: BoolWithAggregatesFilter | boolean
    textSentAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    emailSentAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    calendarEventId?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemCategoryWhereInput = {
    AND?: Enumerable<ItemCategoryWhereInput>
    OR?: Enumerable<ItemCategoryWhereInput>
    NOT?: Enumerable<ItemCategoryWhereInput>
    id?: IntFilter | number
    xactimateKey?: StringFilter | string
    xactimateDescription?: StringFilter | string
    hasItems?: BoolFilter | boolean
    LineItem?: LineItemListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
    LineItem?: LineItemOrderByRelationAggregateInput
    _relevance?: ItemCategoryOrderByRelevanceInput
  }

  export type ItemCategoryWhereUniqueInput = {
    id?: number
    xactimateKey?: string
  }

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    xactimateKey?: StringWithAggregatesFilter | string
    xactimateDescription?: StringWithAggregatesFilter | string
    hasItems?: BoolWithAggregatesFilter | boolean
  }

  export type LineItemWhereInput = {
    AND?: Enumerable<LineItemWhereInput>
    OR?: Enumerable<LineItemWhereInput>
    NOT?: Enumerable<LineItemWhereInput>
    id?: IntFilter | number
    xactimateCode?: StringFilter | string
    xactimateDescription?: StringFilter | string
    unit?: StringNullableFilter | string | null
    itemCategoryId?: IntFilter | number
    xactimateCategory?: XOR<ItemCategoryRelationFilter, ItemCategoryWhereInput>
    alternateItem?: AlternateItemListRelationFilter
    relatedItem?: RelatedItemListRelationFilter
  }

  export type LineItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
    xactimateCategory?: ItemCategoryOrderByWithRelationAndSearchRelevanceInput
    alternateItem?: AlternateItemOrderByRelationAggregateInput
    relatedItem?: RelatedItemOrderByRelationAggregateInput
    _relevance?: LineItemOrderByRelevanceInput
  }

  export type LineItemWhereUniqueInput = {
    id?: number
    itemCategoryId_xactimateCode?: LineItemItemCategoryIdXactimateCodeCompoundUniqueInput
  }

  export type LineItemOrderByWithAggregationInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
    _count?: LineItemCountOrderByAggregateInput
    _avg?: LineItemAvgOrderByAggregateInput
    _max?: LineItemMaxOrderByAggregateInput
    _min?: LineItemMinOrderByAggregateInput
    _sum?: LineItemSumOrderByAggregateInput
  }

  export type LineItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LineItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<LineItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LineItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    xactimateCode?: StringWithAggregatesFilter | string
    xactimateDescription?: StringWithAggregatesFilter | string
    unit?: StringNullableWithAggregatesFilter | string | null
    itemCategoryId?: IntWithAggregatesFilter | number
  }

  export type RelatedItemWhereInput = {
    AND?: Enumerable<RelatedItemWhereInput>
    OR?: Enumerable<RelatedItemWhereInput>
    NOT?: Enumerable<RelatedItemWhereInput>
    id?: IntFilter | number
    relationId?: StringFilter | string
    lineItemId?: IntFilter | number
    lineItem?: XOR<LineItemRelationFilter, LineItemWhereInput>
  }

  export type RelatedItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
    lineItem?: LineItemOrderByWithRelationAndSearchRelevanceInput
    _relevance?: RelatedItemOrderByRelevanceInput
  }

  export type RelatedItemWhereUniqueInput = {
    id?: number
  }

  export type RelatedItemOrderByWithAggregationInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
    _count?: RelatedItemCountOrderByAggregateInput
    _avg?: RelatedItemAvgOrderByAggregateInput
    _max?: RelatedItemMaxOrderByAggregateInput
    _min?: RelatedItemMinOrderByAggregateInput
    _sum?: RelatedItemSumOrderByAggregateInput
  }

  export type RelatedItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RelatedItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<RelatedItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RelatedItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    relationId?: StringWithAggregatesFilter | string
    lineItemId?: IntWithAggregatesFilter | number
  }

  export type AlternateItemWhereInput = {
    AND?: Enumerable<AlternateItemWhereInput>
    OR?: Enumerable<AlternateItemWhereInput>
    NOT?: Enumerable<AlternateItemWhereInput>
    id?: IntFilter | number
    alternateId?: StringFilter | string
    lineItemId?: IntFilter | number
    lineItem?: XOR<LineItemRelationFilter, LineItemWhereInput>
  }

  export type AlternateItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
    lineItem?: LineItemOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AlternateItemOrderByRelevanceInput
  }

  export type AlternateItemWhereUniqueInput = {
    id?: number
  }

  export type AlternateItemOrderByWithAggregationInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
    _count?: AlternateItemCountOrderByAggregateInput
    _avg?: AlternateItemAvgOrderByAggregateInput
    _max?: AlternateItemMaxOrderByAggregateInput
    _min?: AlternateItemMinOrderByAggregateInput
    _sum?: AlternateItemSumOrderByAggregateInput
  }

  export type AlternateItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlternateItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlternateItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlternateItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    alternateId?: StringWithAggregatesFilter | string
    lineItemId?: IntWithAggregatesFilter | number
  }

  export type PlanEntitlementsWhereInput = {
    AND?: Enumerable<PlanEntitlementsWhereInput>
    OR?: Enumerable<PlanEntitlementsWhereInput>
    NOT?: Enumerable<PlanEntitlementsWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    extPlanId?: StringFilter | string
    maxImages?: IntFilter | number
    maxProjects?: IntFilter | number
    maxSeats?: IntFilter | number
    description?: StringFilter | string
    period?: StringFilter | string
    price?: FloatFilter | number
  }

  export type PlanEntitlementsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
    _relevance?: PlanEntitlementsOrderByRelevanceInput
  }

  export type PlanEntitlementsWhereUniqueInput = {
    id?: number
  }

  export type PlanEntitlementsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
    _count?: PlanEntitlementsCountOrderByAggregateInput
    _avg?: PlanEntitlementsAvgOrderByAggregateInput
    _max?: PlanEntitlementsMaxOrderByAggregateInput
    _min?: PlanEntitlementsMinOrderByAggregateInput
    _sum?: PlanEntitlementsSumOrderByAggregateInput
  }

  export type PlanEntitlementsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlanEntitlementsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlanEntitlementsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlanEntitlementsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    extPlanId?: StringWithAggregatesFilter | string
    maxImages?: IntWithAggregatesFilter | number
    maxProjects?: IntWithAggregatesFilter | number
    maxSeats?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    period?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
  }

  export type CustomersWhereInput = {
    AND?: Enumerable<CustomersWhereInput>
    OR?: Enumerable<CustomersWhereInput>
    NOT?: Enumerable<CustomersWhereInput>
    id?: IntFilter | number
    customerId?: StringFilter | string
    billingAddress?: JsonNullableFilter
    paymentMethod?: JsonNullableFilter
    organizationId?: IntFilter | number
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type CustomersOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrder
    paymentMethod?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CustomersOrderByRelevanceInput
  }

  export type CustomersWhereUniqueInput = {
    id?: number
    customerId?: string
  }

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrder
    paymentMethod?: SortOrder
    organizationId?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    customerId?: StringWithAggregatesFilter | string
    billingAddress?: JsonNullableWithAggregatesFilter
    paymentMethod?: JsonNullableWithAggregatesFilter
    organizationId?: IntWithAggregatesFilter | number
  }

  export type ProductsWhereInput = {
    AND?: Enumerable<ProductsWhereInput>
    OR?: Enumerable<ProductsWhereInput>
    NOT?: Enumerable<ProductsWhereInput>
    id?: StringFilter | string
    active?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    metadata?: JsonNullableFilter
    prices?: PricesListRelationFilter
  }

  export type ProductsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
    prices?: PricesOrderByRelationAggregateInput
    _relevance?: ProductsOrderByRelevanceInput
  }

  export type ProductsWhereUniqueInput = {
    id?: string
  }

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    metadata?: JsonNullableWithAggregatesFilter
  }

  export type PricesWhereInput = {
    AND?: Enumerable<PricesWhereInput>
    OR?: Enumerable<PricesWhereInput>
    NOT?: Enumerable<PricesWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    active?: BoolFilter | boolean
    unitAmount?: BigIntNullableFilter | bigint | number | null
    currency?: StringFilter | string
    type?: EnumPricingTypeFilter | PricingType
    interval?: EnumPricingPlanIntervalNullableFilter | PricingPlanInterval | null
    intervalCount?: IntNullableFilter | number | null
    trialPeriodDays?: IntNullableFilter | number | null
    metadata?: JsonNullableFilter
    description?: StringFilter | string
    product?: XOR<ProductsRelationFilter, ProductsWhereInput>
    Subscriptions?: SubscriptionsListRelationFilter
  }

  export type PricesOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    metadata?: SortOrder
    description?: SortOrder
    product?: ProductsOrderByWithRelationAndSearchRelevanceInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
    _relevance?: PricesOrderByRelevanceInput
  }

  export type PricesWhereUniqueInput = {
    id?: string
  }

  export type PricesOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    metadata?: SortOrder
    description?: SortOrder
    _count?: PricesCountOrderByAggregateInput
    _avg?: PricesAvgOrderByAggregateInput
    _max?: PricesMaxOrderByAggregateInput
    _min?: PricesMinOrderByAggregateInput
    _sum?: PricesSumOrderByAggregateInput
  }

  export type PricesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PricesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PricesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PricesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    unitAmount?: BigIntNullableWithAggregatesFilter | bigint | number | null
    currency?: StringWithAggregatesFilter | string
    type?: EnumPricingTypeWithAggregatesFilter | PricingType
    interval?: EnumPricingPlanIntervalNullableWithAggregatesFilter | PricingPlanInterval | null
    intervalCount?: IntNullableWithAggregatesFilter | number | null
    trialPeriodDays?: IntNullableWithAggregatesFilter | number | null
    metadata?: JsonNullableWithAggregatesFilter
    description?: StringWithAggregatesFilter | string
  }

  export type SubscriptionsWhereInput = {
    AND?: Enumerable<SubscriptionsWhereInput>
    OR?: Enumerable<SubscriptionsWhereInput>
    NOT?: Enumerable<SubscriptionsWhereInput>
    id?: StringFilter | string
    organizationId?: IntFilter | number
    status?: EnumSubscriptionStatusFilter | SubscriptionStatus
    metadata?: JsonNullableFilter
    pricesId?: StringFilter | string
    quantity?: IntFilter | number
    cancelAtPeriodEnd?: BoolFilter | boolean
    created?: DateTimeNullableFilter | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    cancelAt?: DateTimeNullableFilter | Date | string | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    trialStart?: DateTimeNullableFilter | Date | string | null
    trialEnd?: DateTimeNullableFilter | Date | string | null
    price?: XOR<PricesRelationFilter, PricesWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type SubscriptionsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    price?: PricesOrderByWithRelationAndSearchRelevanceInput
    organization?: OrganizationOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SubscriptionsOrderByRelevanceInput
  }

  export type SubscriptionsWhereUniqueInput = {
    id?: string
  }

  export type SubscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    _count?: SubscriptionsCountOrderByAggregateInput
    _avg?: SubscriptionsAvgOrderByAggregateInput
    _max?: SubscriptionsMaxOrderByAggregateInput
    _min?: SubscriptionsMinOrderByAggregateInput
    _sum?: SubscriptionsSumOrderByAggregateInput
  }

  export type SubscriptionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    organizationId?: IntWithAggregatesFilter | number
    status?: EnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    metadata?: JsonNullableWithAggregatesFilter
    pricesId?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    cancelAtPeriodEnd?: BoolWithAggregatesFilter | boolean
    created?: DateTimeNullableWithAggregatesFilter | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cancelAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrganizationCreateInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organization: OrganizationCreateNestedOneWithoutEquipmentInput
    ProjectEquipment?: ProjectEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
    ProjectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutEquipmentNestedInput
    ProjectEquipment?: ProjectEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
  }

  export type EquipmentUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
    userId: string
  }

  export type NotificationUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationSavedOptionCreateInput = {
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
    organization: OrganizationCreateNestedOneWithoutOrganizationSavedOptionInput
  }

  export type OrganizationSavedOptionUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
    organizationId: number
  }

  export type OrganizationSavedOptionUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationSavedOptionNestedInput
  }

  export type OrganizationSavedOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationSavedOptionCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
    organizationId: number
  }

  export type OrganizationSavedOptionUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToOrganizationCreateInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: AccessLevel | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutOrgInput
  }

  export type UserToOrganizationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: AccessLevel | null
    userId: string
  }

  export type UserToOrganizationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutOrgNestedInput
  }

  export type UserToOrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToOrganizationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: AccessLevel | null
    userId: string
  }

  export type UserToOrganizationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
  }

  export type UserToOrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationInvitationCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type OrganizationInvitationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type OrganizationInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserToProjectCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserToProjectInput
    project: ProjectCreateNestedOneWithoutProjectAssigneesInput
  }

  export type UserToProjectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    projectId: number
  }

  export type UserToProjectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserToProjectNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput
  }

  export type UserToProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToProjectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    projectId: number
  }

  export type UserToProjectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectNotesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
    project: ProjectCreateNestedOneWithoutProjectNotesInput
  }

  export type ProjectNotesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
  }

  export type ProjectNotesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectNotesNestedInput
  }

  export type ProjectNotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
  }

  export type ProjectNotesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectStatusValueCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectCreateNestedManyWithoutCurrentStatusInput
    organization: OrganizationCreateNestedOneWithoutProjectStatusValueInput
  }

  export type ProjectStatusValueUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
    projects?: ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUpdateManyWithoutCurrentStatusNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
    projects?: ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
  }

  export type ProjectStatusValueUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectStatusValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type PendingRoofReportsCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
    project: ProjectCreateNestedOneWithoutPendingRoofReportsInput
  }

  export type PendingRoofReportsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    isCompleted?: boolean
  }

  export type PendingRoofReportsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutPendingRoofReportsNestedInput
  }

  export type PendingRoofReportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    isCompleted?: boolean
  }

  export type PendingRoofReportsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WeatherReportItemCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
    project: ProjectCreateNestedOneWithoutWeatherReportItemsInput
  }

  export type WeatherReportItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutWeatherReportItemsNestedInput
  }

  export type WeatherReportItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectEquipmentCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipment: EquipmentCreateNestedOneWithoutProjectEquipmentInput
    project: ProjectCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
    equipmentId: number
  }

  export type ProjectEquipmentUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipment?: EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
    equipmentId: number
  }

  export type ProjectEquipmentUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type CostCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: CostType
    project: ProjectCreateNestedOneWithoutCostsInput
  }

  export type CostUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    projectId: number
    isDeleted?: boolean
    type: CostType
  }

  export type CostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
    project?: ProjectUpdateOneRequiredWithoutCostsNestedInput
  }

  export type CostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type CostCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    projectId: number
    isDeleted?: boolean
    type: CostType
  }

  export type CostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type CostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type PropertyDataCreateInput = {
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutPropertyDataInput
  }

  export type PropertyDataUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    projectId?: number | null
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutPropertyDataNestedInput
  }

  export type PropertyDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataCreateManyInput = {
    id?: number
    createdAt?: Date | string
    projectId?: number | null
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DataDeletionRequestCreateInput = {
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestCreateManyInput = {
    id?: number
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhotoAccessLinkCreateInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    project: ProjectCreateNestedOneWithoutPhotoAccessLinksInput
  }

  export type PhotoAccessLinkUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    projectId: number
  }

  export type PhotoAccessLinkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutPhotoAccessLinksNestedInput
  }

  export type PhotoAccessLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoAccessLinkCreateManyInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    projectId: number
  }

  export type PhotoAccessLinkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
  }

  export type ImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnotationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutAnnotationInput
    User: UserCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutAnnotationNestedInput
    User?: UserUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutImageNoteInput
    User: UserCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutImageNoteNestedInput
    User?: UserUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InferenceCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
  }

  export type InferenceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
  }

  export type RoomUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
  }

  export type RoomReadingCreateInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type RoomReadingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    project: ProjectCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NotesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type NotesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailCreateInput = {
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
    note: NotesCreateNestedOneWithoutNotesAuditTrailInput
  }

  export type NotesAuditTrailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    notesId: number
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
    note?: NotesUpdateOneRequiredWithoutNotesAuditTrailNestedInput
  }

  export type NotesAuditTrailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    notesId: number
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type AreaAffectedCreateInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: AreaAffectedType
    room: RoomCreateNestedOneWithoutAreasAffectedInput
    project: ProjectCreateNestedOneWithoutAreaAffectedInput
  }

  export type AreaAffectedUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: AreaAffectedType
  }

  export type AreaAffectedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
    room?: RoomUpdateOneRequiredWithoutAreasAffectedNestedInput
    project?: ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type AreaAffectedCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: AreaAffectedType
  }

  export type AreaAffectedUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type GenericRoomReadingCreateInput = {
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
    roomReading: RoomReadingCreateNestedOneWithoutGenericRoomReadingsInput
  }

  export type GenericRoomReadingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    roomReadingId: number
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    roomReading?: RoomReadingUpdateOneRequiredWithoutGenericRoomReadingsNestedInput
  }

  export type GenericRoomReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    roomReadingId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    roomReadingId: number
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    roomReadingId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DetectionCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: DimensionUnit | null
    inference: InferenceCreateNestedOneWithoutDetectionsInput
    room?: RoomCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type DetectionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
    inference?: InferenceUpdateOneRequiredWithoutDetectionsNestedInput
    room?: RoomUpdateOneWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type DetectionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type DetectionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type DetectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type TemplatesUsedCreateInput = {
    createdAt?: Date | string
    templateCode: string
    room?: RoomCreateNestedOneWithoutTemplatesInput
  }

  export type TemplatesUsedUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
    roomId?: number | null
  }

  export type TemplatesUsedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneWithoutTemplatesNestedInput
  }

  export type TemplatesUsedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplatesUsedCreateManyInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
    roomId?: number | null
  }

  export type TemplatesUsedUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WaitListCreateInput = {
    createdAt?: Date | string
    email: string
  }

  export type WaitListUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    email: string
  }

  export type WaitListUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListCreateManyInput = {
    id?: number
    createdAt?: Date | string
    email: string
  }

  export type WaitListUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type RekognitionRunsCreateInput = {
    createdAt?: Date | string
  }

  export type RekognitionRunsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
  }

  export type RekognitionRunsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsCreateManyInput = {
    id?: number
    createdAt?: Date | string
  }

  export type RekognitionRunsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderCreateNestedManyWithoutCalendarEventInput
    project?: ProjectCreateNestedOneWithoutEventsInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type CalendarEventUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarEventReminderCreateInput = {
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
    calendarEvent?: CalendarEventCreateNestedOneWithoutRemindersInput
  }

  export type CalendarEventReminderUncheckedCreateInput = {
    id?: number
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    calendarEventId?: number | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarEvent?: CalendarEventUpdateOneWithoutRemindersNestedInput
  }

  export type CalendarEventReminderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEventId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderCreateManyInput = {
    id?: number
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    calendarEventId?: number | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateManyMutationInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEventId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCreateInput = {
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
    LineItem?: LineItemCreateNestedManyWithoutXactimateCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
    LineItem?: LineItemUncheckedCreateNestedManyWithoutXactimateCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
    LineItem?: LineItemUpdateManyWithoutXactimateCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
    LineItem?: LineItemUncheckedUpdateManyWithoutXactimateCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryUpdateManyMutationInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LineItemCreateInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUpdateInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemCreateManyInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
  }

  export type LineItemUpdateManyMutationInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LineItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedItemCreateInput = {
    relationId: string
    lineItem: LineItemCreateNestedOneWithoutRelatedItemInput
  }

  export type RelatedItemUncheckedCreateInput = {
    id?: number
    relationId: string
    lineItemId: number
  }

  export type RelatedItemUpdateInput = {
    relationId?: StringFieldUpdateOperationsInput | string
    lineItem?: LineItemUpdateOneRequiredWithoutRelatedItemNestedInput
  }

  export type RelatedItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedItemCreateManyInput = {
    id?: number
    relationId: string
    lineItemId: number
  }

  export type RelatedItemUpdateManyMutationInput = {
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type AlternateItemCreateInput = {
    alternateId: string
    lineItem: LineItemCreateNestedOneWithoutAlternateItemInput
  }

  export type AlternateItemUncheckedCreateInput = {
    id?: number
    alternateId: string
    lineItemId: number
  }

  export type AlternateItemUpdateInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItem?: LineItemUpdateOneRequiredWithoutAlternateItemNestedInput
  }

  export type AlternateItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type AlternateItemCreateManyInput = {
    id?: number
    alternateId: string
    lineItemId: number
  }

  export type AlternateItemUpdateManyMutationInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsCreateInput = {
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CustomersCreateInput = {
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organization: OrganizationCreateNestedOneWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId: number
  }

  export type CustomersUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organization?: OrganizationUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomersCreateManyInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId: number
  }

  export type CustomersUpdateManyMutationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsCreateInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsCreateManyInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PricesCreateInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    product: ProductsCreateNestedOneWithoutPricesInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutPriceInput
  }

  export type PricesUncheckedCreateInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PricesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateOneRequiredWithoutPricesNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricesCreateManyInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PricesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsCreateInput = {
    id: string
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    price: PricesCreateNestedOneWithoutSubscriptionsInput
    organization: OrganizationCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateInput = {
    id: string
    organizationId: number
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: PricesUpdateOneRequiredWithoutSubscriptionsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsCreateManyInput = {
    id: string
    organizationId: number
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type EnumDashboardViewsFilter = {
    equals?: DashboardViews
    in?: Enumerable<DashboardViews>
    notIn?: Enumerable<DashboardViews>
    not?: NestedEnumDashboardViewsFilter | DashboardViews
  }

  export type EnumPhotoViewsFilter = {
    equals?: PhotoViews
    in?: Enumerable<PhotoViews>
    notIn?: Enumerable<PhotoViews>
    not?: NestedEnumPhotoViewsFilter | PhotoViews
  }

  export type EnumGroupByViewsFilter = {
    equals?: GroupByViews
    in?: Enumerable<GroupByViews>
    notIn?: Enumerable<GroupByViews>
    not?: NestedEnumGroupByViewsFilter | GroupByViews
  }

  export type UserToOrganizationRelationFilter = {
    is?: UserToOrganizationWhereInput | null
    isNot?: UserToOrganizationWhereInput | null
  }

  export type UserToProjectListRelationFilter = {
    every?: UserToProjectWhereInput
    some?: UserToProjectWhereInput
    none?: UserToProjectWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ImageNoteListRelationFilter = {
    every?: ImageNoteWhereInput
    some?: ImageNoteWhereInput
    none?: ImageNoteWhereInput
  }

  export type AnnotationListRelationFilter = {
    every?: AnnotationWhereInput
    some?: AnnotationWhereInput
    none?: AnnotationWhereInput
  }

  export type UserToProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type EnumDashboardViewsWithAggregatesFilter = {
    equals?: DashboardViews
    in?: Enumerable<DashboardViews>
    notIn?: Enumerable<DashboardViews>
    not?: NestedEnumDashboardViewsWithAggregatesFilter | DashboardViews
    _count?: NestedIntFilter
    _min?: NestedEnumDashboardViewsFilter
    _max?: NestedEnumDashboardViewsFilter
  }

  export type EnumPhotoViewsWithAggregatesFilter = {
    equals?: PhotoViews
    in?: Enumerable<PhotoViews>
    notIn?: Enumerable<PhotoViews>
    not?: NestedEnumPhotoViewsWithAggregatesFilter | PhotoViews
    _count?: NestedIntFilter
    _min?: NestedEnumPhotoViewsFilter
    _max?: NestedEnumPhotoViewsFilter
  }

  export type EnumGroupByViewsWithAggregatesFilter = {
    equals?: GroupByViews
    in?: Enumerable<GroupByViews>
    notIn?: Enumerable<GroupByViews>
    not?: NestedEnumGroupByViewsWithAggregatesFilter | GroupByViews
    _count?: NestedIntFilter
    _min?: NestedEnumGroupByViewsFilter
    _max?: NestedEnumGroupByViewsFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    search?: string
    mode?: QueryMode
    not?: NestedUuidFilter | string
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type OrganizationInvitationListRelationFilter = {
    every?: OrganizationInvitationWhereInput
    some?: OrganizationInvitationWhereInput
    none?: OrganizationInvitationWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type UserToOrganizationListRelationFilter = {
    every?: UserToOrganizationWhereInput
    some?: UserToOrganizationWhereInput
    none?: UserToOrganizationWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type SubscriptionsListRelationFilter = {
    every?: SubscriptionsWhereInput
    some?: SubscriptionsWhereInput
    none?: SubscriptionsWhereInput
  }

  export type OrganizationSavedOptionListRelationFilter = {
    every?: OrganizationSavedOptionWhereInput
    some?: OrganizationSavedOptionWhereInput
    none?: OrganizationSavedOptionWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type ProjectStatusValueListRelationFilter = {
    every?: ProjectStatusValueWhereInput
    some?: ProjectStatusValueWhereInput
    none?: ProjectStatusValueWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationSavedOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectStatusValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByRelevanceInput = {
    fields: Enumerable<OrganizationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type UuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    search?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type ProjectEquipmentListRelationFilter = {
    every?: ProjectEquipmentWhereInput
    some?: ProjectEquipmentWhereInput
    none?: ProjectEquipmentWhereInput
  }

  export type ProjectEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelevanceInput = {
    fields: Enumerable<EquipmentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumNotificationTypeFilter = {
    equals?: NotificationType
    in?: Enumerable<NotificationType>
    notIn?: Enumerable<NotificationType>
    not?: NestedEnumNotificationTypeFilter | NotificationType
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NotificationOrderByRelevanceInput = {
    fields: Enumerable<NotificationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter = {
    equals?: NotificationType
    in?: Enumerable<NotificationType>
    notIn?: Enumerable<NotificationType>
    not?: NestedEnumNotificationTypeWithAggregatesFilter | NotificationType
    _count?: NestedIntFilter
    _min?: NestedEnumNotificationTypeFilter
    _max?: NestedEnumNotificationTypeFilter
  }

  export type EnumSavedOptionTypeFilter = {
    equals?: SavedOptionType
    in?: Enumerable<SavedOptionType>
    notIn?: Enumerable<SavedOptionType>
    not?: NestedEnumSavedOptionTypeFilter | SavedOptionType
  }

  export type OrganizationSavedOptionOrderByRelevanceInput = {
    fields: Enumerable<OrganizationSavedOptionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OrganizationSavedOptionCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumSavedOptionTypeWithAggregatesFilter = {
    equals?: SavedOptionType
    in?: Enumerable<SavedOptionType>
    notIn?: Enumerable<SavedOptionType>
    not?: NestedEnumSavedOptionTypeWithAggregatesFilter | SavedOptionType
    _count?: NestedIntFilter
    _min?: NestedEnumSavedOptionTypeFilter
    _max?: NestedEnumSavedOptionTypeFilter
  }

  export type EnumAccessLevelNullableFilter = {
    equals?: AccessLevel | null
    in?: Enumerable<AccessLevel> | null
    notIn?: Enumerable<AccessLevel> | null
    not?: NestedEnumAccessLevelNullableFilter | AccessLevel | null
  }

  export type UserToOrganizationOrderByRelevanceInput = {
    fields: Enumerable<UserToOrganizationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserToOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type UserToOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumAccessLevelNullableWithAggregatesFilter = {
    equals?: AccessLevel | null
    in?: Enumerable<AccessLevel> | null
    notIn?: Enumerable<AccessLevel> | null
    not?: NestedEnumAccessLevelNullableWithAggregatesFilter | AccessLevel | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumAccessLevelNullableFilter
    _max?: NestedEnumAccessLevelNullableFilter
  }

  export type OrganizationInvitationOrderByRelevanceInput = {
    fields: Enumerable<OrganizationInvitationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type OrganizationInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserToProjectOrderByRelevanceInput = {
    fields: Enumerable<UserToProjectOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserToProjectUserIdProjectIdCompoundUniqueInput = {
    userId: string
    projectId: number
  }

  export type UserToProjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }
  export type JsonNullableListFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase>, Exclude<keyof Required<JsonNullableListFilterBase>, 'path'>>,
        Required<JsonNullableListFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase>, 'path'>>

  export type JsonNullableListFilterBase = {
    equals?: Enumerable<InputJsonValue> | null
    has?: InputJsonValue | null
    hasEvery?: Enumerable<InputJsonValue>
    hasSome?: Enumerable<InputJsonValue>
    isEmpty?: boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type EnumProjectStatusNullableFilter = {
    equals?: ProjectStatus | null
    in?: Enumerable<ProjectStatus> | null
    notIn?: Enumerable<ProjectStatus> | null
    not?: NestedEnumProjectStatusNullableFilter | ProjectStatus | null
  }

  export type InferenceListRelationFilter = {
    every?: InferenceWhereInput
    some?: InferenceWhereInput
    none?: InferenceWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type RoomReadingListRelationFilter = {
    every?: RoomReadingWhereInput
    some?: RoomReadingWhereInput
    none?: RoomReadingWhereInput
  }

  export type PropertyDataRelationFilter = {
    is?: PropertyDataWhereInput | null
    isNot?: PropertyDataWhereInput | null
  }

  export type AreaAffectedListRelationFilter = {
    every?: AreaAffectedWhereInput
    some?: AreaAffectedWhereInput
    none?: AreaAffectedWhereInput
  }

  export type PhotoAccessLinkListRelationFilter = {
    every?: PhotoAccessLinkWhereInput
    some?: PhotoAccessLinkWhereInput
    none?: PhotoAccessLinkWhereInput
  }

  export type NotesListRelationFilter = {
    every?: NotesWhereInput
    some?: NotesWhereInput
    none?: NotesWhereInput
  }

  export type CostListRelationFilter = {
    every?: CostWhereInput
    some?: CostWhereInput
    none?: CostWhereInput
  }

  export type WeatherReportItemListRelationFilter = {
    every?: WeatherReportItemWhereInput
    some?: WeatherReportItemWhereInput
    none?: WeatherReportItemWhereInput
  }

  export type ProjectStatusValueRelationFilter = {
    is?: ProjectStatusValueWhereInput | null
    isNot?: ProjectStatusValueWhereInput | null
  }

  export type PendingRoofReportsListRelationFilter = {
    every?: PendingRoofReportsWhereInput
    some?: PendingRoofReportsWhereInput
    none?: PendingRoofReportsWhereInput
  }

  export type ProjectNotesListRelationFilter = {
    every?: ProjectNotesWhereInput
    some?: ProjectNotesWhereInput
    none?: ProjectNotesWhereInput
  }

  export type InferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaAffectedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotoAccessLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeatherReportItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingRoofReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectNotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelevanceInput = {
    fields: Enumerable<ProjectOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    catCode?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    catCode?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumProjectStatusNullableWithAggregatesFilter = {
    equals?: ProjectStatus | null
    in?: Enumerable<ProjectStatus> | null
    notIn?: Enumerable<ProjectStatus> | null
    not?: NestedEnumProjectStatusNullableWithAggregatesFilter | ProjectStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumProjectStatusNullableFilter
    _max?: NestedEnumProjectStatusNullableFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ProjectNotesOrderByRelevanceInput = {
    fields: Enumerable<ProjectNotesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectNotesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatusValueOrderByRelevanceInput = {
    fields: Enumerable<ProjectStatusValueOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectStatusValueOrganizationIdLabelCompoundUniqueInput = {
    organizationId: number
    label: string
  }

  export type ProjectStatusValueCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type PendingRoofReportsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PendingRoofReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type WeatherReportItemOrderByRelevanceInput = {
    fields: Enumerable<WeatherReportItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type WeatherReportItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type WeatherReportItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EquipmentRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type ProjectEquipmentOrderByRelevanceInput = {
    fields: Enumerable<ProjectEquipmentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectEquipmentEquipmentIdProjectIdCompoundUniqueInput = {
    equipmentId: number
    projectId: number
  }

  export type ProjectEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type EnumCostTypeFilter = {
    equals?: CostType
    in?: Enumerable<CostType>
    notIn?: Enumerable<CostType>
    not?: NestedEnumCostTypeFilter | CostType
  }

  export type CostOrderByRelevanceInput = {
    fields: Enumerable<CostOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    projectId?: SortOrder
  }

  export type CostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    projectId?: SortOrder
  }

  export type EnumCostTypeWithAggregatesFilter = {
    equals?: CostType
    in?: Enumerable<CostType>
    notIn?: Enumerable<CostType>
    not?: NestedEnumCostTypeWithAggregatesFilter | CostType
    _count?: NestedIntFilter
    _min?: NestedEnumCostTypeFilter
    _max?: NestedEnumCostTypeFilter
  }

  export type PropertyDataOrderByRelevanceInput = {
    fields: Enumerable<PropertyDataOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PropertyDataCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
    data?: SortOrder
  }

  export type PropertyDataAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
  }

  export type PropertyDataMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
  }

  export type PropertyDataMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
  }

  export type PropertyDataSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
  }

  export type DataDeletionRequestOrderByRelevanceInput = {
    fields: Enumerable<DataDeletionRequestOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DataDeletionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DataDeletionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PhotoAccessLinkOrderByRelevanceInput = {
    fields: Enumerable<PhotoAccessLinkOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PhotoAccessLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type InferenceRelationFilter = {
    is?: InferenceWhereInput
    isNot?: InferenceWhereInput
  }

  export type ImageOrderByRelevanceInput = {
    fields: Enumerable<ImageOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type ImageRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type AnnotationOrderByRelevanceInput = {
    fields: Enumerable<AnnotationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type AnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type ImageNoteOrderByRelevanceInput = {
    fields: Enumerable<ImageNoteOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ImageNoteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type ImageNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type DetectionListRelationFilter = {
    every?: DetectionWhereInput
    some?: DetectionWhereInput
    none?: DetectionWhereInput
  }

  export type DetectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InferenceOrderByRelevanceInput = {
    fields: Enumerable<InferenceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InferenceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedListRelationFilter = {
    every?: TemplatesUsedWhereInput
    some?: TemplatesUsedWhereInput
    none?: TemplatesUsedWhereInput
  }

  export type TemplatesUsedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelevanceInput = {
    fields: Enumerable<RoomOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RoomProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
    equipmentUsed?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type GenericRoomReadingListRelationFilter = {
    every?: GenericRoomReadingWhereInput
    some?: GenericRoomReadingWhereInput
    none?: GenericRoomReadingWhereInput
  }

  export type GenericRoomReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomReadingOrderByRelevanceInput = {
    fields: Enumerable<RoomReadingOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RoomReadingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type RoomReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type NotesAuditTrailListRelationFilter = {
    every?: NotesAuditTrailWhereInput
    some?: NotesAuditTrailWhereInput
    none?: NotesAuditTrailWhereInput
  }

  export type NotesAuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelevanceInput = {
    fields: Enumerable<NotesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type NotesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type NotesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type EnumNotesAuditActionFilter = {
    equals?: NotesAuditAction
    in?: Enumerable<NotesAuditAction>
    notIn?: Enumerable<NotesAuditAction>
    not?: NestedEnumNotesAuditActionFilter | NotesAuditAction
  }

  export type NotesRelationFilter = {
    is?: NotesWhereInput
    isNot?: NotesWhereInput
  }

  export type NotesAuditTrailOrderByRelevanceInput = {
    fields: Enumerable<NotesAuditTrailOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type NotesAuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailAvgOrderByAggregateInput = {
    id?: SortOrder
    notesId?: SortOrder
  }

  export type NotesAuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailSumOrderByAggregateInput = {
    id?: SortOrder
    notesId?: SortOrder
  }

  export type EnumNotesAuditActionWithAggregatesFilter = {
    equals?: NotesAuditAction
    in?: Enumerable<NotesAuditAction>
    notIn?: Enumerable<NotesAuditAction>
    not?: NestedEnumNotesAuditActionWithAggregatesFilter | NotesAuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumNotesAuditActionFilter
    _max?: NestedEnumNotesAuditActionFilter
  }

  export type EnumAreaAffectedTypeFilter = {
    equals?: AreaAffectedType
    in?: Enumerable<AreaAffectedType>
    notIn?: Enumerable<AreaAffectedType>
    not?: NestedEnumAreaAffectedTypeFilter | AreaAffectedType
  }

  export type AreaAffectedOrderByRelevanceInput = {
    fields: Enumerable<AreaAffectedOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AreaAffectedTypeRoomIdCompoundUniqueInput = {
    type: AreaAffectedType
    roomId: number
  }

  export type AreaAffectedCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    category?: SortOrder
    projectId?: SortOrder
  }

  export type AreaAffectedMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    category?: SortOrder
    projectId?: SortOrder
  }

  export type EnumAreaAffectedTypeWithAggregatesFilter = {
    equals?: AreaAffectedType
    in?: Enumerable<AreaAffectedType>
    notIn?: Enumerable<AreaAffectedType>
    not?: NestedEnumAreaAffectedTypeWithAggregatesFilter | AreaAffectedType
    _count?: NestedIntFilter
    _min?: NestedEnumAreaAffectedTypeFilter
    _max?: NestedEnumAreaAffectedTypeFilter
  }

  export type EnumRoomReadingTypeFilter = {
    equals?: RoomReadingType
    in?: Enumerable<RoomReadingType>
    notIn?: Enumerable<RoomReadingType>
    not?: NestedEnumRoomReadingTypeFilter | RoomReadingType
  }

  export type RoomReadingRelationFilter = {
    is?: RoomReadingWhereInput
    isNot?: RoomReadingWhereInput
  }

  export type GenericRoomReadingOrderByRelevanceInput = {
    fields: Enumerable<GenericRoomReadingOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type GenericRoomReadingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomReadingId?: SortOrder
  }

  export type GenericRoomReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingSumOrderByAggregateInput = {
    id?: SortOrder
    roomReadingId?: SortOrder
  }

  export type EnumRoomReadingTypeWithAggregatesFilter = {
    equals?: RoomReadingType
    in?: Enumerable<RoomReadingType>
    notIn?: Enumerable<RoomReadingType>
    not?: NestedEnumRoomReadingTypeWithAggregatesFilter | RoomReadingType
    _count?: NestedIntFilter
    _min?: NestedEnumRoomReadingTypeFilter
    _max?: NestedEnumRoomReadingTypeFilter
  }

  export type EnumDimensionUnitNullableFilter = {
    equals?: DimensionUnit | null
    in?: Enumerable<DimensionUnit> | null
    notIn?: Enumerable<DimensionUnit> | null
    not?: NestedEnumDimensionUnitNullableFilter | DimensionUnit | null
  }

  export type DetectionOrderByRelevanceInput = {
    fields: Enumerable<DetectionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DetectionProjectIdCategoryCodeRoomIdCompoundUniqueInput = {
    projectId: number
    category: string
    code: string
    roomId: number
  }

  export type DetectionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionAvgOrderByAggregateInput = {
    id?: SortOrder
    inferenceId?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
  }

  export type DetectionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionSumOrderByAggregateInput = {
    id?: SortOrder
    inferenceId?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
  }

  export type EnumDimensionUnitNullableWithAggregatesFilter = {
    equals?: DimensionUnit | null
    in?: Enumerable<DimensionUnit> | null
    notIn?: Enumerable<DimensionUnit> | null
    not?: NestedEnumDimensionUnitNullableWithAggregatesFilter | DimensionUnit | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumDimensionUnitNullableFilter
    _max?: NestedEnumDimensionUnitNullableFilter
  }

  export type TemplatesUsedOrderByRelevanceInput = {
    fields: Enumerable<TemplatesUsedOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type TemplatesUsedCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type WaitListOrderByRelevanceInput = {
    fields: Enumerable<WaitListOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type WaitListCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaitListMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RekognitionRunsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RekognitionRunsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CalendarEventReminderListRelationFilter = {
    every?: CalendarEventReminderWhereInput
    some?: CalendarEventReminderWhereInput
    none?: CalendarEventReminderWhereInput
  }

  export type CalendarEventReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelevanceInput = {
    fields: Enumerable<CalendarEventOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EnumReminderTargetFilter = {
    equals?: ReminderTarget
    in?: Enumerable<ReminderTarget>
    notIn?: Enumerable<ReminderTarget>
    not?: NestedEnumReminderTargetFilter | ReminderTarget
  }

  export type CalendarEventRelationFilter = {
    is?: CalendarEventWhereInput | null
    isNot?: CalendarEventWhereInput | null
  }

  export type CalendarEventReminderCountOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderAvgOrderByAggregateInput = {
    id?: SortOrder
    calendarEventId?: SortOrder
  }

  export type CalendarEventReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderMinOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderSumOrderByAggregateInput = {
    id?: SortOrder
    calendarEventId?: SortOrder
  }

  export type EnumReminderTargetWithAggregatesFilter = {
    equals?: ReminderTarget
    in?: Enumerable<ReminderTarget>
    notIn?: Enumerable<ReminderTarget>
    not?: NestedEnumReminderTargetWithAggregatesFilter | ReminderTarget
    _count?: NestedIntFilter
    _min?: NestedEnumReminderTargetFilter
    _max?: NestedEnumReminderTargetFilter
  }

  export type LineItemListRelationFilter = {
    every?: LineItemWhereInput
    some?: LineItemWhereInput
    none?: LineItemWhereInput
  }

  export type LineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryOrderByRelevanceInput = {
    fields: Enumerable<ItemCategoryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemCategoryRelationFilter = {
    is?: ItemCategoryWhereInput
    isNot?: ItemCategoryWhereInput
  }

  export type AlternateItemListRelationFilter = {
    every?: AlternateItemWhereInput
    some?: AlternateItemWhereInput
    none?: AlternateItemWhereInput
  }

  export type RelatedItemListRelationFilter = {
    every?: RelatedItemWhereInput
    some?: RelatedItemWhereInput
    none?: RelatedItemWhereInput
  }

  export type AlternateItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelatedItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineItemOrderByRelevanceInput = {
    fields: Enumerable<LineItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LineItemItemCategoryIdXactimateCodeCompoundUniqueInput = {
    itemCategoryId: number
    xactimateCode: string
  }

  export type LineItemCountOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemAvgOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemMinOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemSumOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemRelationFilter = {
    is?: LineItemWhereInput
    isNot?: LineItemWhereInput
  }

  export type RelatedItemOrderByRelevanceInput = {
    fields: Enumerable<RelatedItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RelatedItemCountOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemAvgOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemMaxOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemMinOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemSumOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemOrderByRelevanceInput = {
    fields: Enumerable<AlternateItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AlternateItemCountOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemAvgOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemMaxOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemMinOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemSumOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type PlanEntitlementsOrderByRelevanceInput = {
    fields: Enumerable<PlanEntitlementsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PlanEntitlementsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsAvgOrderByAggregateInput = {
    id?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsSumOrderByAggregateInput = {
    id?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type CustomersOrderByRelevanceInput = {
    fields: Enumerable<CustomersOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrder
    paymentMethod?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type PricesListRelationFilter = {
    every?: PricesWhereInput
    some?: PricesWhereInput
    none?: PricesWhereInput
  }

  export type PricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsOrderByRelevanceInput = {
    fields: Enumerable<ProductsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type EnumPricingTypeFilter = {
    equals?: PricingType
    in?: Enumerable<PricingType>
    notIn?: Enumerable<PricingType>
    not?: NestedEnumPricingTypeFilter | PricingType
  }

  export type EnumPricingPlanIntervalNullableFilter = {
    equals?: PricingPlanInterval | null
    in?: Enumerable<PricingPlanInterval> | null
    notIn?: Enumerable<PricingPlanInterval> | null
    not?: NestedEnumPricingPlanIntervalNullableFilter | PricingPlanInterval | null
  }

  export type ProductsRelationFilter = {
    is?: ProductsWhereInput
    isNot?: ProductsWhereInput
  }

  export type PricesOrderByRelevanceInput = {
    fields: Enumerable<PricesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PricesCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    metadata?: SortOrder
    description?: SortOrder
  }

  export type PricesAvgOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type PricesMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    description?: SortOrder
  }

  export type PricesMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    description?: SortOrder
  }

  export type PricesSumOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type EnumPricingTypeWithAggregatesFilter = {
    equals?: PricingType
    in?: Enumerable<PricingType>
    notIn?: Enumerable<PricingType>
    not?: NestedEnumPricingTypeWithAggregatesFilter | PricingType
    _count?: NestedIntFilter
    _min?: NestedEnumPricingTypeFilter
    _max?: NestedEnumPricingTypeFilter
  }

  export type EnumPricingPlanIntervalNullableWithAggregatesFilter = {
    equals?: PricingPlanInterval | null
    in?: Enumerable<PricingPlanInterval> | null
    notIn?: Enumerable<PricingPlanInterval> | null
    not?: NestedEnumPricingPlanIntervalNullableWithAggregatesFilter | PricingPlanInterval | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPricingPlanIntervalNullableFilter
    _max?: NestedEnumPricingPlanIntervalNullableFilter
  }

  export type EnumSubscriptionStatusFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusFilter | SubscriptionStatus
  }

  export type PricesRelationFilter = {
    is?: PricesWhereInput
    isNot?: PricesWhereInput
  }

  export type SubscriptionsOrderByRelevanceInput = {
    fields: Enumerable<SubscriptionsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SubscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    quantity?: SortOrder
  }

  export type SubscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsSumOrderByAggregateInput = {
    organizationId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSubscriptionStatusFilter
    _max?: NestedEnumSubscriptionStatusFilter
  }

  export type UserToOrganizationCreateNestedOneWithoutUserInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    connect?: UserToOrganizationWhereUniqueInput
  }

  export type UserToProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutUserInput>, Enumerable<UserToProjectUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutUserInput>
    createMany?: UserToProjectCreateManyUserInputEnvelope
    connect?: Enumerable<UserToProjectWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ImageNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutUserInput>, Enumerable<ImageNoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutUserInput>
    createMany?: ImageNoteCreateManyUserInputEnvelope
    connect?: Enumerable<ImageNoteWhereUniqueInput>
  }

  export type AnnotationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutUserInput>, Enumerable<AnnotationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutUserInput>
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: Enumerable<AnnotationWhereUniqueInput>
  }

  export type UserToOrganizationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    connect?: UserToOrganizationWhereUniqueInput
  }

  export type UserToProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutUserInput>, Enumerable<UserToProjectUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutUserInput>
    createMany?: UserToProjectCreateManyUserInputEnvelope
    connect?: Enumerable<UserToProjectWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ImageNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutUserInput>, Enumerable<ImageNoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutUserInput>
    createMany?: ImageNoteCreateManyUserInputEnvelope
    connect?: Enumerable<ImageNoteWhereUniqueInput>
  }

  export type AnnotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutUserInput>, Enumerable<AnnotationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutUserInput>
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: Enumerable<AnnotationWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumDashboardViewsFieldUpdateOperationsInput = {
    set?: DashboardViews
  }

  export type EnumPhotoViewsFieldUpdateOperationsInput = {
    set?: PhotoViews
  }

  export type EnumGroupByViewsFieldUpdateOperationsInput = {
    set?: GroupByViews
  }

  export type UserToOrganizationUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    upsert?: UserToOrganizationUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserToOrganizationWhereUniqueInput
    update?: XOR<UserToOrganizationUpdateWithoutUserInput, UserToOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutUserInput>, Enumerable<UserToProjectUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToProjectUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToProjectCreateManyUserInputEnvelope
    set?: Enumerable<UserToProjectWhereUniqueInput>
    disconnect?: Enumerable<UserToProjectWhereUniqueInput>
    delete?: Enumerable<UserToProjectWhereUniqueInput>
    connect?: Enumerable<UserToProjectWhereUniqueInput>
    update?: Enumerable<UserToProjectUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToProjectUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToProjectScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ImageNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutUserInput>, Enumerable<ImageNoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageNoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageNoteCreateManyUserInputEnvelope
    set?: Enumerable<ImageNoteWhereUniqueInput>
    disconnect?: Enumerable<ImageNoteWhereUniqueInput>
    delete?: Enumerable<ImageNoteWhereUniqueInput>
    connect?: Enumerable<ImageNoteWhereUniqueInput>
    update?: Enumerable<ImageNoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageNoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageNoteScalarWhereInput>
  }

  export type AnnotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutUserInput>, Enumerable<AnnotationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnnotationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: Enumerable<AnnotationWhereUniqueInput>
    disconnect?: Enumerable<AnnotationWhereUniqueInput>
    delete?: Enumerable<AnnotationWhereUniqueInput>
    connect?: Enumerable<AnnotationWhereUniqueInput>
    update?: Enumerable<AnnotationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnnotationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnnotationScalarWhereInput>
  }

  export type UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    upsert?: UserToOrganizationUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserToOrganizationWhereUniqueInput
    update?: XOR<UserToOrganizationUpdateWithoutUserInput, UserToOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutUserInput>, Enumerable<UserToProjectUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToProjectUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToProjectCreateManyUserInputEnvelope
    set?: Enumerable<UserToProjectWhereUniqueInput>
    disconnect?: Enumerable<UserToProjectWhereUniqueInput>
    delete?: Enumerable<UserToProjectWhereUniqueInput>
    connect?: Enumerable<UserToProjectWhereUniqueInput>
    update?: Enumerable<UserToProjectUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToProjectUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToProjectScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ImageNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutUserInput>, Enumerable<ImageNoteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageNoteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageNoteCreateManyUserInputEnvelope
    set?: Enumerable<ImageNoteWhereUniqueInput>
    disconnect?: Enumerable<ImageNoteWhereUniqueInput>
    delete?: Enumerable<ImageNoteWhereUniqueInput>
    connect?: Enumerable<ImageNoteWhereUniqueInput>
    update?: Enumerable<ImageNoteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageNoteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageNoteScalarWhereInput>
  }

  export type AnnotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutUserInput>, Enumerable<AnnotationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnnotationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: Enumerable<AnnotationWhereUniqueInput>
    disconnect?: Enumerable<AnnotationWhereUniqueInput>
    delete?: Enumerable<AnnotationWhereUniqueInput>
    connect?: Enumerable<AnnotationWhereUniqueInput>
    update?: Enumerable<AnnotationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnnotationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnnotationScalarWhereInput>
  }

  export type ImageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ImageCreateWithoutOrganizationInput>, Enumerable<ImageUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutOrganizationInput>
    createMany?: ImageCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type OrganizationInvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationInvitationCreateWithoutOrganizationInput>, Enumerable<OrganizationInvitationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationInvitationCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationInvitationWhereUniqueInput>
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOrganizationInput>, Enumerable<ProjectUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOrganizationInput>
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type UserToOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserToOrganizationCreateWithoutOrganizationInput>, Enumerable<UserToOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserToOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<UserToOrganizationWhereUniqueInput>
  }

  export type CustomersCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutOrganizationInput>, Enumerable<CustomersUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutOrganizationInput>
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type SubscriptionsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutOrganizationInput>, Enumerable<SubscriptionsUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutOrganizationInput>
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
  }

  export type OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationSavedOptionCreateWithoutOrganizationInput>, Enumerable<OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
  }

  export type EquipmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutOrganizationInput>, Enumerable<EquipmentUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutOrganizationInput>
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type ProjectStatusValueCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProjectStatusValueCreateWithoutOrganizationInput>, Enumerable<ProjectStatusValueUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectStatusValueCreateOrConnectWithoutOrganizationInput>
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProjectStatusValueWhereUniqueInput>
  }

  export type ImageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ImageCreateWithoutOrganizationInput>, Enumerable<ImageUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutOrganizationInput>
    createMany?: ImageCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationInvitationCreateWithoutOrganizationInput>, Enumerable<OrganizationInvitationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationInvitationCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationInvitationWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOrganizationInput>, Enumerable<ProjectUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOrganizationInput>
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserToOrganizationCreateWithoutOrganizationInput>, Enumerable<UserToOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserToOrganizationCreateOrConnectWithoutOrganizationInput>
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    connect?: Enumerable<UserToOrganizationWhereUniqueInput>
  }

  export type CustomersUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutOrganizationInput>, Enumerable<CustomersUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutOrganizationInput>
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutOrganizationInput>, Enumerable<SubscriptionsUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutOrganizationInput>
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
  }

  export type OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationSavedOptionCreateWithoutOrganizationInput>, Enumerable<OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
  }

  export type EquipmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutOrganizationInput>, Enumerable<EquipmentUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutOrganizationInput>
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<ProjectStatusValueCreateWithoutOrganizationInput>, Enumerable<ProjectStatusValueUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectStatusValueCreateOrConnectWithoutOrganizationInput>
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    connect?: Enumerable<ProjectStatusValueWhereUniqueInput>
  }

  export type ImageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutOrganizationInput>, Enumerable<ImageUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ImageCreateManyOrganizationInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type OrganizationInvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrganizationInvitationCreateWithoutOrganizationInput>, Enumerable<OrganizationInvitationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationInvitationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationInvitationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationInvitationWhereUniqueInput>
    delete?: Enumerable<OrganizationInvitationWhereUniqueInput>
    connect?: Enumerable<OrganizationInvitationWhereUniqueInput>
    update?: Enumerable<OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationInvitationScalarWhereInput>
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOrganizationInput>, Enumerable<ProjectUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type UserToOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<UserToOrganizationCreateWithoutOrganizationInput>, Enumerable<UserToOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserToOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<UserToOrganizationWhereUniqueInput>
    disconnect?: Enumerable<UserToOrganizationWhereUniqueInput>
    delete?: Enumerable<UserToOrganizationWhereUniqueInput>
    connect?: Enumerable<UserToOrganizationWhereUniqueInput>
    update?: Enumerable<UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<UserToOrganizationScalarWhereInput>
  }

  export type CustomersUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutOrganizationInput>, Enumerable<CustomersUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type SubscriptionsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutOrganizationInput>, Enumerable<SubscriptionsUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    set?: Enumerable<SubscriptionsWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionsWhereUniqueInput>
    delete?: Enumerable<SubscriptionsWhereUniqueInput>
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
    update?: Enumerable<SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<SubscriptionsUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<SubscriptionsScalarWhereInput>
  }

  export type OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrganizationSavedOptionCreateWithoutOrganizationInput>, Enumerable<OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    disconnect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    delete?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    connect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    update?: Enumerable<OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationSavedOptionScalarWhereInput>
  }

  export type EquipmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutOrganizationInput>, Enumerable<EquipmentUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type ProjectStatusValueUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProjectStatusValueCreateWithoutOrganizationInput>, Enumerable<ProjectStatusValueUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectStatusValueCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProjectStatusValueWhereUniqueInput>
    disconnect?: Enumerable<ProjectStatusValueWhereUniqueInput>
    delete?: Enumerable<ProjectStatusValueWhereUniqueInput>
    connect?: Enumerable<ProjectStatusValueWhereUniqueInput>
    update?: Enumerable<ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProjectStatusValueScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ImageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutOrganizationInput>, Enumerable<ImageUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ImageCreateManyOrganizationInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrganizationInvitationCreateWithoutOrganizationInput>, Enumerable<OrganizationInvitationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationInvitationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationInvitationWhereUniqueInput>
    disconnect?: Enumerable<OrganizationInvitationWhereUniqueInput>
    delete?: Enumerable<OrganizationInvitationWhereUniqueInput>
    connect?: Enumerable<OrganizationInvitationWhereUniqueInput>
    update?: Enumerable<OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationInvitationScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutOrganizationInput>, Enumerable<ProjectUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<UserToOrganizationCreateWithoutOrganizationInput>, Enumerable<UserToOrganizationUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserToOrganizationCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    set?: Enumerable<UserToOrganizationWhereUniqueInput>
    disconnect?: Enumerable<UserToOrganizationWhereUniqueInput>
    delete?: Enumerable<UserToOrganizationWhereUniqueInput>
    connect?: Enumerable<UserToOrganizationWhereUniqueInput>
    update?: Enumerable<UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<UserToOrganizationScalarWhereInput>
  }

  export type CustomersUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutOrganizationInput>, Enumerable<CustomersUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutOrganizationInput>, Enumerable<SubscriptionsUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    set?: Enumerable<SubscriptionsWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionsWhereUniqueInput>
    delete?: Enumerable<SubscriptionsWhereUniqueInput>
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
    update?: Enumerable<SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<SubscriptionsUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<SubscriptionsScalarWhereInput>
  }

  export type OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<OrganizationSavedOptionCreateWithoutOrganizationInput>, Enumerable<OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    disconnect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    delete?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    connect?: Enumerable<OrganizationSavedOptionWhereUniqueInput>
    update?: Enumerable<OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationSavedOptionScalarWhereInput>
  }

  export type EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutOrganizationInput>, Enumerable<EquipmentUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<Enumerable<ProjectStatusValueCreateWithoutOrganizationInput>, Enumerable<ProjectStatusValueUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<ProjectStatusValueCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    set?: Enumerable<ProjectStatusValueWhereUniqueInput>
    disconnect?: Enumerable<ProjectStatusValueWhereUniqueInput>
    delete?: Enumerable<ProjectStatusValueWhereUniqueInput>
    connect?: Enumerable<ProjectStatusValueWhereUniqueInput>
    update?: Enumerable<ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<ProjectStatusValueScalarWhereInput>
  }

  export type OrganizationCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEquipmentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectEquipmentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutEquipmentInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutEquipmentInput>
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
  }

  export type ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutEquipmentInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutEquipmentInput>
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
  }

  export type OrganizationUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEquipmentInput
    upsert?: OrganizationUpsertWithoutEquipmentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutEquipmentInput, OrganizationUncheckedUpdateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutEquipmentInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    set?: Enumerable<ProjectEquipmentWhereUniqueInput>
    disconnect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    delete?: Enumerable<ProjectEquipmentWhereUniqueInput>
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    update?: Enumerable<ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<ProjectEquipmentScalarWhereInput>
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutEquipmentInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    set?: Enumerable<ProjectEquipmentWhereUniqueInput>
    disconnect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    delete?: Enumerable<ProjectEquipmentWhereUniqueInput>
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    update?: Enumerable<ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<ProjectEquipmentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type OrganizationCreateNestedOneWithoutOrganizationSavedOptionInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSavedOptionTypeFieldUpdateOperationsInput = {
    set?: SavedOptionType
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationSavedOptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput
    upsert?: OrganizationUpsertWithoutOrganizationSavedOptionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutOrganizationSavedOptionInput, OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumAccessLevelFieldUpdateOperationsInput = {
    set?: AccessLevel | null
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput
    upsert?: UserUpsertWithoutOrgInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutUserToProjectInput = {
    create?: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToProjectInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectAssigneesInput = {
    create?: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAssigneesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserToProjectNestedInput = {
    create?: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToProjectInput
    upsert?: UserUpsertWithoutUserToProjectInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserToProjectInput, UserUncheckedUpdateWithoutUserToProjectInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAssigneesInput
    upsert?: ProjectUpsertWithoutProjectAssigneesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutProjectAssigneesInput, ProjectUncheckedUpdateWithoutProjectAssigneesInput>
  }

  export type ProjectCreateroofSegmentsInput = {
    set: Enumerable<InputJsonValue>
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ImageCreateWithoutProjectInput>, Enumerable<ImageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutProjectInput>
    createMany?: ImageCreateManyProjectInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type InferenceCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutProjectInput>, Enumerable<InferenceUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutProjectInput>
    createMany?: InferenceCreateManyProjectInputEnvelope
    connect?: Enumerable<InferenceWhereUniqueInput>
  }

  export type RoomCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<RoomCreateWithoutProjectInput>, Enumerable<RoomUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomCreateOrConnectWithoutProjectInput>
    createMany?: RoomCreateManyProjectInputEnvelope
    connect?: Enumerable<RoomWhereUniqueInput>
  }

  export type CalendarEventCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CalendarEventCreateWithoutProjectInput>, Enumerable<CalendarEventUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CalendarEventCreateOrConnectWithoutProjectInput>
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: Enumerable<CalendarEventWhereUniqueInput>
  }

  export type UserToProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutProjectInput>, Enumerable<UserToProjectUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutProjectInput>
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    connect?: Enumerable<UserToProjectWhereUniqueInput>
  }

  export type RoomReadingCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutProjectInput>, Enumerable<RoomReadingUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutProjectInput>
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    connect?: Enumerable<RoomReadingWhereUniqueInput>
  }

  export type PropertyDataCreateNestedOneWithoutProjectInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    connect?: PropertyDataWhereUniqueInput
  }

  export type AreaAffectedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutProjectInput>, Enumerable<AreaAffectedUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutProjectInput>
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
  }

  export type PhotoAccessLinkCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<PhotoAccessLinkCreateWithoutProjectInput>, Enumerable<PhotoAccessLinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PhotoAccessLinkCreateOrConnectWithoutProjectInput>
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    connect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
  }

  export type NotesCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<NotesCreateWithoutProjectInput>, Enumerable<NotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutProjectInput>
    createMany?: NotesCreateManyProjectInputEnvelope
    connect?: Enumerable<NotesWhereUniqueInput>
  }

  export type CostCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CostCreateWithoutProjectInput>, Enumerable<CostUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CostCreateOrConnectWithoutProjectInput>
    createMany?: CostCreateManyProjectInputEnvelope
    connect?: Enumerable<CostWhereUniqueInput>
  }

  export type ProjectEquipmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutProjectInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutProjectInput>
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
  }

  export type WeatherReportItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<WeatherReportItemCreateWithoutProjectInput>, Enumerable<WeatherReportItemUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<WeatherReportItemCreateOrConnectWithoutProjectInput>
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    connect?: Enumerable<WeatherReportItemWhereUniqueInput>
  }

  export type ProjectStatusValueCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutProjectsInput
    connect?: ProjectStatusValueWhereUniqueInput
  }

  export type PendingRoofReportsCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<PendingRoofReportsCreateWithoutProjectInput>, Enumerable<PendingRoofReportsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PendingRoofReportsCreateOrConnectWithoutProjectInput>
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    connect?: Enumerable<PendingRoofReportsWhereUniqueInput>
  }

  export type ProjectNotesCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectNotesCreateWithoutProjectInput>, Enumerable<ProjectNotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectNotesCreateOrConnectWithoutProjectInput>
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectNotesWhereUniqueInput>
  }

  export type ImageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ImageCreateWithoutProjectInput>, Enumerable<ImageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutProjectInput>
    createMany?: ImageCreateManyProjectInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type InferenceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutProjectInput>, Enumerable<InferenceUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutProjectInput>
    createMany?: InferenceCreateManyProjectInputEnvelope
    connect?: Enumerable<InferenceWhereUniqueInput>
  }

  export type RoomUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<RoomCreateWithoutProjectInput>, Enumerable<RoomUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomCreateOrConnectWithoutProjectInput>
    createMany?: RoomCreateManyProjectInputEnvelope
    connect?: Enumerable<RoomWhereUniqueInput>
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CalendarEventCreateWithoutProjectInput>, Enumerable<CalendarEventUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CalendarEventCreateOrConnectWithoutProjectInput>
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: Enumerable<CalendarEventWhereUniqueInput>
  }

  export type UserToProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutProjectInput>, Enumerable<UserToProjectUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutProjectInput>
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    connect?: Enumerable<UserToProjectWhereUniqueInput>
  }

  export type RoomReadingUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutProjectInput>, Enumerable<RoomReadingUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutProjectInput>
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    connect?: Enumerable<RoomReadingWhereUniqueInput>
  }

  export type PropertyDataUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    connect?: PropertyDataWhereUniqueInput
  }

  export type AreaAffectedUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutProjectInput>, Enumerable<AreaAffectedUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutProjectInput>
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
  }

  export type PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<PhotoAccessLinkCreateWithoutProjectInput>, Enumerable<PhotoAccessLinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PhotoAccessLinkCreateOrConnectWithoutProjectInput>
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    connect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
  }

  export type NotesUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<NotesCreateWithoutProjectInput>, Enumerable<NotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutProjectInput>
    createMany?: NotesCreateManyProjectInputEnvelope
    connect?: Enumerable<NotesWhereUniqueInput>
  }

  export type CostUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<CostCreateWithoutProjectInput>, Enumerable<CostUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CostCreateOrConnectWithoutProjectInput>
    createMany?: CostCreateManyProjectInputEnvelope
    connect?: Enumerable<CostWhereUniqueInput>
  }

  export type ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutProjectInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutProjectInput>
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
  }

  export type WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<WeatherReportItemCreateWithoutProjectInput>, Enumerable<WeatherReportItemUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<WeatherReportItemCreateOrConnectWithoutProjectInput>
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    connect?: Enumerable<WeatherReportItemWhereUniqueInput>
  }

  export type PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<PendingRoofReportsCreateWithoutProjectInput>, Enumerable<PendingRoofReportsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PendingRoofReportsCreateOrConnectWithoutProjectInput>
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    connect?: Enumerable<PendingRoofReportsWhereUniqueInput>
  }

  export type ProjectNotesUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectNotesCreateWithoutProjectInput>, Enumerable<ProjectNotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectNotesCreateOrConnectWithoutProjectInput>
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectNotesWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateroofSegmentsInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProjectStatusFieldUpdateOperationsInput = {
    set?: ProjectStatus | null
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type ImageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutProjectInput>, Enumerable<ImageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ImageCreateManyProjectInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type InferenceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutProjectInput>, Enumerable<InferenceUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<InferenceUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: InferenceCreateManyProjectInputEnvelope
    set?: Enumerable<InferenceWhereUniqueInput>
    disconnect?: Enumerable<InferenceWhereUniqueInput>
    delete?: Enumerable<InferenceWhereUniqueInput>
    connect?: Enumerable<InferenceWhereUniqueInput>
    update?: Enumerable<InferenceUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<InferenceUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<InferenceScalarWhereInput>
  }

  export type RoomUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<RoomCreateWithoutProjectInput>, Enumerable<RoomUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<RoomUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: RoomCreateManyProjectInputEnvelope
    set?: Enumerable<RoomWhereUniqueInput>
    disconnect?: Enumerable<RoomWhereUniqueInput>
    delete?: Enumerable<RoomWhereUniqueInput>
    connect?: Enumerable<RoomWhereUniqueInput>
    update?: Enumerable<RoomUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<RoomUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<RoomScalarWhereInput>
  }

  export type CalendarEventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CalendarEventCreateWithoutProjectInput>, Enumerable<CalendarEventUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CalendarEventCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CalendarEventUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: Enumerable<CalendarEventWhereUniqueInput>
    disconnect?: Enumerable<CalendarEventWhereUniqueInput>
    delete?: Enumerable<CalendarEventWhereUniqueInput>
    connect?: Enumerable<CalendarEventWhereUniqueInput>
    update?: Enumerable<CalendarEventUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CalendarEventUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CalendarEventScalarWhereInput>
  }

  export type UserToProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutProjectInput>, Enumerable<UserToProjectUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<UserToProjectUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    set?: Enumerable<UserToProjectWhereUniqueInput>
    disconnect?: Enumerable<UserToProjectWhereUniqueInput>
    delete?: Enumerable<UserToProjectWhereUniqueInput>
    connect?: Enumerable<UserToProjectWhereUniqueInput>
    update?: Enumerable<UserToProjectUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<UserToProjectUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<UserToProjectScalarWhereInput>
  }

  export type RoomReadingUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutProjectInput>, Enumerable<RoomReadingUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<RoomReadingUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    set?: Enumerable<RoomReadingWhereUniqueInput>
    disconnect?: Enumerable<RoomReadingWhereUniqueInput>
    delete?: Enumerable<RoomReadingWhereUniqueInput>
    connect?: Enumerable<RoomReadingWhereUniqueInput>
    update?: Enumerable<RoomReadingUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<RoomReadingUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<RoomReadingScalarWhereInput>
  }

  export type PropertyDataUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    upsert?: PropertyDataUpsertWithoutProjectInput
    disconnect?: boolean
    delete?: boolean
    connect?: PropertyDataWhereUniqueInput
    update?: XOR<PropertyDataUpdateWithoutProjectInput, PropertyDataUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutProjectInput>, Enumerable<AreaAffectedUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<AreaAffectedUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    set?: Enumerable<AreaAffectedWhereUniqueInput>
    disconnect?: Enumerable<AreaAffectedWhereUniqueInput>
    delete?: Enumerable<AreaAffectedWhereUniqueInput>
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
    update?: Enumerable<AreaAffectedUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<AreaAffectedUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<AreaAffectedScalarWhereInput>
  }

  export type PhotoAccessLinkUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<PhotoAccessLinkCreateWithoutProjectInput>, Enumerable<PhotoAccessLinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PhotoAccessLinkCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    set?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    disconnect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    delete?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    connect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    update?: Enumerable<PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<PhotoAccessLinkScalarWhereInput>
  }

  export type NotesUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<NotesCreateWithoutProjectInput>, Enumerable<NotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<NotesUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: NotesCreateManyProjectInputEnvelope
    set?: Enumerable<NotesWhereUniqueInput>
    disconnect?: Enumerable<NotesWhereUniqueInput>
    delete?: Enumerable<NotesWhereUniqueInput>
    connect?: Enumerable<NotesWhereUniqueInput>
    update?: Enumerable<NotesUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<NotesUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<NotesScalarWhereInput>
  }

  export type CostUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CostCreateWithoutProjectInput>, Enumerable<CostUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CostCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CostUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CostCreateManyProjectInputEnvelope
    set?: Enumerable<CostWhereUniqueInput>
    disconnect?: Enumerable<CostWhereUniqueInput>
    delete?: Enumerable<CostWhereUniqueInput>
    connect?: Enumerable<CostWhereUniqueInput>
    update?: Enumerable<CostUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CostUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CostScalarWhereInput>
  }

  export type ProjectEquipmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutProjectInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectEquipmentWhereUniqueInput>
    disconnect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    delete?: Enumerable<ProjectEquipmentWhereUniqueInput>
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    update?: Enumerable<ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectEquipmentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectEquipmentScalarWhereInput>
  }

  export type WeatherReportItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<WeatherReportItemCreateWithoutProjectInput>, Enumerable<WeatherReportItemUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<WeatherReportItemCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    set?: Enumerable<WeatherReportItemWhereUniqueInput>
    disconnect?: Enumerable<WeatherReportItemWhereUniqueInput>
    delete?: Enumerable<WeatherReportItemWhereUniqueInput>
    connect?: Enumerable<WeatherReportItemWhereUniqueInput>
    update?: Enumerable<WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<WeatherReportItemUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<WeatherReportItemScalarWhereInput>
  }

  export type ProjectStatusValueUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutProjectsInput
    upsert?: ProjectStatusValueUpsertWithoutProjectsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectStatusValueWhereUniqueInput
    update?: XOR<ProjectStatusValueUpdateWithoutProjectsInput, ProjectStatusValueUncheckedUpdateWithoutProjectsInput>
  }

  export type PendingRoofReportsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<PendingRoofReportsCreateWithoutProjectInput>, Enumerable<PendingRoofReportsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PendingRoofReportsCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    set?: Enumerable<PendingRoofReportsWhereUniqueInput>
    disconnect?: Enumerable<PendingRoofReportsWhereUniqueInput>
    delete?: Enumerable<PendingRoofReportsWhereUniqueInput>
    connect?: Enumerable<PendingRoofReportsWhereUniqueInput>
    update?: Enumerable<PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<PendingRoofReportsUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<PendingRoofReportsScalarWhereInput>
  }

  export type ProjectNotesUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectNotesCreateWithoutProjectInput>, Enumerable<ProjectNotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectNotesCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectNotesUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectNotesWhereUniqueInput>
    disconnect?: Enumerable<ProjectNotesWhereUniqueInput>
    delete?: Enumerable<ProjectNotesWhereUniqueInput>
    connect?: Enumerable<ProjectNotesWhereUniqueInput>
    update?: Enumerable<ProjectNotesUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectNotesUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectNotesScalarWhereInput>
  }

  export type ImageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutProjectInput>, Enumerable<ImageUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ImageCreateManyProjectInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type InferenceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutProjectInput>, Enumerable<InferenceUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<InferenceUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: InferenceCreateManyProjectInputEnvelope
    set?: Enumerable<InferenceWhereUniqueInput>
    disconnect?: Enumerable<InferenceWhereUniqueInput>
    delete?: Enumerable<InferenceWhereUniqueInput>
    connect?: Enumerable<InferenceWhereUniqueInput>
    update?: Enumerable<InferenceUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<InferenceUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<InferenceScalarWhereInput>
  }

  export type RoomUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<RoomCreateWithoutProjectInput>, Enumerable<RoomUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<RoomUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: RoomCreateManyProjectInputEnvelope
    set?: Enumerable<RoomWhereUniqueInput>
    disconnect?: Enumerable<RoomWhereUniqueInput>
    delete?: Enumerable<RoomWhereUniqueInput>
    connect?: Enumerable<RoomWhereUniqueInput>
    update?: Enumerable<RoomUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<RoomUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<RoomScalarWhereInput>
  }

  export type CalendarEventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CalendarEventCreateWithoutProjectInput>, Enumerable<CalendarEventUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CalendarEventCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CalendarEventUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: Enumerable<CalendarEventWhereUniqueInput>
    disconnect?: Enumerable<CalendarEventWhereUniqueInput>
    delete?: Enumerable<CalendarEventWhereUniqueInput>
    connect?: Enumerable<CalendarEventWhereUniqueInput>
    update?: Enumerable<CalendarEventUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CalendarEventUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CalendarEventScalarWhereInput>
  }

  export type UserToProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<UserToProjectCreateWithoutProjectInput>, Enumerable<UserToProjectUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<UserToProjectCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<UserToProjectUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    set?: Enumerable<UserToProjectWhereUniqueInput>
    disconnect?: Enumerable<UserToProjectWhereUniqueInput>
    delete?: Enumerable<UserToProjectWhereUniqueInput>
    connect?: Enumerable<UserToProjectWhereUniqueInput>
    update?: Enumerable<UserToProjectUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<UserToProjectUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<UserToProjectScalarWhereInput>
  }

  export type RoomReadingUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutProjectInput>, Enumerable<RoomReadingUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<RoomReadingUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    set?: Enumerable<RoomReadingWhereUniqueInput>
    disconnect?: Enumerable<RoomReadingWhereUniqueInput>
    delete?: Enumerable<RoomReadingWhereUniqueInput>
    connect?: Enumerable<RoomReadingWhereUniqueInput>
    update?: Enumerable<RoomReadingUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<RoomReadingUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<RoomReadingScalarWhereInput>
  }

  export type PropertyDataUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    upsert?: PropertyDataUpsertWithoutProjectInput
    disconnect?: boolean
    delete?: boolean
    connect?: PropertyDataWhereUniqueInput
    update?: XOR<PropertyDataUpdateWithoutProjectInput, PropertyDataUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutProjectInput>, Enumerable<AreaAffectedUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<AreaAffectedUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    set?: Enumerable<AreaAffectedWhereUniqueInput>
    disconnect?: Enumerable<AreaAffectedWhereUniqueInput>
    delete?: Enumerable<AreaAffectedWhereUniqueInput>
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
    update?: Enumerable<AreaAffectedUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<AreaAffectedUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<AreaAffectedScalarWhereInput>
  }

  export type PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<PhotoAccessLinkCreateWithoutProjectInput>, Enumerable<PhotoAccessLinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PhotoAccessLinkCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    set?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    disconnect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    delete?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    connect?: Enumerable<PhotoAccessLinkWhereUniqueInput>
    update?: Enumerable<PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<PhotoAccessLinkScalarWhereInput>
  }

  export type NotesUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<NotesCreateWithoutProjectInput>, Enumerable<NotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<NotesUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: NotesCreateManyProjectInputEnvelope
    set?: Enumerable<NotesWhereUniqueInput>
    disconnect?: Enumerable<NotesWhereUniqueInput>
    delete?: Enumerable<NotesWhereUniqueInput>
    connect?: Enumerable<NotesWhereUniqueInput>
    update?: Enumerable<NotesUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<NotesUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<NotesScalarWhereInput>
  }

  export type CostUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<CostCreateWithoutProjectInput>, Enumerable<CostUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<CostCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<CostUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: CostCreateManyProjectInputEnvelope
    set?: Enumerable<CostWhereUniqueInput>
    disconnect?: Enumerable<CostWhereUniqueInput>
    delete?: Enumerable<CostWhereUniqueInput>
    connect?: Enumerable<CostWhereUniqueInput>
    update?: Enumerable<CostUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<CostUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<CostScalarWhereInput>
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectEquipmentCreateWithoutProjectInput>, Enumerable<ProjectEquipmentUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectEquipmentCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectEquipmentWhereUniqueInput>
    disconnect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    delete?: Enumerable<ProjectEquipmentWhereUniqueInput>
    connect?: Enumerable<ProjectEquipmentWhereUniqueInput>
    update?: Enumerable<ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectEquipmentUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectEquipmentScalarWhereInput>
  }

  export type WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<WeatherReportItemCreateWithoutProjectInput>, Enumerable<WeatherReportItemUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<WeatherReportItemCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    set?: Enumerable<WeatherReportItemWhereUniqueInput>
    disconnect?: Enumerable<WeatherReportItemWhereUniqueInput>
    delete?: Enumerable<WeatherReportItemWhereUniqueInput>
    connect?: Enumerable<WeatherReportItemWhereUniqueInput>
    update?: Enumerable<WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<WeatherReportItemUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<WeatherReportItemScalarWhereInput>
  }

  export type PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<PendingRoofReportsCreateWithoutProjectInput>, Enumerable<PendingRoofReportsUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<PendingRoofReportsCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    set?: Enumerable<PendingRoofReportsWhereUniqueInput>
    disconnect?: Enumerable<PendingRoofReportsWhereUniqueInput>
    delete?: Enumerable<PendingRoofReportsWhereUniqueInput>
    connect?: Enumerable<PendingRoofReportsWhereUniqueInput>
    update?: Enumerable<PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<PendingRoofReportsUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<PendingRoofReportsScalarWhereInput>
  }

  export type ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectNotesCreateWithoutProjectInput>, Enumerable<ProjectNotesUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectNotesCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectNotesUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectNotesWhereUniqueInput>
    disconnect?: Enumerable<ProjectNotesWhereUniqueInput>
    delete?: Enumerable<ProjectNotesWhereUniqueInput>
    connect?: Enumerable<ProjectNotesWhereUniqueInput>
    update?: Enumerable<ProjectNotesUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectNotesUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectNotesScalarWhereInput>
  }

  export type ProjectNotesCreatementionsInput = {
    set: Enumerable<string>
  }

  export type ProjectCreateNestedOneWithoutProjectNotesInput = {
    create?: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectNotesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectNotesUpdatementionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProjectUpdateOneRequiredWithoutProjectNotesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectNotesInput
    upsert?: ProjectUpsertWithoutProjectNotesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutProjectNotesInput, ProjectUncheckedUpdateWithoutProjectNotesInput>
  }

  export type ProjectCreateNestedManyWithoutCurrentStatusInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCurrentStatusInput>, Enumerable<ProjectUncheckedCreateWithoutCurrentStatusInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCurrentStatusInput>
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type OrganizationCreateNestedOneWithoutProjectStatusValueInput = {
    create?: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectStatusValueInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCurrentStatusInput>, Enumerable<ProjectUncheckedCreateWithoutCurrentStatusInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCurrentStatusInput>
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type ProjectUpdateManyWithoutCurrentStatusNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCurrentStatusInput>, Enumerable<ProjectUncheckedCreateWithoutCurrentStatusInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCurrentStatusInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput>
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutCurrentStatusInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectStatusValueInput
    upsert?: OrganizationUpsertWithoutProjectStatusValueInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutProjectStatusValueInput, OrganizationUncheckedUpdateWithoutProjectStatusValueInput>
  }

  export type ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCurrentStatusInput>, Enumerable<ProjectUncheckedCreateWithoutCurrentStatusInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCurrentStatusInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput>
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    connect?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutCurrentStatusInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type ProjectCreateNestedOneWithoutPendingRoofReportsInput = {
    create?: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPendingRoofReportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPendingRoofReportsNestedInput = {
    create?: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPendingRoofReportsInput
    upsert?: ProjectUpsertWithoutPendingRoofReportsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutPendingRoofReportsInput, ProjectUncheckedUpdateWithoutPendingRoofReportsInput>
  }

  export type ProjectCreateNestedOneWithoutWeatherReportItemsInput = {
    create?: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWeatherReportItemsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutWeatherReportItemsNestedInput = {
    create?: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWeatherReportItemsInput
    upsert?: ProjectUpsertWithoutWeatherReportItemsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutWeatherReportItemsInput, ProjectUncheckedUpdateWithoutWeatherReportItemsInput>
  }

  export type EquipmentCreateNestedOneWithoutProjectEquipmentInput = {
    create?: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProjectEquipmentInput
    connect?: EquipmentWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectEquipmentInput = {
    create?: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEquipmentInput
    connect?: ProjectWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput = {
    create?: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProjectEquipmentInput
    upsert?: EquipmentUpsertWithoutProjectEquipmentInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<EquipmentUpdateWithoutProjectEquipmentInput, EquipmentUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEquipmentInput
    upsert?: ProjectUpsertWithoutProjectEquipmentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutProjectEquipmentInput, ProjectUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type ProjectCreateNestedOneWithoutCostsInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumCostTypeFieldUpdateOperationsInput = {
    set?: CostType
  }

  export type ProjectUpdateOneRequiredWithoutCostsNestedInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    upsert?: ProjectUpsertWithoutCostsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
  }

  export type ProjectCreateNestedOneWithoutPropertyDataInput = {
    create?: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyDataInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutPropertyDataNestedInput = {
    create?: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyDataInput
    upsert?: ProjectUpsertWithoutPropertyDataInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutPropertyDataInput, ProjectUncheckedUpdateWithoutPropertyDataInput>
  }

  export type ProjectCreateNestedOneWithoutPhotoAccessLinksInput = {
    create?: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhotoAccessLinksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPhotoAccessLinksNestedInput = {
    create?: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhotoAccessLinksInput
    upsert?: ProjectUpsertWithoutPhotoAccessLinksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutPhotoAccessLinksInput, ProjectUncheckedUpdateWithoutPhotoAccessLinksInput>
  }

  export type OrganizationCreateNestedOneWithoutImageInput = {
    create?: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type InferenceCreateNestedOneWithoutImageInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    connect?: InferenceWhereUniqueInput
  }

  export type ImageNoteCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutImageInput>, Enumerable<ImageNoteUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutImageInput>
    createMany?: ImageNoteCreateManyImageInputEnvelope
    connect?: Enumerable<ImageNoteWhereUniqueInput>
  }

  export type AnnotationCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutImageInput>, Enumerable<AnnotationUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutImageInput>
    createMany?: AnnotationCreateManyImageInputEnvelope
    connect?: Enumerable<AnnotationWhereUniqueInput>
  }

  export type InferenceUncheckedCreateNestedOneWithoutImageInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    connect?: InferenceWhereUniqueInput
  }

  export type ImageNoteUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutImageInput>, Enumerable<ImageNoteUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutImageInput>
    createMany?: ImageNoteCreateManyImageInputEnvelope
    connect?: Enumerable<ImageNoteWhereUniqueInput>
  }

  export type AnnotationUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutImageInput>, Enumerable<AnnotationUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutImageInput>
    createMany?: AnnotationCreateManyImageInputEnvelope
    connect?: Enumerable<AnnotationWhereUniqueInput>
  }

  export type OrganizationUpdateOneWithoutImageNestedInput = {
    create?: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageInput
    upsert?: OrganizationUpsertWithoutImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutImageInput, OrganizationUncheckedUpdateWithoutImageInput>
  }

  export type ProjectUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImagesInput
    upsert?: ProjectUpsertWithoutImagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutImagesInput, ProjectUncheckedUpdateWithoutImagesInput>
  }

  export type InferenceUpdateOneWithoutImageNestedInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    upsert?: InferenceUpsertWithoutImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: InferenceWhereUniqueInput
    update?: XOR<InferenceUpdateWithoutImageInput, InferenceUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutImageInput>, Enumerable<ImageNoteUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<ImageNoteUpsertWithWhereUniqueWithoutImageInput>
    createMany?: ImageNoteCreateManyImageInputEnvelope
    set?: Enumerable<ImageNoteWhereUniqueInput>
    disconnect?: Enumerable<ImageNoteWhereUniqueInput>
    delete?: Enumerable<ImageNoteWhereUniqueInput>
    connect?: Enumerable<ImageNoteWhereUniqueInput>
    update?: Enumerable<ImageNoteUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<ImageNoteUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<ImageNoteScalarWhereInput>
  }

  export type AnnotationUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutImageInput>, Enumerable<AnnotationUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<AnnotationUpsertWithWhereUniqueWithoutImageInput>
    createMany?: AnnotationCreateManyImageInputEnvelope
    set?: Enumerable<AnnotationWhereUniqueInput>
    disconnect?: Enumerable<AnnotationWhereUniqueInput>
    delete?: Enumerable<AnnotationWhereUniqueInput>
    connect?: Enumerable<AnnotationWhereUniqueInput>
    update?: Enumerable<AnnotationUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<AnnotationUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<AnnotationScalarWhereInput>
  }

  export type InferenceUncheckedUpdateOneWithoutImageNestedInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    upsert?: InferenceUpsertWithoutImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: InferenceWhereUniqueInput
    update?: XOR<InferenceUpdateWithoutImageInput, InferenceUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<ImageNoteCreateWithoutImageInput>, Enumerable<ImageNoteUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<ImageNoteCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<ImageNoteUpsertWithWhereUniqueWithoutImageInput>
    createMany?: ImageNoteCreateManyImageInputEnvelope
    set?: Enumerable<ImageNoteWhereUniqueInput>
    disconnect?: Enumerable<ImageNoteWhereUniqueInput>
    delete?: Enumerable<ImageNoteWhereUniqueInput>
    connect?: Enumerable<ImageNoteWhereUniqueInput>
    update?: Enumerable<ImageNoteUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<ImageNoteUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<ImageNoteScalarWhereInput>
  }

  export type AnnotationUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<AnnotationCreateWithoutImageInput>, Enumerable<AnnotationUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<AnnotationCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<AnnotationUpsertWithWhereUniqueWithoutImageInput>
    createMany?: AnnotationCreateManyImageInputEnvelope
    set?: Enumerable<AnnotationWhereUniqueInput>
    disconnect?: Enumerable<AnnotationWhereUniqueInput>
    delete?: Enumerable<AnnotationWhereUniqueInput>
    connect?: Enumerable<AnnotationWhereUniqueInput>
    update?: Enumerable<AnnotationUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<AnnotationUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<AnnotationScalarWhereInput>
  }

  export type ImageCreateNestedOneWithoutAnnotationInput = {
    create?: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: ImageCreateOrConnectWithoutAnnotationInput
    connect?: ImageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotationInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    connect?: UserWhereUniqueInput
  }

  export type ImageUpdateOneRequiredWithoutAnnotationNestedInput = {
    create?: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: ImageCreateOrConnectWithoutAnnotationInput
    upsert?: ImageUpsertWithoutAnnotationInput
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutAnnotationInput, ImageUncheckedUpdateWithoutAnnotationInput>
  }

  export type UserUpdateOneRequiredWithoutAnnotationNestedInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    upsert?: UserUpsertWithoutAnnotationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
  }

  export type ImageNoteCreatementionsInput = {
    set: Enumerable<string>
  }

  export type ImageCreateNestedOneWithoutImageNoteInput = {
    create?: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: ImageCreateOrConnectWithoutImageNoteInput
    connect?: ImageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutImageNoteInput = {
    create?: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageNoteInput
    connect?: UserWhereUniqueInput
  }

  export type ImageNoteUpdatementionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ImageUpdateOneRequiredWithoutImageNoteNestedInput = {
    create?: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: ImageCreateOrConnectWithoutImageNoteInput
    upsert?: ImageUpsertWithoutImageNoteInput
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutImageNoteInput, ImageUncheckedUpdateWithoutImageNoteInput>
  }

  export type UserUpdateOneRequiredWithoutImageNoteNestedInput = {
    create?: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageNoteInput
    upsert?: UserUpsertWithoutImageNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutImageNoteInput, UserUncheckedUpdateWithoutImageNoteInput>
  }

  export type ImageCreateNestedOneWithoutInferenceInput = {
    create?: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
    connectOrCreate?: ImageCreateOrConnectWithoutInferenceInput
    connect?: ImageWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInferencesInput = {
    create?: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInferencesInput
    connect?: ProjectWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutInferencesInput = {
    create?: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInferencesInput
    connect?: RoomWhereUniqueInput
  }

  export type DetectionCreateNestedManyWithoutInferenceInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutInferenceInput>, Enumerable<DetectionUncheckedCreateWithoutInferenceInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutInferenceInput>
    createMany?: DetectionCreateManyInferenceInputEnvelope
    connect?: Enumerable<DetectionWhereUniqueInput>
  }

  export type DetectionUncheckedCreateNestedManyWithoutInferenceInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutInferenceInput>, Enumerable<DetectionUncheckedCreateWithoutInferenceInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutInferenceInput>
    createMany?: DetectionCreateManyInferenceInputEnvelope
    connect?: Enumerable<DetectionWhereUniqueInput>
  }

  export type ImageUpdateOneWithoutInferenceNestedInput = {
    create?: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
    connectOrCreate?: ImageCreateOrConnectWithoutInferenceInput
    upsert?: ImageUpsertWithoutInferenceInput
    disconnect?: boolean
    delete?: boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutInferenceInput, ImageUncheckedUpdateWithoutInferenceInput>
  }

  export type ProjectUpdateOneRequiredWithoutInferencesNestedInput = {
    create?: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInferencesInput
    upsert?: ProjectUpsertWithoutInferencesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutInferencesInput, ProjectUncheckedUpdateWithoutInferencesInput>
  }

  export type RoomUpdateOneWithoutInferencesNestedInput = {
    create?: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInferencesInput
    upsert?: RoomUpsertWithoutInferencesInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutInferencesInput, RoomUncheckedUpdateWithoutInferencesInput>
  }

  export type DetectionUpdateManyWithoutInferenceNestedInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutInferenceInput>, Enumerable<DetectionUncheckedCreateWithoutInferenceInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutInferenceInput>
    upsert?: Enumerable<DetectionUpsertWithWhereUniqueWithoutInferenceInput>
    createMany?: DetectionCreateManyInferenceInputEnvelope
    set?: Enumerable<DetectionWhereUniqueInput>
    disconnect?: Enumerable<DetectionWhereUniqueInput>
    delete?: Enumerable<DetectionWhereUniqueInput>
    connect?: Enumerable<DetectionWhereUniqueInput>
    update?: Enumerable<DetectionUpdateWithWhereUniqueWithoutInferenceInput>
    updateMany?: Enumerable<DetectionUpdateManyWithWhereWithoutInferenceInput>
    deleteMany?: Enumerable<DetectionScalarWhereInput>
  }

  export type DetectionUncheckedUpdateManyWithoutInferenceNestedInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutInferenceInput>, Enumerable<DetectionUncheckedCreateWithoutInferenceInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutInferenceInput>
    upsert?: Enumerable<DetectionUpsertWithWhereUniqueWithoutInferenceInput>
    createMany?: DetectionCreateManyInferenceInputEnvelope
    set?: Enumerable<DetectionWhereUniqueInput>
    disconnect?: Enumerable<DetectionWhereUniqueInput>
    delete?: Enumerable<DetectionWhereUniqueInput>
    connect?: Enumerable<DetectionWhereUniqueInput>
    update?: Enumerable<DetectionUpdateWithWhereUniqueWithoutInferenceInput>
    updateMany?: Enumerable<DetectionUpdateManyWithWhereWithoutInferenceInput>
    deleteMany?: Enumerable<DetectionScalarWhereInput>
  }

  export type RoomCreateequipmentUsedInput = {
    set: Enumerable<string>
  }

  export type ProjectCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DetectionCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutRoomInput>, Enumerable<DetectionUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutRoomInput>
    createMany?: DetectionCreateManyRoomInputEnvelope
    connect?: Enumerable<DetectionWhereUniqueInput>
  }

  export type InferenceCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutRoomInput>, Enumerable<InferenceUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutRoomInput>
    createMany?: InferenceCreateManyRoomInputEnvelope
    connect?: Enumerable<InferenceWhereUniqueInput>
  }

  export type TemplatesUsedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<TemplatesUsedCreateWithoutRoomInput>, Enumerable<TemplatesUsedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<TemplatesUsedCreateOrConnectWithoutRoomInput>
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    connect?: Enumerable<TemplatesUsedWhereUniqueInput>
  }

  export type RoomReadingCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutRoomInput>, Enumerable<RoomReadingUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutRoomInput>
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    connect?: Enumerable<RoomReadingWhereUniqueInput>
  }

  export type AreaAffectedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutRoomInput>, Enumerable<AreaAffectedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutRoomInput>
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
  }

  export type NotesCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<NotesCreateWithoutRoomInput>, Enumerable<NotesUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutRoomInput>
    createMany?: NotesCreateManyRoomInputEnvelope
    connect?: Enumerable<NotesWhereUniqueInput>
  }

  export type DetectionUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutRoomInput>, Enumerable<DetectionUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutRoomInput>
    createMany?: DetectionCreateManyRoomInputEnvelope
    connect?: Enumerable<DetectionWhereUniqueInput>
  }

  export type InferenceUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutRoomInput>, Enumerable<InferenceUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutRoomInput>
    createMany?: InferenceCreateManyRoomInputEnvelope
    connect?: Enumerable<InferenceWhereUniqueInput>
  }

  export type TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<TemplatesUsedCreateWithoutRoomInput>, Enumerable<TemplatesUsedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<TemplatesUsedCreateOrConnectWithoutRoomInput>
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    connect?: Enumerable<TemplatesUsedWhereUniqueInput>
  }

  export type RoomReadingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutRoomInput>, Enumerable<RoomReadingUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutRoomInput>
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    connect?: Enumerable<RoomReadingWhereUniqueInput>
  }

  export type AreaAffectedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutRoomInput>, Enumerable<AreaAffectedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutRoomInput>
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
  }

  export type NotesUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<NotesCreateWithoutRoomInput>, Enumerable<NotesUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutRoomInput>
    createMany?: NotesCreateManyRoomInputEnvelope
    connect?: Enumerable<NotesWhereUniqueInput>
  }

  export type RoomUpdateequipmentUsedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProjectUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomsInput
    upsert?: ProjectUpsertWithoutRoomsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutRoomsInput, ProjectUncheckedUpdateWithoutRoomsInput>
  }

  export type DetectionUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutRoomInput>, Enumerable<DetectionUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<DetectionUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: DetectionCreateManyRoomInputEnvelope
    set?: Enumerable<DetectionWhereUniqueInput>
    disconnect?: Enumerable<DetectionWhereUniqueInput>
    delete?: Enumerable<DetectionWhereUniqueInput>
    connect?: Enumerable<DetectionWhereUniqueInput>
    update?: Enumerable<DetectionUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<DetectionUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<DetectionScalarWhereInput>
  }

  export type InferenceUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutRoomInput>, Enumerable<InferenceUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<InferenceUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: InferenceCreateManyRoomInputEnvelope
    set?: Enumerable<InferenceWhereUniqueInput>
    disconnect?: Enumerable<InferenceWhereUniqueInput>
    delete?: Enumerable<InferenceWhereUniqueInput>
    connect?: Enumerable<InferenceWhereUniqueInput>
    update?: Enumerable<InferenceUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<InferenceUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<InferenceScalarWhereInput>
  }

  export type TemplatesUsedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<TemplatesUsedCreateWithoutRoomInput>, Enumerable<TemplatesUsedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<TemplatesUsedCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    set?: Enumerable<TemplatesUsedWhereUniqueInput>
    disconnect?: Enumerable<TemplatesUsedWhereUniqueInput>
    delete?: Enumerable<TemplatesUsedWhereUniqueInput>
    connect?: Enumerable<TemplatesUsedWhereUniqueInput>
    update?: Enumerable<TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<TemplatesUsedUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<TemplatesUsedScalarWhereInput>
  }

  export type RoomReadingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutRoomInput>, Enumerable<RoomReadingUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<RoomReadingUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    set?: Enumerable<RoomReadingWhereUniqueInput>
    disconnect?: Enumerable<RoomReadingWhereUniqueInput>
    delete?: Enumerable<RoomReadingWhereUniqueInput>
    connect?: Enumerable<RoomReadingWhereUniqueInput>
    update?: Enumerable<RoomReadingUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<RoomReadingUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<RoomReadingScalarWhereInput>
  }

  export type AreaAffectedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutRoomInput>, Enumerable<AreaAffectedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<AreaAffectedUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    set?: Enumerable<AreaAffectedWhereUniqueInput>
    disconnect?: Enumerable<AreaAffectedWhereUniqueInput>
    delete?: Enumerable<AreaAffectedWhereUniqueInput>
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
    update?: Enumerable<AreaAffectedUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<AreaAffectedUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<AreaAffectedScalarWhereInput>
  }

  export type NotesUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<NotesCreateWithoutRoomInput>, Enumerable<NotesUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<NotesUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: NotesCreateManyRoomInputEnvelope
    set?: Enumerable<NotesWhereUniqueInput>
    disconnect?: Enumerable<NotesWhereUniqueInput>
    delete?: Enumerable<NotesWhereUniqueInput>
    connect?: Enumerable<NotesWhereUniqueInput>
    update?: Enumerable<NotesUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<NotesUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<NotesScalarWhereInput>
  }

  export type DetectionUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<DetectionCreateWithoutRoomInput>, Enumerable<DetectionUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<DetectionCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<DetectionUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: DetectionCreateManyRoomInputEnvelope
    set?: Enumerable<DetectionWhereUniqueInput>
    disconnect?: Enumerable<DetectionWhereUniqueInput>
    delete?: Enumerable<DetectionWhereUniqueInput>
    connect?: Enumerable<DetectionWhereUniqueInput>
    update?: Enumerable<DetectionUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<DetectionUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<DetectionScalarWhereInput>
  }

  export type InferenceUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<InferenceCreateWithoutRoomInput>, Enumerable<InferenceUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<InferenceCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<InferenceUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: InferenceCreateManyRoomInputEnvelope
    set?: Enumerable<InferenceWhereUniqueInput>
    disconnect?: Enumerable<InferenceWhereUniqueInput>
    delete?: Enumerable<InferenceWhereUniqueInput>
    connect?: Enumerable<InferenceWhereUniqueInput>
    update?: Enumerable<InferenceUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<InferenceUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<InferenceScalarWhereInput>
  }

  export type TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<TemplatesUsedCreateWithoutRoomInput>, Enumerable<TemplatesUsedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<TemplatesUsedCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    set?: Enumerable<TemplatesUsedWhereUniqueInput>
    disconnect?: Enumerable<TemplatesUsedWhereUniqueInput>
    delete?: Enumerable<TemplatesUsedWhereUniqueInput>
    connect?: Enumerable<TemplatesUsedWhereUniqueInput>
    update?: Enumerable<TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<TemplatesUsedUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<TemplatesUsedScalarWhereInput>
  }

  export type RoomReadingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<RoomReadingCreateWithoutRoomInput>, Enumerable<RoomReadingUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RoomReadingCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<RoomReadingUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    set?: Enumerable<RoomReadingWhereUniqueInput>
    disconnect?: Enumerable<RoomReadingWhereUniqueInput>
    delete?: Enumerable<RoomReadingWhereUniqueInput>
    connect?: Enumerable<RoomReadingWhereUniqueInput>
    update?: Enumerable<RoomReadingUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<RoomReadingUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<RoomReadingScalarWhereInput>
  }

  export type AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<AreaAffectedCreateWithoutRoomInput>, Enumerable<AreaAffectedUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<AreaAffectedCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<AreaAffectedUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    set?: Enumerable<AreaAffectedWhereUniqueInput>
    disconnect?: Enumerable<AreaAffectedWhereUniqueInput>
    delete?: Enumerable<AreaAffectedWhereUniqueInput>
    connect?: Enumerable<AreaAffectedWhereUniqueInput>
    update?: Enumerable<AreaAffectedUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<AreaAffectedUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<AreaAffectedScalarWhereInput>
  }

  export type NotesUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<NotesCreateWithoutRoomInput>, Enumerable<NotesUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<NotesCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<NotesUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: NotesCreateManyRoomInputEnvelope
    set?: Enumerable<NotesWhereUniqueInput>
    disconnect?: Enumerable<NotesWhereUniqueInput>
    delete?: Enumerable<NotesWhereUniqueInput>
    connect?: Enumerable<NotesWhereUniqueInput>
    update?: Enumerable<NotesUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<NotesUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<NotesScalarWhereInput>
  }

  export type RoomReadingCreateequipmentUsedInput = {
    set: Enumerable<string>
  }

  export type RoomCreateNestedOneWithoutRoomReadingsInput = {
    create?: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomReadingsInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutRoomReadingsInput = {
    create?: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomReadingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type GenericRoomReadingCreateNestedManyWithoutRoomReadingInput = {
    create?: XOR<Enumerable<GenericRoomReadingCreateWithoutRoomReadingInput>, Enumerable<GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>>
    connectOrCreate?: Enumerable<GenericRoomReadingCreateOrConnectWithoutRoomReadingInput>
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    connect?: Enumerable<GenericRoomReadingWhereUniqueInput>
  }

  export type GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput = {
    create?: XOR<Enumerable<GenericRoomReadingCreateWithoutRoomReadingInput>, Enumerable<GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>>
    connectOrCreate?: Enumerable<GenericRoomReadingCreateOrConnectWithoutRoomReadingInput>
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    connect?: Enumerable<GenericRoomReadingWhereUniqueInput>
  }

  export type RoomReadingUpdateequipmentUsedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type RoomUpdateOneRequiredWithoutRoomReadingsNestedInput = {
    create?: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomReadingsInput
    upsert?: RoomUpsertWithoutRoomReadingsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutRoomReadingsInput, RoomUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomReadingsInput
    upsert?: ProjectUpsertWithoutRoomReadingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutRoomReadingsInput, ProjectUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput = {
    create?: XOR<Enumerable<GenericRoomReadingCreateWithoutRoomReadingInput>, Enumerable<GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>>
    connectOrCreate?: Enumerable<GenericRoomReadingCreateOrConnectWithoutRoomReadingInput>
    upsert?: Enumerable<GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput>
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    set?: Enumerable<GenericRoomReadingWhereUniqueInput>
    disconnect?: Enumerable<GenericRoomReadingWhereUniqueInput>
    delete?: Enumerable<GenericRoomReadingWhereUniqueInput>
    connect?: Enumerable<GenericRoomReadingWhereUniqueInput>
    update?: Enumerable<GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput>
    updateMany?: Enumerable<GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput>
    deleteMany?: Enumerable<GenericRoomReadingScalarWhereInput>
  }

  export type GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput = {
    create?: XOR<Enumerable<GenericRoomReadingCreateWithoutRoomReadingInput>, Enumerable<GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>>
    connectOrCreate?: Enumerable<GenericRoomReadingCreateOrConnectWithoutRoomReadingInput>
    upsert?: Enumerable<GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput>
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    set?: Enumerable<GenericRoomReadingWhereUniqueInput>
    disconnect?: Enumerable<GenericRoomReadingWhereUniqueInput>
    delete?: Enumerable<GenericRoomReadingWhereUniqueInput>
    connect?: Enumerable<GenericRoomReadingWhereUniqueInput>
    update?: Enumerable<GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput>
    updateMany?: Enumerable<GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput>
    deleteMany?: Enumerable<GenericRoomReadingScalarWhereInput>
  }

  export type RoomCreateNestedOneWithoutNotesInput = {
    create?: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutNotesInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutNotesInput = {
    create?: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotesInput
    connect?: ProjectWhereUniqueInput
  }

  export type NotesAuditTrailCreateNestedManyWithoutNoteInput = {
    create?: XOR<Enumerable<NotesAuditTrailCreateWithoutNoteInput>, Enumerable<NotesAuditTrailUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<NotesAuditTrailCreateOrConnectWithoutNoteInput>
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    connect?: Enumerable<NotesAuditTrailWhereUniqueInput>
  }

  export type NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<Enumerable<NotesAuditTrailCreateWithoutNoteInput>, Enumerable<NotesAuditTrailUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<NotesAuditTrailCreateOrConnectWithoutNoteInput>
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    connect?: Enumerable<NotesAuditTrailWhereUniqueInput>
  }

  export type RoomUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutNotesInput
    upsert?: RoomUpsertWithoutNotesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutNotesInput, RoomUncheckedUpdateWithoutNotesInput>
  }

  export type ProjectUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotesInput
    upsert?: ProjectUpsertWithoutNotesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutNotesInput, ProjectUncheckedUpdateWithoutNotesInput>
  }

  export type NotesAuditTrailUpdateManyWithoutNoteNestedInput = {
    create?: XOR<Enumerable<NotesAuditTrailCreateWithoutNoteInput>, Enumerable<NotesAuditTrailUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<NotesAuditTrailCreateOrConnectWithoutNoteInput>
    upsert?: Enumerable<NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput>
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    set?: Enumerable<NotesAuditTrailWhereUniqueInput>
    disconnect?: Enumerable<NotesAuditTrailWhereUniqueInput>
    delete?: Enumerable<NotesAuditTrailWhereUniqueInput>
    connect?: Enumerable<NotesAuditTrailWhereUniqueInput>
    update?: Enumerable<NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput>
    updateMany?: Enumerable<NotesAuditTrailUpdateManyWithWhereWithoutNoteInput>
    deleteMany?: Enumerable<NotesAuditTrailScalarWhereInput>
  }

  export type NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<Enumerable<NotesAuditTrailCreateWithoutNoteInput>, Enumerable<NotesAuditTrailUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<NotesAuditTrailCreateOrConnectWithoutNoteInput>
    upsert?: Enumerable<NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput>
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    set?: Enumerable<NotesAuditTrailWhereUniqueInput>
    disconnect?: Enumerable<NotesAuditTrailWhereUniqueInput>
    delete?: Enumerable<NotesAuditTrailWhereUniqueInput>
    connect?: Enumerable<NotesAuditTrailWhereUniqueInput>
    update?: Enumerable<NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput>
    updateMany?: Enumerable<NotesAuditTrailUpdateManyWithWhereWithoutNoteInput>
    deleteMany?: Enumerable<NotesAuditTrailScalarWhereInput>
  }

  export type NotesCreateNestedOneWithoutNotesAuditTrailInput = {
    create?: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
    connectOrCreate?: NotesCreateOrConnectWithoutNotesAuditTrailInput
    connect?: NotesWhereUniqueInput
  }

  export type EnumNotesAuditActionFieldUpdateOperationsInput = {
    set?: NotesAuditAction
  }

  export type NotesUpdateOneRequiredWithoutNotesAuditTrailNestedInput = {
    create?: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
    connectOrCreate?: NotesCreateOrConnectWithoutNotesAuditTrailInput
    upsert?: NotesUpsertWithoutNotesAuditTrailInput
    connect?: NotesWhereUniqueInput
    update?: XOR<NotesUpdateWithoutNotesAuditTrailInput, NotesUncheckedUpdateWithoutNotesAuditTrailInput>
  }

  export type RoomCreateNestedOneWithoutAreasAffectedInput = {
    create?: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAreasAffectedInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAreaAffectedInput = {
    create?: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAreaAffectedInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAreaAffectedTypeFieldUpdateOperationsInput = {
    set?: AreaAffectedType
  }

  export type RoomUpdateOneRequiredWithoutAreasAffectedNestedInput = {
    create?: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAreasAffectedInput
    upsert?: RoomUpsertWithoutAreasAffectedInput
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutAreasAffectedInput, RoomUncheckedUpdateWithoutAreasAffectedInput>
  }

  export type ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput = {
    create?: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAreaAffectedInput
    upsert?: ProjectUpsertWithoutAreaAffectedInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutAreaAffectedInput, ProjectUncheckedUpdateWithoutAreaAffectedInput>
  }

  export type RoomReadingCreateNestedOneWithoutGenericRoomReadingsInput = {
    create?: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
    connectOrCreate?: RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput
    connect?: RoomReadingWhereUniqueInput
  }

  export type EnumRoomReadingTypeFieldUpdateOperationsInput = {
    set?: RoomReadingType
  }

  export type RoomReadingUpdateOneRequiredWithoutGenericRoomReadingsNestedInput = {
    create?: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
    connectOrCreate?: RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput
    upsert?: RoomReadingUpsertWithoutGenericRoomReadingsInput
    connect?: RoomReadingWhereUniqueInput
    update?: XOR<RoomReadingUpdateWithoutGenericRoomReadingsInput, RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput>
  }

  export type InferenceCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutDetectionsInput
    connect?: InferenceWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutDetectionsInput
    connect?: RoomWhereUniqueInput
  }

  export type NullableEnumDimensionUnitFieldUpdateOperationsInput = {
    set?: DimensionUnit | null
  }

  export type InferenceUpdateOneRequiredWithoutDetectionsNestedInput = {
    create?: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutDetectionsInput
    upsert?: InferenceUpsertWithoutDetectionsInput
    connect?: InferenceWhereUniqueInput
    update?: XOR<InferenceUpdateWithoutDetectionsInput, InferenceUncheckedUpdateWithoutDetectionsInput>
  }

  export type RoomUpdateOneWithoutDetectionsNestedInput = {
    create?: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutDetectionsInput
    upsert?: RoomUpsertWithoutDetectionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutDetectionsInput, RoomUncheckedUpdateWithoutDetectionsInput>
  }

  export type RoomCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTemplatesInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTemplatesInput
    upsert?: RoomUpsertWithoutTemplatesInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<RoomUpdateWithoutTemplatesInput, RoomUncheckedUpdateWithoutTemplatesInput>
  }

  export type CalendarEventReminderCreateNestedManyWithoutCalendarEventInput = {
    create?: XOR<Enumerable<CalendarEventReminderCreateWithoutCalendarEventInput>, Enumerable<CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>>
    connectOrCreate?: Enumerable<CalendarEventReminderCreateOrConnectWithoutCalendarEventInput>
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    connect?: Enumerable<CalendarEventReminderWhereUniqueInput>
  }

  export type ProjectCreateNestedOneWithoutEventsInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput = {
    create?: XOR<Enumerable<CalendarEventReminderCreateWithoutCalendarEventInput>, Enumerable<CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>>
    connectOrCreate?: Enumerable<CalendarEventReminderCreateOrConnectWithoutCalendarEventInput>
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    connect?: Enumerable<CalendarEventReminderWhereUniqueInput>
  }

  export type CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput = {
    create?: XOR<Enumerable<CalendarEventReminderCreateWithoutCalendarEventInput>, Enumerable<CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>>
    connectOrCreate?: Enumerable<CalendarEventReminderCreateOrConnectWithoutCalendarEventInput>
    upsert?: Enumerable<CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput>
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    set?: Enumerable<CalendarEventReminderWhereUniqueInput>
    disconnect?: Enumerable<CalendarEventReminderWhereUniqueInput>
    delete?: Enumerable<CalendarEventReminderWhereUniqueInput>
    connect?: Enumerable<CalendarEventReminderWhereUniqueInput>
    update?: Enumerable<CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput>
    updateMany?: Enumerable<CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput>
    deleteMany?: Enumerable<CalendarEventReminderScalarWhereInput>
  }

  export type ProjectUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    upsert?: ProjectUpsertWithoutEventsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
  }

  export type CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput = {
    create?: XOR<Enumerable<CalendarEventReminderCreateWithoutCalendarEventInput>, Enumerable<CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>>
    connectOrCreate?: Enumerable<CalendarEventReminderCreateOrConnectWithoutCalendarEventInput>
    upsert?: Enumerable<CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput>
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    set?: Enumerable<CalendarEventReminderWhereUniqueInput>
    disconnect?: Enumerable<CalendarEventReminderWhereUniqueInput>
    delete?: Enumerable<CalendarEventReminderWhereUniqueInput>
    connect?: Enumerable<CalendarEventReminderWhereUniqueInput>
    update?: Enumerable<CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput>
    updateMany?: Enumerable<CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput>
    deleteMany?: Enumerable<CalendarEventReminderScalarWhereInput>
  }

  export type CalendarEventCreateNestedOneWithoutRemindersInput = {
    create?: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutRemindersInput
    connect?: CalendarEventWhereUniqueInput
  }

  export type EnumReminderTargetFieldUpdateOperationsInput = {
    set?: ReminderTarget
  }

  export type CalendarEventUpdateOneWithoutRemindersNestedInput = {
    create?: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutRemindersInput
    upsert?: CalendarEventUpsertWithoutRemindersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CalendarEventWhereUniqueInput
    update?: XOR<CalendarEventUpdateWithoutRemindersInput, CalendarEventUncheckedUpdateWithoutRemindersInput>
  }

  export type LineItemCreateNestedManyWithoutXactimateCategoryInput = {
    create?: XOR<Enumerable<LineItemCreateWithoutXactimateCategoryInput>, Enumerable<LineItemUncheckedCreateWithoutXactimateCategoryInput>>
    connectOrCreate?: Enumerable<LineItemCreateOrConnectWithoutXactimateCategoryInput>
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    connect?: Enumerable<LineItemWhereUniqueInput>
  }

  export type LineItemUncheckedCreateNestedManyWithoutXactimateCategoryInput = {
    create?: XOR<Enumerable<LineItemCreateWithoutXactimateCategoryInput>, Enumerable<LineItemUncheckedCreateWithoutXactimateCategoryInput>>
    connectOrCreate?: Enumerable<LineItemCreateOrConnectWithoutXactimateCategoryInput>
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    connect?: Enumerable<LineItemWhereUniqueInput>
  }

  export type LineItemUpdateManyWithoutXactimateCategoryNestedInput = {
    create?: XOR<Enumerable<LineItemCreateWithoutXactimateCategoryInput>, Enumerable<LineItemUncheckedCreateWithoutXactimateCategoryInput>>
    connectOrCreate?: Enumerable<LineItemCreateOrConnectWithoutXactimateCategoryInput>
    upsert?: Enumerable<LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput>
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    set?: Enumerable<LineItemWhereUniqueInput>
    disconnect?: Enumerable<LineItemWhereUniqueInput>
    delete?: Enumerable<LineItemWhereUniqueInput>
    connect?: Enumerable<LineItemWhereUniqueInput>
    update?: Enumerable<LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput>
    updateMany?: Enumerable<LineItemUpdateManyWithWhereWithoutXactimateCategoryInput>
    deleteMany?: Enumerable<LineItemScalarWhereInput>
  }

  export type LineItemUncheckedUpdateManyWithoutXactimateCategoryNestedInput = {
    create?: XOR<Enumerable<LineItemCreateWithoutXactimateCategoryInput>, Enumerable<LineItemUncheckedCreateWithoutXactimateCategoryInput>>
    connectOrCreate?: Enumerable<LineItemCreateOrConnectWithoutXactimateCategoryInput>
    upsert?: Enumerable<LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput>
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    set?: Enumerable<LineItemWhereUniqueInput>
    disconnect?: Enumerable<LineItemWhereUniqueInput>
    delete?: Enumerable<LineItemWhereUniqueInput>
    connect?: Enumerable<LineItemWhereUniqueInput>
    update?: Enumerable<LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput>
    updateMany?: Enumerable<LineItemUpdateManyWithWhereWithoutXactimateCategoryInput>
    deleteMany?: Enumerable<LineItemScalarWhereInput>
  }

  export type ItemCategoryCreateNestedOneWithoutLineItemInput = {
    create?: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutLineItemInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type AlternateItemCreateNestedManyWithoutLineItemInput = {
    create?: XOR<Enumerable<AlternateItemCreateWithoutLineItemInput>, Enumerable<AlternateItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<AlternateItemCreateOrConnectWithoutLineItemInput>
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    connect?: Enumerable<AlternateItemWhereUniqueInput>
  }

  export type RelatedItemCreateNestedManyWithoutLineItemInput = {
    create?: XOR<Enumerable<RelatedItemCreateWithoutLineItemInput>, Enumerable<RelatedItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<RelatedItemCreateOrConnectWithoutLineItemInput>
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    connect?: Enumerable<RelatedItemWhereUniqueInput>
  }

  export type AlternateItemUncheckedCreateNestedManyWithoutLineItemInput = {
    create?: XOR<Enumerable<AlternateItemCreateWithoutLineItemInput>, Enumerable<AlternateItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<AlternateItemCreateOrConnectWithoutLineItemInput>
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    connect?: Enumerable<AlternateItemWhereUniqueInput>
  }

  export type RelatedItemUncheckedCreateNestedManyWithoutLineItemInput = {
    create?: XOR<Enumerable<RelatedItemCreateWithoutLineItemInput>, Enumerable<RelatedItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<RelatedItemCreateOrConnectWithoutLineItemInput>
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    connect?: Enumerable<RelatedItemWhereUniqueInput>
  }

  export type ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutLineItemInput
    upsert?: ItemCategoryUpsertWithoutLineItemInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<ItemCategoryUpdateWithoutLineItemInput, ItemCategoryUncheckedUpdateWithoutLineItemInput>
  }

  export type AlternateItemUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<Enumerable<AlternateItemCreateWithoutLineItemInput>, Enumerable<AlternateItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<AlternateItemCreateOrConnectWithoutLineItemInput>
    upsert?: Enumerable<AlternateItemUpsertWithWhereUniqueWithoutLineItemInput>
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    set?: Enumerable<AlternateItemWhereUniqueInput>
    disconnect?: Enumerable<AlternateItemWhereUniqueInput>
    delete?: Enumerable<AlternateItemWhereUniqueInput>
    connect?: Enumerable<AlternateItemWhereUniqueInput>
    update?: Enumerable<AlternateItemUpdateWithWhereUniqueWithoutLineItemInput>
    updateMany?: Enumerable<AlternateItemUpdateManyWithWhereWithoutLineItemInput>
    deleteMany?: Enumerable<AlternateItemScalarWhereInput>
  }

  export type RelatedItemUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<Enumerable<RelatedItemCreateWithoutLineItemInput>, Enumerable<RelatedItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<RelatedItemCreateOrConnectWithoutLineItemInput>
    upsert?: Enumerable<RelatedItemUpsertWithWhereUniqueWithoutLineItemInput>
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    set?: Enumerable<RelatedItemWhereUniqueInput>
    disconnect?: Enumerable<RelatedItemWhereUniqueInput>
    delete?: Enumerable<RelatedItemWhereUniqueInput>
    connect?: Enumerable<RelatedItemWhereUniqueInput>
    update?: Enumerable<RelatedItemUpdateWithWhereUniqueWithoutLineItemInput>
    updateMany?: Enumerable<RelatedItemUpdateManyWithWhereWithoutLineItemInput>
    deleteMany?: Enumerable<RelatedItemScalarWhereInput>
  }

  export type AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<Enumerable<AlternateItemCreateWithoutLineItemInput>, Enumerable<AlternateItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<AlternateItemCreateOrConnectWithoutLineItemInput>
    upsert?: Enumerable<AlternateItemUpsertWithWhereUniqueWithoutLineItemInput>
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    set?: Enumerable<AlternateItemWhereUniqueInput>
    disconnect?: Enumerable<AlternateItemWhereUniqueInput>
    delete?: Enumerable<AlternateItemWhereUniqueInput>
    connect?: Enumerable<AlternateItemWhereUniqueInput>
    update?: Enumerable<AlternateItemUpdateWithWhereUniqueWithoutLineItemInput>
    updateMany?: Enumerable<AlternateItemUpdateManyWithWhereWithoutLineItemInput>
    deleteMany?: Enumerable<AlternateItemScalarWhereInput>
  }

  export type RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<Enumerable<RelatedItemCreateWithoutLineItemInput>, Enumerable<RelatedItemUncheckedCreateWithoutLineItemInput>>
    connectOrCreate?: Enumerable<RelatedItemCreateOrConnectWithoutLineItemInput>
    upsert?: Enumerable<RelatedItemUpsertWithWhereUniqueWithoutLineItemInput>
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    set?: Enumerable<RelatedItemWhereUniqueInput>
    disconnect?: Enumerable<RelatedItemWhereUniqueInput>
    delete?: Enumerable<RelatedItemWhereUniqueInput>
    connect?: Enumerable<RelatedItemWhereUniqueInput>
    update?: Enumerable<RelatedItemUpdateWithWhereUniqueWithoutLineItemInput>
    updateMany?: Enumerable<RelatedItemUpdateManyWithWhereWithoutLineItemInput>
    deleteMany?: Enumerable<RelatedItemScalarWhereInput>
  }

  export type LineItemCreateNestedOneWithoutRelatedItemInput = {
    create?: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutRelatedItemInput
    connect?: LineItemWhereUniqueInput
  }

  export type LineItemUpdateOneRequiredWithoutRelatedItemNestedInput = {
    create?: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutRelatedItemInput
    upsert?: LineItemUpsertWithoutRelatedItemInput
    connect?: LineItemWhereUniqueInput
    update?: XOR<LineItemUpdateWithoutRelatedItemInput, LineItemUncheckedUpdateWithoutRelatedItemInput>
  }

  export type LineItemCreateNestedOneWithoutAlternateItemInput = {
    create?: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutAlternateItemInput
    connect?: LineItemWhereUniqueInput
  }

  export type LineItemUpdateOneRequiredWithoutAlternateItemNestedInput = {
    create?: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutAlternateItemInput
    upsert?: LineItemUpsertWithoutAlternateItemInput
    connect?: LineItemWhereUniqueInput
    update?: XOR<LineItemUpdateWithoutAlternateItemInput, LineItemUncheckedUpdateWithoutAlternateItemInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationCreateNestedOneWithoutCustomersInput = {
    create?: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomersInput
    upsert?: OrganizationUpsertWithoutCustomersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutCustomersInput, OrganizationUncheckedUpdateWithoutCustomersInput>
  }

  export type PricesCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type PricesUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: Enumerable<PricesWhereUniqueInput>
  }

  export type PricesUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type PricesUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PricesCreateWithoutProductInput>, Enumerable<PricesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PricesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PricesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PricesCreateManyProductInputEnvelope
    set?: Enumerable<PricesWhereUniqueInput>
    disconnect?: Enumerable<PricesWhereUniqueInput>
    delete?: Enumerable<PricesWhereUniqueInput>
    connect?: Enumerable<PricesWhereUniqueInput>
    update?: Enumerable<PricesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PricesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PricesScalarWhereInput>
  }

  export type ProductsCreateNestedOneWithoutPricesInput = {
    create?: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPricesInput
    connect?: ProductsWhereUniqueInput
  }

  export type SubscriptionsCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutPriceInput>, Enumerable<SubscriptionsUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutPriceInput>
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutPriceInput>, Enumerable<SubscriptionsUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutPriceInput>
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumPricingTypeFieldUpdateOperationsInput = {
    set?: PricingType
  }

  export type NullableEnumPricingPlanIntervalFieldUpdateOperationsInput = {
    set?: PricingPlanInterval | null
  }

  export type ProductsUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPricesInput
    upsert?: ProductsUpsertWithoutPricesInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutPricesInput, ProductsUncheckedUpdateWithoutPricesInput>
  }

  export type SubscriptionsUpdateManyWithoutPriceNestedInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutPriceInput>, Enumerable<SubscriptionsUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<SubscriptionsUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    set?: Enumerable<SubscriptionsWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionsWhereUniqueInput>
    delete?: Enumerable<SubscriptionsWhereUniqueInput>
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
    update?: Enumerable<SubscriptionsUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<SubscriptionsUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<SubscriptionsScalarWhereInput>
  }

  export type SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput = {
    create?: XOR<Enumerable<SubscriptionsCreateWithoutPriceInput>, Enumerable<SubscriptionsUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionsCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<SubscriptionsUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    set?: Enumerable<SubscriptionsWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionsWhereUniqueInput>
    delete?: Enumerable<SubscriptionsWhereUniqueInput>
    connect?: Enumerable<SubscriptionsWhereUniqueInput>
    update?: Enumerable<SubscriptionsUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<SubscriptionsUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<SubscriptionsScalarWhereInput>
  }

  export type PricesCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutSubscriptionsInput
    connect?: PricesWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: SubscriptionStatus
  }

  export type PricesUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutSubscriptionsInput
    upsert?: PricesUpsertWithoutSubscriptionsInput
    connect?: PricesWhereUniqueInput
    update?: XOR<PricesUpdateWithoutSubscriptionsInput, PricesUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionsInput
    upsert?: OrganizationUpsertWithoutSubscriptionsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutSubscriptionsInput, OrganizationUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumDashboardViewsFilter = {
    equals?: DashboardViews
    in?: Enumerable<DashboardViews>
    notIn?: Enumerable<DashboardViews>
    not?: NestedEnumDashboardViewsFilter | DashboardViews
  }

  export type NestedEnumPhotoViewsFilter = {
    equals?: PhotoViews
    in?: Enumerable<PhotoViews>
    notIn?: Enumerable<PhotoViews>
    not?: NestedEnumPhotoViewsFilter | PhotoViews
  }

  export type NestedEnumGroupByViewsFilter = {
    equals?: GroupByViews
    in?: Enumerable<GroupByViews>
    notIn?: Enumerable<GroupByViews>
    not?: NestedEnumGroupByViewsFilter | GroupByViews
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumDashboardViewsWithAggregatesFilter = {
    equals?: DashboardViews
    in?: Enumerable<DashboardViews>
    notIn?: Enumerable<DashboardViews>
    not?: NestedEnumDashboardViewsWithAggregatesFilter | DashboardViews
    _count?: NestedIntFilter
    _min?: NestedEnumDashboardViewsFilter
    _max?: NestedEnumDashboardViewsFilter
  }

  export type NestedEnumPhotoViewsWithAggregatesFilter = {
    equals?: PhotoViews
    in?: Enumerable<PhotoViews>
    notIn?: Enumerable<PhotoViews>
    not?: NestedEnumPhotoViewsWithAggregatesFilter | PhotoViews
    _count?: NestedIntFilter
    _min?: NestedEnumPhotoViewsFilter
    _max?: NestedEnumPhotoViewsFilter
  }

  export type NestedEnumGroupByViewsWithAggregatesFilter = {
    equals?: GroupByViews
    in?: Enumerable<GroupByViews>
    notIn?: Enumerable<GroupByViews>
    not?: NestedEnumGroupByViewsWithAggregatesFilter | GroupByViews
    _count?: NestedIntFilter
    _min?: NestedEnumGroupByViewsFilter
    _max?: NestedEnumGroupByViewsFilter
  }

  export type NestedUuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    search?: string
    not?: NestedUuidFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedUuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    search?: string
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumNotificationTypeFilter = {
    equals?: NotificationType
    in?: Enumerable<NotificationType>
    notIn?: Enumerable<NotificationType>
    not?: NestedEnumNotificationTypeFilter | NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter = {
    equals?: NotificationType
    in?: Enumerable<NotificationType>
    notIn?: Enumerable<NotificationType>
    not?: NestedEnumNotificationTypeWithAggregatesFilter | NotificationType
    _count?: NestedIntFilter
    _min?: NestedEnumNotificationTypeFilter
    _max?: NestedEnumNotificationTypeFilter
  }

  export type NestedEnumSavedOptionTypeFilter = {
    equals?: SavedOptionType
    in?: Enumerable<SavedOptionType>
    notIn?: Enumerable<SavedOptionType>
    not?: NestedEnumSavedOptionTypeFilter | SavedOptionType
  }

  export type NestedEnumSavedOptionTypeWithAggregatesFilter = {
    equals?: SavedOptionType
    in?: Enumerable<SavedOptionType>
    notIn?: Enumerable<SavedOptionType>
    not?: NestedEnumSavedOptionTypeWithAggregatesFilter | SavedOptionType
    _count?: NestedIntFilter
    _min?: NestedEnumSavedOptionTypeFilter
    _max?: NestedEnumSavedOptionTypeFilter
  }

  export type NestedEnumAccessLevelNullableFilter = {
    equals?: AccessLevel | null
    in?: Enumerable<AccessLevel> | null
    notIn?: Enumerable<AccessLevel> | null
    not?: NestedEnumAccessLevelNullableFilter | AccessLevel | null
  }

  export type NestedEnumAccessLevelNullableWithAggregatesFilter = {
    equals?: AccessLevel | null
    in?: Enumerable<AccessLevel> | null
    notIn?: Enumerable<AccessLevel> | null
    not?: NestedEnumAccessLevelNullableWithAggregatesFilter | AccessLevel | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumAccessLevelNullableFilter
    _max?: NestedEnumAccessLevelNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumProjectStatusNullableFilter = {
    equals?: ProjectStatus | null
    in?: Enumerable<ProjectStatus> | null
    notIn?: Enumerable<ProjectStatus> | null
    not?: NestedEnumProjectStatusNullableFilter | ProjectStatus | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumProjectStatusNullableWithAggregatesFilter = {
    equals?: ProjectStatus | null
    in?: Enumerable<ProjectStatus> | null
    notIn?: Enumerable<ProjectStatus> | null
    not?: NestedEnumProjectStatusNullableWithAggregatesFilter | ProjectStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumProjectStatusNullableFilter
    _max?: NestedEnumProjectStatusNullableFilter
  }

  export type NestedEnumCostTypeFilter = {
    equals?: CostType
    in?: Enumerable<CostType>
    notIn?: Enumerable<CostType>
    not?: NestedEnumCostTypeFilter | CostType
  }

  export type NestedEnumCostTypeWithAggregatesFilter = {
    equals?: CostType
    in?: Enumerable<CostType>
    notIn?: Enumerable<CostType>
    not?: NestedEnumCostTypeWithAggregatesFilter | CostType
    _count?: NestedIntFilter
    _min?: NestedEnumCostTypeFilter
    _max?: NestedEnumCostTypeFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumNotesAuditActionFilter = {
    equals?: NotesAuditAction
    in?: Enumerable<NotesAuditAction>
    notIn?: Enumerable<NotesAuditAction>
    not?: NestedEnumNotesAuditActionFilter | NotesAuditAction
  }

  export type NestedEnumNotesAuditActionWithAggregatesFilter = {
    equals?: NotesAuditAction
    in?: Enumerable<NotesAuditAction>
    notIn?: Enumerable<NotesAuditAction>
    not?: NestedEnumNotesAuditActionWithAggregatesFilter | NotesAuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumNotesAuditActionFilter
    _max?: NestedEnumNotesAuditActionFilter
  }

  export type NestedEnumAreaAffectedTypeFilter = {
    equals?: AreaAffectedType
    in?: Enumerable<AreaAffectedType>
    notIn?: Enumerable<AreaAffectedType>
    not?: NestedEnumAreaAffectedTypeFilter | AreaAffectedType
  }

  export type NestedEnumAreaAffectedTypeWithAggregatesFilter = {
    equals?: AreaAffectedType
    in?: Enumerable<AreaAffectedType>
    notIn?: Enumerable<AreaAffectedType>
    not?: NestedEnumAreaAffectedTypeWithAggregatesFilter | AreaAffectedType
    _count?: NestedIntFilter
    _min?: NestedEnumAreaAffectedTypeFilter
    _max?: NestedEnumAreaAffectedTypeFilter
  }

  export type NestedEnumRoomReadingTypeFilter = {
    equals?: RoomReadingType
    in?: Enumerable<RoomReadingType>
    notIn?: Enumerable<RoomReadingType>
    not?: NestedEnumRoomReadingTypeFilter | RoomReadingType
  }

  export type NestedEnumRoomReadingTypeWithAggregatesFilter = {
    equals?: RoomReadingType
    in?: Enumerable<RoomReadingType>
    notIn?: Enumerable<RoomReadingType>
    not?: NestedEnumRoomReadingTypeWithAggregatesFilter | RoomReadingType
    _count?: NestedIntFilter
    _min?: NestedEnumRoomReadingTypeFilter
    _max?: NestedEnumRoomReadingTypeFilter
  }

  export type NestedEnumDimensionUnitNullableFilter = {
    equals?: DimensionUnit | null
    in?: Enumerable<DimensionUnit> | null
    notIn?: Enumerable<DimensionUnit> | null
    not?: NestedEnumDimensionUnitNullableFilter | DimensionUnit | null
  }

  export type NestedEnumDimensionUnitNullableWithAggregatesFilter = {
    equals?: DimensionUnit | null
    in?: Enumerable<DimensionUnit> | null
    notIn?: Enumerable<DimensionUnit> | null
    not?: NestedEnumDimensionUnitNullableWithAggregatesFilter | DimensionUnit | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumDimensionUnitNullableFilter
    _max?: NestedEnumDimensionUnitNullableFilter
  }

  export type NestedEnumReminderTargetFilter = {
    equals?: ReminderTarget
    in?: Enumerable<ReminderTarget>
    notIn?: Enumerable<ReminderTarget>
    not?: NestedEnumReminderTargetFilter | ReminderTarget
  }

  export type NestedEnumReminderTargetWithAggregatesFilter = {
    equals?: ReminderTarget
    in?: Enumerable<ReminderTarget>
    notIn?: Enumerable<ReminderTarget>
    not?: NestedEnumReminderTargetWithAggregatesFilter | ReminderTarget
    _count?: NestedIntFilter
    _min?: NestedEnumReminderTargetFilter
    _max?: NestedEnumReminderTargetFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedEnumPricingTypeFilter = {
    equals?: PricingType
    in?: Enumerable<PricingType>
    notIn?: Enumerable<PricingType>
    not?: NestedEnumPricingTypeFilter | PricingType
  }

  export type NestedEnumPricingPlanIntervalNullableFilter = {
    equals?: PricingPlanInterval | null
    in?: Enumerable<PricingPlanInterval> | null
    notIn?: Enumerable<PricingPlanInterval> | null
    not?: NestedEnumPricingPlanIntervalNullableFilter | PricingPlanInterval | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedEnumPricingTypeWithAggregatesFilter = {
    equals?: PricingType
    in?: Enumerable<PricingType>
    notIn?: Enumerable<PricingType>
    not?: NestedEnumPricingTypeWithAggregatesFilter | PricingType
    _count?: NestedIntFilter
    _min?: NestedEnumPricingTypeFilter
    _max?: NestedEnumPricingTypeFilter
  }

  export type NestedEnumPricingPlanIntervalNullableWithAggregatesFilter = {
    equals?: PricingPlanInterval | null
    in?: Enumerable<PricingPlanInterval> | null
    notIn?: Enumerable<PricingPlanInterval> | null
    not?: NestedEnumPricingPlanIntervalNullableWithAggregatesFilter | PricingPlanInterval | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPricingPlanIntervalNullableFilter
    _max?: NestedEnumPricingPlanIntervalNullableFilter
  }

  export type NestedEnumSubscriptionStatusFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusFilter | SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSubscriptionStatusFilter
    _max?: NestedEnumSubscriptionStatusFilter
  }

  export type UserToOrganizationCreateWithoutUserInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: AccessLevel | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UserToOrganizationUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: AccessLevel | null
  }

  export type UserToOrganizationCreateOrConnectWithoutUserInput = {
    where: UserToOrganizationWhereUniqueInput
    create: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectCreateWithoutUserInput = {
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectAssigneesInput
  }

  export type UserToProjectUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type UserToProjectCreateOrConnectWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    create: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectCreateManyUserInputEnvelope = {
    data: Enumerable<UserToProjectCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ImageNoteCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    isDeleted?: boolean
  }

  export type ImageNoteCreateOrConnectWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    create: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput>
  }

  export type ImageNoteCreateManyUserInputEnvelope = {
    data: Enumerable<ImageNoteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationCreateManyUserInputEnvelope = {
    data: Enumerable<AnnotationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserToOrganizationUpsertWithoutUserInput = {
    update: XOR<UserToOrganizationUpdateWithoutUserInput, UserToOrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserToOrganizationUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserToOrganizationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
  }

  export type UserToProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    update: XOR<UserToProjectUpdateWithoutUserInput, UserToProjectUncheckedUpdateWithoutUserInput>
    create: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    data: XOR<UserToProjectUpdateWithoutUserInput, UserToProjectUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUpdateManyWithWhereWithoutUserInput = {
    where: UserToProjectScalarWhereInput
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyWithoutUserToProjectInput>
  }

  export type UserToProjectScalarWhereInput = {
    AND?: Enumerable<UserToProjectScalarWhereInput>
    OR?: Enumerable<UserToProjectScalarWhereInput>
    NOT?: Enumerable<UserToProjectScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    projectId?: IntFilter | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    title?: StringFilter | string
    content?: StringFilter | string
    isSeen?: BoolFilter | boolean
    link?: StringNullableFilter | string | null
    linkText?: StringNullableFilter | string | null
    type?: EnumNotificationTypeFilter | NotificationType
    userId?: StringFilter | string
  }

  export type ImageNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    update: XOR<ImageNoteUpdateWithoutUserInput, ImageNoteUncheckedUpdateWithoutUserInput>
    create: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput>
  }

  export type ImageNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    data: XOR<ImageNoteUpdateWithoutUserInput, ImageNoteUncheckedUpdateWithoutUserInput>
  }

  export type ImageNoteUpdateManyWithWhereWithoutUserInput = {
    where: ImageNoteScalarWhereInput
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyWithoutImageNoteInput>
  }

  export type ImageNoteScalarWhereInput = {
    AND?: Enumerable<ImageNoteScalarWhereInput>
    OR?: Enumerable<ImageNoteScalarWhereInput>
    NOT?: Enumerable<ImageNoteScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    imageId?: IntFilter | number
    body?: StringFilter | string
    mentions?: StringNullableListFilter
    userId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
  }

  export type AnnotationUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutUserInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutAnnotationInput>
  }

  export type AnnotationScalarWhereInput = {
    AND?: Enumerable<AnnotationScalarWhereInput>
    OR?: Enumerable<AnnotationScalarWhereInput>
    NOT?: Enumerable<AnnotationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    imageId?: IntFilter | number
    coordinates?: JsonFilter
    userId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
  }

  export type ImageCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageCreateManyOrganizationInputEnvelope = {
    data: Enumerable<ImageCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type OrganizationInvitationCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationCreateManyOrganizationInputEnvelope = {
    data: Enumerable<OrganizationInvitationCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: Enumerable<ProjectCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type UserToOrganizationCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: AccessLevel | null
    user: UserCreateNestedOneWithoutOrgInput
  }

  export type UserToOrganizationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: AccessLevel | null
    userId: string
  }

  export type UserToOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    create: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserToOrganizationCreateManyOrganizationInputEnvelope = {
    data: Enumerable<UserToOrganizationCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutOrganizationInput = {
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedCreateWithoutOrganizationInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersCreateOrConnectWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomersCreateManyOrganizationInputEnvelope = {
    data: Enumerable<CustomersCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionsCreateWithoutOrganizationInput = {
    id: string
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    price: PricesCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutOrganizationInput = {
    id: string
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsCreateOrConnectWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionsCreateManyOrganizationInputEnvelope = {
    data: Enumerable<SubscriptionsCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type OrganizationSavedOptionCreateWithoutOrganizationInput = {
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
  }

  export type OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    create: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionCreateManyOrganizationInputEnvelope = {
    data: Enumerable<OrganizationSavedOptionCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutOrganizationInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    ProjectEquipment?: ProjectEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    ProjectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput>
  }

  export type EquipmentCreateManyOrganizationInputEnvelope = {
    data: Enumerable<EquipmentCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type ProjectStatusValueCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueCreateOrConnectWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    create: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectStatusValueCreateManyOrganizationInputEnvelope = {
    data: Enumerable<ProjectStatusValueCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutOrganizationInput, ImageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutOrganizationInput, ImageUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageUpdateManyWithWhereWithoutOrganizationInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutImageInput>
  }

  export type ImageScalarWhereInput = {
    AND?: Enumerable<ImageScalarWhereInput>
    OR?: Enumerable<ImageScalarWhereInput>
    NOT?: Enumerable<ImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    key?: StringFilter | string
    projectId?: IntFilter | number
    organizationId?: IntNullableFilter | number | null
    includeInReport?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
  }

  export type OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    update: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    data: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationInvitationScalarWhereInput
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyWithoutInvitationsInput>
  }

  export type OrganizationInvitationScalarWhereInput = {
    AND?: Enumerable<OrganizationInvitationScalarWhereInput>
    OR?: Enumerable<OrganizationInvitationScalarWhereInput>
    NOT?: Enumerable<OrganizationInvitationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    email?: StringFilter | string
    invitationId?: StringFilter | string
    isAccepted?: BoolFilter | boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: Enumerable<ProjectScalarWhereInput>
    OR?: Enumerable<ProjectScalarWhereInput>
    NOT?: Enumerable<ProjectScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    closedAt?: DateTimeNullableFilter | Date | string | null
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    assignmentNumber?: StringFilter | string
    publicId?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    clientName?: StringFilter | string
    clientEmail?: StringFilter | string
    clientPhoneNumber?: StringFilter | string
    companyName?: StringFilter | string
    managerName?: StringFilter | string
    adjusterEmail?: StringFilter | string
    adjusterName?: StringFilter | string
    adjusterPhoneNumber?: StringFilter | string
    insuranceCompanyName?: StringFilter | string
    insuranceClaimId?: StringFilter | string
    lossType?: StringFilter | string
    catCode?: IntNullableFilter | number | null
    humidity?: StringFilter | string
    lastTimeWeatherFetched?: DateTimeNullableFilter | Date | string | null
    temperature?: StringFilter | string
    wind?: StringFilter | string
    lat?: StringFilter | string
    lng?: StringFilter | string
    forecast?: StringFilter | string
    claimSummary?: StringFilter | string
    roofSegments?: JsonNullableListFilter
    roofSpecs?: JsonNullableFilter
    rcvValue?: FloatNullableFilter | number | null
    actualValue?: FloatNullableFilter | number | null
    status?: EnumProjectStatusNullableFilter | ProjectStatus | null
    projectStatusValueId?: IntNullableFilter | number | null
  }

  export type UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    update: XOR<UserToOrganizationUpdateWithoutOrganizationInput, UserToOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    data: XOR<UserToOrganizationUpdateWithoutOrganizationInput, UserToOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserToOrganizationScalarWhereInput
    data: XOR<UserToOrganizationUpdateManyMutationInput, UserToOrganizationUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserToOrganizationScalarWhereInput = {
    AND?: Enumerable<UserToOrganizationScalarWhereInput>
    OR?: Enumerable<UserToOrganizationScalarWhereInput>
    NOT?: Enumerable<UserToOrganizationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isAdmin?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    organizationId?: IntFilter | number
    role?: StringNullableFilter | string | null
    accessLevel?: EnumAccessLevelNullableFilter | AccessLevel | null
    userId?: StringFilter | string
  }

  export type CustomersUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutOrganizationInput, CustomersUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutOrganizationInput, CustomersUncheckedUpdateWithoutOrganizationInput>
  }

  export type CustomersUpdateManyWithWhereWithoutOrganizationInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: Enumerable<CustomersScalarWhereInput>
    OR?: Enumerable<CustomersScalarWhereInput>
    NOT?: Enumerable<CustomersScalarWhereInput>
    id?: IntFilter | number
    customerId?: StringFilter | string
    billingAddress?: JsonNullableFilter
    paymentMethod?: JsonNullableFilter
    organizationId?: IntFilter | number
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutOrganizationInput, SubscriptionsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutOrganizationInput, SubscriptionsUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type SubscriptionsScalarWhereInput = {
    AND?: Enumerable<SubscriptionsScalarWhereInput>
    OR?: Enumerable<SubscriptionsScalarWhereInput>
    NOT?: Enumerable<SubscriptionsScalarWhereInput>
    id?: StringFilter | string
    organizationId?: IntFilter | number
    status?: EnumSubscriptionStatusFilter | SubscriptionStatus
    metadata?: JsonNullableFilter
    pricesId?: StringFilter | string
    quantity?: IntFilter | number
    cancelAtPeriodEnd?: BoolFilter | boolean
    created?: DateTimeNullableFilter | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    cancelAt?: DateTimeNullableFilter | Date | string | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    trialStart?: DateTimeNullableFilter | Date | string | null
    trialEnd?: DateTimeNullableFilter | Date | string | null
  }

  export type OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    update: XOR<OrganizationSavedOptionUpdateWithoutOrganizationInput, OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    data: XOR<OrganizationSavedOptionUpdateWithoutOrganizationInput, OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationSavedOptionScalarWhereInput
    data: XOR<OrganizationSavedOptionUpdateManyMutationInput, OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationSavedOptionScalarWhereInput = {
    AND?: Enumerable<OrganizationSavedOptionScalarWhereInput>
    OR?: Enumerable<OrganizationSavedOptionScalarWhereInput>
    NOT?: Enumerable<OrganizationSavedOptionScalarWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    label?: StringFilter | string
    value?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    type?: EnumSavedOptionTypeFilter | SavedOptionType
    organizationId?: IntFilter | number
  }

  export type EquipmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutOrganizationInput, EquipmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutOrganizationInput, EquipmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: Enumerable<EquipmentScalarWhereInput>
    OR?: Enumerable<EquipmentScalarWhereInput>
    NOT?: Enumerable<EquipmentScalarWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    quantity?: IntFilter | number
    organizationId?: IntFilter | number
  }

  export type ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    update: XOR<ProjectStatusValueUpdateWithoutOrganizationInput, ProjectStatusValueUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    data: XOR<ProjectStatusValueUpdateWithoutOrganizationInput, ProjectStatusValueUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectStatusValueScalarWhereInput
    data: XOR<ProjectStatusValueUpdateManyMutationInput, ProjectStatusValueUncheckedUpdateManyWithoutProjectStatusValueInput>
  }

  export type ProjectStatusValueScalarWhereInput = {
    AND?: Enumerable<ProjectStatusValueScalarWhereInput>
    OR?: Enumerable<ProjectStatusValueScalarWhereInput>
    NOT?: Enumerable<ProjectStatusValueScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: UuidFilter | string
    label?: StringFilter | string
    description?: StringFilter | string
    color?: StringFilter | string
    order?: IntNullableFilter | number | null
    organizationId?: IntFilter | number
  }

  export type OrganizationCreateWithoutEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEquipmentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentCreateWithoutEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    project: ProjectCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateWithoutEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
  }

  export type ProjectEquipmentCreateOrConnectWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    create: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentCreateManyEquipmentInputEnvelope = {
    data: Enumerable<ProjectEquipmentCreateManyEquipmentInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutEquipmentInput = {
    update: XOR<OrganizationUpdateWithoutEquipmentInput, OrganizationUncheckedUpdateWithoutEquipmentInput>
    create: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
  }

  export type OrganizationUpdateWithoutEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    update: XOR<ProjectEquipmentUpdateWithoutEquipmentInput, ProjectEquipmentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    data: XOR<ProjectEquipmentUpdateWithoutEquipmentInput, ProjectEquipmentUncheckedUpdateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput = {
    where: ProjectEquipmentScalarWhereInput
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyWithoutProjectEquipmentInput>
  }

  export type ProjectEquipmentScalarWhereInput = {
    AND?: Enumerable<ProjectEquipmentScalarWhereInput>
    OR?: Enumerable<ProjectEquipmentScalarWhereInput>
    NOT?: Enumerable<ProjectEquipmentScalarWhereInput>
    id?: IntFilter | number
    publicId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    quantity?: IntFilter | number
    projectId?: IntFilter | number
    equipmentId?: IntFilter | number
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutOrganizationSavedOptionInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationUpsertWithoutOrganizationSavedOptionInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationSavedOptionInput, OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput>
    create: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationUpdateWithoutOrganizationSavedOptionInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutUsersInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutOrgInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrgInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrgInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrgInput = {
    update: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type UserUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutUserToProjectInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserToProjectInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserToProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
  }

  export type ProjectCreateWithoutProjectAssigneesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectAssigneesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectAssigneesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
  }

  export type UserUpsertWithoutUserToProjectInput = {
    update: XOR<UserUpdateWithoutUserToProjectInput, UserUncheckedUpdateWithoutUserToProjectInput>
    create: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
  }

  export type UserUpdateWithoutUserToProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserToProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutProjectAssigneesInput = {
    update: XOR<ProjectUpdateWithoutProjectAssigneesInput, ProjectUncheckedUpdateWithoutProjectAssigneesInput>
    create: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
  }

  export type ProjectUpdateWithoutProjectAssigneesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutProjectsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type ImageCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutProjectInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput>
  }

  export type ImageCreateManyProjectInputEnvelope = {
    data: Enumerable<ImageCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type InferenceCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput>
  }

  export type InferenceCreateManyProjectInputEnvelope = {
    data: Enumerable<InferenceCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutProjectInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput>
  }

  export type RoomCreateManyProjectInputEnvelope = {
    data: Enumerable<RoomCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutProjectInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventUncheckedCreateWithoutProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventCreateOrConnectWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventCreateManyProjectInputEnvelope = {
    data: Enumerable<CalendarEventCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type UserToProjectCreateWithoutProjectInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserToProjectInput
  }

  export type UserToProjectUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type UserToProjectCreateOrConnectWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    create: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput>
  }

  export type UserToProjectCreateManyProjectInputEnvelope = {
    data: Enumerable<UserToProjectCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type RoomReadingCreateWithoutProjectInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    roomId: number
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingCreateOrConnectWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput>
  }

  export type RoomReadingCreateManyProjectInputEnvelope = {
    data: Enumerable<RoomReadingCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type PropertyDataCreateWithoutProjectInput = {
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataCreateOrConnectWithoutProjectInput = {
    where: PropertyDataWhereUniqueInput
    create: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedCreateWithoutProjectInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: AreaAffectedType
    room: RoomCreateNestedOneWithoutAreasAffectedInput
  }

  export type AreaAffectedUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: AreaAffectedType
  }

  export type AreaAffectedCreateOrConnectWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    create: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedCreateManyProjectInputEnvelope = {
    data: Enumerable<AreaAffectedCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type PhotoAccessLinkCreateWithoutProjectInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type PhotoAccessLinkUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type PhotoAccessLinkCreateOrConnectWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    create: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput>
  }

  export type PhotoAccessLinkCreateManyProjectInputEnvelope = {
    data: Enumerable<PhotoAccessLinkCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type NotesCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesCreateOrConnectWithoutProjectInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput>
  }

  export type NotesCreateManyProjectInputEnvelope = {
    data: Enumerable<NotesCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type CostCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: CostType
  }

  export type CostUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: CostType
  }

  export type CostCreateOrConnectWithoutProjectInput = {
    where: CostWhereUniqueInput
    create: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput>
  }

  export type CostCreateManyProjectInputEnvelope = {
    data: Enumerable<CostCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectEquipmentCreateWithoutProjectInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipment: EquipmentCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateWithoutProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipmentId: number
  }

  export type ProjectEquipmentCreateOrConnectWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    create: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEquipmentCreateManyProjectInputEnvelope = {
    data: Enumerable<ProjectEquipmentCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type WeatherReportItemCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemCreateOrConnectWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    create: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput>
  }

  export type WeatherReportItemCreateManyProjectInputEnvelope = {
    data: Enumerable<WeatherReportItemCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectStatusValueCreateWithoutProjectsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organization: OrganizationCreateNestedOneWithoutProjectStatusValueInput
  }

  export type ProjectStatusValueUncheckedCreateWithoutProjectsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
  }

  export type ProjectStatusValueCreateOrConnectWithoutProjectsInput = {
    where: ProjectStatusValueWhereUniqueInput
    create: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
  }

  export type PendingRoofReportsCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type PendingRoofReportsUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type PendingRoofReportsCreateOrConnectWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    create: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput>
  }

  export type PendingRoofReportsCreateManyProjectInputEnvelope = {
    data: Enumerable<PendingRoofReportsCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectNotesCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
  }

  export type ProjectNotesUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
  }

  export type ProjectNotesCreateOrConnectWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    create: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotesCreateManyProjectInputEnvelope = {
    data: Enumerable<ProjectNotesCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutProjectInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutProjectInput, ImageUncheckedUpdateWithoutProjectInput>
    create: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutProjectInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutProjectInput, ImageUncheckedUpdateWithoutProjectInput>
  }

  export type ImageUpdateManyWithWhereWithoutProjectInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutImagesInput>
  }

  export type InferenceUpsertWithWhereUniqueWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    update: XOR<InferenceUpdateWithoutProjectInput, InferenceUncheckedUpdateWithoutProjectInput>
    create: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput>
  }

  export type InferenceUpdateWithWhereUniqueWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    data: XOR<InferenceUpdateWithoutProjectInput, InferenceUncheckedUpdateWithoutProjectInput>
  }

  export type InferenceUpdateManyWithWhereWithoutProjectInput = {
    where: InferenceScalarWhereInput
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyWithoutInferencesInput>
  }

  export type InferenceScalarWhereInput = {
    AND?: Enumerable<InferenceScalarWhereInput>
    OR?: Enumerable<InferenceScalarWhereInput>
    NOT?: Enumerable<InferenceScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    imageId?: IntNullableFilter | number | null
    imageKey?: StringNullableFilter | string | null
    projectId?: IntFilter | number
    roomId?: IntNullableFilter | number | null
  }

  export type RoomUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutProjectInput, RoomUncheckedUpdateWithoutProjectInput>
    create: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutProjectInput, RoomUncheckedUpdateWithoutProjectInput>
  }

  export type RoomUpdateManyWithWhereWithoutProjectInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutRoomsInput>
  }

  export type RoomScalarWhereInput = {
    AND?: Enumerable<RoomScalarWhereInput>
    OR?: Enumerable<RoomScalarWhereInput>
    NOT?: Enumerable<RoomScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    name?: StringFilter | string
    projectId?: IntFilter | number
    gpp?: StringNullableFilter | string | null
    humidity?: StringNullableFilter | string | null
    dehuReading?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    totalSqft?: StringNullableFilter | string | null
    windows?: IntNullableFilter | number | null
    doors?: IntNullableFilter | number | null
    equipmentUsed?: StringNullableListFilter
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutProjectInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutEventsInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: Enumerable<CalendarEventScalarWhereInput>
    OR?: Enumerable<CalendarEventScalarWhereInput>
    NOT?: Enumerable<CalendarEventScalarWhereInput>
    id?: IntFilter | number
    publicId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subject?: StringFilter | string
    payload?: StringFilter | string
    projectId?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    dynamicId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    remindClient?: BoolFilter | boolean
    remindProjectOwners?: BoolFilter | boolean
  }

  export type UserToProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    update: XOR<UserToProjectUpdateWithoutProjectInput, UserToProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput>
  }

  export type UserToProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    data: XOR<UserToProjectUpdateWithoutProjectInput, UserToProjectUncheckedUpdateWithoutProjectInput>
  }

  export type UserToProjectUpdateManyWithWhereWithoutProjectInput = {
    where: UserToProjectScalarWhereInput
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyWithoutProjectAssigneesInput>
  }

  export type RoomReadingUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    update: XOR<RoomReadingUpdateWithoutProjectInput, RoomReadingUncheckedUpdateWithoutProjectInput>
    create: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput>
  }

  export type RoomReadingUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    data: XOR<RoomReadingUpdateWithoutProjectInput, RoomReadingUncheckedUpdateWithoutProjectInput>
  }

  export type RoomReadingUpdateManyWithWhereWithoutProjectInput = {
    where: RoomReadingScalarWhereInput
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyWithoutRoomReadingsInput>
  }

  export type RoomReadingScalarWhereInput = {
    AND?: Enumerable<RoomReadingScalarWhereInput>
    OR?: Enumerable<RoomReadingScalarWhereInput>
    NOT?: Enumerable<RoomReadingScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    date?: DateTimeFilter | Date | string
    humidity?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    moistureContentWall?: StringNullableFilter | string | null
    moistureContentFloor?: StringNullableFilter | string | null
    equipmentUsed?: StringNullableListFilter
    roomId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    gpp?: StringNullableFilter | string | null
  }

  export type PropertyDataUpsertWithoutProjectInput = {
    update: XOR<PropertyDataUpdateWithoutProjectInput, PropertyDataUncheckedUpdateWithoutProjectInput>
    create: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
  }

  export type PropertyDataUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AreaAffectedUpsertWithWhereUniqueWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    update: XOR<AreaAffectedUpdateWithoutProjectInput, AreaAffectedUncheckedUpdateWithoutProjectInput>
    create: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedUpdateWithWhereUniqueWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    data: XOR<AreaAffectedUpdateWithoutProjectInput, AreaAffectedUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUpdateManyWithWhereWithoutProjectInput = {
    where: AreaAffectedScalarWhereInput
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyWithoutAreaAffectedInput>
  }

  export type AreaAffectedScalarWhereInput = {
    AND?: Enumerable<AreaAffectedScalarWhereInput>
    OR?: Enumerable<AreaAffectedScalarWhereInput>
    NOT?: Enumerable<AreaAffectedScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    date?: DateTimeFilter | Date | string
    roomId?: IntFilter | number
    material?: StringNullableFilter | string | null
    totalAreaRemoved?: StringNullableFilter | string | null
    totalAreaMicrobialApplied?: StringNullableFilter | string | null
    cause?: StringNullableFilter | string | null
    category?: IntNullableFilter | number | null
    cabinetryRemoved?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    type?: EnumAreaAffectedTypeFilter | AreaAffectedType
  }

  export type PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    update: XOR<PhotoAccessLinkUpdateWithoutProjectInput, PhotoAccessLinkUncheckedUpdateWithoutProjectInput>
    create: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput>
  }

  export type PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    data: XOR<PhotoAccessLinkUpdateWithoutProjectInput, PhotoAccessLinkUncheckedUpdateWithoutProjectInput>
  }

  export type PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput = {
    where: PhotoAccessLinkScalarWhereInput
    data: XOR<PhotoAccessLinkUpdateManyMutationInput, PhotoAccessLinkUncheckedUpdateManyWithoutPhotoAccessLinksInput>
  }

  export type PhotoAccessLinkScalarWhereInput = {
    AND?: Enumerable<PhotoAccessLinkScalarWhereInput>
    OR?: Enumerable<PhotoAccessLinkScalarWhereInput>
    NOT?: Enumerable<PhotoAccessLinkScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    accessId?: StringFilter | string
    email?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    projectId?: IntFilter | number
  }

  export type NotesUpsertWithWhereUniqueWithoutProjectInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutProjectInput, NotesUncheckedUpdateWithoutProjectInput>
    create: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutProjectInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutProjectInput, NotesUncheckedUpdateWithoutProjectInput>
  }

  export type NotesUpdateManyWithWhereWithoutProjectInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutNotesInput>
  }

  export type NotesScalarWhereInput = {
    AND?: Enumerable<NotesScalarWhereInput>
    OR?: Enumerable<NotesScalarWhereInput>
    NOT?: Enumerable<NotesScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    date?: DateTimeFilter | Date | string
    roomId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    body?: StringFilter | string
  }

  export type CostUpsertWithWhereUniqueWithoutProjectInput = {
    where: CostWhereUniqueInput
    update: XOR<CostUpdateWithoutProjectInput, CostUncheckedUpdateWithoutProjectInput>
    create: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput>
  }

  export type CostUpdateWithWhereUniqueWithoutProjectInput = {
    where: CostWhereUniqueInput
    data: XOR<CostUpdateWithoutProjectInput, CostUncheckedUpdateWithoutProjectInput>
  }

  export type CostUpdateManyWithWhereWithoutProjectInput = {
    where: CostScalarWhereInput
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyWithoutCostsInput>
  }

  export type CostScalarWhereInput = {
    AND?: Enumerable<CostScalarWhereInput>
    OR?: Enumerable<CostScalarWhereInput>
    NOT?: Enumerable<CostScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    estimatedCost?: FloatNullableFilter | number | null
    actualCost?: FloatNullableFilter | number | null
    name?: StringNullableFilter | string | null
    projectId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    type?: EnumCostTypeFilter | CostType
  }

  export type ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    update: XOR<ProjectEquipmentUpdateWithoutProjectInput, ProjectEquipmentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    data: XOR<ProjectEquipmentUpdateWithoutProjectInput, ProjectEquipmentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectEquipmentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectEquipmentScalarWhereInput
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyWithoutProjectEquipmentInput>
  }

  export type WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    update: XOR<WeatherReportItemUpdateWithoutProjectInput, WeatherReportItemUncheckedUpdateWithoutProjectInput>
    create: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput>
  }

  export type WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    data: XOR<WeatherReportItemUpdateWithoutProjectInput, WeatherReportItemUncheckedUpdateWithoutProjectInput>
  }

  export type WeatherReportItemUpdateManyWithWhereWithoutProjectInput = {
    where: WeatherReportItemScalarWhereInput
    data: XOR<WeatherReportItemUpdateManyMutationInput, WeatherReportItemUncheckedUpdateManyWithoutWeatherReportItemsInput>
  }

  export type WeatherReportItemScalarWhereInput = {
    AND?: Enumerable<WeatherReportItemScalarWhereInput>
    OR?: Enumerable<WeatherReportItemScalarWhereInput>
    NOT?: Enumerable<WeatherReportItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    projectId?: IntFilter | number
    date?: DateTimeFilter | Date | string
    time?: StringFilter | string
    f_scale?: StringNullableFilter | string | null
    speed?: StringNullableFilter | string | null
    size?: StringNullableFilter | string | null
    location?: StringFilter | string
    county?: StringFilter | string
    state?: StringFilter | string
    lat?: StringFilter | string
    lon?: StringFilter | string
    comments?: StringFilter | string
  }

  export type ProjectStatusValueUpsertWithoutProjectsInput = {
    update: XOR<ProjectStatusValueUpdateWithoutProjectsInput, ProjectStatusValueUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectStatusValueUpdateWithoutProjectsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    update: XOR<PendingRoofReportsUpdateWithoutProjectInput, PendingRoofReportsUncheckedUpdateWithoutProjectInput>
    create: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput>
  }

  export type PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    data: XOR<PendingRoofReportsUpdateWithoutProjectInput, PendingRoofReportsUncheckedUpdateWithoutProjectInput>
  }

  export type PendingRoofReportsUpdateManyWithWhereWithoutProjectInput = {
    where: PendingRoofReportsScalarWhereInput
    data: XOR<PendingRoofReportsUpdateManyMutationInput, PendingRoofReportsUncheckedUpdateManyWithoutPendingRoofReportsInput>
  }

  export type PendingRoofReportsScalarWhereInput = {
    AND?: Enumerable<PendingRoofReportsScalarWhereInput>
    OR?: Enumerable<PendingRoofReportsScalarWhereInput>
    NOT?: Enumerable<PendingRoofReportsScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    projectId?: IntFilter | number
    isCompleted?: BoolFilter | boolean
  }

  export type ProjectNotesUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    update: XOR<ProjectNotesUpdateWithoutProjectInput, ProjectNotesUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotesUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    data: XOR<ProjectNotesUpdateWithoutProjectInput, ProjectNotesUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectNotesUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectNotesScalarWhereInput
    data: XOR<ProjectNotesUpdateManyMutationInput, ProjectNotesUncheckedUpdateManyWithoutProjectNotesInput>
  }

  export type ProjectNotesScalarWhereInput = {
    AND?: Enumerable<ProjectNotesScalarWhereInput>
    OR?: Enumerable<ProjectNotesScalarWhereInput>
    NOT?: Enumerable<ProjectNotesScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    date?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    projectId?: IntFilter | number
    body?: StringFilter | string
    mentions?: StringNullableListFilter
    userId?: StringFilter | string
  }

  export type ProjectCreateWithoutProjectNotesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectNotesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectNotesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
  }

  export type ProjectUpsertWithoutProjectNotesInput = {
    update: XOR<ProjectUpdateWithoutProjectNotesInput, ProjectUncheckedUpdateWithoutProjectNotesInput>
    create: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
  }

  export type ProjectUpdateWithoutProjectNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutCurrentStatusInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCurrentStatusInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput>
  }

  export type ProjectCreateManyCurrentStatusInputEnvelope = {
    data: Enumerable<ProjectCreateManyCurrentStatusInput>
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProjectStatusValueInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectStatusValueInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectStatusValueInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCurrentStatusInput, ProjectUncheckedUpdateWithoutCurrentStatusInput>
    create: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCurrentStatusInput, ProjectUncheckedUpdateWithoutCurrentStatusInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCurrentStatusInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
  }

  export type OrganizationUpsertWithoutProjectStatusValueInput = {
    update: XOR<OrganizationUpdateWithoutProjectStatusValueInput, OrganizationUncheckedUpdateWithoutProjectStatusValueInput>
    create: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
  }

  export type OrganizationUpdateWithoutProjectStatusValueInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectStatusValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectCreateWithoutPendingRoofReportsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPendingRoofReportsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPendingRoofReportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
  }

  export type ProjectUpsertWithoutPendingRoofReportsInput = {
    update: XOR<ProjectUpdateWithoutPendingRoofReportsInput, ProjectUncheckedUpdateWithoutPendingRoofReportsInput>
    create: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
  }

  export type ProjectUpdateWithoutPendingRoofReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPendingRoofReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutWeatherReportItemsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWeatherReportItemsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWeatherReportItemsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
  }

  export type ProjectUpsertWithoutWeatherReportItemsInput = {
    update: XOR<ProjectUpdateWithoutWeatherReportItemsInput, ProjectUncheckedUpdateWithoutWeatherReportItemsInput>
    create: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
  }

  export type ProjectUpdateWithoutWeatherReportItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWeatherReportItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EquipmentCreateWithoutProjectEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organization: OrganizationCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutProjectEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
  }

  export type EquipmentCreateOrConnectWithoutProjectEquipmentInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type ProjectCreateWithoutProjectEquipmentInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectEquipmentInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectEquipmentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type EquipmentUpsertWithoutProjectEquipmentInput = {
    update: XOR<EquipmentUpdateWithoutProjectEquipmentInput, EquipmentUncheckedUpdateWithoutProjectEquipmentInput>
    create: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type EquipmentUpdateWithoutProjectEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutProjectEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectUpsertWithoutProjectEquipmentInput = {
    update: XOR<ProjectUpdateWithoutProjectEquipmentInput, ProjectUncheckedUpdateWithoutProjectEquipmentInput>
    create: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type ProjectUpdateWithoutProjectEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutCostsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCostsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCostsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
  }

  export type ProjectUpsertWithoutCostsInput = {
    update: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
  }

  export type ProjectUpdateWithoutCostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPropertyDataInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPropertyDataInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPropertyDataInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
  }

  export type ProjectUpsertWithoutPropertyDataInput = {
    update: XOR<ProjectUpdateWithoutPropertyDataInput, ProjectUncheckedUpdateWithoutPropertyDataInput>
    create: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
  }

  export type ProjectUpdateWithoutPropertyDataInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPropertyDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPhotoAccessLinksInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPhotoAccessLinksInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPhotoAccessLinksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
  }

  export type ProjectUpsertWithoutPhotoAccessLinksInput = {
    update: XOR<ProjectUpdateWithoutPhotoAccessLinksInput, ProjectUncheckedUpdateWithoutPhotoAccessLinksInput>
    create: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
  }

  export type ProjectUpdateWithoutPhotoAccessLinksInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPhotoAccessLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutImageInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutImageInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutImageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
  }

  export type ProjectCreateWithoutImagesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutImagesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutImagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
  }

  export type InferenceCreateWithoutImageInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    projectId: number
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutImageInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteCreateWithoutImageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    isDeleted?: boolean
    User: UserCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteCreateOrConnectWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    create: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteCreateManyImageInputEnvelope = {
    data: Enumerable<ImageNoteCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutImageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    User: UserCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput>
  }

  export type AnnotationCreateManyImageInputEnvelope = {
    data: Enumerable<AnnotationCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutImageInput = {
    update: XOR<OrganizationUpdateWithoutImageInput, OrganizationUncheckedUpdateWithoutImageInput>
    create: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
  }

  export type OrganizationUpdateWithoutImageInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithoutImagesInput = {
    update: XOR<ProjectUpdateWithoutImagesInput, ProjectUncheckedUpdateWithoutImagesInput>
    create: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
  }

  export type ProjectUpdateWithoutImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type InferenceUpsertWithoutImageInput = {
    update: XOR<InferenceUpdateWithoutImageInput, InferenceUncheckedUpdateWithoutImageInput>
    create: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
  }

  export type InferenceUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type ImageNoteUpsertWithWhereUniqueWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    update: XOR<ImageNoteUpdateWithoutImageInput, ImageNoteUncheckedUpdateWithoutImageInput>
    create: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteUpdateWithWhereUniqueWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    data: XOR<ImageNoteUpdateWithoutImageInput, ImageNoteUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUpdateManyWithWhereWithoutImageInput = {
    where: ImageNoteScalarWhereInput
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyWithoutImageNoteInput>
  }

  export type AnnotationUpsertWithWhereUniqueWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutImageInput, AnnotationUncheckedUpdateWithoutImageInput>
    create: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutImageInput, AnnotationUncheckedUpdateWithoutImageInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutImageInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutAnnotationInput>
  }

  export type ImageCreateWithoutAnnotationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutAnnotationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutAnnotationInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
  }

  export type UserCreateWithoutAnnotationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnotationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnotationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
  }

  export type ImageUpsertWithoutAnnotationInput = {
    update: XOR<ImageUpdateWithoutAnnotationInput, ImageUncheckedUpdateWithoutAnnotationInput>
    create: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
  }

  export type ImageUpdateWithoutAnnotationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutAnnotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UserUpsertWithoutAnnotationInput = {
    update: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
  }

  export type UserUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImageCreateWithoutImageNoteInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutImageNoteInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutImageNoteInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
  }

  export type UserCreateWithoutImageNoteInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageNoteInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: DashboardViews
    photoView?: PhotoViews
    groupView?: GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
  }

  export type ImageUpsertWithoutImageNoteInput = {
    update: XOR<ImageUpdateWithoutImageNoteInput, ImageUncheckedUpdateWithoutImageNoteInput>
    create: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
  }

  export type ImageUpdateWithoutImageNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutImageNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UserUpsertWithoutImageNoteInput = {
    update: XOR<UserUpdateWithoutImageNoteInput, UserUncheckedUpdateWithoutImageNoteInput>
    create: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
  }

  export type UserUpdateWithoutImageNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImageCreateWithoutInferenceInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutInferenceInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
  }

  export type ProjectCreateWithoutInferencesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInferencesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInferencesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
  }

  export type RoomCreateWithoutInferencesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutInferencesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutInferencesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
  }

  export type DetectionCreateWithoutInferenceInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: DimensionUnit | null
    room?: RoomCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateWithoutInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type DetectionCreateOrConnectWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    create: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput>
  }

  export type DetectionCreateManyInferenceInputEnvelope = {
    data: Enumerable<DetectionCreateManyInferenceInput>
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithoutInferenceInput = {
    update: XOR<ImageUpdateWithoutInferenceInput, ImageUncheckedUpdateWithoutInferenceInput>
    create: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
  }

  export type ImageUpdateWithoutInferenceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutInferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ProjectUpsertWithoutInferencesInput = {
    update: XOR<ProjectUpdateWithoutInferencesInput, ProjectUncheckedUpdateWithoutInferencesInput>
    create: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
  }

  export type ProjectUpdateWithoutInferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RoomUpsertWithoutInferencesInput = {
    update: XOR<RoomUpdateWithoutInferencesInput, RoomUncheckedUpdateWithoutInferencesInput>
    create: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
  }

  export type RoomUpdateWithoutInferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutInferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type DetectionUpsertWithWhereUniqueWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    update: XOR<DetectionUpdateWithoutInferenceInput, DetectionUncheckedUpdateWithoutInferenceInput>
    create: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput>
  }

  export type DetectionUpdateWithWhereUniqueWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    data: XOR<DetectionUpdateWithoutInferenceInput, DetectionUncheckedUpdateWithoutInferenceInput>
  }

  export type DetectionUpdateManyWithWhereWithoutInferenceInput = {
    where: DetectionScalarWhereInput
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyWithoutDetectionsInput>
  }

  export type DetectionScalarWhereInput = {
    AND?: Enumerable<DetectionScalarWhereInput>
    OR?: Enumerable<DetectionScalarWhereInput>
    NOT?: Enumerable<DetectionScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    publicId?: StringFilter | string
    inferenceId?: IntFilter | number
    imageKey?: StringNullableFilter | string | null
    xMinCord?: FloatNullableFilter | number | null
    yMinCord?: FloatNullableFilter | number | null
    confidence?: FloatNullableFilter | number | null
    xMaxCord?: FloatNullableFilter | number | null
    yMaxCord?: FloatNullableFilter | number | null
    projectId?: IntFilter | number
    category?: StringFilter | string
    code?: StringFilter | string
    item?: StringFilter | string
    quality?: StringFilter | string
    roomId?: IntNullableFilter | number | null
    dimension?: IntNullableFilter | number | null
    unit?: EnumDimensionUnitNullableFilter | DimensionUnit | null
  }

  export type ProjectCreateWithoutRoomsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoomsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoomsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
  }

  export type DetectionCreateWithoutRoomInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: DimensionUnit | null
    inference: InferenceCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type DetectionCreateOrConnectWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    create: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput>
  }

  export type DetectionCreateManyRoomInputEnvelope = {
    data: Enumerable<DetectionCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type InferenceCreateWithoutRoomInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput>
  }

  export type InferenceCreateManyRoomInputEnvelope = {
    data: Enumerable<InferenceCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type TemplatesUsedCreateWithoutRoomInput = {
    createdAt?: Date | string
    templateCode: string
  }

  export type TemplatesUsedUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
  }

  export type TemplatesUsedCreateOrConnectWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    create: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput>
  }

  export type TemplatesUsedCreateManyRoomInputEnvelope = {
    data: Enumerable<TemplatesUsedCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type RoomReadingCreateWithoutRoomInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingCreateOrConnectWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput>
  }

  export type RoomReadingCreateManyRoomInputEnvelope = {
    data: Enumerable<RoomReadingCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type AreaAffectedCreateWithoutRoomInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: AreaAffectedType
    project: ProjectCreateNestedOneWithoutAreaAffectedInput
  }

  export type AreaAffectedUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: AreaAffectedType
  }

  export type AreaAffectedCreateOrConnectWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    create: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput>
  }

  export type AreaAffectedCreateManyRoomInputEnvelope = {
    data: Enumerable<AreaAffectedCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type NotesCreateWithoutRoomInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    project: ProjectCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesCreateOrConnectWithoutRoomInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput>
  }

  export type NotesCreateManyRoomInputEnvelope = {
    data: Enumerable<NotesCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutRoomsInput = {
    update: XOR<ProjectUpdateWithoutRoomsInput, ProjectUncheckedUpdateWithoutRoomsInput>
    create: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
  }

  export type ProjectUpdateWithoutRoomsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DetectionUpsertWithWhereUniqueWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    update: XOR<DetectionUpdateWithoutRoomInput, DetectionUncheckedUpdateWithoutRoomInput>
    create: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput>
  }

  export type DetectionUpdateWithWhereUniqueWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    data: XOR<DetectionUpdateWithoutRoomInput, DetectionUncheckedUpdateWithoutRoomInput>
  }

  export type DetectionUpdateManyWithWhereWithoutRoomInput = {
    where: DetectionScalarWhereInput
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyWithoutDetectionsInput>
  }

  export type InferenceUpsertWithWhereUniqueWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    update: XOR<InferenceUpdateWithoutRoomInput, InferenceUncheckedUpdateWithoutRoomInput>
    create: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput>
  }

  export type InferenceUpdateWithWhereUniqueWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    data: XOR<InferenceUpdateWithoutRoomInput, InferenceUncheckedUpdateWithoutRoomInput>
  }

  export type InferenceUpdateManyWithWhereWithoutRoomInput = {
    where: InferenceScalarWhereInput
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyWithoutInferencesInput>
  }

  export type TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    update: XOR<TemplatesUsedUpdateWithoutRoomInput, TemplatesUsedUncheckedUpdateWithoutRoomInput>
    create: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput>
  }

  export type TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    data: XOR<TemplatesUsedUpdateWithoutRoomInput, TemplatesUsedUncheckedUpdateWithoutRoomInput>
  }

  export type TemplatesUsedUpdateManyWithWhereWithoutRoomInput = {
    where: TemplatesUsedScalarWhereInput
    data: XOR<TemplatesUsedUpdateManyMutationInput, TemplatesUsedUncheckedUpdateManyWithoutTemplatesInput>
  }

  export type TemplatesUsedScalarWhereInput = {
    AND?: Enumerable<TemplatesUsedScalarWhereInput>
    OR?: Enumerable<TemplatesUsedScalarWhereInput>
    NOT?: Enumerable<TemplatesUsedScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    templateCode?: StringFilter | string
    roomId?: IntNullableFilter | number | null
  }

  export type RoomReadingUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    update: XOR<RoomReadingUpdateWithoutRoomInput, RoomReadingUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput>
  }

  export type RoomReadingUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    data: XOR<RoomReadingUpdateWithoutRoomInput, RoomReadingUncheckedUpdateWithoutRoomInput>
  }

  export type RoomReadingUpdateManyWithWhereWithoutRoomInput = {
    where: RoomReadingScalarWhereInput
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyWithoutRoomReadingsInput>
  }

  export type AreaAffectedUpsertWithWhereUniqueWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    update: XOR<AreaAffectedUpdateWithoutRoomInput, AreaAffectedUncheckedUpdateWithoutRoomInput>
    create: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput>
  }

  export type AreaAffectedUpdateWithWhereUniqueWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    data: XOR<AreaAffectedUpdateWithoutRoomInput, AreaAffectedUncheckedUpdateWithoutRoomInput>
  }

  export type AreaAffectedUpdateManyWithWhereWithoutRoomInput = {
    where: AreaAffectedScalarWhereInput
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyWithoutAreasAffectedInput>
  }

  export type NotesUpsertWithWhereUniqueWithoutRoomInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutRoomInput, NotesUncheckedUpdateWithoutRoomInput>
    create: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutRoomInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutRoomInput, NotesUncheckedUpdateWithoutRoomInput>
  }

  export type NotesUpdateManyWithWhereWithoutRoomInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutNotesInput>
  }

  export type RoomCreateWithoutRoomReadingsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutRoomReadingsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
  }

  export type ProjectCreateWithoutRoomReadingsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoomReadingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
  }

  export type GenericRoomReadingCreateWithoutRoomReadingInput = {
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingUncheckedCreateWithoutRoomReadingInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingCreateOrConnectWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    create: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingCreateManyRoomReadingInputEnvelope = {
    data: Enumerable<GenericRoomReadingCreateManyRoomReadingInput>
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithoutRoomReadingsInput = {
    update: XOR<RoomUpdateWithoutRoomReadingsInput, RoomUncheckedUpdateWithoutRoomReadingsInput>
    create: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
  }

  export type RoomUpdateWithoutRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutRoomReadingsInput = {
    update: XOR<ProjectUpdateWithoutRoomReadingsInput, ProjectUncheckedUpdateWithoutRoomReadingsInput>
    create: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
  }

  export type ProjectUpdateWithoutRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    update: XOR<GenericRoomReadingUpdateWithoutRoomReadingInput, GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput>
    create: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    data: XOR<GenericRoomReadingUpdateWithoutRoomReadingInput, GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput = {
    where: GenericRoomReadingScalarWhereInput
    data: XOR<GenericRoomReadingUpdateManyMutationInput, GenericRoomReadingUncheckedUpdateManyWithoutGenericRoomReadingsInput>
  }

  export type GenericRoomReadingScalarWhereInput = {
    AND?: Enumerable<GenericRoomReadingScalarWhereInput>
    OR?: Enumerable<GenericRoomReadingScalarWhereInput>
    NOT?: Enumerable<GenericRoomReadingScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    publicId?: StringFilter | string
    type?: EnumRoomReadingTypeFilter | RoomReadingType
    value?: StringFilter | string
    humidity?: StringNullableFilter | string | null
    temperature?: StringNullableFilter | string | null
    gpp?: StringNullableFilter | string | null
    roomReadingId?: IntFilter | number
    isDeleted?: BoolFilter | boolean
  }

  export type RoomCreateWithoutNotesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutNotesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutNotesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
  }

  export type ProjectCreateWithoutNotesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNotesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNotesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
  }

  export type NotesAuditTrailCreateWithoutNoteInput = {
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUncheckedCreateWithoutNoteInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
  }

  export type NotesAuditTrailCreateOrConnectWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    create: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput>
  }

  export type NotesAuditTrailCreateManyNoteInputEnvelope = {
    data: Enumerable<NotesAuditTrailCreateManyNoteInput>
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithoutNotesInput = {
    update: XOR<RoomUpdateWithoutNotesInput, RoomUncheckedUpdateWithoutNotesInput>
    create: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
  }

  export type RoomUpdateWithoutNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutNotesInput = {
    update: XOR<ProjectUpdateWithoutNotesInput, ProjectUncheckedUpdateWithoutNotesInput>
    create: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
  }

  export type ProjectUpdateWithoutNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    update: XOR<NotesAuditTrailUpdateWithoutNoteInput, NotesAuditTrailUncheckedUpdateWithoutNoteInput>
    create: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput>
  }

  export type NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    data: XOR<NotesAuditTrailUpdateWithoutNoteInput, NotesAuditTrailUncheckedUpdateWithoutNoteInput>
  }

  export type NotesAuditTrailUpdateManyWithWhereWithoutNoteInput = {
    where: NotesAuditTrailScalarWhereInput
    data: XOR<NotesAuditTrailUpdateManyMutationInput, NotesAuditTrailUncheckedUpdateManyWithoutNotesAuditTrailInput>
  }

  export type NotesAuditTrailScalarWhereInput = {
    AND?: Enumerable<NotesAuditTrailScalarWhereInput>
    OR?: Enumerable<NotesAuditTrailScalarWhereInput>
    NOT?: Enumerable<NotesAuditTrailScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    notesId?: IntFilter | number
    userId?: StringFilter | string
    userName?: StringNullableFilter | string | null
    action?: EnumNotesAuditActionFilter | NotesAuditAction
    body?: StringFilter | string
  }

  export type NotesCreateWithoutNotesAuditTrailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    project: ProjectCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutNotesAuditTrailInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type NotesCreateOrConnectWithoutNotesAuditTrailInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
  }

  export type NotesUpsertWithoutNotesAuditTrailInput = {
    update: XOR<NotesUpdateWithoutNotesAuditTrailInput, NotesUncheckedUpdateWithoutNotesAuditTrailInput>
    create: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
  }

  export type NotesUpdateWithoutNotesAuditTrailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutNotesAuditTrailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateWithoutAreasAffectedInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutAreasAffectedInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutAreasAffectedInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
  }

  export type ProjectCreateWithoutAreaAffectedInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAreaAffectedInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAreaAffectedInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
  }

  export type RoomUpsertWithoutAreasAffectedInput = {
    update: XOR<RoomUpdateWithoutAreasAffectedInput, RoomUncheckedUpdateWithoutAreasAffectedInput>
    create: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
  }

  export type RoomUpdateWithoutAreasAffectedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAreasAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutAreaAffectedInput = {
    update: XOR<ProjectUpdateWithoutAreaAffectedInput, ProjectUncheckedUpdateWithoutAreaAffectedInput>
    create: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
  }

  export type ProjectUpdateWithoutAreaAffectedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAreaAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RoomReadingCreateWithoutGenericRoomReadingsInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
  }

  export type RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
  }

  export type RoomReadingUpsertWithoutGenericRoomReadingsInput = {
    update: XOR<RoomReadingUpdateWithoutGenericRoomReadingsInput, RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput>
    create: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
  }

  export type RoomReadingUpdateWithoutGenericRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceCreateWithoutDetectionsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
  }

  export type InferenceUncheckedCreateWithoutDetectionsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
  }

  export type InferenceCreateOrConnectWithoutDetectionsInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
  }

  export type RoomCreateWithoutDetectionsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutDetectionsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutDetectionsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
  }

  export type InferenceUpsertWithoutDetectionsInput = {
    update: XOR<InferenceUpdateWithoutDetectionsInput, InferenceUncheckedUpdateWithoutDetectionsInput>
    create: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
  }

  export type InferenceUpdateWithoutDetectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
  }

  export type InferenceUncheckedUpdateWithoutDetectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUpsertWithoutDetectionsInput = {
    update: XOR<RoomUpdateWithoutDetectionsInput, RoomUncheckedUpdateWithoutDetectionsInput>
    create: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
  }

  export type RoomUpdateWithoutDetectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutDetectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateWithoutTemplatesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutTemplatesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutTemplatesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
  }

  export type RoomUpsertWithoutTemplatesInput = {
    update: XOR<RoomUpdateWithoutTemplatesInput, RoomUncheckedUpdateWithoutTemplatesInput>
    create: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
  }

  export type RoomUpdateWithoutTemplatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type CalendarEventReminderCreateWithoutCalendarEventInput = {
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderUncheckedCreateWithoutCalendarEventInput = {
    id?: number
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderCreateOrConnectWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    create: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderCreateManyCalendarEventInputEnvelope = {
    data: Enumerable<CalendarEventReminderCreateManyCalendarEventInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutEventsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEventsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
  }

  export type CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    update: XOR<CalendarEventReminderUpdateWithoutCalendarEventInput, CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput>
    create: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    data: XOR<CalendarEventReminderUpdateWithoutCalendarEventInput, CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput = {
    where: CalendarEventReminderScalarWhereInput
    data: XOR<CalendarEventReminderUpdateManyMutationInput, CalendarEventReminderUncheckedUpdateManyWithoutRemindersInput>
  }

  export type CalendarEventReminderScalarWhereInput = {
    AND?: Enumerable<CalendarEventReminderScalarWhereInput>
    OR?: Enumerable<CalendarEventReminderScalarWhereInput>
    NOT?: Enumerable<CalendarEventReminderScalarWhereInput>
    id?: IntFilter | number
    reminderTarget?: EnumReminderTargetFilter | ReminderTarget
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sendText?: BoolFilter | boolean
    sendEmail?: BoolFilter | boolean
    textSentAt?: DateTimeNullableFilter | Date | string | null
    emailSentAt?: DateTimeNullableFilter | Date | string | null
    calendarEventId?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
  }

  export type ProjectUpsertWithoutEventsInput = {
    update: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
  }

  export type ProjectUpdateWithoutEventsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CalendarEventCreateWithoutRemindersInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    project?: ProjectCreateNestedOneWithoutEventsInput
  }

  export type CalendarEventUncheckedCreateWithoutRemindersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type CalendarEventCreateOrConnectWithoutRemindersInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
  }

  export type CalendarEventUpsertWithoutRemindersInput = {
    update: XOR<CalendarEventUpdateWithoutRemindersInput, CalendarEventUncheckedUpdateWithoutRemindersInput>
    create: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
  }

  export type CalendarEventUpdateWithoutRemindersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneWithoutEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LineItemCreateWithoutXactimateCategoryInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutXactimateCategoryInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput>
  }

  export type LineItemCreateManyXactimateCategoryInputEnvelope = {
    data: Enumerable<LineItemCreateManyXactimateCategoryInput>
    skipDuplicates?: boolean
  }

  export type LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    update: XOR<LineItemUpdateWithoutXactimateCategoryInput, LineItemUncheckedUpdateWithoutXactimateCategoryInput>
    create: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput>
  }

  export type LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    data: XOR<LineItemUpdateWithoutXactimateCategoryInput, LineItemUncheckedUpdateWithoutXactimateCategoryInput>
  }

  export type LineItemUpdateManyWithWhereWithoutXactimateCategoryInput = {
    where: LineItemScalarWhereInput
    data: XOR<LineItemUpdateManyMutationInput, LineItemUncheckedUpdateManyWithoutLineItemInput>
  }

  export type LineItemScalarWhereInput = {
    AND?: Enumerable<LineItemScalarWhereInput>
    OR?: Enumerable<LineItemScalarWhereInput>
    NOT?: Enumerable<LineItemScalarWhereInput>
    id?: IntFilter | number
    xactimateCode?: StringFilter | string
    xactimateDescription?: StringFilter | string
    unit?: StringNullableFilter | string | null
    itemCategoryId?: IntFilter | number
  }

  export type ItemCategoryCreateWithoutLineItemInput = {
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryUncheckedCreateWithoutLineItemInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryCreateOrConnectWithoutLineItemInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemCreateWithoutLineItemInput = {
    alternateId: string
  }

  export type AlternateItemUncheckedCreateWithoutLineItemInput = {
    id?: number
    alternateId: string
  }

  export type AlternateItemCreateOrConnectWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    create: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemCreateManyLineItemInputEnvelope = {
    data: Enumerable<AlternateItemCreateManyLineItemInput>
    skipDuplicates?: boolean
  }

  export type RelatedItemCreateWithoutLineItemInput = {
    relationId: string
  }

  export type RelatedItemUncheckedCreateWithoutLineItemInput = {
    id?: number
    relationId: string
  }

  export type RelatedItemCreateOrConnectWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    create: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput>
  }

  export type RelatedItemCreateManyLineItemInputEnvelope = {
    data: Enumerable<RelatedItemCreateManyLineItemInput>
    skipDuplicates?: boolean
  }

  export type ItemCategoryUpsertWithoutLineItemInput = {
    update: XOR<ItemCategoryUpdateWithoutLineItemInput, ItemCategoryUncheckedUpdateWithoutLineItemInput>
    create: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
  }

  export type ItemCategoryUpdateWithoutLineItemInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCategoryUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlternateItemUpsertWithWhereUniqueWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    update: XOR<AlternateItemUpdateWithoutLineItemInput, AlternateItemUncheckedUpdateWithoutLineItemInput>
    create: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemUpdateWithWhereUniqueWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    data: XOR<AlternateItemUpdateWithoutLineItemInput, AlternateItemUncheckedUpdateWithoutLineItemInput>
  }

  export type AlternateItemUpdateManyWithWhereWithoutLineItemInput = {
    where: AlternateItemScalarWhereInput
    data: XOR<AlternateItemUpdateManyMutationInput, AlternateItemUncheckedUpdateManyWithoutAlternateItemInput>
  }

  export type AlternateItemScalarWhereInput = {
    AND?: Enumerable<AlternateItemScalarWhereInput>
    OR?: Enumerable<AlternateItemScalarWhereInput>
    NOT?: Enumerable<AlternateItemScalarWhereInput>
    id?: IntFilter | number
    alternateId?: StringFilter | string
    lineItemId?: IntFilter | number
  }

  export type RelatedItemUpsertWithWhereUniqueWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    update: XOR<RelatedItemUpdateWithoutLineItemInput, RelatedItemUncheckedUpdateWithoutLineItemInput>
    create: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput>
  }

  export type RelatedItemUpdateWithWhereUniqueWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    data: XOR<RelatedItemUpdateWithoutLineItemInput, RelatedItemUncheckedUpdateWithoutLineItemInput>
  }

  export type RelatedItemUpdateManyWithWhereWithoutLineItemInput = {
    where: RelatedItemScalarWhereInput
    data: XOR<RelatedItemUpdateManyMutationInput, RelatedItemUncheckedUpdateManyWithoutRelatedItemInput>
  }

  export type RelatedItemScalarWhereInput = {
    AND?: Enumerable<RelatedItemScalarWhereInput>
    OR?: Enumerable<RelatedItemScalarWhereInput>
    NOT?: Enumerable<RelatedItemScalarWhereInput>
    id?: IntFilter | number
    relationId?: StringFilter | string
    lineItemId?: IntFilter | number
  }

  export type LineItemCreateWithoutRelatedItemInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutRelatedItemInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutRelatedItemInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
  }

  export type LineItemUpsertWithoutRelatedItemInput = {
    update: XOR<LineItemUpdateWithoutRelatedItemInput, LineItemUncheckedUpdateWithoutRelatedItemInput>
    create: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
  }

  export type LineItemUpdateWithoutRelatedItemInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutRelatedItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemCreateWithoutAlternateItemInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutAlternateItemInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutAlternateItemInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
  }

  export type LineItemUpsertWithoutAlternateItemInput = {
    update: XOR<LineItemUpdateWithoutAlternateItemInput, LineItemUncheckedUpdateWithoutAlternateItemInput>
    create: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
  }

  export type LineItemUpdateWithoutAlternateItemInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutAlternateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type OrganizationCreateWithoutCustomersInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCustomersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCustomersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
  }

  export type OrganizationUpsertWithoutCustomersInput = {
    update: XOR<OrganizationUpdateWithoutCustomersInput, OrganizationUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
  }

  export type OrganizationUpdateWithoutCustomersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type PricesCreateWithoutProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsCreateNestedManyWithoutPriceInput
  }

  export type PricesUncheckedCreateWithoutProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PricesCreateOrConnectWithoutProductInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesCreateManyProductInputEnvelope = {
    data: Enumerable<PricesCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PricesUpsertWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    update: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesUpdateWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    data: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
  }

  export type PricesUpdateManyWithWhereWithoutProductInput = {
    where: PricesScalarWhereInput
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyWithoutPricesInput>
  }

  export type PricesScalarWhereInput = {
    AND?: Enumerable<PricesScalarWhereInput>
    OR?: Enumerable<PricesScalarWhereInput>
    NOT?: Enumerable<PricesScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    active?: BoolFilter | boolean
    unitAmount?: BigIntNullableFilter | bigint | number | null
    currency?: StringFilter | string
    type?: EnumPricingTypeFilter | PricingType
    interval?: EnumPricingPlanIntervalNullableFilter | PricingPlanInterval | null
    intervalCount?: IntNullableFilter | number | null
    trialPeriodDays?: IntNullableFilter | number | null
    metadata?: JsonNullableFilter
    description?: StringFilter | string
  }

  export type ProductsCreateWithoutPricesInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedCreateWithoutPricesInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsCreateOrConnectWithoutPricesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
  }

  export type SubscriptionsCreateWithoutPriceInput = {
    id: string
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutPriceInput = {
    id: string
    organizationId: number
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsCreateOrConnectWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionsCreateManyPriceInputEnvelope = {
    data: Enumerable<SubscriptionsCreateManyPriceInput>
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutPricesInput = {
    update: XOR<ProductsUpdateWithoutPricesInput, ProductsUncheckedUpdateWithoutPricesInput>
    create: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
  }

  export type ProductsUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutPriceInput, SubscriptionsUncheckedUpdateWithoutPriceInput>
    create: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutPriceInput, SubscriptionsUncheckedUpdateWithoutPriceInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutPriceInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type PricesCreateWithoutSubscriptionsInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    product: ProductsCreateNestedOneWithoutPricesInput
  }

  export type PricesUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesCreateOrConnectWithoutSubscriptionsInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
  }

  export type OrganizationCreateWithoutSubscriptionsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubscriptionsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PricesUpsertWithoutSubscriptionsInput = {
    update: XOR<PricesUpdateWithoutSubscriptionsInput, PricesUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PricesUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUpsertWithoutSubscriptionsInput = {
    update: XOR<OrganizationUpdateWithoutSubscriptionsInput, OrganizationUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
  }

  export type OrganizationUpdateWithoutSubscriptionsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserToProjectCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: NotificationType
  }

  export type ImageNoteCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    isDeleted?: boolean
  }

  export type AnnotationCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
  }

  export type UserToProjectUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput
  }

  export type UserToProjectUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToProjectUncheckedUpdateManyWithoutUserToProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | NotificationType
  }

  export type ImageNoteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteUncheckedUpdateManyWithoutImageNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyWithoutAnnotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    includeInReport?: boolean
    description?: string | null
  }

  export type OrganizationInvitationCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
    projectStatusValueId?: number | null
  }

  export type UserToOrganizationCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: AccessLevel | null
    userId: string
  }

  export type CustomersCreateManyOrganizationInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsCreateManyOrganizationInput = {
    id: string
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type OrganizationSavedOptionCreateManyOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: SavedOptionType
  }

  export type EquipmentCreateManyOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
  }

  export type ProjectStatusValueCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
  }

  export type ImageUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationInvitationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserToOrganizationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    user?: UserUpdateOneRequiredWithoutOrgNestedInput
  }

  export type UserToOrganizationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToOrganizationUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUpdateWithoutOrganizationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: PricesUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationSavedOptionUpdateWithoutOrganizationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationSavedOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | SavedOptionType
  }

  export type EquipmentUpdateWithoutOrganizationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectStatusValueUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateManyWithoutProjectStatusValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectEquipmentCreateManyEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
  }

  export type ProjectEquipmentUpdateWithoutEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutProjectEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
  }

  export type InferenceCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    roomId?: number | null
  }

  export type RoomCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | Enumerable<string>
  }

  export type CalendarEventCreateManyProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type UserToProjectCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type RoomReadingCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    roomId: number
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
  }

  export type AreaAffectedCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: AreaAffectedType
  }

  export type PhotoAccessLinkCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type NotesCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    body?: string
  }

  export type CostCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: CostType
  }

  export type ProjectEquipmentCreateManyProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipmentId: number
  }

  export type WeatherReportItemCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type PendingRoofReportsCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type ProjectNotesCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | Enumerable<string>
    userId: string
  }

  export type ImageUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateManyWithoutInferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | Enumerable<string>
  }

  export type CalendarEventUpdateWithoutProjectInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserToProjectUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserToProjectNestedInput
  }

  export type UserToProjectUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToProjectUncheckedUpdateManyWithoutProjectAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomReadingUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateManyWithoutRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaAffectedUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
    room?: RoomUpdateOneRequiredWithoutAreasAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyWithoutAreaAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type PhotoAccessLinkUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateManyWithoutPhotoAccessLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotesUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateManyWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type CostUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type CostUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type CostUncheckedUpdateManyWithoutCostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | CostType
  }

  export type ProjectEquipmentUpdateWithoutProjectInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipment?: EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherReportItemUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateManyWithoutWeatherReportItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type PendingRoofReportsUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateManyWithoutPendingRoofReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectNotesUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateManyWithoutProjectNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyCurrentStatusInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: ProjectStatus | null
  }

  export type ProjectUpdateWithoutCurrentStatusInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCurrentStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | Enumerable<InputJsonValue>
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | ProjectStatus | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ImageNoteCreateManyImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | Enumerable<string>
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationCreateManyImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | Enumerable<string>
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DetectionCreateManyInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type DetectionUpdateWithoutInferenceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
    room?: RoomUpdateOneWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateWithoutInferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type DetectionUncheckedUpdateManyWithoutDetectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type DetectionCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: DimensionUnit | null
  }

  export type InferenceCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
  }

  export type TemplatesUsedCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
  }

  export type RoomReadingCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | Enumerable<string>
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type AreaAffectedCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: AreaAffectedType
  }

  export type NotesCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type DetectionUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
    inference?: InferenceUpdateOneRequiredWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | DimensionUnit | null
  }

  export type InferenceUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type TemplatesUsedUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateManyWithoutTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type RoomReadingUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | Enumerable<string>
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type AreaAffectedUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
    project?: ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyWithoutAreasAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | AreaAffectedType
  }

  export type NotesUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type GenericRoomReadingCreateManyRoomReadingInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateWithoutRoomReadingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateManyWithoutGenericRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesAuditTrailCreateManyNoteInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateWithoutNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateManyWithoutNotesAuditTrailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventReminderCreateManyCalendarEventInput = {
    id?: number
    reminderTarget: ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateWithoutCalendarEventInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateManyWithoutRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineItemCreateManyXactimateCategoryInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
  }

  export type LineItemUpdateWithoutXactimateCategoryInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutXactimateCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateManyWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlternateItemCreateManyLineItemInput = {
    id?: number
    alternateId: string
  }

  export type RelatedItemCreateManyLineItemInput = {
    id?: number
    relationId: string
  }

  export type AlternateItemUpdateWithoutLineItemInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateManyWithoutAlternateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUpdateWithoutLineItemInput = {
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateManyWithoutRelatedItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type PricesCreateManyProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: PricingType
    interval?: PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateManyWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsCreateManyPriceInput = {
    id: string
    organizationId: number
    status: SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}