
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model OrganizationSavedOption
 * 
 */
export type OrganizationSavedOption = $Result.DefaultSelection<Prisma.$OrganizationSavedOptionPayload>
/**
 * Model UserToOrganization
 * 
 */
export type UserToOrganization = $Result.DefaultSelection<Prisma.$UserToOrganizationPayload>
/**
 * Model OrganizationInvitation
 * 
 */
export type OrganizationInvitation = $Result.DefaultSelection<Prisma.$OrganizationInvitationPayload>
/**
 * Model UserToProject
 * 
 */
export type UserToProject = $Result.DefaultSelection<Prisma.$UserToProjectPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectNotes
 * 
 */
export type ProjectNotes = $Result.DefaultSelection<Prisma.$ProjectNotesPayload>
/**
 * Model ProjectStatusValue
 * 
 */
export type ProjectStatusValue = $Result.DefaultSelection<Prisma.$ProjectStatusValuePayload>
/**
 * Model PendingRoofReports
 * 
 */
export type PendingRoofReports = $Result.DefaultSelection<Prisma.$PendingRoofReportsPayload>
/**
 * Model WeatherReportItem
 * 
 */
export type WeatherReportItem = $Result.DefaultSelection<Prisma.$WeatherReportItemPayload>
/**
 * Model ProjectEquipment
 * 
 */
export type ProjectEquipment = $Result.DefaultSelection<Prisma.$ProjectEquipmentPayload>
/**
 * Model Cost
 * 
 */
export type Cost = $Result.DefaultSelection<Prisma.$CostPayload>
/**
 * Model PropertyData
 * 
 */
export type PropertyData = $Result.DefaultSelection<Prisma.$PropertyDataPayload>
/**
 * Model DataDeletionRequest
 * 
 */
export type DataDeletionRequest = $Result.DefaultSelection<Prisma.$DataDeletionRequestPayload>
/**
 * Model PhotoAccessLink
 * 
 */
export type PhotoAccessLink = $Result.DefaultSelection<Prisma.$PhotoAccessLinkPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Annotation
 * 
 */
export type Annotation = $Result.DefaultSelection<Prisma.$AnnotationPayload>
/**
 * Model ImageNote
 * 
 */
export type ImageNote = $Result.DefaultSelection<Prisma.$ImageNotePayload>
/**
 * Model Inference
 * 
 */
export type Inference = $Result.DefaultSelection<Prisma.$InferencePayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomReading
 * 
 */
export type RoomReading = $Result.DefaultSelection<Prisma.$RoomReadingPayload>
/**
 * Model Notes
 * 
 */
export type Notes = $Result.DefaultSelection<Prisma.$NotesPayload>
/**
 * Model NotesAuditTrail
 * 
 */
export type NotesAuditTrail = $Result.DefaultSelection<Prisma.$NotesAuditTrailPayload>
/**
 * Model AreaAffected
 * 
 */
export type AreaAffected = $Result.DefaultSelection<Prisma.$AreaAffectedPayload>
/**
 * Model GenericRoomReading
 * 
 */
export type GenericRoomReading = $Result.DefaultSelection<Prisma.$GenericRoomReadingPayload>
/**
 * Model Detection
 * 
 */
export type Detection = $Result.DefaultSelection<Prisma.$DetectionPayload>
/**
 * Model TemplatesUsed
 * 
 */
export type TemplatesUsed = $Result.DefaultSelection<Prisma.$TemplatesUsedPayload>
/**
 * Model WaitList
 * 
 */
export type WaitList = $Result.DefaultSelection<Prisma.$WaitListPayload>
/**
 * Model RekognitionRuns
 * 
 */
export type RekognitionRuns = $Result.DefaultSelection<Prisma.$RekognitionRunsPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model CalendarEventReminder
 * 
 */
export type CalendarEventReminder = $Result.DefaultSelection<Prisma.$CalendarEventReminderPayload>
/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model LineItem
 * 
 */
export type LineItem = $Result.DefaultSelection<Prisma.$LineItemPayload>
/**
 * Model RelatedItem
 * 
 */
export type RelatedItem = $Result.DefaultSelection<Prisma.$RelatedItemPayload>
/**
 * Model AlternateItem
 * 
 */
export type AlternateItem = $Result.DefaultSelection<Prisma.$AlternateItemPayload>
/**
 * Model PlanEntitlements
 * 
 */
export type PlanEntitlements = $Result.DefaultSelection<Prisma.$PlanEntitlementsPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model Prices
 * 
 */
export type Prices = $Result.DefaultSelection<Prisma.$PricesPayload>
/**
 * Model Subscriptions
 * 
 */
export type Subscriptions = $Result.DefaultSelection<Prisma.$SubscriptionsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DashboardViews: {
  listView: 'listView',
  boardView: 'boardView',
  mapView: 'mapView'
};

export type DashboardViews = (typeof DashboardViews)[keyof typeof DashboardViews]


export const PhotoViews: {
  photoListView: 'photoListView',
  photoGridView: 'photoGridView'
};

export type PhotoViews = (typeof PhotoViews)[keyof typeof PhotoViews]


export const GroupByViews: {
  roomView: 'roomView',
  dateView: 'dateView'
};

export type GroupByViews = (typeof GroupByViews)[keyof typeof GroupByViews]


export const NotificationType: {
  notification: 'notification',
  activity: 'activity'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const SavedOptionType: {
  carrier: 'carrier',
  wallMaterial: 'wallMaterial',
  floorMaterial: 'floorMaterial'
};

export type SavedOptionType = (typeof SavedOptionType)[keyof typeof SavedOptionType]


export const AccessLevel: {
  admin: 'admin',
  viewer: 'viewer',
  projectManager: 'projectManager',
  accountManager: 'accountManager',
  contractor: 'contractor',
  removed: 'removed'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const ProjectStatus: {
  active: 'active',
  mitigation: 'mitigation',
  inspection: 'inspection',
  review: 'review',
  completed: 'completed',
  inactive: 'inactive',
  incomplete: 'incomplete'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const CostType: {
  subcontractor: 'subcontractor',
  miscellaneous: 'miscellaneous',
  materials: 'materials',
  labor: 'labor'
};

export type CostType = (typeof CostType)[keyof typeof CostType]


export const RoomReadingType: {
  dehumidifer: 'dehumidifer'
};

export type RoomReadingType = (typeof RoomReadingType)[keyof typeof RoomReadingType]


export const EqiupmentType: {
  fan: 'fan',
  dehumidifier: 'dehumidifier',
  airScrubber: 'airScrubber'
};

export type EqiupmentType = (typeof EqiupmentType)[keyof typeof EqiupmentType]


export const NotesAuditAction: {
  updated: 'updated',
  deleted: 'deleted',
  created: 'created'
};

export type NotesAuditAction = (typeof NotesAuditAction)[keyof typeof NotesAuditAction]


export const AreaAffectedType: {
  wall: 'wall',
  ceiling: 'ceiling',
  floor: 'floor'
};

export type AreaAffectedType = (typeof AreaAffectedType)[keyof typeof AreaAffectedType]


export const DimensionUnit: {
  sf: 'sf',
  lf: 'lf',
  ea: 'ea'
};

export type DimensionUnit = (typeof DimensionUnit)[keyof typeof DimensionUnit]


export const ReminderTarget: {
  client: 'client',
  allAssigned: 'allAssigned',
  projectCreator: 'projectCreator'
};

export type ReminderTarget = (typeof ReminderTarget)[keyof typeof ReminderTarget]


export const PricingType: {
  one_time: 'one_time',
  recurring: 'recurring'
};

export type PricingType = (typeof PricingType)[keyof typeof PricingType]


export const PricingPlanInterval: {
  day: 'day',
  week: 'week',
  month: 'month',
  year: 'year'
};

export type PricingPlanInterval = (typeof PricingPlanInterval)[keyof typeof PricingPlanInterval]


export const SubscriptionStatus: {
  trialing: 'trialing',
  active: 'active',
  canceled: 'canceled',
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired',
  past_due: 'past_due',
  unpaid: 'unpaid'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type DashboardViews = $Enums.DashboardViews

export const DashboardViews: typeof $Enums.DashboardViews

export type PhotoViews = $Enums.PhotoViews

export const PhotoViews: typeof $Enums.PhotoViews

export type GroupByViews = $Enums.GroupByViews

export const GroupByViews: typeof $Enums.GroupByViews

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type SavedOptionType = $Enums.SavedOptionType

export const SavedOptionType: typeof $Enums.SavedOptionType

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type CostType = $Enums.CostType

export const CostType: typeof $Enums.CostType

export type RoomReadingType = $Enums.RoomReadingType

export const RoomReadingType: typeof $Enums.RoomReadingType

export type EqiupmentType = $Enums.EqiupmentType

export const EqiupmentType: typeof $Enums.EqiupmentType

export type NotesAuditAction = $Enums.NotesAuditAction

export const NotesAuditAction: typeof $Enums.NotesAuditAction

export type AreaAffectedType = $Enums.AreaAffectedType

export const AreaAffectedType: typeof $Enums.AreaAffectedType

export type DimensionUnit = $Enums.DimensionUnit

export const DimensionUnit: typeof $Enums.DimensionUnit

export type ReminderTarget = $Enums.ReminderTarget

export const ReminderTarget: typeof $Enums.ReminderTarget

export type PricingType = $Enums.PricingType

export const PricingType: typeof $Enums.PricingType

export type PricingPlanInterval = $Enums.PricingPlanInterval

export const PricingPlanInterval: typeof $Enums.PricingPlanInterval

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationSavedOption`: Exposes CRUD operations for the **OrganizationSavedOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationSavedOptions
    * const organizationSavedOptions = await prisma.organizationSavedOption.findMany()
    * ```
    */
  get organizationSavedOption(): Prisma.OrganizationSavedOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToOrganization`: Exposes CRUD operations for the **UserToOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToOrganizations
    * const userToOrganizations = await prisma.userToOrganization.findMany()
    * ```
    */
  get userToOrganization(): Prisma.UserToOrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationInvitation`: Exposes CRUD operations for the **OrganizationInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationInvitations
    * const organizationInvitations = await prisma.organizationInvitation.findMany()
    * ```
    */
  get organizationInvitation(): Prisma.OrganizationInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToProject`: Exposes CRUD operations for the **UserToProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToProjects
    * const userToProjects = await prisma.userToProject.findMany()
    * ```
    */
  get userToProject(): Prisma.UserToProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectNotes`: Exposes CRUD operations for the **ProjectNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectNotes
    * const projectNotes = await prisma.projectNotes.findMany()
    * ```
    */
  get projectNotes(): Prisma.ProjectNotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStatusValue`: Exposes CRUD operations for the **ProjectStatusValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStatusValues
    * const projectStatusValues = await prisma.projectStatusValue.findMany()
    * ```
    */
  get projectStatusValue(): Prisma.ProjectStatusValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingRoofReports`: Exposes CRUD operations for the **PendingRoofReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingRoofReports
    * const pendingRoofReports = await prisma.pendingRoofReports.findMany()
    * ```
    */
  get pendingRoofReports(): Prisma.PendingRoofReportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weatherReportItem`: Exposes CRUD operations for the **WeatherReportItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherReportItems
    * const weatherReportItems = await prisma.weatherReportItem.findMany()
    * ```
    */
  get weatherReportItem(): Prisma.WeatherReportItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectEquipment`: Exposes CRUD operations for the **ProjectEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectEquipments
    * const projectEquipments = await prisma.projectEquipment.findMany()
    * ```
    */
  get projectEquipment(): Prisma.ProjectEquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cost`: Exposes CRUD operations for the **Cost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costs
    * const costs = await prisma.cost.findMany()
    * ```
    */
  get cost(): Prisma.CostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyData`: Exposes CRUD operations for the **PropertyData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyData
    * const propertyData = await prisma.propertyData.findMany()
    * ```
    */
  get propertyData(): Prisma.PropertyDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataDeletionRequest`: Exposes CRUD operations for the **DataDeletionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataDeletionRequests
    * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
    * ```
    */
  get dataDeletionRequest(): Prisma.DataDeletionRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photoAccessLink`: Exposes CRUD operations for the **PhotoAccessLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotoAccessLinks
    * const photoAccessLinks = await prisma.photoAccessLink.findMany()
    * ```
    */
  get photoAccessLink(): Prisma.PhotoAccessLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.annotation`: Exposes CRUD operations for the **Annotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annotations
    * const annotations = await prisma.annotation.findMany()
    * ```
    */
  get annotation(): Prisma.AnnotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imageNote`: Exposes CRUD operations for the **ImageNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageNotes
    * const imageNotes = await prisma.imageNote.findMany()
    * ```
    */
  get imageNote(): Prisma.ImageNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inference`: Exposes CRUD operations for the **Inference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inferences
    * const inferences = await prisma.inference.findMany()
    * ```
    */
  get inference(): Prisma.InferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomReading`: Exposes CRUD operations for the **RoomReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomReadings
    * const roomReadings = await prisma.roomReading.findMany()
    * ```
    */
  get roomReading(): Prisma.RoomReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **Notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.NotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notesAuditTrail`: Exposes CRUD operations for the **NotesAuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotesAuditTrails
    * const notesAuditTrails = await prisma.notesAuditTrail.findMany()
    * ```
    */
  get notesAuditTrail(): Prisma.NotesAuditTrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.areaAffected`: Exposes CRUD operations for the **AreaAffected** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaAffecteds
    * const areaAffecteds = await prisma.areaAffected.findMany()
    * ```
    */
  get areaAffected(): Prisma.AreaAffectedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genericRoomReading`: Exposes CRUD operations for the **GenericRoomReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenericRoomReadings
    * const genericRoomReadings = await prisma.genericRoomReading.findMany()
    * ```
    */
  get genericRoomReading(): Prisma.GenericRoomReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detection`: Exposes CRUD operations for the **Detection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detections
    * const detections = await prisma.detection.findMany()
    * ```
    */
  get detection(): Prisma.DetectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templatesUsed`: Exposes CRUD operations for the **TemplatesUsed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplatesUseds
    * const templatesUseds = await prisma.templatesUsed.findMany()
    * ```
    */
  get templatesUsed(): Prisma.TemplatesUsedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.waitList`: Exposes CRUD operations for the **WaitList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaitLists
    * const waitLists = await prisma.waitList.findMany()
    * ```
    */
  get waitList(): Prisma.WaitListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rekognitionRuns`: Exposes CRUD operations for the **RekognitionRuns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RekognitionRuns
    * const rekognitionRuns = await prisma.rekognitionRuns.findMany()
    * ```
    */
  get rekognitionRuns(): Prisma.RekognitionRunsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEventReminder`: Exposes CRUD operations for the **CalendarEventReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEventReminders
    * const calendarEventReminders = await prisma.calendarEventReminder.findMany()
    * ```
    */
  get calendarEventReminder(): Prisma.CalendarEventReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lineItem`: Exposes CRUD operations for the **LineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineItems
    * const lineItems = await prisma.lineItem.findMany()
    * ```
    */
  get lineItem(): Prisma.LineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relatedItem`: Exposes CRUD operations for the **RelatedItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelatedItems
    * const relatedItems = await prisma.relatedItem.findMany()
    * ```
    */
  get relatedItem(): Prisma.RelatedItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alternateItem`: Exposes CRUD operations for the **AlternateItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlternateItems
    * const alternateItems = await prisma.alternateItem.findMany()
    * ```
    */
  get alternateItem(): Prisma.AlternateItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planEntitlements`: Exposes CRUD operations for the **PlanEntitlements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanEntitlements
    * const planEntitlements = await prisma.planEntitlements.findMany()
    * ```
    */
  get planEntitlements(): Prisma.PlanEntitlementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prices`: Exposes CRUD operations for the **Prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.prices.findMany()
    * ```
    */
  get prices(): Prisma.PricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **Subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.SubscriptionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Equipment: 'Equipment',
    Notification: 'Notification',
    OrganizationSavedOption: 'OrganizationSavedOption',
    UserToOrganization: 'UserToOrganization',
    OrganizationInvitation: 'OrganizationInvitation',
    UserToProject: 'UserToProject',
    Project: 'Project',
    ProjectNotes: 'ProjectNotes',
    ProjectStatusValue: 'ProjectStatusValue',
    PendingRoofReports: 'PendingRoofReports',
    WeatherReportItem: 'WeatherReportItem',
    ProjectEquipment: 'ProjectEquipment',
    Cost: 'Cost',
    PropertyData: 'PropertyData',
    DataDeletionRequest: 'DataDeletionRequest',
    PhotoAccessLink: 'PhotoAccessLink',
    Image: 'Image',
    Annotation: 'Annotation',
    ImageNote: 'ImageNote',
    Inference: 'Inference',
    Room: 'Room',
    RoomReading: 'RoomReading',
    Notes: 'Notes',
    NotesAuditTrail: 'NotesAuditTrail',
    AreaAffected: 'AreaAffected',
    GenericRoomReading: 'GenericRoomReading',
    Detection: 'Detection',
    TemplatesUsed: 'TemplatesUsed',
    WaitList: 'WaitList',
    RekognitionRuns: 'RekognitionRuns',
    CalendarEvent: 'CalendarEvent',
    CalendarEventReminder: 'CalendarEventReminder',
    ItemCategory: 'ItemCategory',
    LineItem: 'LineItem',
    RelatedItem: 'RelatedItem',
    AlternateItem: 'AlternateItem',
    PlanEntitlements: 'PlanEntitlements',
    Customers: 'Customers',
    Products: 'Products',
    Prices: 'Prices',
    Subscriptions: 'Subscriptions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "organization" | "equipment" | "notification" | "organizationSavedOption" | "userToOrganization" | "organizationInvitation" | "userToProject" | "project" | "projectNotes" | "projectStatusValue" | "pendingRoofReports" | "weatherReportItem" | "projectEquipment" | "cost" | "propertyData" | "dataDeletionRequest" | "photoAccessLink" | "image" | "annotation" | "imageNote" | "inference" | "room" | "roomReading" | "notes" | "notesAuditTrail" | "areaAffected" | "genericRoomReading" | "detection" | "templatesUsed" | "waitList" | "rekognitionRuns" | "calendarEvent" | "calendarEventReminder" | "itemCategory" | "lineItem" | "relatedItem" | "alternateItem" | "planEntitlements" | "customers" | "products" | "prices" | "subscriptions"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationSavedOption: {
        payload: Prisma.$OrganizationSavedOptionPayload<ExtArgs>
        fields: Prisma.OrganizationSavedOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationSavedOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationSavedOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          findFirst: {
            args: Prisma.OrganizationSavedOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationSavedOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          findMany: {
            args: Prisma.OrganizationSavedOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>[]
          }
          create: {
            args: Prisma.OrganizationSavedOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          createMany: {
            args: Prisma.OrganizationSavedOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationSavedOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>[]
          }
          delete: {
            args: Prisma.OrganizationSavedOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          update: {
            args: Prisma.OrganizationSavedOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationSavedOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationSavedOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationSavedOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationSavedOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationSavedOptionPayload>
          }
          aggregate: {
            args: Prisma.OrganizationSavedOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationSavedOption>
          }
          groupBy: {
            args: Prisma.OrganizationSavedOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationSavedOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationSavedOptionCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationSavedOptionCountAggregateOutputType> | number
          }
        }
      }
      UserToOrganization: {
        payload: Prisma.$UserToOrganizationPayload<ExtArgs>
        fields: Prisma.UserToOrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToOrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToOrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          findFirst: {
            args: Prisma.UserToOrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToOrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          findMany: {
            args: Prisma.UserToOrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>[]
          }
          create: {
            args: Prisma.UserToOrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          createMany: {
            args: Prisma.UserToOrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserToOrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>[]
          }
          delete: {
            args: Prisma.UserToOrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          update: {
            args: Prisma.UserToOrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          deleteMany: {
            args: Prisma.UserToOrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToOrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserToOrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>[]
          }
          upsert: {
            args: Prisma.UserToOrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToOrganizationPayload>
          }
          aggregate: {
            args: Prisma.UserToOrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToOrganization>
          }
          groupBy: {
            args: Prisma.UserToOrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToOrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserToOrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<UserToOrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationInvitation: {
        payload: Prisma.$OrganizationInvitationPayload<ExtArgs>
        fields: Prisma.OrganizationInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          findMany: {
            args: Prisma.OrganizationInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          create: {
            args: Prisma.OrganizationInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          createMany: {
            args: Prisma.OrganizationInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          update: {
            args: Prisma.OrganizationInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationInvitation>
          }
          groupBy: {
            args: Prisma.OrganizationInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationInvitationCountAggregateOutputType> | number
          }
        }
      }
      UserToProject: {
        payload: Prisma.$UserToProjectPayload<ExtArgs>
        fields: Prisma.UserToProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          findFirst: {
            args: Prisma.UserToProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          findMany: {
            args: Prisma.UserToProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>[]
          }
          create: {
            args: Prisma.UserToProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          createMany: {
            args: Prisma.UserToProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserToProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>[]
          }
          delete: {
            args: Prisma.UserToProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          update: {
            args: Prisma.UserToProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          deleteMany: {
            args: Prisma.UserToProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserToProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>[]
          }
          upsert: {
            args: Prisma.UserToProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToProjectPayload>
          }
          aggregate: {
            args: Prisma.UserToProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToProject>
          }
          groupBy: {
            args: Prisma.UserToProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserToProjectCountArgs<ExtArgs>
            result: $Utils.Optional<UserToProjectCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectNotes: {
        payload: Prisma.$ProjectNotesPayload<ExtArgs>
        fields: Prisma.ProjectNotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectNotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectNotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          findFirst: {
            args: Prisma.ProjectNotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectNotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          findMany: {
            args: Prisma.ProjectNotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>[]
          }
          create: {
            args: Prisma.ProjectNotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          createMany: {
            args: Prisma.ProjectNotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectNotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>[]
          }
          delete: {
            args: Prisma.ProjectNotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          update: {
            args: Prisma.ProjectNotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          deleteMany: {
            args: Prisma.ProjectNotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectNotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectNotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>[]
          }
          upsert: {
            args: Prisma.ProjectNotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotesPayload>
          }
          aggregate: {
            args: Prisma.ProjectNotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectNotes>
          }
          groupBy: {
            args: Prisma.ProjectNotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectNotesCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotesCountAggregateOutputType> | number
          }
        }
      }
      ProjectStatusValue: {
        payload: Prisma.$ProjectStatusValuePayload<ExtArgs>
        fields: Prisma.ProjectStatusValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStatusValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStatusValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          findFirst: {
            args: Prisma.ProjectStatusValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStatusValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          findMany: {
            args: Prisma.ProjectStatusValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>[]
          }
          create: {
            args: Prisma.ProjectStatusValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          createMany: {
            args: Prisma.ProjectStatusValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectStatusValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>[]
          }
          delete: {
            args: Prisma.ProjectStatusValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          update: {
            args: Prisma.ProjectStatusValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          deleteMany: {
            args: Prisma.ProjectStatusValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStatusValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectStatusValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>[]
          }
          upsert: {
            args: Prisma.ProjectStatusValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusValuePayload>
          }
          aggregate: {
            args: Prisma.ProjectStatusValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStatusValue>
          }
          groupBy: {
            args: Prisma.ProjectStatusValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectStatusValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusValueCountAggregateOutputType> | number
          }
        }
      }
      PendingRoofReports: {
        payload: Prisma.$PendingRoofReportsPayload<ExtArgs>
        fields: Prisma.PendingRoofReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingRoofReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingRoofReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          findFirst: {
            args: Prisma.PendingRoofReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingRoofReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          findMany: {
            args: Prisma.PendingRoofReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>[]
          }
          create: {
            args: Prisma.PendingRoofReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          createMany: {
            args: Prisma.PendingRoofReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingRoofReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>[]
          }
          delete: {
            args: Prisma.PendingRoofReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          update: {
            args: Prisma.PendingRoofReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          deleteMany: {
            args: Prisma.PendingRoofReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingRoofReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingRoofReportsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>[]
          }
          upsert: {
            args: Prisma.PendingRoofReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingRoofReportsPayload>
          }
          aggregate: {
            args: Prisma.PendingRoofReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingRoofReports>
          }
          groupBy: {
            args: Prisma.PendingRoofReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingRoofReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingRoofReportsCountArgs<ExtArgs>
            result: $Utils.Optional<PendingRoofReportsCountAggregateOutputType> | number
          }
        }
      }
      WeatherReportItem: {
        payload: Prisma.$WeatherReportItemPayload<ExtArgs>
        fields: Prisma.WeatherReportItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherReportItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherReportItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          findFirst: {
            args: Prisma.WeatherReportItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherReportItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          findMany: {
            args: Prisma.WeatherReportItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>[]
          }
          create: {
            args: Prisma.WeatherReportItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          createMany: {
            args: Prisma.WeatherReportItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherReportItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>[]
          }
          delete: {
            args: Prisma.WeatherReportItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          update: {
            args: Prisma.WeatherReportItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          deleteMany: {
            args: Prisma.WeatherReportItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherReportItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherReportItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>[]
          }
          upsert: {
            args: Prisma.WeatherReportItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherReportItemPayload>
          }
          aggregate: {
            args: Prisma.WeatherReportItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherReportItem>
          }
          groupBy: {
            args: Prisma.WeatherReportItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherReportItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherReportItemCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherReportItemCountAggregateOutputType> | number
          }
        }
      }
      ProjectEquipment: {
        payload: Prisma.$ProjectEquipmentPayload<ExtArgs>
        fields: Prisma.ProjectEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          findFirst: {
            args: Prisma.ProjectEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          findMany: {
            args: Prisma.ProjectEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>[]
          }
          create: {
            args: Prisma.ProjectEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          createMany: {
            args: Prisma.ProjectEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>[]
          }
          delete: {
            args: Prisma.ProjectEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          update: {
            args: Prisma.ProjectEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectEquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>[]
          }
          upsert: {
            args: Prisma.ProjectEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEquipmentPayload>
          }
          aggregate: {
            args: Prisma.ProjectEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectEquipment>
          }
          groupBy: {
            args: Prisma.ProjectEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectEquipmentCountAggregateOutputType> | number
          }
        }
      }
      Cost: {
        payload: Prisma.$CostPayload<ExtArgs>
        fields: Prisma.CostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findFirst: {
            args: Prisma.CostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findMany: {
            args: Prisma.CostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          create: {
            args: Prisma.CostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          createMany: {
            args: Prisma.CostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          delete: {
            args: Prisma.CostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          update: {
            args: Prisma.CostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          deleteMany: {
            args: Prisma.CostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          upsert: {
            args: Prisma.CostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          aggregate: {
            args: Prisma.CostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCost>
          }
          groupBy: {
            args: Prisma.CostGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCountArgs<ExtArgs>
            result: $Utils.Optional<CostCountAggregateOutputType> | number
          }
        }
      }
      PropertyData: {
        payload: Prisma.$PropertyDataPayload<ExtArgs>
        fields: Prisma.PropertyDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          findFirst: {
            args: Prisma.PropertyDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          findMany: {
            args: Prisma.PropertyDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>[]
          }
          create: {
            args: Prisma.PropertyDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          createMany: {
            args: Prisma.PropertyDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>[]
          }
          delete: {
            args: Prisma.PropertyDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          update: {
            args: Prisma.PropertyDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>[]
          }
          upsert: {
            args: Prisma.PropertyDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyDataPayload>
          }
          aggregate: {
            args: Prisma.PropertyDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyData>
          }
          groupBy: {
            args: Prisma.PropertyDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyDataCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyDataCountAggregateOutputType> | number
          }
        }
      }
      DataDeletionRequest: {
        payload: Prisma.$DataDeletionRequestPayload<ExtArgs>
        fields: Prisma.DataDeletionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataDeletionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findFirst: {
            args: Prisma.DataDeletionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findMany: {
            args: Prisma.DataDeletionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          create: {
            args: Prisma.DataDeletionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          createMany: {
            args: Prisma.DataDeletionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          delete: {
            args: Prisma.DataDeletionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          update: {
            args: Prisma.DataDeletionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataDeletionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataDeletionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataDeletionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          aggregate: {
            args: Prisma.DataDeletionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataDeletionRequest>
          }
          groupBy: {
            args: Prisma.DataDeletionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataDeletionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestCountAggregateOutputType> | number
          }
        }
      }
      PhotoAccessLink: {
        payload: Prisma.$PhotoAccessLinkPayload<ExtArgs>
        fields: Prisma.PhotoAccessLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoAccessLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoAccessLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          findFirst: {
            args: Prisma.PhotoAccessLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoAccessLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          findMany: {
            args: Prisma.PhotoAccessLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>[]
          }
          create: {
            args: Prisma.PhotoAccessLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          createMany: {
            args: Prisma.PhotoAccessLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotoAccessLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>[]
          }
          delete: {
            args: Prisma.PhotoAccessLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          update: {
            args: Prisma.PhotoAccessLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          deleteMany: {
            args: Prisma.PhotoAccessLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoAccessLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhotoAccessLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>[]
          }
          upsert: {
            args: Prisma.PhotoAccessLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoAccessLinkPayload>
          }
          aggregate: {
            args: Prisma.PhotoAccessLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotoAccessLink>
          }
          groupBy: {
            args: Prisma.PhotoAccessLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoAccessLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoAccessLinkCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoAccessLinkCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Annotation: {
        payload: Prisma.$AnnotationPayload<ExtArgs>
        fields: Prisma.AnnotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findFirst: {
            args: Prisma.AnnotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findMany: {
            args: Prisma.AnnotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          create: {
            args: Prisma.AnnotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          createMany: {
            args: Prisma.AnnotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          delete: {
            args: Prisma.AnnotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          update: {
            args: Prisma.AnnotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          deleteMany: {
            args: Prisma.AnnotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          upsert: {
            args: Prisma.AnnotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          aggregate: {
            args: Prisma.AnnotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnotation>
          }
          groupBy: {
            args: Prisma.AnnotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnotationCountArgs<ExtArgs>
            result: $Utils.Optional<AnnotationCountAggregateOutputType> | number
          }
        }
      }
      ImageNote: {
        payload: Prisma.$ImageNotePayload<ExtArgs>
        fields: Prisma.ImageNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          findFirst: {
            args: Prisma.ImageNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          findMany: {
            args: Prisma.ImageNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>[]
          }
          create: {
            args: Prisma.ImageNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          createMany: {
            args: Prisma.ImageNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>[]
          }
          delete: {
            args: Prisma.ImageNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          update: {
            args: Prisma.ImageNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          deleteMany: {
            args: Prisma.ImageNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>[]
          }
          upsert: {
            args: Prisma.ImageNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageNotePayload>
          }
          aggregate: {
            args: Prisma.ImageNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageNote>
          }
          groupBy: {
            args: Prisma.ImageNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ImageNoteCountAggregateOutputType> | number
          }
        }
      }
      Inference: {
        payload: Prisma.$InferencePayload<ExtArgs>
        fields: Prisma.InferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          findFirst: {
            args: Prisma.InferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          findMany: {
            args: Prisma.InferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>[]
          }
          create: {
            args: Prisma.InferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          createMany: {
            args: Prisma.InferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>[]
          }
          delete: {
            args: Prisma.InferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          update: {
            args: Prisma.InferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          deleteMany: {
            args: Prisma.InferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>[]
          }
          upsert: {
            args: Prisma.InferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InferencePayload>
          }
          aggregate: {
            args: Prisma.InferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInference>
          }
          groupBy: {
            args: Prisma.InferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InferenceCountArgs<ExtArgs>
            result: $Utils.Optional<InferenceCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomReading: {
        payload: Prisma.$RoomReadingPayload<ExtArgs>
        fields: Prisma.RoomReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          findFirst: {
            args: Prisma.RoomReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          findMany: {
            args: Prisma.RoomReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>[]
          }
          create: {
            args: Prisma.RoomReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          createMany: {
            args: Prisma.RoomReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>[]
          }
          delete: {
            args: Prisma.RoomReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          update: {
            args: Prisma.RoomReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          deleteMany: {
            args: Prisma.RoomReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>[]
          }
          upsert: {
            args: Prisma.RoomReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomReadingPayload>
          }
          aggregate: {
            args: Prisma.RoomReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomReading>
          }
          groupBy: {
            args: Prisma.RoomReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomReadingCountArgs<ExtArgs>
            result: $Utils.Optional<RoomReadingCountAggregateOutputType> | number
          }
        }
      }
      Notes: {
        payload: Prisma.$NotesPayload<ExtArgs>
        fields: Prisma.NotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findFirst: {
            args: Prisma.NotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findMany: {
            args: Prisma.NotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          create: {
            args: Prisma.NotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          createMany: {
            args: Prisma.NotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          delete: {
            args: Prisma.NotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          update: {
            args: Prisma.NotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          deleteMany: {
            args: Prisma.NotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          upsert: {
            args: Prisma.NotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.NotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      NotesAuditTrail: {
        payload: Prisma.$NotesAuditTrailPayload<ExtArgs>
        fields: Prisma.NotesAuditTrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotesAuditTrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotesAuditTrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          findFirst: {
            args: Prisma.NotesAuditTrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotesAuditTrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          findMany: {
            args: Prisma.NotesAuditTrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>[]
          }
          create: {
            args: Prisma.NotesAuditTrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          createMany: {
            args: Prisma.NotesAuditTrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotesAuditTrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>[]
          }
          delete: {
            args: Prisma.NotesAuditTrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          update: {
            args: Prisma.NotesAuditTrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          deleteMany: {
            args: Prisma.NotesAuditTrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotesAuditTrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotesAuditTrailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>[]
          }
          upsert: {
            args: Prisma.NotesAuditTrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesAuditTrailPayload>
          }
          aggregate: {
            args: Prisma.NotesAuditTrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotesAuditTrail>
          }
          groupBy: {
            args: Prisma.NotesAuditTrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesAuditTrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotesAuditTrailCountArgs<ExtArgs>
            result: $Utils.Optional<NotesAuditTrailCountAggregateOutputType> | number
          }
        }
      }
      AreaAffected: {
        payload: Prisma.$AreaAffectedPayload<ExtArgs>
        fields: Prisma.AreaAffectedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaAffectedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaAffectedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          findFirst: {
            args: Prisma.AreaAffectedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaAffectedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          findMany: {
            args: Prisma.AreaAffectedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>[]
          }
          create: {
            args: Prisma.AreaAffectedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          createMany: {
            args: Prisma.AreaAffectedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaAffectedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>[]
          }
          delete: {
            args: Prisma.AreaAffectedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          update: {
            args: Prisma.AreaAffectedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          deleteMany: {
            args: Prisma.AreaAffectedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaAffectedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaAffectedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>[]
          }
          upsert: {
            args: Prisma.AreaAffectedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaAffectedPayload>
          }
          aggregate: {
            args: Prisma.AreaAffectedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreaAffected>
          }
          groupBy: {
            args: Prisma.AreaAffectedGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaAffectedGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaAffectedCountArgs<ExtArgs>
            result: $Utils.Optional<AreaAffectedCountAggregateOutputType> | number
          }
        }
      }
      GenericRoomReading: {
        payload: Prisma.$GenericRoomReadingPayload<ExtArgs>
        fields: Prisma.GenericRoomReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenericRoomReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenericRoomReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          findFirst: {
            args: Prisma.GenericRoomReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenericRoomReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          findMany: {
            args: Prisma.GenericRoomReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>[]
          }
          create: {
            args: Prisma.GenericRoomReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          createMany: {
            args: Prisma.GenericRoomReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenericRoomReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>[]
          }
          delete: {
            args: Prisma.GenericRoomReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          update: {
            args: Prisma.GenericRoomReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          deleteMany: {
            args: Prisma.GenericRoomReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenericRoomReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenericRoomReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>[]
          }
          upsert: {
            args: Prisma.GenericRoomReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenericRoomReadingPayload>
          }
          aggregate: {
            args: Prisma.GenericRoomReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenericRoomReading>
          }
          groupBy: {
            args: Prisma.GenericRoomReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenericRoomReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenericRoomReadingCountArgs<ExtArgs>
            result: $Utils.Optional<GenericRoomReadingCountAggregateOutputType> | number
          }
        }
      }
      Detection: {
        payload: Prisma.$DetectionPayload<ExtArgs>
        fields: Prisma.DetectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          findFirst: {
            args: Prisma.DetectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          findMany: {
            args: Prisma.DetectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>[]
          }
          create: {
            args: Prisma.DetectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          createMany: {
            args: Prisma.DetectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>[]
          }
          delete: {
            args: Prisma.DetectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          update: {
            args: Prisma.DetectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          deleteMany: {
            args: Prisma.DetectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>[]
          }
          upsert: {
            args: Prisma.DetectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectionPayload>
          }
          aggregate: {
            args: Prisma.DetectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetection>
          }
          groupBy: {
            args: Prisma.DetectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetectionCountArgs<ExtArgs>
            result: $Utils.Optional<DetectionCountAggregateOutputType> | number
          }
        }
      }
      TemplatesUsed: {
        payload: Prisma.$TemplatesUsedPayload<ExtArgs>
        fields: Prisma.TemplatesUsedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplatesUsedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplatesUsedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          findFirst: {
            args: Prisma.TemplatesUsedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplatesUsedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          findMany: {
            args: Prisma.TemplatesUsedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>[]
          }
          create: {
            args: Prisma.TemplatesUsedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          createMany: {
            args: Prisma.TemplatesUsedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplatesUsedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>[]
          }
          delete: {
            args: Prisma.TemplatesUsedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          update: {
            args: Prisma.TemplatesUsedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          deleteMany: {
            args: Prisma.TemplatesUsedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplatesUsedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplatesUsedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>[]
          }
          upsert: {
            args: Prisma.TemplatesUsedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatesUsedPayload>
          }
          aggregate: {
            args: Prisma.TemplatesUsedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplatesUsed>
          }
          groupBy: {
            args: Prisma.TemplatesUsedGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplatesUsedGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplatesUsedCountArgs<ExtArgs>
            result: $Utils.Optional<TemplatesUsedCountAggregateOutputType> | number
          }
        }
      }
      WaitList: {
        payload: Prisma.$WaitListPayload<ExtArgs>
        fields: Prisma.WaitListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaitListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaitListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          findFirst: {
            args: Prisma.WaitListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaitListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          findMany: {
            args: Prisma.WaitListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>[]
          }
          create: {
            args: Prisma.WaitListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          createMany: {
            args: Prisma.WaitListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaitListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>[]
          }
          delete: {
            args: Prisma.WaitListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          update: {
            args: Prisma.WaitListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          deleteMany: {
            args: Prisma.WaitListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaitListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WaitListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>[]
          }
          upsert: {
            args: Prisma.WaitListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaitListPayload>
          }
          aggregate: {
            args: Prisma.WaitListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWaitList>
          }
          groupBy: {
            args: Prisma.WaitListGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaitListGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaitListCountArgs<ExtArgs>
            result: $Utils.Optional<WaitListCountAggregateOutputType> | number
          }
        }
      }
      RekognitionRuns: {
        payload: Prisma.$RekognitionRunsPayload<ExtArgs>
        fields: Prisma.RekognitionRunsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RekognitionRunsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RekognitionRunsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          findFirst: {
            args: Prisma.RekognitionRunsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RekognitionRunsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          findMany: {
            args: Prisma.RekognitionRunsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>[]
          }
          create: {
            args: Prisma.RekognitionRunsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          createMany: {
            args: Prisma.RekognitionRunsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RekognitionRunsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>[]
          }
          delete: {
            args: Prisma.RekognitionRunsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          update: {
            args: Prisma.RekognitionRunsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          deleteMany: {
            args: Prisma.RekognitionRunsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RekognitionRunsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RekognitionRunsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>[]
          }
          upsert: {
            args: Prisma.RekognitionRunsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RekognitionRunsPayload>
          }
          aggregate: {
            args: Prisma.RekognitionRunsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRekognitionRuns>
          }
          groupBy: {
            args: Prisma.RekognitionRunsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RekognitionRunsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RekognitionRunsCountArgs<ExtArgs>
            result: $Utils.Optional<RekognitionRunsCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      CalendarEventReminder: {
        payload: Prisma.$CalendarEventReminderPayload<ExtArgs>
        fields: Prisma.CalendarEventReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          findMany: {
            args: Prisma.CalendarEventReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>[]
          }
          create: {
            args: Prisma.CalendarEventReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          createMany: {
            args: Prisma.CalendarEventReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          update: {
            args: Prisma.CalendarEventReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEventReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEventReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventReminderPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEventReminder>
          }
          groupBy: {
            args: Prisma.CalendarEventReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventReminderCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventReminderCountAggregateOutputType> | number
          }
        }
      }
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      LineItem: {
        payload: Prisma.$LineItemPayload<ExtArgs>
        fields: Prisma.LineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          findFirst: {
            args: Prisma.LineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          findMany: {
            args: Prisma.LineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>[]
          }
          create: {
            args: Prisma.LineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          createMany: {
            args: Prisma.LineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>[]
          }
          delete: {
            args: Prisma.LineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          update: {
            args: Prisma.LineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          deleteMany: {
            args: Prisma.LineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>[]
          }
          upsert: {
            args: Prisma.LineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineItemPayload>
          }
          aggregate: {
            args: Prisma.LineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineItem>
          }
          groupBy: {
            args: Prisma.LineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineItemCountArgs<ExtArgs>
            result: $Utils.Optional<LineItemCountAggregateOutputType> | number
          }
        }
      }
      RelatedItem: {
        payload: Prisma.$RelatedItemPayload<ExtArgs>
        fields: Prisma.RelatedItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelatedItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelatedItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          findFirst: {
            args: Prisma.RelatedItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelatedItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          findMany: {
            args: Prisma.RelatedItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>[]
          }
          create: {
            args: Prisma.RelatedItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          createMany: {
            args: Prisma.RelatedItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelatedItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>[]
          }
          delete: {
            args: Prisma.RelatedItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          update: {
            args: Prisma.RelatedItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          deleteMany: {
            args: Prisma.RelatedItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelatedItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelatedItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>[]
          }
          upsert: {
            args: Prisma.RelatedItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedItemPayload>
          }
          aggregate: {
            args: Prisma.RelatedItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelatedItem>
          }
          groupBy: {
            args: Prisma.RelatedItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelatedItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelatedItemCountArgs<ExtArgs>
            result: $Utils.Optional<RelatedItemCountAggregateOutputType> | number
          }
        }
      }
      AlternateItem: {
        payload: Prisma.$AlternateItemPayload<ExtArgs>
        fields: Prisma.AlternateItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlternateItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlternateItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          findFirst: {
            args: Prisma.AlternateItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlternateItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          findMany: {
            args: Prisma.AlternateItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>[]
          }
          create: {
            args: Prisma.AlternateItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          createMany: {
            args: Prisma.AlternateItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlternateItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>[]
          }
          delete: {
            args: Prisma.AlternateItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          update: {
            args: Prisma.AlternateItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          deleteMany: {
            args: Prisma.AlternateItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlternateItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlternateItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>[]
          }
          upsert: {
            args: Prisma.AlternateItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternateItemPayload>
          }
          aggregate: {
            args: Prisma.AlternateItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlternateItem>
          }
          groupBy: {
            args: Prisma.AlternateItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlternateItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlternateItemCountArgs<ExtArgs>
            result: $Utils.Optional<AlternateItemCountAggregateOutputType> | number
          }
        }
      }
      PlanEntitlements: {
        payload: Prisma.$PlanEntitlementsPayload<ExtArgs>
        fields: Prisma.PlanEntitlementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanEntitlementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanEntitlementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          findFirst: {
            args: Prisma.PlanEntitlementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanEntitlementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          findMany: {
            args: Prisma.PlanEntitlementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>[]
          }
          create: {
            args: Prisma.PlanEntitlementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          createMany: {
            args: Prisma.PlanEntitlementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanEntitlementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>[]
          }
          delete: {
            args: Prisma.PlanEntitlementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          update: {
            args: Prisma.PlanEntitlementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          deleteMany: {
            args: Prisma.PlanEntitlementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanEntitlementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanEntitlementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>[]
          }
          upsert: {
            args: Prisma.PlanEntitlementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEntitlementsPayload>
          }
          aggregate: {
            args: Prisma.PlanEntitlementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanEntitlements>
          }
          groupBy: {
            args: Prisma.PlanEntitlementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanEntitlementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanEntitlementsCountArgs<ExtArgs>
            result: $Utils.Optional<PlanEntitlementsCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      Prices: {
        payload: Prisma.$PricesPayload<ExtArgs>
        fields: Prisma.PricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          findFirst: {
            args: Prisma.PricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          findMany: {
            args: Prisma.PricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>[]
          }
          create: {
            args: Prisma.PricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          createMany: {
            args: Prisma.PricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>[]
          }
          delete: {
            args: Prisma.PricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          update: {
            args: Prisma.PricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          deleteMany: {
            args: Prisma.PricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>[]
          }
          upsert: {
            args: Prisma.PricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricesPayload>
          }
          aggregate: {
            args: Prisma.PricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrices>
          }
          groupBy: {
            args: Prisma.PricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricesCountArgs<ExtArgs>
            result: $Utils.Optional<PricesCountAggregateOutputType> | number
          }
        }
      }
      Subscriptions: {
        payload: Prisma.$SubscriptionsPayload<ExtArgs>
        fields: Prisma.SubscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findMany: {
            args: Prisma.SubscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          create: {
            args: Prisma.SubscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          createMany: {
            args: Prisma.SubscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          update: {
            args: Prisma.SubscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.SubscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organization?: OrganizationOmit
    equipment?: EquipmentOmit
    notification?: NotificationOmit
    organizationSavedOption?: OrganizationSavedOptionOmit
    userToOrganization?: UserToOrganizationOmit
    organizationInvitation?: OrganizationInvitationOmit
    userToProject?: UserToProjectOmit
    project?: ProjectOmit
    projectNotes?: ProjectNotesOmit
    projectStatusValue?: ProjectStatusValueOmit
    pendingRoofReports?: PendingRoofReportsOmit
    weatherReportItem?: WeatherReportItemOmit
    projectEquipment?: ProjectEquipmentOmit
    cost?: CostOmit
    propertyData?: PropertyDataOmit
    dataDeletionRequest?: DataDeletionRequestOmit
    photoAccessLink?: PhotoAccessLinkOmit
    image?: ImageOmit
    annotation?: AnnotationOmit
    imageNote?: ImageNoteOmit
    inference?: InferenceOmit
    room?: RoomOmit
    roomReading?: RoomReadingOmit
    notes?: NotesOmit
    notesAuditTrail?: NotesAuditTrailOmit
    areaAffected?: AreaAffectedOmit
    genericRoomReading?: GenericRoomReadingOmit
    detection?: DetectionOmit
    templatesUsed?: TemplatesUsedOmit
    waitList?: WaitListOmit
    rekognitionRuns?: RekognitionRunsOmit
    calendarEvent?: CalendarEventOmit
    calendarEventReminder?: CalendarEventReminderOmit
    itemCategory?: ItemCategoryOmit
    lineItem?: LineItemOmit
    relatedItem?: RelatedItemOmit
    alternateItem?: AlternateItemOmit
    planEntitlements?: PlanEntitlementsOmit
    customers?: CustomersOmit
    products?: ProductsOmit
    prices?: PricesOmit
    subscriptions?: SubscriptionsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    UserToProject: number
    Notification: number
    ImageNote: number
    Annotation: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserToProject?: boolean | UserCountOutputTypeCountUserToProjectArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    ImageNote?: boolean | UserCountOutputTypeCountImageNoteArgs
    Annotation?: boolean | UserCountOutputTypeCountAnnotationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserToProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    Image: number
    invitations: number
    projects: number
    users: number
    Customers: number
    Subscriptions: number
    OrganizationSavedOption: number
    equipment: number
    ProjectStatusValue: number
    User: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | OrganizationCountOutputTypeCountImageArgs
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    Customers?: boolean | OrganizationCountOutputTypeCountCustomersArgs
    Subscriptions?: boolean | OrganizationCountOutputTypeCountSubscriptionsArgs
    OrganizationSavedOption?: boolean | OrganizationCountOutputTypeCountOrganizationSavedOptionArgs
    equipment?: boolean | OrganizationCountOutputTypeCountEquipmentArgs
    ProjectStatusValue?: boolean | OrganizationCountOutputTypeCountProjectStatusValueArgs
    User?: boolean | OrganizationCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationInvitationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToOrganizationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationSavedOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationSavedOptionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectStatusValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatusValueWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    ProjectEquipment: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProjectEquipment?: boolean | EquipmentCountOutputTypeCountProjectEquipmentArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountProjectEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEquipmentWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    images: number
    inferences: number
    rooms: number
    events: number
    projectAssignees: number
    roomReadings: number
    AreaAffected: number
    photoAccessLinks: number
    notes: number
    costs: number
    projectEquipment: number
    weatherReportItems: number
    PendingRoofReports: number
    ProjectNotes: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProjectCountOutputTypeCountImagesArgs
    inferences?: boolean | ProjectCountOutputTypeCountInferencesArgs
    rooms?: boolean | ProjectCountOutputTypeCountRoomsArgs
    events?: boolean | ProjectCountOutputTypeCountEventsArgs
    projectAssignees?: boolean | ProjectCountOutputTypeCountProjectAssigneesArgs
    roomReadings?: boolean | ProjectCountOutputTypeCountRoomReadingsArgs
    AreaAffected?: boolean | ProjectCountOutputTypeCountAreaAffectedArgs
    photoAccessLinks?: boolean | ProjectCountOutputTypeCountPhotoAccessLinksArgs
    notes?: boolean | ProjectCountOutputTypeCountNotesArgs
    costs?: boolean | ProjectCountOutputTypeCountCostsArgs
    projectEquipment?: boolean | ProjectCountOutputTypeCountProjectEquipmentArgs
    weatherReportItems?: boolean | ProjectCountOutputTypeCountWeatherReportItemsArgs
    PendingRoofReports?: boolean | ProjectCountOutputTypeCountPendingRoofReportsArgs
    ProjectNotes?: boolean | ProjectCountOutputTypeCountProjectNotesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InferenceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToProjectWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRoomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReadingWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAreaAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaAffectedWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPhotoAccessLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoAccessLinkWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEquipmentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWeatherReportItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherReportItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPendingRoofReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingRoofReportsWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotesWhereInput
  }


  /**
   * Count Type ProjectStatusValueCountOutputType
   */

  export type ProjectStatusValueCountOutputType = {
    projects: number
  }

  export type ProjectStatusValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectStatusValueCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectStatusValueCountOutputType without action
   */
  export type ProjectStatusValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValueCountOutputType
     */
    select?: ProjectStatusValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectStatusValueCountOutputType without action
   */
  export type ProjectStatusValueCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ImageCountOutputType
   */

  export type ImageCountOutputType = {
    ImageNote: number
    Annotation: number
  }

  export type ImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ImageNote?: boolean | ImageCountOutputTypeCountImageNoteArgs
    Annotation?: boolean | ImageCountOutputTypeCountAnnotationArgs
  }

  // Custom InputTypes
  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountImageNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageNoteWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountAnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
  }


  /**
   * Count Type InferenceCountOutputType
   */

  export type InferenceCountOutputType = {
    detections: number
  }

  export type InferenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detections?: boolean | InferenceCountOutputTypeCountDetectionsArgs
  }

  // Custom InputTypes
  /**
   * InferenceCountOutputType without action
   */
  export type InferenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InferenceCountOutputType
     */
    select?: InferenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InferenceCountOutputType without action
   */
  export type InferenceCountOutputTypeCountDetectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectionWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    detections: number
    inferences: number
    templates: number
    roomReadings: number
    areasAffected: number
    notes: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detections?: boolean | RoomCountOutputTypeCountDetectionsArgs
    inferences?: boolean | RoomCountOutputTypeCountInferencesArgs
    templates?: boolean | RoomCountOutputTypeCountTemplatesArgs
    roomReadings?: boolean | RoomCountOutputTypeCountRoomReadingsArgs
    areasAffected?: boolean | RoomCountOutputTypeCountAreasAffectedArgs
    notes?: boolean | RoomCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountDetectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectionWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountInferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InferenceWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplatesUsedWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountRoomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReadingWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAreasAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaAffectedWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }


  /**
   * Count Type RoomReadingCountOutputType
   */

  export type RoomReadingCountOutputType = {
    genericRoomReadings: number
  }

  export type RoomReadingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genericRoomReadings?: boolean | RoomReadingCountOutputTypeCountGenericRoomReadingsArgs
  }

  // Custom InputTypes
  /**
   * RoomReadingCountOutputType without action
   */
  export type RoomReadingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReadingCountOutputType
     */
    select?: RoomReadingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomReadingCountOutputType without action
   */
  export type RoomReadingCountOutputTypeCountGenericRoomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenericRoomReadingWhereInput
  }


  /**
   * Count Type NotesCountOutputType
   */

  export type NotesCountOutputType = {
    notesAuditTrail: number
  }

  export type NotesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notesAuditTrail?: boolean | NotesCountOutputTypeCountNotesAuditTrailArgs
  }

  // Custom InputTypes
  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesCountOutputType
     */
    select?: NotesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountNotesAuditTrailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesAuditTrailWhereInput
  }


  /**
   * Count Type CalendarEventCountOutputType
   */

  export type CalendarEventCountOutputType = {
    reminders: number
  }

  export type CalendarEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reminders?: boolean | CalendarEventCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes
  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventCountOutputType
     */
    select?: CalendarEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventReminderWhereInput
  }


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    LineItem: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LineItem?: boolean | ItemCategoryCountOutputTypeCountLineItemArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountLineItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineItemWhereInput
  }


  /**
   * Count Type LineItemCountOutputType
   */

  export type LineItemCountOutputType = {
    alternateItem: number
    relatedItem: number
  }

  export type LineItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alternateItem?: boolean | LineItemCountOutputTypeCountAlternateItemArgs
    relatedItem?: boolean | LineItemCountOutputTypeCountRelatedItemArgs
  }

  // Custom InputTypes
  /**
   * LineItemCountOutputType without action
   */
  export type LineItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItemCountOutputType
     */
    select?: LineItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LineItemCountOutputType without action
   */
  export type LineItemCountOutputTypeCountAlternateItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternateItemWhereInput
  }

  /**
   * LineItemCountOutputType without action
   */
  export type LineItemCountOutputTypeCountRelatedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedItemWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    prices: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | ProductsCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricesWhereInput
  }


  /**
   * Count Type PricesCountOutputType
   */

  export type PricesCountOutputType = {
    Subscriptions: number
  }

  export type PricesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscriptions?: boolean | PricesCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PricesCountOutputType without action
   */
  export type PricesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricesCountOutputType
     */
    select?: PricesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PricesCountOutputType without action
   */
  export type PricesCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    email: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    inviteId: string | null
    isSupportUser: boolean | null
    hasSeenProductTour: boolean | null
    savedDashboardView: $Enums.DashboardViews | null
    photoView: $Enums.PhotoViews | null
    groupView: $Enums.GroupByViews | null
    organizationId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    email: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    inviteId: string | null
    isSupportUser: boolean | null
    hasSeenProductTour: boolean | null
    savedDashboardView: $Enums.DashboardViews | null
    photoView: $Enums.PhotoViews | null
    groupView: $Enums.GroupByViews | null
    organizationId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    email: number
    isDeleted: number
    updatedAt: number
    firstName: number
    lastName: number
    phone: number
    inviteId: number
    isSupportUser: number
    hasSeenProductTour: number
    productTourData: number
    savedDashboardView: number
    photoView: number
    groupView: number
    onboardingStatus: number
    organizationId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
    organizationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
    organizationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    email?: true
    isDeleted?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    phone?: true
    inviteId?: true
    isSupportUser?: true
    hasSeenProductTour?: true
    productTourData?: true
    savedDashboardView?: true
    photoView?: true
    groupView?: true
    onboardingStatus?: true
    organizationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    token: string | null
    createdAt: Date
    email: string
    isDeleted: boolean
    updatedAt: Date
    firstName: string
    lastName: string
    phone: string
    inviteId: string | null
    isSupportUser: boolean
    hasSeenProductTour: boolean
    productTourData: JsonValue | null
    savedDashboardView: $Enums.DashboardViews
    photoView: $Enums.PhotoViews
    groupView: $Enums.GroupByViews
    onboardingStatus: JsonValue | null
    organizationId: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    email?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    inviteId?: boolean
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: boolean
    savedDashboardView?: boolean
    photoView?: boolean
    groupView?: boolean
    onboardingStatus?: boolean
    organizationId?: boolean
    org?: boolean | User$orgArgs<ExtArgs>
    UserToProject?: boolean | User$UserToProjectArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    ImageNote?: boolean | User$ImageNoteArgs<ExtArgs>
    Annotation?: boolean | User$AnnotationArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    email?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    inviteId?: boolean
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: boolean
    savedDashboardView?: boolean
    photoView?: boolean
    groupView?: boolean
    onboardingStatus?: boolean
    organizationId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    email?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    inviteId?: boolean
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: boolean
    savedDashboardView?: boolean
    photoView?: boolean
    groupView?: boolean
    onboardingStatus?: boolean
    organizationId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    email?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    inviteId?: boolean
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: boolean
    savedDashboardView?: boolean
    photoView?: boolean
    groupView?: boolean
    onboardingStatus?: boolean
    organizationId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "createdAt" | "email" | "isDeleted" | "updatedAt" | "firstName" | "lastName" | "phone" | "inviteId" | "isSupportUser" | "hasSeenProductTour" | "productTourData" | "savedDashboardView" | "photoView" | "groupView" | "onboardingStatus" | "organizationId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | User$orgArgs<ExtArgs>
    UserToProject?: boolean | User$UserToProjectArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    ImageNote?: boolean | User$ImageNoteArgs<ExtArgs>
    Annotation?: boolean | User$AnnotationArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      org: Prisma.$UserToOrganizationPayload<ExtArgs> | null
      UserToProject: Prisma.$UserToProjectPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      ImageNote: Prisma.$ImageNotePayload<ExtArgs>[]
      Annotation: Prisma.$AnnotationPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string | null
      createdAt: Date
      email: string
      isDeleted: boolean
      updatedAt: Date
      firstName: string
      lastName: string
      phone: string
      inviteId: string | null
      isSupportUser: boolean
      hasSeenProductTour: boolean
      productTourData: Prisma.JsonValue | null
      savedDashboardView: $Enums.DashboardViews
      photoView: $Enums.PhotoViews
      groupView: $Enums.GroupByViews
      onboardingStatus: Prisma.JsonValue | null
      organizationId: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends User$orgArgs<ExtArgs> = {}>(args?: Subset<T, User$orgArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    UserToProject<T extends User$UserToProjectArgs<ExtArgs> = {}>(args?: Subset<T, User$UserToProjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ImageNote<T extends User$ImageNoteArgs<ExtArgs> = {}>(args?: Subset<T, User$ImageNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Annotation<T extends User$AnnotationArgs<ExtArgs> = {}>(args?: Subset<T, User$AnnotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly token: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly inviteId: FieldRef<"User", 'String'>
    readonly isSupportUser: FieldRef<"User", 'Boolean'>
    readonly hasSeenProductTour: FieldRef<"User", 'Boolean'>
    readonly productTourData: FieldRef<"User", 'Json'>
    readonly savedDashboardView: FieldRef<"User", 'DashboardViews'>
    readonly photoView: FieldRef<"User", 'PhotoViews'>
    readonly groupView: FieldRef<"User", 'GroupByViews'>
    readonly onboardingStatus: FieldRef<"User", 'Json'>
    readonly organizationId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.org
   */
  export type User$orgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    where?: UserToOrganizationWhereInput
  }

  /**
   * User.UserToProject
   */
  export type User$UserToProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    where?: UserToProjectWhereInput
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    cursor?: UserToProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToProjectScalarFieldEnum | UserToProjectScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.ImageNote
   */
  export type User$ImageNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    where?: ImageNoteWhereInput
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    cursor?: ImageNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageNoteScalarFieldEnum | ImageNoteScalarFieldEnum[]
  }

  /**
   * User.Annotation
   */
  export type User$AnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
    lat: number | null
    lng: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
    lat: number | null
    lng: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    name: string | null
    address: string | null
    faxNumber: string | null
    size: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    logoId: string | null
    lat: number | null
    lng: number | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    name: string | null
    address: string | null
    faxNumber: string | null
    size: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    logoId: string | null
    lat: number | null
    lng: number | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    name: number
    address: number
    faxNumber: number
    size: number
    isDeleted: number
    updatedAt: number
    logoId: number
    lat: number
    lng: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
    lat?: true
    lng?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
    lat?: true
    lng?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
    lat?: true
    lng?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
    lat?: true
    lng?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    name?: true
    address?: true
    faxNumber?: true
    size?: true
    isDeleted?: true
    updatedAt?: true
    logoId?: true
    lat?: true
    lng?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    name: string
    address: string
    faxNumber: string
    size: string
    isDeleted: boolean
    updatedAt: Date
    logoId: string | null
    lat: number
    lng: number
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    name?: boolean
    address?: boolean
    faxNumber?: boolean
    size?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    logoId?: boolean
    lat?: boolean
    lng?: boolean
    Image?: boolean | Organization$ImageArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    Customers?: boolean | Organization$CustomersArgs<ExtArgs>
    Subscriptions?: boolean | Organization$SubscriptionsArgs<ExtArgs>
    OrganizationSavedOption?: boolean | Organization$OrganizationSavedOptionArgs<ExtArgs>
    equipment?: boolean | Organization$equipmentArgs<ExtArgs>
    ProjectStatusValue?: boolean | Organization$ProjectStatusValueArgs<ExtArgs>
    User?: boolean | Organization$UserArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    name?: boolean
    address?: boolean
    faxNumber?: boolean
    size?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    logoId?: boolean
    lat?: boolean
    lng?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    name?: boolean
    address?: boolean
    faxNumber?: boolean
    size?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    logoId?: boolean
    lat?: boolean
    lng?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    name?: boolean
    address?: boolean
    faxNumber?: boolean
    size?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    logoId?: boolean
    lat?: boolean
    lng?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "name" | "address" | "faxNumber" | "size" | "isDeleted" | "updatedAt" | "logoId" | "lat" | "lng", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | Organization$ImageArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    Customers?: boolean | Organization$CustomersArgs<ExtArgs>
    Subscriptions?: boolean | Organization$SubscriptionsArgs<ExtArgs>
    OrganizationSavedOption?: boolean | Organization$OrganizationSavedOptionArgs<ExtArgs>
    equipment?: boolean | Organization$equipmentArgs<ExtArgs>
    ProjectStatusValue?: boolean | Organization$ProjectStatusValueArgs<ExtArgs>
    User?: boolean | Organization$UserArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      Image: Prisma.$ImagePayload<ExtArgs>[]
      invitations: Prisma.$OrganizationInvitationPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      users: Prisma.$UserToOrganizationPayload<ExtArgs>[]
      Customers: Prisma.$CustomersPayload<ExtArgs>[]
      Subscriptions: Prisma.$SubscriptionsPayload<ExtArgs>[]
      OrganizationSavedOption: Prisma.$OrganizationSavedOptionPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      ProjectStatusValue: Prisma.$ProjectStatusValuePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      name: string
      address: string
      faxNumber: string
      size: string
      isDeleted: boolean
      updatedAt: Date
      logoId: string | null
      lat: number
      lng: number
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Image<T extends Organization$ImageArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Customers<T extends Organization$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$CustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Subscriptions<T extends Organization$SubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$SubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OrganizationSavedOption<T extends Organization$OrganizationSavedOptionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$OrganizationSavedOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    equipment<T extends Organization$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ProjectStatusValue<T extends Organization$ProjectStatusValueArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ProjectStatusValueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    User<T extends Organization$UserArgs<ExtArgs> = {}>(args?: Subset<T, Organization$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly publicId: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly faxNumber: FieldRef<"Organization", 'String'>
    readonly size: FieldRef<"Organization", 'String'>
    readonly isDeleted: FieldRef<"Organization", 'Boolean'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly logoId: FieldRef<"Organization", 'String'>
    readonly lat: FieldRef<"Organization", 'Float'>
    readonly lng: FieldRef<"Organization", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.Image
   */
  export type Organization$ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    where?: OrganizationInvitationWhereInput
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    cursor?: OrganizationInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    where?: UserToOrganizationWhereInput
    orderBy?: UserToOrganizationOrderByWithRelationInput | UserToOrganizationOrderByWithRelationInput[]
    cursor?: UserToOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToOrganizationScalarFieldEnum | UserToOrganizationScalarFieldEnum[]
  }

  /**
   * Organization.Customers
   */
  export type Organization$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Organization.Subscriptions
   */
  export type Organization$SubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Organization.OrganizationSavedOption
   */
  export type Organization$OrganizationSavedOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    where?: OrganizationSavedOptionWhereInput
    orderBy?: OrganizationSavedOptionOrderByWithRelationInput | OrganizationSavedOptionOrderByWithRelationInput[]
    cursor?: OrganizationSavedOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationSavedOptionScalarFieldEnum | OrganizationSavedOptionScalarFieldEnum[]
  }

  /**
   * Organization.equipment
   */
  export type Organization$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Organization.ProjectStatusValue
   */
  export type Organization$ProjectStatusValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    where?: ProjectStatusValueWhereInput
    orderBy?: ProjectStatusValueOrderByWithRelationInput | ProjectStatusValueOrderByWithRelationInput[]
    cursor?: ProjectStatusValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectStatusValueScalarFieldEnum | ProjectStatusValueScalarFieldEnum[]
  }

  /**
   * Organization.User
   */
  export type Organization$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    name: string | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    name: string | null
    quantity: number | null
    organizationId: number | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    name: number
    quantity: number
    organizationId: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    id?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentSumAggregateInputType = {
    id?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    name?: true
    quantity?: true
    organizationId?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    name: string
    quantity: number
    organizationId: number
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    name?: boolean
    quantity?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ProjectEquipment?: boolean | Equipment$ProjectEquipmentArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    name?: boolean
    quantity?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    name?: boolean
    quantity?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    name?: boolean
    quantity?: boolean
    organizationId?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "isDeleted" | "name" | "quantity" | "organizationId", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ProjectEquipment?: boolean | Equipment$ProjectEquipmentArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      ProjectEquipment: Prisma.$ProjectEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      isDeleted: boolean
      name: string
      quantity: number
      organizationId: number
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ProjectEquipment<T extends Equipment$ProjectEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$ProjectEquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */ 
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'Int'>
    readonly publicId: FieldRef<"Equipment", 'String'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly isDeleted: FieldRef<"Equipment", 'Boolean'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly quantity: FieldRef<"Equipment", 'Int'>
    readonly organizationId: FieldRef<"Equipment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment.ProjectEquipment
   */
  export type Equipment$ProjectEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    where?: ProjectEquipmentWhereInput
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    cursor?: ProjectEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectEquipmentScalarFieldEnum | ProjectEquipmentScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    title: string | null
    content: string | null
    isSeen: boolean | null
    link: string | null
    linkText: string | null
    type: $Enums.NotificationType | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    title: string | null
    content: string | null
    isSeen: boolean | null
    link: string | null
    linkText: string | null
    type: $Enums.NotificationType | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    title: number
    content: number
    isSeen: number
    link: number
    linkText: number
    type: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    title?: true
    content?: true
    isSeen?: true
    link?: true
    linkText?: true
    type?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    title: string
    content: string
    isSeen: boolean
    link: string | null
    linkText: string | null
    type: $Enums.NotificationType
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    title?: boolean
    content?: boolean
    isSeen?: boolean
    link?: boolean
    linkText?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    title?: boolean
    content?: boolean
    isSeen?: boolean
    link?: boolean
    linkText?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    title?: boolean
    content?: boolean
    isSeen?: boolean
    link?: boolean
    linkText?: boolean
    type?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    title?: boolean
    content?: boolean
    isSeen?: boolean
    link?: boolean
    linkText?: boolean
    type?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "isDeleted" | "title" | "content" | "isSeen" | "link" | "linkText" | "type" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      isDeleted: boolean
      title: string
      content: string
      isSeen: boolean
      link: string | null
      linkText: string | null
      type: $Enums.NotificationType
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly publicId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly isDeleted: FieldRef<"Notification", 'Boolean'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isSeen: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly linkText: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationSavedOption
   */

  export type AggregateOrganizationSavedOption = {
    _count: OrganizationSavedOptionCountAggregateOutputType | null
    _avg: OrganizationSavedOptionAvgAggregateOutputType | null
    _sum: OrganizationSavedOptionSumAggregateOutputType | null
    _min: OrganizationSavedOptionMinAggregateOutputType | null
    _max: OrganizationSavedOptionMaxAggregateOutputType | null
  }

  export type OrganizationSavedOptionAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    label: string | null
    value: string | null
    isDeleted: boolean | null
    type: $Enums.SavedOptionType | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    label: string | null
    value: string | null
    isDeleted: boolean | null
    type: $Enums.SavedOptionType | null
    organizationId: number | null
  }

  export type OrganizationSavedOptionCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    label: number
    value: number
    isDeleted: number
    type: number
    organizationId: number
    _all: number
  }


  export type OrganizationSavedOptionAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
  }

  export type OrganizationSavedOptionCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    label?: true
    value?: true
    isDeleted?: true
    type?: true
    organizationId?: true
    _all?: true
  }

  export type OrganizationSavedOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationSavedOption to aggregate.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: OrganizationSavedOptionOrderByWithRelationInput | OrganizationSavedOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationSavedOptions
    **/
    _count?: true | OrganizationSavedOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationSavedOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSavedOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationSavedOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationSavedOptionMaxAggregateInputType
  }

  export type GetOrganizationSavedOptionAggregateType<T extends OrganizationSavedOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationSavedOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationSavedOption[P]>
      : GetScalarType<T[P], AggregateOrganizationSavedOption[P]>
  }




  export type OrganizationSavedOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationSavedOptionWhereInput
    orderBy?: OrganizationSavedOptionOrderByWithAggregationInput | OrganizationSavedOptionOrderByWithAggregationInput[]
    by: OrganizationSavedOptionScalarFieldEnum[] | OrganizationSavedOptionScalarFieldEnum
    having?: OrganizationSavedOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationSavedOptionCountAggregateInputType | true
    _avg?: OrganizationSavedOptionAvgAggregateInputType
    _sum?: OrganizationSavedOptionSumAggregateInputType
    _min?: OrganizationSavedOptionMinAggregateInputType
    _max?: OrganizationSavedOptionMaxAggregateInputType
  }

  export type OrganizationSavedOptionGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    label: string
    value: string
    isDeleted: boolean
    type: $Enums.SavedOptionType
    organizationId: number
    _count: OrganizationSavedOptionCountAggregateOutputType | null
    _avg: OrganizationSavedOptionAvgAggregateOutputType | null
    _sum: OrganizationSavedOptionSumAggregateOutputType | null
    _min: OrganizationSavedOptionMinAggregateOutputType | null
    _max: OrganizationSavedOptionMaxAggregateOutputType | null
  }

  type GetOrganizationSavedOptionGroupByPayload<T extends OrganizationSavedOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationSavedOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationSavedOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationSavedOptionGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationSavedOptionGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSavedOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    label?: boolean
    value?: boolean
    isDeleted?: boolean
    type?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationSavedOption"]>

  export type OrganizationSavedOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    label?: boolean
    value?: boolean
    isDeleted?: boolean
    type?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationSavedOption"]>

  export type OrganizationSavedOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    label?: boolean
    value?: boolean
    isDeleted?: boolean
    type?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationSavedOption"]>

  export type OrganizationSavedOptionSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    label?: boolean
    value?: boolean
    isDeleted?: boolean
    type?: boolean
    organizationId?: boolean
  }

  export type OrganizationSavedOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "label" | "value" | "isDeleted" | "type" | "organizationId", ExtArgs["result"]["organizationSavedOption"]>
  export type OrganizationSavedOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationSavedOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationSavedOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationSavedOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationSavedOption"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      label: string
      value: string
      isDeleted: boolean
      type: $Enums.SavedOptionType
      organizationId: number
    }, ExtArgs["result"]["organizationSavedOption"]>
    composites: {}
  }

  type OrganizationSavedOptionGetPayload<S extends boolean | null | undefined | OrganizationSavedOptionDefaultArgs> = $Result.GetResult<Prisma.$OrganizationSavedOptionPayload, S>

  type OrganizationSavedOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationSavedOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationSavedOptionCountAggregateInputType | true
    }

  export interface OrganizationSavedOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationSavedOption'], meta: { name: 'OrganizationSavedOption' } }
    /**
     * Find zero or one OrganizationSavedOption that matches the filter.
     * @param {OrganizationSavedOptionFindUniqueArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationSavedOptionFindUniqueArgs>(args: SelectSubset<T, OrganizationSavedOptionFindUniqueArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrganizationSavedOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationSavedOptionFindUniqueOrThrowArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationSavedOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationSavedOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrganizationSavedOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindFirstArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationSavedOptionFindFirstArgs>(args?: SelectSubset<T, OrganizationSavedOptionFindFirstArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrganizationSavedOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindFirstOrThrowArgs} args - Arguments to find a OrganizationSavedOption
     * @example
     * // Get one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationSavedOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationSavedOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrganizationSavedOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationSavedOptions
     * const organizationSavedOptions = await prisma.organizationSavedOption.findMany()
     * 
     * // Get first 10 OrganizationSavedOptions
     * const organizationSavedOptions = await prisma.organizationSavedOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationSavedOptionWithIdOnly = await prisma.organizationSavedOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationSavedOptionFindManyArgs>(args?: SelectSubset<T, OrganizationSavedOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrganizationSavedOption.
     * @param {OrganizationSavedOptionCreateArgs} args - Arguments to create a OrganizationSavedOption.
     * @example
     * // Create one OrganizationSavedOption
     * const OrganizationSavedOption = await prisma.organizationSavedOption.create({
     *   data: {
     *     // ... data to create a OrganizationSavedOption
     *   }
     * })
     * 
     */
    create<T extends OrganizationSavedOptionCreateArgs>(args: SelectSubset<T, OrganizationSavedOptionCreateArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrganizationSavedOptions.
     * @param {OrganizationSavedOptionCreateManyArgs} args - Arguments to create many OrganizationSavedOptions.
     * @example
     * // Create many OrganizationSavedOptions
     * const organizationSavedOption = await prisma.organizationSavedOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationSavedOptionCreateManyArgs>(args?: SelectSubset<T, OrganizationSavedOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationSavedOptions and returns the data saved in the database.
     * @param {OrganizationSavedOptionCreateManyAndReturnArgs} args - Arguments to create many OrganizationSavedOptions.
     * @example
     * // Create many OrganizationSavedOptions
     * const organizationSavedOption = await prisma.organizationSavedOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationSavedOptions and only return the `id`
     * const organizationSavedOptionWithIdOnly = await prisma.organizationSavedOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationSavedOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationSavedOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a OrganizationSavedOption.
     * @param {OrganizationSavedOptionDeleteArgs} args - Arguments to delete one OrganizationSavedOption.
     * @example
     * // Delete one OrganizationSavedOption
     * const OrganizationSavedOption = await prisma.organizationSavedOption.delete({
     *   where: {
     *     // ... filter to delete one OrganizationSavedOption
     *   }
     * })
     * 
     */
    delete<T extends OrganizationSavedOptionDeleteArgs>(args: SelectSubset<T, OrganizationSavedOptionDeleteArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrganizationSavedOption.
     * @param {OrganizationSavedOptionUpdateArgs} args - Arguments to update one OrganizationSavedOption.
     * @example
     * // Update one OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationSavedOptionUpdateArgs>(args: SelectSubset<T, OrganizationSavedOptionUpdateArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrganizationSavedOptions.
     * @param {OrganizationSavedOptionDeleteManyArgs} args - Arguments to filter OrganizationSavedOptions to delete.
     * @example
     * // Delete a few OrganizationSavedOptions
     * const { count } = await prisma.organizationSavedOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationSavedOptionDeleteManyArgs>(args?: SelectSubset<T, OrganizationSavedOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationSavedOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationSavedOptions
     * const organizationSavedOption = await prisma.organizationSavedOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationSavedOptionUpdateManyArgs>(args: SelectSubset<T, OrganizationSavedOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationSavedOptions and returns the data updated in the database.
     * @param {OrganizationSavedOptionUpdateManyAndReturnArgs} args - Arguments to update many OrganizationSavedOptions.
     * @example
     * // Update many OrganizationSavedOptions
     * const organizationSavedOption = await prisma.organizationSavedOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationSavedOptions and only return the `id`
     * const organizationSavedOptionWithIdOnly = await prisma.organizationSavedOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationSavedOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationSavedOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one OrganizationSavedOption.
     * @param {OrganizationSavedOptionUpsertArgs} args - Arguments to update or create a OrganizationSavedOption.
     * @example
     * // Update or create a OrganizationSavedOption
     * const organizationSavedOption = await prisma.organizationSavedOption.upsert({
     *   create: {
     *     // ... data to create a OrganizationSavedOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationSavedOption we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationSavedOptionUpsertArgs>(args: SelectSubset<T, OrganizationSavedOptionUpsertArgs<ExtArgs>>): Prisma__OrganizationSavedOptionClient<$Result.GetResult<Prisma.$OrganizationSavedOptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrganizationSavedOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionCountArgs} args - Arguments to filter OrganizationSavedOptions to count.
     * @example
     * // Count the number of OrganizationSavedOptions
     * const count = await prisma.organizationSavedOption.count({
     *   where: {
     *     // ... the filter for the OrganizationSavedOptions we want to count
     *   }
     * })
    **/
    count<T extends OrganizationSavedOptionCountArgs>(
      args?: Subset<T, OrganizationSavedOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationSavedOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationSavedOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationSavedOptionAggregateArgs>(args: Subset<T, OrganizationSavedOptionAggregateArgs>): Prisma.PrismaPromise<GetOrganizationSavedOptionAggregateType<T>>

    /**
     * Group by OrganizationSavedOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSavedOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationSavedOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationSavedOptionGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationSavedOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationSavedOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationSavedOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationSavedOption model
   */
  readonly fields: OrganizationSavedOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationSavedOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationSavedOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationSavedOption model
   */ 
  interface OrganizationSavedOptionFieldRefs {
    readonly id: FieldRef<"OrganizationSavedOption", 'Int'>
    readonly publicId: FieldRef<"OrganizationSavedOption", 'String'>
    readonly createdAt: FieldRef<"OrganizationSavedOption", 'DateTime'>
    readonly label: FieldRef<"OrganizationSavedOption", 'String'>
    readonly value: FieldRef<"OrganizationSavedOption", 'String'>
    readonly isDeleted: FieldRef<"OrganizationSavedOption", 'Boolean'>
    readonly type: FieldRef<"OrganizationSavedOption", 'SavedOptionType'>
    readonly organizationId: FieldRef<"OrganizationSavedOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationSavedOption findUnique
   */
  export type OrganizationSavedOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }

  /**
   * OrganizationSavedOption findUniqueOrThrow
   */
  export type OrganizationSavedOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }

  /**
   * OrganizationSavedOption findFirst
   */
  export type OrganizationSavedOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: OrganizationSavedOptionOrderByWithRelationInput | OrganizationSavedOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSavedOptions.
     */
    distinct?: OrganizationSavedOptionScalarFieldEnum | OrganizationSavedOptionScalarFieldEnum[]
  }

  /**
   * OrganizationSavedOption findFirstOrThrow
   */
  export type OrganizationSavedOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSavedOption to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: OrganizationSavedOptionOrderByWithRelationInput | OrganizationSavedOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSavedOptions.
     */
    distinct?: OrganizationSavedOptionScalarFieldEnum | OrganizationSavedOptionScalarFieldEnum[]
  }

  /**
   * OrganizationSavedOption findMany
   */
  export type OrganizationSavedOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSavedOptions to fetch.
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSavedOptions to fetch.
     */
    orderBy?: OrganizationSavedOptionOrderByWithRelationInput | OrganizationSavedOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationSavedOptions.
     */
    cursor?: OrganizationSavedOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSavedOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSavedOptions.
     */
    skip?: number
    distinct?: OrganizationSavedOptionScalarFieldEnum | OrganizationSavedOptionScalarFieldEnum[]
  }

  /**
   * OrganizationSavedOption create
   */
  export type OrganizationSavedOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationSavedOption.
     */
    data: XOR<OrganizationSavedOptionCreateInput, OrganizationSavedOptionUncheckedCreateInput>
  }

  /**
   * OrganizationSavedOption createMany
   */
  export type OrganizationSavedOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationSavedOptions.
     */
    data: OrganizationSavedOptionCreateManyInput | OrganizationSavedOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationSavedOption createManyAndReturn
   */
  export type OrganizationSavedOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationSavedOptions.
     */
    data: OrganizationSavedOptionCreateManyInput | OrganizationSavedOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationSavedOption update
   */
  export type OrganizationSavedOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationSavedOption.
     */
    data: XOR<OrganizationSavedOptionUpdateInput, OrganizationSavedOptionUncheckedUpdateInput>
    /**
     * Choose, which OrganizationSavedOption to update.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }

  /**
   * OrganizationSavedOption updateMany
   */
  export type OrganizationSavedOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationSavedOptions.
     */
    data: XOR<OrganizationSavedOptionUpdateManyMutationInput, OrganizationSavedOptionUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationSavedOptions to update
     */
    where?: OrganizationSavedOptionWhereInput
  }

  /**
   * OrganizationSavedOption updateManyAndReturn
   */
  export type OrganizationSavedOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationSavedOptions.
     */
    data: XOR<OrganizationSavedOptionUpdateManyMutationInput, OrganizationSavedOptionUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationSavedOptions to update
     */
    where?: OrganizationSavedOptionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationSavedOption upsert
   */
  export type OrganizationSavedOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationSavedOption to update in case it exists.
     */
    where: OrganizationSavedOptionWhereUniqueInput
    /**
     * In case the OrganizationSavedOption found by the `where` argument doesn't exist, create a new OrganizationSavedOption with this data.
     */
    create: XOR<OrganizationSavedOptionCreateInput, OrganizationSavedOptionUncheckedCreateInput>
    /**
     * In case the OrganizationSavedOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationSavedOptionUpdateInput, OrganizationSavedOptionUncheckedUpdateInput>
  }

  /**
   * OrganizationSavedOption delete
   */
  export type OrganizationSavedOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
    /**
     * Filter which OrganizationSavedOption to delete.
     */
    where: OrganizationSavedOptionWhereUniqueInput
  }

  /**
   * OrganizationSavedOption deleteMany
   */
  export type OrganizationSavedOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationSavedOptions to delete
     */
    where?: OrganizationSavedOptionWhereInput
  }

  /**
   * OrganizationSavedOption without action
   */
  export type OrganizationSavedOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSavedOption
     */
    select?: OrganizationSavedOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationSavedOption
     */
    omit?: OrganizationSavedOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationSavedOptionInclude<ExtArgs> | null
  }


  /**
   * Model UserToOrganization
   */

  export type AggregateUserToOrganization = {
    _count: UserToOrganizationCountAggregateOutputType | null
    _avg: UserToOrganizationAvgAggregateOutputType | null
    _sum: UserToOrganizationSumAggregateOutputType | null
    _min: UserToOrganizationMinAggregateOutputType | null
    _max: UserToOrganizationMaxAggregateOutputType | null
  }

  export type UserToOrganizationAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserToOrganizationSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserToOrganizationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    organizationId: number | null
    role: string | null
    accessLevel: $Enums.AccessLevel | null
    userId: string | null
  }

  export type UserToOrganizationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    organizationId: number | null
    role: string | null
    accessLevel: $Enums.AccessLevel | null
    userId: string | null
  }

  export type UserToOrganizationCountAggregateOutputType = {
    id: number
    createdAt: number
    isAdmin: number
    isDeleted: number
    organizationId: number
    role: number
    accessLevel: number
    userId: number
    _all: number
  }


  export type UserToOrganizationAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserToOrganizationSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserToOrganizationMinAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
  }

  export type UserToOrganizationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
  }

  export type UserToOrganizationCountAggregateInputType = {
    id?: true
    createdAt?: true
    isAdmin?: true
    isDeleted?: true
    organizationId?: true
    role?: true
    accessLevel?: true
    userId?: true
    _all?: true
  }

  export type UserToOrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToOrganization to aggregate.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: UserToOrganizationOrderByWithRelationInput | UserToOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToOrganizations
    **/
    _count?: true | UserToOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToOrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToOrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToOrganizationMaxAggregateInputType
  }

  export type GetUserToOrganizationAggregateType<T extends UserToOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToOrganization[P]>
      : GetScalarType<T[P], AggregateUserToOrganization[P]>
  }




  export type UserToOrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToOrganizationWhereInput
    orderBy?: UserToOrganizationOrderByWithAggregationInput | UserToOrganizationOrderByWithAggregationInput[]
    by: UserToOrganizationScalarFieldEnum[] | UserToOrganizationScalarFieldEnum
    having?: UserToOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToOrganizationCountAggregateInputType | true
    _avg?: UserToOrganizationAvgAggregateInputType
    _sum?: UserToOrganizationSumAggregateInputType
    _min?: UserToOrganizationMinAggregateInputType
    _max?: UserToOrganizationMaxAggregateInputType
  }

  export type UserToOrganizationGroupByOutputType = {
    id: number
    createdAt: Date
    isAdmin: boolean
    isDeleted: boolean
    organizationId: number
    role: string | null
    accessLevel: $Enums.AccessLevel | null
    userId: string
    _count: UserToOrganizationCountAggregateOutputType | null
    _avg: UserToOrganizationAvgAggregateOutputType | null
    _sum: UserToOrganizationSumAggregateOutputType | null
    _min: UserToOrganizationMinAggregateOutputType | null
    _max: UserToOrganizationMaxAggregateOutputType | null
  }

  type GetUserToOrganizationGroupByPayload<T extends UserToOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], UserToOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type UserToOrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    role?: boolean
    accessLevel?: boolean
    userId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToOrganization"]>

  export type UserToOrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    role?: boolean
    accessLevel?: boolean
    userId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToOrganization"]>

  export type UserToOrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    role?: boolean
    accessLevel?: boolean
    userId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToOrganization"]>

  export type UserToOrganizationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    role?: boolean
    accessLevel?: boolean
    userId?: boolean
  }

  export type UserToOrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isAdmin" | "isDeleted" | "organizationId" | "role" | "accessLevel" | "userId", ExtArgs["result"]["userToOrganization"]>
  export type UserToOrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToOrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToOrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserToOrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToOrganization"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isAdmin: boolean
      isDeleted: boolean
      organizationId: number
      role: string | null
      accessLevel: $Enums.AccessLevel | null
      userId: string
    }, ExtArgs["result"]["userToOrganization"]>
    composites: {}
  }

  type UserToOrganizationGetPayload<S extends boolean | null | undefined | UserToOrganizationDefaultArgs> = $Result.GetResult<Prisma.$UserToOrganizationPayload, S>

  type UserToOrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToOrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToOrganizationCountAggregateInputType | true
    }

  export interface UserToOrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToOrganization'], meta: { name: 'UserToOrganization' } }
    /**
     * Find zero or one UserToOrganization that matches the filter.
     * @param {UserToOrganizationFindUniqueArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToOrganizationFindUniqueArgs>(args: SelectSubset<T, UserToOrganizationFindUniqueArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserToOrganization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToOrganizationFindUniqueOrThrowArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToOrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToOrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserToOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindFirstArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToOrganizationFindFirstArgs>(args?: SelectSubset<T, UserToOrganizationFindFirstArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserToOrganization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindFirstOrThrowArgs} args - Arguments to find a UserToOrganization
     * @example
     * // Get one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToOrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToOrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserToOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToOrganizations
     * const userToOrganizations = await prisma.userToOrganization.findMany()
     * 
     * // Get first 10 UserToOrganizations
     * const userToOrganizations = await prisma.userToOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToOrganizationWithIdOnly = await prisma.userToOrganization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToOrganizationFindManyArgs>(args?: SelectSubset<T, UserToOrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserToOrganization.
     * @param {UserToOrganizationCreateArgs} args - Arguments to create a UserToOrganization.
     * @example
     * // Create one UserToOrganization
     * const UserToOrganization = await prisma.userToOrganization.create({
     *   data: {
     *     // ... data to create a UserToOrganization
     *   }
     * })
     * 
     */
    create<T extends UserToOrganizationCreateArgs>(args: SelectSubset<T, UserToOrganizationCreateArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserToOrganizations.
     * @param {UserToOrganizationCreateManyArgs} args - Arguments to create many UserToOrganizations.
     * @example
     * // Create many UserToOrganizations
     * const userToOrganization = await prisma.userToOrganization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToOrganizationCreateManyArgs>(args?: SelectSubset<T, UserToOrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserToOrganizations and returns the data saved in the database.
     * @param {UserToOrganizationCreateManyAndReturnArgs} args - Arguments to create many UserToOrganizations.
     * @example
     * // Create many UserToOrganizations
     * const userToOrganization = await prisma.userToOrganization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserToOrganizations and only return the `id`
     * const userToOrganizationWithIdOnly = await prisma.userToOrganization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserToOrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserToOrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserToOrganization.
     * @param {UserToOrganizationDeleteArgs} args - Arguments to delete one UserToOrganization.
     * @example
     * // Delete one UserToOrganization
     * const UserToOrganization = await prisma.userToOrganization.delete({
     *   where: {
     *     // ... filter to delete one UserToOrganization
     *   }
     * })
     * 
     */
    delete<T extends UserToOrganizationDeleteArgs>(args: SelectSubset<T, UserToOrganizationDeleteArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserToOrganization.
     * @param {UserToOrganizationUpdateArgs} args - Arguments to update one UserToOrganization.
     * @example
     * // Update one UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToOrganizationUpdateArgs>(args: SelectSubset<T, UserToOrganizationUpdateArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserToOrganizations.
     * @param {UserToOrganizationDeleteManyArgs} args - Arguments to filter UserToOrganizations to delete.
     * @example
     * // Delete a few UserToOrganizations
     * const { count } = await prisma.userToOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToOrganizationDeleteManyArgs>(args?: SelectSubset<T, UserToOrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToOrganizations
     * const userToOrganization = await prisma.userToOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToOrganizationUpdateManyArgs>(args: SelectSubset<T, UserToOrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToOrganizations and returns the data updated in the database.
     * @param {UserToOrganizationUpdateManyAndReturnArgs} args - Arguments to update many UserToOrganizations.
     * @example
     * // Update many UserToOrganizations
     * const userToOrganization = await prisma.userToOrganization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserToOrganizations and only return the `id`
     * const userToOrganizationWithIdOnly = await prisma.userToOrganization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserToOrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserToOrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserToOrganization.
     * @param {UserToOrganizationUpsertArgs} args - Arguments to update or create a UserToOrganization.
     * @example
     * // Update or create a UserToOrganization
     * const userToOrganization = await prisma.userToOrganization.upsert({
     *   create: {
     *     // ... data to create a UserToOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToOrganization we want to update
     *   }
     * })
     */
    upsert<T extends UserToOrganizationUpsertArgs>(args: SelectSubset<T, UserToOrganizationUpsertArgs<ExtArgs>>): Prisma__UserToOrganizationClient<$Result.GetResult<Prisma.$UserToOrganizationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserToOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationCountArgs} args - Arguments to filter UserToOrganizations to count.
     * @example
     * // Count the number of UserToOrganizations
     * const count = await prisma.userToOrganization.count({
     *   where: {
     *     // ... the filter for the UserToOrganizations we want to count
     *   }
     * })
    **/
    count<T extends UserToOrganizationCountArgs>(
      args?: Subset<T, UserToOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToOrganizationAggregateArgs>(args: Subset<T, UserToOrganizationAggregateArgs>): Prisma.PrismaPromise<GetUserToOrganizationAggregateType<T>>

    /**
     * Group by UserToOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: UserToOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToOrganization model
   */
  readonly fields: UserToOrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToOrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToOrganization model
   */ 
  interface UserToOrganizationFieldRefs {
    readonly id: FieldRef<"UserToOrganization", 'Int'>
    readonly createdAt: FieldRef<"UserToOrganization", 'DateTime'>
    readonly isAdmin: FieldRef<"UserToOrganization", 'Boolean'>
    readonly isDeleted: FieldRef<"UserToOrganization", 'Boolean'>
    readonly organizationId: FieldRef<"UserToOrganization", 'Int'>
    readonly role: FieldRef<"UserToOrganization", 'String'>
    readonly accessLevel: FieldRef<"UserToOrganization", 'AccessLevel'>
    readonly userId: FieldRef<"UserToOrganization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserToOrganization findUnique
   */
  export type UserToOrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where: UserToOrganizationWhereUniqueInput
  }

  /**
   * UserToOrganization findUniqueOrThrow
   */
  export type UserToOrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where: UserToOrganizationWhereUniqueInput
  }

  /**
   * UserToOrganization findFirst
   */
  export type UserToOrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: UserToOrganizationOrderByWithRelationInput | UserToOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToOrganizations.
     */
    distinct?: UserToOrganizationScalarFieldEnum | UserToOrganizationScalarFieldEnum[]
  }

  /**
   * UserToOrganization findFirstOrThrow
   */
  export type UserToOrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserToOrganization to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: UserToOrganizationOrderByWithRelationInput | UserToOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToOrganizations.
     */
    distinct?: UserToOrganizationScalarFieldEnum | UserToOrganizationScalarFieldEnum[]
  }

  /**
   * UserToOrganization findMany
   */
  export type UserToOrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserToOrganizations to fetch.
     */
    where?: UserToOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToOrganizations to fetch.
     */
    orderBy?: UserToOrganizationOrderByWithRelationInput | UserToOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToOrganizations.
     */
    cursor?: UserToOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToOrganizations.
     */
    skip?: number
    distinct?: UserToOrganizationScalarFieldEnum | UserToOrganizationScalarFieldEnum[]
  }

  /**
   * UserToOrganization create
   */
  export type UserToOrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToOrganization.
     */
    data: XOR<UserToOrganizationCreateInput, UserToOrganizationUncheckedCreateInput>
  }

  /**
   * UserToOrganization createMany
   */
  export type UserToOrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToOrganizations.
     */
    data: UserToOrganizationCreateManyInput | UserToOrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserToOrganization createManyAndReturn
   */
  export type UserToOrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many UserToOrganizations.
     */
    data: UserToOrganizationCreateManyInput | UserToOrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToOrganization update
   */
  export type UserToOrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToOrganization.
     */
    data: XOR<UserToOrganizationUpdateInput, UserToOrganizationUncheckedUpdateInput>
    /**
     * Choose, which UserToOrganization to update.
     */
    where: UserToOrganizationWhereUniqueInput
  }

  /**
   * UserToOrganization updateMany
   */
  export type UserToOrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToOrganizations.
     */
    data: XOR<UserToOrganizationUpdateManyMutationInput, UserToOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserToOrganizations to update
     */
    where?: UserToOrganizationWhereInput
  }

  /**
   * UserToOrganization updateManyAndReturn
   */
  export type UserToOrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * The data used to update UserToOrganizations.
     */
    data: XOR<UserToOrganizationUpdateManyMutationInput, UserToOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserToOrganizations to update
     */
    where?: UserToOrganizationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToOrganization upsert
   */
  export type UserToOrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToOrganization to update in case it exists.
     */
    where: UserToOrganizationWhereUniqueInput
    /**
     * In case the UserToOrganization found by the `where` argument doesn't exist, create a new UserToOrganization with this data.
     */
    create: XOR<UserToOrganizationCreateInput, UserToOrganizationUncheckedCreateInput>
    /**
     * In case the UserToOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToOrganizationUpdateInput, UserToOrganizationUncheckedUpdateInput>
  }

  /**
   * UserToOrganization delete
   */
  export type UserToOrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
    /**
     * Filter which UserToOrganization to delete.
     */
    where: UserToOrganizationWhereUniqueInput
  }

  /**
   * UserToOrganization deleteMany
   */
  export type UserToOrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToOrganizations to delete
     */
    where?: UserToOrganizationWhereInput
  }

  /**
   * UserToOrganization without action
   */
  export type UserToOrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToOrganization
     */
    select?: UserToOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToOrganization
     */
    omit?: UserToOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToOrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationInvitation
   */

  export type AggregateOrganizationInvitation = {
    _count: OrganizationInvitationCountAggregateOutputType | null
    _avg: OrganizationInvitationAvgAggregateOutputType | null
    _sum: OrganizationInvitationSumAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  export type OrganizationInvitationAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationInvitationSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type OrganizationInvitationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    email: string | null
    invitationId: string | null
    isAccepted: boolean | null
  }

  export type OrganizationInvitationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    email: string | null
    invitationId: string | null
    isAccepted: boolean | null
  }

  export type OrganizationInvitationCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    organizationId: number
    email: number
    invitationId: number
    isAccepted: number
    _all: number
  }


  export type OrganizationInvitationAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationInvitationSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type OrganizationInvitationMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
  }

  export type OrganizationInvitationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
  }

  export type OrganizationInvitationCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    organizationId?: true
    email?: true
    invitationId?: true
    isAccepted?: true
    _all?: true
  }

  export type OrganizationInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationInvitation to aggregate.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationInvitations
    **/
    _count?: true | OrganizationInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationInvitationMaxAggregateInputType
  }

  export type GetOrganizationInvitationAggregateType<T extends OrganizationInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
      : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
  }




  export type OrganizationInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationInvitationWhereInput
    orderBy?: OrganizationInvitationOrderByWithAggregationInput | OrganizationInvitationOrderByWithAggregationInput[]
    by: OrganizationInvitationScalarFieldEnum[] | OrganizationInvitationScalarFieldEnum
    having?: OrganizationInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationInvitationCountAggregateInputType | true
    _avg?: OrganizationInvitationAvgAggregateInputType
    _sum?: OrganizationInvitationSumAggregateInputType
    _min?: OrganizationInvitationMinAggregateInputType
    _max?: OrganizationInvitationMaxAggregateInputType
  }

  export type OrganizationInvitationGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted: boolean
    _count: OrganizationInvitationCountAggregateOutputType | null
    _avg: OrganizationInvitationAvgAggregateOutputType | null
    _sum: OrganizationInvitationSumAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  type GetOrganizationInvitationGroupByPayload<T extends OrganizationInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    email?: boolean
    invitationId?: boolean
    isAccepted?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    email?: boolean
    invitationId?: boolean
    isAccepted?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    email?: boolean
    invitationId?: boolean
    isAccepted?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    email?: boolean
    invitationId?: boolean
    isAccepted?: boolean
  }

  export type OrganizationInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "organizationId" | "email" | "invitationId" | "isAccepted", ExtArgs["result"]["organizationInvitation"]>
  export type OrganizationInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationInvitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      organizationId: number
      email: string
      invitationId: string
      isAccepted: boolean
    }, ExtArgs["result"]["organizationInvitation"]>
    composites: {}
  }

  type OrganizationInvitationGetPayload<S extends boolean | null | undefined | OrganizationInvitationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationInvitationPayload, S>

  type OrganizationInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationInvitationCountAggregateInputType | true
    }

  export interface OrganizationInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationInvitation'], meta: { name: 'OrganizationInvitation' } }
    /**
     * Find zero or one OrganizationInvitation that matches the filter.
     * @param {OrganizationInvitationFindUniqueArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationInvitationFindUniqueArgs>(args: SelectSubset<T, OrganizationInvitationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrganizationInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationInvitationFindUniqueOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrganizationInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationInvitationFindFirstArgs>(args?: SelectSubset<T, OrganizationInvitationFindFirstArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrganizationInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrganizationInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany()
     * 
     * // Get first 10 OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationInvitationFindManyArgs>(args?: SelectSubset<T, OrganizationInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrganizationInvitation.
     * @param {OrganizationInvitationCreateArgs} args - Arguments to create a OrganizationInvitation.
     * @example
     * // Create one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.create({
     *   data: {
     *     // ... data to create a OrganizationInvitation
     *   }
     * })
     * 
     */
    create<T extends OrganizationInvitationCreateArgs>(args: SelectSubset<T, OrganizationInvitationCreateArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrganizationInvitations.
     * @param {OrganizationInvitationCreateManyArgs} args - Arguments to create many OrganizationInvitations.
     * @example
     * // Create many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationInvitationCreateManyArgs>(args?: SelectSubset<T, OrganizationInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationInvitations and returns the data saved in the database.
     * @param {OrganizationInvitationCreateManyAndReturnArgs} args - Arguments to create many OrganizationInvitations.
     * @example
     * // Create many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationInvitations and only return the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a OrganizationInvitation.
     * @param {OrganizationInvitationDeleteArgs} args - Arguments to delete one OrganizationInvitation.
     * @example
     * // Delete one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.delete({
     *   where: {
     *     // ... filter to delete one OrganizationInvitation
     *   }
     * })
     * 
     */
    delete<T extends OrganizationInvitationDeleteArgs>(args: SelectSubset<T, OrganizationInvitationDeleteArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrganizationInvitation.
     * @param {OrganizationInvitationUpdateArgs} args - Arguments to update one OrganizationInvitation.
     * @example
     * // Update one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationInvitationUpdateArgs>(args: SelectSubset<T, OrganizationInvitationUpdateArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrganizationInvitations.
     * @param {OrganizationInvitationDeleteManyArgs} args - Arguments to filter OrganizationInvitations to delete.
     * @example
     * // Delete a few OrganizationInvitations
     * const { count } = await prisma.organizationInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationInvitationDeleteManyArgs>(args?: SelectSubset<T, OrganizationInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationInvitationUpdateManyArgs>(args: SelectSubset<T, OrganizationInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationInvitations and returns the data updated in the database.
     * @param {OrganizationInvitationUpdateManyAndReturnArgs} args - Arguments to update many OrganizationInvitations.
     * @example
     * // Update many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationInvitations and only return the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one OrganizationInvitation.
     * @param {OrganizationInvitationUpsertArgs} args - Arguments to update or create a OrganizationInvitation.
     * @example
     * // Update or create a OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.upsert({
     *   create: {
     *     // ... data to create a OrganizationInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationInvitation we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationInvitationUpsertArgs>(args: SelectSubset<T, OrganizationInvitationUpsertArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationCountArgs} args - Arguments to filter OrganizationInvitations to count.
     * @example
     * // Count the number of OrganizationInvitations
     * const count = await prisma.organizationInvitation.count({
     *   where: {
     *     // ... the filter for the OrganizationInvitations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationInvitationCountArgs>(
      args?: Subset<T, OrganizationInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationInvitationAggregateArgs>(args: Subset<T, OrganizationInvitationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationInvitationAggregateType<T>>

    /**
     * Group by OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationInvitationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationInvitation model
   */
  readonly fields: OrganizationInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationInvitation model
   */ 
  interface OrganizationInvitationFieldRefs {
    readonly id: FieldRef<"OrganizationInvitation", 'Int'>
    readonly createdAt: FieldRef<"OrganizationInvitation", 'DateTime'>
    readonly isDeleted: FieldRef<"OrganizationInvitation", 'Boolean'>
    readonly organizationId: FieldRef<"OrganizationInvitation", 'Int'>
    readonly email: FieldRef<"OrganizationInvitation", 'String'>
    readonly invitationId: FieldRef<"OrganizationInvitation", 'String'>
    readonly isAccepted: FieldRef<"OrganizationInvitation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationInvitation findUnique
   */
  export type OrganizationInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation findUniqueOrThrow
   */
  export type OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation findFirst
   */
  export type OrganizationInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation findFirstOrThrow
   */
  export type OrganizationInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation findMany
   */
  export type OrganizationInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitations to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation create
   */
  export type OrganizationInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
  }

  /**
   * OrganizationInvitation createMany
   */
  export type OrganizationInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationInvitations.
     */
    data: OrganizationInvitationCreateManyInput | OrganizationInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationInvitation createManyAndReturn
   */
  export type OrganizationInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationInvitations.
     */
    data: OrganizationInvitationCreateManyInput | OrganizationInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationInvitation update
   */
  export type OrganizationInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
    /**
     * Choose, which OrganizationInvitation to update.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation updateMany
   */
  export type OrganizationInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationInvitations.
     */
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationInvitations to update
     */
    where?: OrganizationInvitationWhereInput
  }

  /**
   * OrganizationInvitation updateManyAndReturn
   */
  export type OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationInvitations.
     */
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationInvitations to update
     */
    where?: OrganizationInvitationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationInvitation upsert
   */
  export type OrganizationInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationInvitation to update in case it exists.
     */
    where: OrganizationInvitationWhereUniqueInput
    /**
     * In case the OrganizationInvitation found by the `where` argument doesn't exist, create a new OrganizationInvitation with this data.
     */
    create: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
    /**
     * In case the OrganizationInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
  }

  /**
   * OrganizationInvitation delete
   */
  export type OrganizationInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter which OrganizationInvitation to delete.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation deleteMany
   */
  export type OrganizationInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationInvitations to delete
     */
    where?: OrganizationInvitationWhereInput
  }

  /**
   * OrganizationInvitation without action
   */
  export type OrganizationInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
  }


  /**
   * Model UserToProject
   */

  export type AggregateUserToProject = {
    _count: UserToProjectCountAggregateOutputType | null
    _avg: UserToProjectAvgAggregateOutputType | null
    _sum: UserToProjectSumAggregateOutputType | null
    _min: UserToProjectMinAggregateOutputType | null
    _max: UserToProjectMaxAggregateOutputType | null
  }

  export type UserToProjectAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type UserToProjectSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type UserToProjectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    projectId: number | null
  }

  export type UserToProjectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    projectId: number | null
  }

  export type UserToProjectCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    projectId: number
    _all: number
  }


  export type UserToProjectAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type UserToProjectSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type UserToProjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
  }

  export type UserToProjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
  }

  export type UserToProjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    projectId?: true
    _all?: true
  }

  export type UserToProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToProject to aggregate.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToProjects
    **/
    _count?: true | UserToProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToProjectMaxAggregateInputType
  }

  export type GetUserToProjectAggregateType<T extends UserToProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToProject[P]>
      : GetScalarType<T[P], AggregateUserToProject[P]>
  }




  export type UserToProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToProjectWhereInput
    orderBy?: UserToProjectOrderByWithAggregationInput | UserToProjectOrderByWithAggregationInput[]
    by: UserToProjectScalarFieldEnum[] | UserToProjectScalarFieldEnum
    having?: UserToProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToProjectCountAggregateInputType | true
    _avg?: UserToProjectAvgAggregateInputType
    _sum?: UserToProjectSumAggregateInputType
    _min?: UserToProjectMinAggregateInputType
    _max?: UserToProjectMaxAggregateInputType
  }

  export type UserToProjectGroupByOutputType = {
    id: number
    createdAt: Date
    userId: string
    projectId: number
    _count: UserToProjectCountAggregateOutputType | null
    _avg: UserToProjectAvgAggregateOutputType | null
    _sum: UserToProjectSumAggregateOutputType | null
    _min: UserToProjectMinAggregateOutputType | null
    _max: UserToProjectMaxAggregateOutputType | null
  }

  type GetUserToProjectGroupByPayload<T extends UserToProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToProjectGroupByOutputType[P]>
            : GetScalarType<T[P], UserToProjectGroupByOutputType[P]>
        }
      >
    >


  export type UserToProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToProject"]>

  export type UserToProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToProject"]>

  export type UserToProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToProject"]>

  export type UserToProjectSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    projectId?: boolean
  }

  export type UserToProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "projectId", ExtArgs["result"]["userToProject"]>
  export type UserToProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type UserToProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type UserToProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $UserToProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToProject"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      userId: string
      projectId: number
    }, ExtArgs["result"]["userToProject"]>
    composites: {}
  }

  type UserToProjectGetPayload<S extends boolean | null | undefined | UserToProjectDefaultArgs> = $Result.GetResult<Prisma.$UserToProjectPayload, S>

  type UserToProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToProjectCountAggregateInputType | true
    }

  export interface UserToProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToProject'], meta: { name: 'UserToProject' } }
    /**
     * Find zero or one UserToProject that matches the filter.
     * @param {UserToProjectFindUniqueArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToProjectFindUniqueArgs>(args: SelectSubset<T, UserToProjectFindUniqueArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserToProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToProjectFindUniqueOrThrowArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserToProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindFirstArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToProjectFindFirstArgs>(args?: SelectSubset<T, UserToProjectFindFirstArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserToProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindFirstOrThrowArgs} args - Arguments to find a UserToProject
     * @example
     * // Get one UserToProject
     * const userToProject = await prisma.userToProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserToProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToProjects
     * const userToProjects = await prisma.userToProject.findMany()
     * 
     * // Get first 10 UserToProjects
     * const userToProjects = await prisma.userToProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToProjectWithIdOnly = await prisma.userToProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToProjectFindManyArgs>(args?: SelectSubset<T, UserToProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserToProject.
     * @param {UserToProjectCreateArgs} args - Arguments to create a UserToProject.
     * @example
     * // Create one UserToProject
     * const UserToProject = await prisma.userToProject.create({
     *   data: {
     *     // ... data to create a UserToProject
     *   }
     * })
     * 
     */
    create<T extends UserToProjectCreateArgs>(args: SelectSubset<T, UserToProjectCreateArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserToProjects.
     * @param {UserToProjectCreateManyArgs} args - Arguments to create many UserToProjects.
     * @example
     * // Create many UserToProjects
     * const userToProject = await prisma.userToProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToProjectCreateManyArgs>(args?: SelectSubset<T, UserToProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserToProjects and returns the data saved in the database.
     * @param {UserToProjectCreateManyAndReturnArgs} args - Arguments to create many UserToProjects.
     * @example
     * // Create many UserToProjects
     * const userToProject = await prisma.userToProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserToProjects and only return the `id`
     * const userToProjectWithIdOnly = await prisma.userToProject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserToProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, UserToProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserToProject.
     * @param {UserToProjectDeleteArgs} args - Arguments to delete one UserToProject.
     * @example
     * // Delete one UserToProject
     * const UserToProject = await prisma.userToProject.delete({
     *   where: {
     *     // ... filter to delete one UserToProject
     *   }
     * })
     * 
     */
    delete<T extends UserToProjectDeleteArgs>(args: SelectSubset<T, UserToProjectDeleteArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserToProject.
     * @param {UserToProjectUpdateArgs} args - Arguments to update one UserToProject.
     * @example
     * // Update one UserToProject
     * const userToProject = await prisma.userToProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToProjectUpdateArgs>(args: SelectSubset<T, UserToProjectUpdateArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserToProjects.
     * @param {UserToProjectDeleteManyArgs} args - Arguments to filter UserToProjects to delete.
     * @example
     * // Delete a few UserToProjects
     * const { count } = await prisma.userToProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToProjectDeleteManyArgs>(args?: SelectSubset<T, UserToProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToProjects
     * const userToProject = await prisma.userToProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToProjectUpdateManyArgs>(args: SelectSubset<T, UserToProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToProjects and returns the data updated in the database.
     * @param {UserToProjectUpdateManyAndReturnArgs} args - Arguments to update many UserToProjects.
     * @example
     * // Update many UserToProjects
     * const userToProject = await prisma.userToProject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserToProjects and only return the `id`
     * const userToProjectWithIdOnly = await prisma.userToProject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserToProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, UserToProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserToProject.
     * @param {UserToProjectUpsertArgs} args - Arguments to update or create a UserToProject.
     * @example
     * // Update or create a UserToProject
     * const userToProject = await prisma.userToProject.upsert({
     *   create: {
     *     // ... data to create a UserToProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToProject we want to update
     *   }
     * })
     */
    upsert<T extends UserToProjectUpsertArgs>(args: SelectSubset<T, UserToProjectUpsertArgs<ExtArgs>>): Prisma__UserToProjectClient<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserToProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectCountArgs} args - Arguments to filter UserToProjects to count.
     * @example
     * // Count the number of UserToProjects
     * const count = await prisma.userToProject.count({
     *   where: {
     *     // ... the filter for the UserToProjects we want to count
     *   }
     * })
    **/
    count<T extends UserToProjectCountArgs>(
      args?: Subset<T, UserToProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToProjectAggregateArgs>(args: Subset<T, UserToProjectAggregateArgs>): Prisma.PrismaPromise<GetUserToProjectAggregateType<T>>

    /**
     * Group by UserToProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToProjectGroupByArgs['orderBy'] }
        : { orderBy?: UserToProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToProject model
   */
  readonly fields: UserToProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToProject model
   */ 
  interface UserToProjectFieldRefs {
    readonly id: FieldRef<"UserToProject", 'Int'>
    readonly createdAt: FieldRef<"UserToProject", 'DateTime'>
    readonly userId: FieldRef<"UserToProject", 'String'>
    readonly projectId: FieldRef<"UserToProject", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserToProject findUnique
   */
  export type UserToProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where: UserToProjectWhereUniqueInput
  }

  /**
   * UserToProject findUniqueOrThrow
   */
  export type UserToProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where: UserToProjectWhereUniqueInput
  }

  /**
   * UserToProject findFirst
   */
  export type UserToProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToProjects.
     */
    distinct?: UserToProjectScalarFieldEnum | UserToProjectScalarFieldEnum[]
  }

  /**
   * UserToProject findFirstOrThrow
   */
  export type UserToProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserToProject to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToProjects.
     */
    distinct?: UserToProjectScalarFieldEnum | UserToProjectScalarFieldEnum[]
  }

  /**
   * UserToProject findMany
   */
  export type UserToProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserToProjects to fetch.
     */
    where?: UserToProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToProjects to fetch.
     */
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToProjects.
     */
    cursor?: UserToProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToProjects.
     */
    skip?: number
    distinct?: UserToProjectScalarFieldEnum | UserToProjectScalarFieldEnum[]
  }

  /**
   * UserToProject create
   */
  export type UserToProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToProject.
     */
    data: XOR<UserToProjectCreateInput, UserToProjectUncheckedCreateInput>
  }

  /**
   * UserToProject createMany
   */
  export type UserToProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToProjects.
     */
    data: UserToProjectCreateManyInput | UserToProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserToProject createManyAndReturn
   */
  export type UserToProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * The data used to create many UserToProjects.
     */
    data: UserToProjectCreateManyInput | UserToProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToProject update
   */
  export type UserToProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToProject.
     */
    data: XOR<UserToProjectUpdateInput, UserToProjectUncheckedUpdateInput>
    /**
     * Choose, which UserToProject to update.
     */
    where: UserToProjectWhereUniqueInput
  }

  /**
   * UserToProject updateMany
   */
  export type UserToProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToProjects.
     */
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyInput>
    /**
     * Filter which UserToProjects to update
     */
    where?: UserToProjectWhereInput
  }

  /**
   * UserToProject updateManyAndReturn
   */
  export type UserToProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * The data used to update UserToProjects.
     */
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyInput>
    /**
     * Filter which UserToProjects to update
     */
    where?: UserToProjectWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToProject upsert
   */
  export type UserToProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToProject to update in case it exists.
     */
    where: UserToProjectWhereUniqueInput
    /**
     * In case the UserToProject found by the `where` argument doesn't exist, create a new UserToProject with this data.
     */
    create: XOR<UserToProjectCreateInput, UserToProjectUncheckedCreateInput>
    /**
     * In case the UserToProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToProjectUpdateInput, UserToProjectUncheckedUpdateInput>
  }

  /**
   * UserToProject delete
   */
  export type UserToProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    /**
     * Filter which UserToProject to delete.
     */
    where: UserToProjectWhereUniqueInput
  }

  /**
   * UserToProject deleteMany
   */
  export type UserToProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToProjects to delete
     */
    where?: UserToProjectWhereInput
  }

  /**
   * UserToProject without action
   */
  export type UserToProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    catCode: number | null
    rcvValue: number | null
    actualValue: number | null
    projectStatusValueId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    catCode: number | null
    rcvValue: number | null
    actualValue: number | null
    projectStatusValueId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    closedAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    assignmentNumber: string | null
    publicId: string | null
    name: string | null
    location: string | null
    clientName: string | null
    clientEmail: string | null
    clientPhoneNumber: string | null
    companyName: string | null
    managerName: string | null
    adjusterEmail: string | null
    adjusterName: string | null
    adjusterPhoneNumber: string | null
    insuranceCompanyName: string | null
    insuranceClaimId: string | null
    lossType: string | null
    catCode: number | null
    humidity: string | null
    lastTimeWeatherFetched: Date | null
    temperature: string | null
    wind: string | null
    lat: string | null
    lng: string | null
    forecast: string | null
    claimSummary: string | null
    rcvValue: number | null
    actualValue: number | null
    status: $Enums.ProjectStatus | null
    projectStatusValueId: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    closedAt: Date | null
    isDeleted: boolean | null
    organizationId: number | null
    assignmentNumber: string | null
    publicId: string | null
    name: string | null
    location: string | null
    clientName: string | null
    clientEmail: string | null
    clientPhoneNumber: string | null
    companyName: string | null
    managerName: string | null
    adjusterEmail: string | null
    adjusterName: string | null
    adjusterPhoneNumber: string | null
    insuranceCompanyName: string | null
    insuranceClaimId: string | null
    lossType: string | null
    catCode: number | null
    humidity: string | null
    lastTimeWeatherFetched: Date | null
    temperature: string | null
    wind: string | null
    lat: string | null
    lng: string | null
    forecast: string | null
    claimSummary: string | null
    rcvValue: number | null
    actualValue: number | null
    status: $Enums.ProjectStatus | null
    projectStatusValueId: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    createdAt: number
    closedAt: number
    isDeleted: number
    organizationId: number
    assignmentNumber: number
    publicId: number
    name: number
    location: number
    clientName: number
    clientEmail: number
    clientPhoneNumber: number
    companyName: number
    managerName: number
    adjusterEmail: number
    adjusterName: number
    adjusterPhoneNumber: number
    insuranceCompanyName: number
    insuranceClaimId: number
    lossType: number
    catCode: number
    humidity: number
    lastTimeWeatherFetched: number
    temperature: number
    wind: number
    lat: number
    lng: number
    forecast: number
    claimSummary: number
    roofSegments: number
    roofSpecs: number
    rcvValue: number
    actualValue: number
    status: number
    projectStatusValueId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    organizationId?: true
    catCode?: true
    rcvValue?: true
    actualValue?: true
    projectStatusValueId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    organizationId?: true
    catCode?: true
    rcvValue?: true
    actualValue?: true
    projectStatusValueId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    isDeleted?: true
    organizationId?: true
    assignmentNumber?: true
    publicId?: true
    name?: true
    location?: true
    clientName?: true
    clientEmail?: true
    clientPhoneNumber?: true
    companyName?: true
    managerName?: true
    adjusterEmail?: true
    adjusterName?: true
    adjusterPhoneNumber?: true
    insuranceCompanyName?: true
    insuranceClaimId?: true
    lossType?: true
    catCode?: true
    humidity?: true
    lastTimeWeatherFetched?: true
    temperature?: true
    wind?: true
    lat?: true
    lng?: true
    forecast?: true
    claimSummary?: true
    roofSegments?: true
    roofSpecs?: true
    rcvValue?: true
    actualValue?: true
    status?: true
    projectStatusValueId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    createdAt: Date
    closedAt: Date | null
    isDeleted: boolean
    organizationId: number
    assignmentNumber: string
    publicId: string
    name: string
    location: string
    clientName: string
    clientEmail: string
    clientPhoneNumber: string
    companyName: string
    managerName: string
    adjusterEmail: string
    adjusterName: string
    adjusterPhoneNumber: string
    insuranceCompanyName: string
    insuranceClaimId: string
    lossType: string
    catCode: number | null
    humidity: string
    lastTimeWeatherFetched: Date | null
    temperature: string
    wind: string
    lat: string
    lng: string
    forecast: string
    claimSummary: string
    roofSegments: JsonValue[]
    roofSpecs: JsonValue | null
    rcvValue: number | null
    actualValue: number | null
    status: $Enums.ProjectStatus | null
    projectStatusValueId: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    assignmentNumber?: boolean
    publicId?: boolean
    name?: boolean
    location?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientPhoneNumber?: boolean
    companyName?: boolean
    managerName?: boolean
    adjusterEmail?: boolean
    adjusterName?: boolean
    adjusterPhoneNumber?: boolean
    insuranceCompanyName?: boolean
    insuranceClaimId?: boolean
    lossType?: boolean
    catCode?: boolean
    humidity?: boolean
    lastTimeWeatherFetched?: boolean
    temperature?: boolean
    wind?: boolean
    lat?: boolean
    lng?: boolean
    forecast?: boolean
    claimSummary?: boolean
    roofSegments?: boolean
    roofSpecs?: boolean
    rcvValue?: boolean
    actualValue?: boolean
    status?: boolean
    projectStatusValueId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    images?: boolean | Project$imagesArgs<ExtArgs>
    inferences?: boolean | Project$inferencesArgs<ExtArgs>
    rooms?: boolean | Project$roomsArgs<ExtArgs>
    events?: boolean | Project$eventsArgs<ExtArgs>
    projectAssignees?: boolean | Project$projectAssigneesArgs<ExtArgs>
    roomReadings?: boolean | Project$roomReadingsArgs<ExtArgs>
    propertyData?: boolean | Project$propertyDataArgs<ExtArgs>
    AreaAffected?: boolean | Project$AreaAffectedArgs<ExtArgs>
    photoAccessLinks?: boolean | Project$photoAccessLinksArgs<ExtArgs>
    notes?: boolean | Project$notesArgs<ExtArgs>
    costs?: boolean | Project$costsArgs<ExtArgs>
    projectEquipment?: boolean | Project$projectEquipmentArgs<ExtArgs>
    weatherReportItems?: boolean | Project$weatherReportItemsArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
    PendingRoofReports?: boolean | Project$PendingRoofReportsArgs<ExtArgs>
    ProjectNotes?: boolean | Project$ProjectNotesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    assignmentNumber?: boolean
    publicId?: boolean
    name?: boolean
    location?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientPhoneNumber?: boolean
    companyName?: boolean
    managerName?: boolean
    adjusterEmail?: boolean
    adjusterName?: boolean
    adjusterPhoneNumber?: boolean
    insuranceCompanyName?: boolean
    insuranceClaimId?: boolean
    lossType?: boolean
    catCode?: boolean
    humidity?: boolean
    lastTimeWeatherFetched?: boolean
    temperature?: boolean
    wind?: boolean
    lat?: boolean
    lng?: boolean
    forecast?: boolean
    claimSummary?: boolean
    roofSegments?: boolean
    roofSpecs?: boolean
    rcvValue?: boolean
    actualValue?: boolean
    status?: boolean
    projectStatusValueId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    assignmentNumber?: boolean
    publicId?: boolean
    name?: boolean
    location?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientPhoneNumber?: boolean
    companyName?: boolean
    managerName?: boolean
    adjusterEmail?: boolean
    adjusterName?: boolean
    adjusterPhoneNumber?: boolean
    insuranceCompanyName?: boolean
    insuranceClaimId?: boolean
    lossType?: boolean
    catCode?: boolean
    humidity?: boolean
    lastTimeWeatherFetched?: boolean
    temperature?: boolean
    wind?: boolean
    lat?: boolean
    lng?: boolean
    forecast?: boolean
    claimSummary?: boolean
    roofSegments?: boolean
    roofSpecs?: boolean
    rcvValue?: boolean
    actualValue?: boolean
    status?: boolean
    projectStatusValueId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    isDeleted?: boolean
    organizationId?: boolean
    assignmentNumber?: boolean
    publicId?: boolean
    name?: boolean
    location?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientPhoneNumber?: boolean
    companyName?: boolean
    managerName?: boolean
    adjusterEmail?: boolean
    adjusterName?: boolean
    adjusterPhoneNumber?: boolean
    insuranceCompanyName?: boolean
    insuranceClaimId?: boolean
    lossType?: boolean
    catCode?: boolean
    humidity?: boolean
    lastTimeWeatherFetched?: boolean
    temperature?: boolean
    wind?: boolean
    lat?: boolean
    lng?: boolean
    forecast?: boolean
    claimSummary?: boolean
    roofSegments?: boolean
    roofSpecs?: boolean
    rcvValue?: boolean
    actualValue?: boolean
    status?: boolean
    projectStatusValueId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "closedAt" | "isDeleted" | "organizationId" | "assignmentNumber" | "publicId" | "name" | "location" | "clientName" | "clientEmail" | "clientPhoneNumber" | "companyName" | "managerName" | "adjusterEmail" | "adjusterName" | "adjusterPhoneNumber" | "insuranceCompanyName" | "insuranceClaimId" | "lossType" | "catCode" | "humidity" | "lastTimeWeatherFetched" | "temperature" | "wind" | "lat" | "lng" | "forecast" | "claimSummary" | "roofSegments" | "roofSpecs" | "rcvValue" | "actualValue" | "status" | "projectStatusValueId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    images?: boolean | Project$imagesArgs<ExtArgs>
    inferences?: boolean | Project$inferencesArgs<ExtArgs>
    rooms?: boolean | Project$roomsArgs<ExtArgs>
    events?: boolean | Project$eventsArgs<ExtArgs>
    projectAssignees?: boolean | Project$projectAssigneesArgs<ExtArgs>
    roomReadings?: boolean | Project$roomReadingsArgs<ExtArgs>
    propertyData?: boolean | Project$propertyDataArgs<ExtArgs>
    AreaAffected?: boolean | Project$AreaAffectedArgs<ExtArgs>
    photoAccessLinks?: boolean | Project$photoAccessLinksArgs<ExtArgs>
    notes?: boolean | Project$notesArgs<ExtArgs>
    costs?: boolean | Project$costsArgs<ExtArgs>
    projectEquipment?: boolean | Project$projectEquipmentArgs<ExtArgs>
    weatherReportItems?: boolean | Project$weatherReportItemsArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
    PendingRoofReports?: boolean | Project$PendingRoofReportsArgs<ExtArgs>
    ProjectNotes?: boolean | Project$ProjectNotesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    currentStatus?: boolean | Project$currentStatusArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      images: Prisma.$ImagePayload<ExtArgs>[]
      inferences: Prisma.$InferencePayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      events: Prisma.$CalendarEventPayload<ExtArgs>[]
      projectAssignees: Prisma.$UserToProjectPayload<ExtArgs>[]
      roomReadings: Prisma.$RoomReadingPayload<ExtArgs>[]
      propertyData: Prisma.$PropertyDataPayload<ExtArgs> | null
      AreaAffected: Prisma.$AreaAffectedPayload<ExtArgs>[]
      photoAccessLinks: Prisma.$PhotoAccessLinkPayload<ExtArgs>[]
      notes: Prisma.$NotesPayload<ExtArgs>[]
      costs: Prisma.$CostPayload<ExtArgs>[]
      projectEquipment: Prisma.$ProjectEquipmentPayload<ExtArgs>[]
      weatherReportItems: Prisma.$WeatherReportItemPayload<ExtArgs>[]
      currentStatus: Prisma.$ProjectStatusValuePayload<ExtArgs> | null
      PendingRoofReports: Prisma.$PendingRoofReportsPayload<ExtArgs>[]
      ProjectNotes: Prisma.$ProjectNotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      closedAt: Date | null
      isDeleted: boolean
      organizationId: number
      assignmentNumber: string
      publicId: string
      name: string
      location: string
      clientName: string
      clientEmail: string
      clientPhoneNumber: string
      companyName: string
      managerName: string
      adjusterEmail: string
      adjusterName: string
      adjusterPhoneNumber: string
      insuranceCompanyName: string
      insuranceClaimId: string
      lossType: string
      catCode: number | null
      humidity: string
      lastTimeWeatherFetched: Date | null
      temperature: string
      wind: string
      lat: string
      lng: string
      forecast: string
      claimSummary: string
      roofSegments: Prisma.JsonValue[]
      roofSpecs: Prisma.JsonValue | null
      rcvValue: number | null
      actualValue: number | null
      status: $Enums.ProjectStatus | null
      projectStatusValueId: number | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    images<T extends Project$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    inferences<T extends Project$inferencesArgs<ExtArgs> = {}>(args?: Subset<T, Project$inferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rooms<T extends Project$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Project$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends Project$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Project$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    projectAssignees<T extends Project$projectAssigneesArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectAssigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToProjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    roomReadings<T extends Project$roomReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Project$roomReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    propertyData<T extends Project$propertyDataArgs<ExtArgs> = {}>(args?: Subset<T, Project$propertyDataArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    AreaAffected<T extends Project$AreaAffectedArgs<ExtArgs> = {}>(args?: Subset<T, Project$AreaAffectedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    photoAccessLinks<T extends Project$photoAccessLinksArgs<ExtArgs> = {}>(args?: Subset<T, Project$photoAccessLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends Project$notesArgs<ExtArgs> = {}>(args?: Subset<T, Project$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    costs<T extends Project$costsArgs<ExtArgs> = {}>(args?: Subset<T, Project$costsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    projectEquipment<T extends Project$projectEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectEquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    weatherReportItems<T extends Project$weatherReportItemsArgs<ExtArgs> = {}>(args?: Subset<T, Project$weatherReportItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    currentStatus<T extends Project$currentStatusArgs<ExtArgs> = {}>(args?: Subset<T, Project$currentStatusArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    PendingRoofReports<T extends Project$PendingRoofReportsArgs<ExtArgs> = {}>(args?: Subset<T, Project$PendingRoofReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ProjectNotes<T extends Project$ProjectNotesArgs<ExtArgs> = {}>(args?: Subset<T, Project$ProjectNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly closedAt: FieldRef<"Project", 'DateTime'>
    readonly isDeleted: FieldRef<"Project", 'Boolean'>
    readonly organizationId: FieldRef<"Project", 'Int'>
    readonly assignmentNumber: FieldRef<"Project", 'String'>
    readonly publicId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly location: FieldRef<"Project", 'String'>
    readonly clientName: FieldRef<"Project", 'String'>
    readonly clientEmail: FieldRef<"Project", 'String'>
    readonly clientPhoneNumber: FieldRef<"Project", 'String'>
    readonly companyName: FieldRef<"Project", 'String'>
    readonly managerName: FieldRef<"Project", 'String'>
    readonly adjusterEmail: FieldRef<"Project", 'String'>
    readonly adjusterName: FieldRef<"Project", 'String'>
    readonly adjusterPhoneNumber: FieldRef<"Project", 'String'>
    readonly insuranceCompanyName: FieldRef<"Project", 'String'>
    readonly insuranceClaimId: FieldRef<"Project", 'String'>
    readonly lossType: FieldRef<"Project", 'String'>
    readonly catCode: FieldRef<"Project", 'Int'>
    readonly humidity: FieldRef<"Project", 'String'>
    readonly lastTimeWeatherFetched: FieldRef<"Project", 'DateTime'>
    readonly temperature: FieldRef<"Project", 'String'>
    readonly wind: FieldRef<"Project", 'String'>
    readonly lat: FieldRef<"Project", 'String'>
    readonly lng: FieldRef<"Project", 'String'>
    readonly forecast: FieldRef<"Project", 'String'>
    readonly claimSummary: FieldRef<"Project", 'String'>
    readonly roofSegments: FieldRef<"Project", 'Json[]'>
    readonly roofSpecs: FieldRef<"Project", 'Json'>
    readonly rcvValue: FieldRef<"Project", 'Float'>
    readonly actualValue: FieldRef<"Project", 'Float'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly projectStatusValueId: FieldRef<"Project", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.images
   */
  export type Project$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Project.inferences
   */
  export type Project$inferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    where?: InferenceWhereInput
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    cursor?: InferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InferenceScalarFieldEnum | InferenceScalarFieldEnum[]
  }

  /**
   * Project.rooms
   */
  export type Project$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Project.events
   */
  export type Project$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Project.projectAssignees
   */
  export type Project$projectAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToProject
     */
    select?: UserToProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToProject
     */
    omit?: UserToProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToProjectInclude<ExtArgs> | null
    where?: UserToProjectWhereInput
    orderBy?: UserToProjectOrderByWithRelationInput | UserToProjectOrderByWithRelationInput[]
    cursor?: UserToProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToProjectScalarFieldEnum | UserToProjectScalarFieldEnum[]
  }

  /**
   * Project.roomReadings
   */
  export type Project$roomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    where?: RoomReadingWhereInput
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    cursor?: RoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomReadingScalarFieldEnum | RoomReadingScalarFieldEnum[]
  }

  /**
   * Project.propertyData
   */
  export type Project$propertyDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    where?: PropertyDataWhereInput
  }

  /**
   * Project.AreaAffected
   */
  export type Project$AreaAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    where?: AreaAffectedWhereInput
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    cursor?: AreaAffectedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaAffectedScalarFieldEnum | AreaAffectedScalarFieldEnum[]
  }

  /**
   * Project.photoAccessLinks
   */
  export type Project$photoAccessLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    where?: PhotoAccessLinkWhereInput
    orderBy?: PhotoAccessLinkOrderByWithRelationInput | PhotoAccessLinkOrderByWithRelationInput[]
    cursor?: PhotoAccessLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoAccessLinkScalarFieldEnum | PhotoAccessLinkScalarFieldEnum[]
  }

  /**
   * Project.notes
   */
  export type Project$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Project.costs
   */
  export type Project$costsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    where?: CostWhereInput
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    cursor?: CostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Project.projectEquipment
   */
  export type Project$projectEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    where?: ProjectEquipmentWhereInput
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    cursor?: ProjectEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectEquipmentScalarFieldEnum | ProjectEquipmentScalarFieldEnum[]
  }

  /**
   * Project.weatherReportItems
   */
  export type Project$weatherReportItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    where?: WeatherReportItemWhereInput
    orderBy?: WeatherReportItemOrderByWithRelationInput | WeatherReportItemOrderByWithRelationInput[]
    cursor?: WeatherReportItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeatherReportItemScalarFieldEnum | WeatherReportItemScalarFieldEnum[]
  }

  /**
   * Project.currentStatus
   */
  export type Project$currentStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    where?: ProjectStatusValueWhereInput
  }

  /**
   * Project.PendingRoofReports
   */
  export type Project$PendingRoofReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    where?: PendingRoofReportsWhereInput
    orderBy?: PendingRoofReportsOrderByWithRelationInput | PendingRoofReportsOrderByWithRelationInput[]
    cursor?: PendingRoofReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingRoofReportsScalarFieldEnum | PendingRoofReportsScalarFieldEnum[]
  }

  /**
   * Project.ProjectNotes
   */
  export type Project$ProjectNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    where?: ProjectNotesWhereInput
    orderBy?: ProjectNotesOrderByWithRelationInput | ProjectNotesOrderByWithRelationInput[]
    cursor?: ProjectNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectNotesScalarFieldEnum | ProjectNotesScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectNotes
   */

  export type AggregateProjectNotes = {
    _count: ProjectNotesCountAggregateOutputType | null
    _avg: ProjectNotesAvgAggregateOutputType | null
    _sum: ProjectNotesSumAggregateOutputType | null
    _min: ProjectNotesMinAggregateOutputType | null
    _max: ProjectNotesMaxAggregateOutputType | null
  }

  export type ProjectNotesAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectNotesSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectNotesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
    userId: string | null
  }

  export type ProjectNotesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
    userId: string | null
  }

  export type ProjectNotesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    isDeleted: number
    publicId: number
    projectId: number
    body: number
    mentions: number
    userId: number
    _all: number
  }


  export type ProjectNotesAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectNotesSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectNotesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    userId?: true
  }

  export type ProjectNotesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    userId?: true
  }

  export type ProjectNotesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    mentions?: true
    userId?: true
    _all?: true
  }

  export type ProjectNotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotes to aggregate.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: ProjectNotesOrderByWithRelationInput | ProjectNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectNotes
    **/
    _count?: true | ProjectNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectNotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectNotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectNotesMaxAggregateInputType
  }

  export type GetProjectNotesAggregateType<T extends ProjectNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectNotes[P]>
      : GetScalarType<T[P], AggregateProjectNotes[P]>
  }




  export type ProjectNotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotesWhereInput
    orderBy?: ProjectNotesOrderByWithAggregationInput | ProjectNotesOrderByWithAggregationInput[]
    by: ProjectNotesScalarFieldEnum[] | ProjectNotesScalarFieldEnum
    having?: ProjectNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectNotesCountAggregateInputType | true
    _avg?: ProjectNotesAvgAggregateInputType
    _sum?: ProjectNotesSumAggregateInputType
    _min?: ProjectNotesMinAggregateInputType
    _max?: ProjectNotesMaxAggregateInputType
  }

  export type ProjectNotesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    date: Date
    isDeleted: boolean
    publicId: string
    projectId: number
    body: string
    mentions: string[]
    userId: string
    _count: ProjectNotesCountAggregateOutputType | null
    _avg: ProjectNotesAvgAggregateOutputType | null
    _sum: ProjectNotesSumAggregateOutputType | null
    _min: ProjectNotesMinAggregateOutputType | null
    _max: ProjectNotesMaxAggregateOutputType | null
  }

  type GetProjectNotesGroupByPayload<T extends ProjectNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectNotesGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectNotesGroupByOutputType[P]>
        }
      >
    >


  export type ProjectNotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectNotes"]>

  export type ProjectNotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectNotes"]>

  export type ProjectNotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectNotes"]>

  export type ProjectNotesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
  }

  export type ProjectNotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "date" | "isDeleted" | "publicId" | "projectId" | "body" | "mentions" | "userId", ExtArgs["result"]["projectNotes"]>
  export type ProjectNotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectNotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectNotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectNotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectNotes"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      date: Date
      isDeleted: boolean
      publicId: string
      projectId: number
      body: string
      mentions: string[]
      userId: string
    }, ExtArgs["result"]["projectNotes"]>
    composites: {}
  }

  type ProjectNotesGetPayload<S extends boolean | null | undefined | ProjectNotesDefaultArgs> = $Result.GetResult<Prisma.$ProjectNotesPayload, S>

  type ProjectNotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectNotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectNotesCountAggregateInputType | true
    }

  export interface ProjectNotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectNotes'], meta: { name: 'ProjectNotes' } }
    /**
     * Find zero or one ProjectNotes that matches the filter.
     * @param {ProjectNotesFindUniqueArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectNotesFindUniqueArgs>(args: SelectSubset<T, ProjectNotesFindUniqueArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProjectNotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectNotesFindUniqueOrThrowArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectNotesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectNotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindFirstArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectNotesFindFirstArgs>(args?: SelectSubset<T, ProjectNotesFindFirstArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectNotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindFirstOrThrowArgs} args - Arguments to find a ProjectNotes
     * @example
     * // Get one ProjectNotes
     * const projectNotes = await prisma.projectNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectNotesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectNotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProjectNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectNotes
     * const projectNotes = await prisma.projectNotes.findMany()
     * 
     * // Get first 10 ProjectNotes
     * const projectNotes = await prisma.projectNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectNotesWithIdOnly = await prisma.projectNotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectNotesFindManyArgs>(args?: SelectSubset<T, ProjectNotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProjectNotes.
     * @param {ProjectNotesCreateArgs} args - Arguments to create a ProjectNotes.
     * @example
     * // Create one ProjectNotes
     * const ProjectNotes = await prisma.projectNotes.create({
     *   data: {
     *     // ... data to create a ProjectNotes
     *   }
     * })
     * 
     */
    create<T extends ProjectNotesCreateArgs>(args: SelectSubset<T, ProjectNotesCreateArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProjectNotes.
     * @param {ProjectNotesCreateManyArgs} args - Arguments to create many ProjectNotes.
     * @example
     * // Create many ProjectNotes
     * const projectNotes = await prisma.projectNotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectNotesCreateManyArgs>(args?: SelectSubset<T, ProjectNotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectNotes and returns the data saved in the database.
     * @param {ProjectNotesCreateManyAndReturnArgs} args - Arguments to create many ProjectNotes.
     * @example
     * // Create many ProjectNotes
     * const projectNotes = await prisma.projectNotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectNotes and only return the `id`
     * const projectNotesWithIdOnly = await prisma.projectNotes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectNotesCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectNotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProjectNotes.
     * @param {ProjectNotesDeleteArgs} args - Arguments to delete one ProjectNotes.
     * @example
     * // Delete one ProjectNotes
     * const ProjectNotes = await prisma.projectNotes.delete({
     *   where: {
     *     // ... filter to delete one ProjectNotes
     *   }
     * })
     * 
     */
    delete<T extends ProjectNotesDeleteArgs>(args: SelectSubset<T, ProjectNotesDeleteArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProjectNotes.
     * @param {ProjectNotesUpdateArgs} args - Arguments to update one ProjectNotes.
     * @example
     * // Update one ProjectNotes
     * const projectNotes = await prisma.projectNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectNotesUpdateArgs>(args: SelectSubset<T, ProjectNotesUpdateArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProjectNotes.
     * @param {ProjectNotesDeleteManyArgs} args - Arguments to filter ProjectNotes to delete.
     * @example
     * // Delete a few ProjectNotes
     * const { count } = await prisma.projectNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectNotesDeleteManyArgs>(args?: SelectSubset<T, ProjectNotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectNotes
     * const projectNotes = await prisma.projectNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectNotesUpdateManyArgs>(args: SelectSubset<T, ProjectNotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectNotes and returns the data updated in the database.
     * @param {ProjectNotesUpdateManyAndReturnArgs} args - Arguments to update many ProjectNotes.
     * @example
     * // Update many ProjectNotes
     * const projectNotes = await prisma.projectNotes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectNotes and only return the `id`
     * const projectNotesWithIdOnly = await prisma.projectNotes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectNotesUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectNotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProjectNotes.
     * @param {ProjectNotesUpsertArgs} args - Arguments to update or create a ProjectNotes.
     * @example
     * // Update or create a ProjectNotes
     * const projectNotes = await prisma.projectNotes.upsert({
     *   create: {
     *     // ... data to create a ProjectNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectNotes we want to update
     *   }
     * })
     */
    upsert<T extends ProjectNotesUpsertArgs>(args: SelectSubset<T, ProjectNotesUpsertArgs<ExtArgs>>): Prisma__ProjectNotesClient<$Result.GetResult<Prisma.$ProjectNotesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesCountArgs} args - Arguments to filter ProjectNotes to count.
     * @example
     * // Count the number of ProjectNotes
     * const count = await prisma.projectNotes.count({
     *   where: {
     *     // ... the filter for the ProjectNotes we want to count
     *   }
     * })
    **/
    count<T extends ProjectNotesCountArgs>(
      args?: Subset<T, ProjectNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectNotesAggregateArgs>(args: Subset<T, ProjectNotesAggregateArgs>): Prisma.PrismaPromise<GetProjectNotesAggregateType<T>>

    /**
     * Group by ProjectNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectNotesGroupByArgs['orderBy'] }
        : { orderBy?: ProjectNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectNotes model
   */
  readonly fields: ProjectNotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectNotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectNotes model
   */ 
  interface ProjectNotesFieldRefs {
    readonly id: FieldRef<"ProjectNotes", 'Int'>
    readonly createdAt: FieldRef<"ProjectNotes", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectNotes", 'DateTime'>
    readonly date: FieldRef<"ProjectNotes", 'DateTime'>
    readonly isDeleted: FieldRef<"ProjectNotes", 'Boolean'>
    readonly publicId: FieldRef<"ProjectNotes", 'String'>
    readonly projectId: FieldRef<"ProjectNotes", 'Int'>
    readonly body: FieldRef<"ProjectNotes", 'String'>
    readonly mentions: FieldRef<"ProjectNotes", 'String[]'>
    readonly userId: FieldRef<"ProjectNotes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectNotes findUnique
   */
  export type ProjectNotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where: ProjectNotesWhereUniqueInput
  }

  /**
   * ProjectNotes findUniqueOrThrow
   */
  export type ProjectNotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where: ProjectNotesWhereUniqueInput
  }

  /**
   * ProjectNotes findFirst
   */
  export type ProjectNotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: ProjectNotesOrderByWithRelationInput | ProjectNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotes.
     */
    distinct?: ProjectNotesScalarFieldEnum | ProjectNotesScalarFieldEnum[]
  }

  /**
   * ProjectNotes findFirstOrThrow
   */
  export type ProjectNotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: ProjectNotesOrderByWithRelationInput | ProjectNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotes.
     */
    distinct?: ProjectNotesScalarFieldEnum | ProjectNotesScalarFieldEnum[]
  }

  /**
   * ProjectNotes findMany
   */
  export type ProjectNotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotes to fetch.
     */
    where?: ProjectNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotes to fetch.
     */
    orderBy?: ProjectNotesOrderByWithRelationInput | ProjectNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectNotes.
     */
    cursor?: ProjectNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotes.
     */
    skip?: number
    distinct?: ProjectNotesScalarFieldEnum | ProjectNotesScalarFieldEnum[]
  }

  /**
   * ProjectNotes create
   */
  export type ProjectNotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectNotes.
     */
    data: XOR<ProjectNotesCreateInput, ProjectNotesUncheckedCreateInput>
  }

  /**
   * ProjectNotes createMany
   */
  export type ProjectNotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectNotes.
     */
    data: ProjectNotesCreateManyInput | ProjectNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectNotes createManyAndReturn
   */
  export type ProjectNotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectNotes.
     */
    data: ProjectNotesCreateManyInput | ProjectNotesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectNotes update
   */
  export type ProjectNotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectNotes.
     */
    data: XOR<ProjectNotesUpdateInput, ProjectNotesUncheckedUpdateInput>
    /**
     * Choose, which ProjectNotes to update.
     */
    where: ProjectNotesWhereUniqueInput
  }

  /**
   * ProjectNotes updateMany
   */
  export type ProjectNotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectNotes.
     */
    data: XOR<ProjectNotesUpdateManyMutationInput, ProjectNotesUncheckedUpdateManyInput>
    /**
     * Filter which ProjectNotes to update
     */
    where?: ProjectNotesWhereInput
  }

  /**
   * ProjectNotes updateManyAndReturn
   */
  export type ProjectNotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * The data used to update ProjectNotes.
     */
    data: XOR<ProjectNotesUpdateManyMutationInput, ProjectNotesUncheckedUpdateManyInput>
    /**
     * Filter which ProjectNotes to update
     */
    where?: ProjectNotesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectNotes upsert
   */
  export type ProjectNotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectNotes to update in case it exists.
     */
    where: ProjectNotesWhereUniqueInput
    /**
     * In case the ProjectNotes found by the `where` argument doesn't exist, create a new ProjectNotes with this data.
     */
    create: XOR<ProjectNotesCreateInput, ProjectNotesUncheckedCreateInput>
    /**
     * In case the ProjectNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectNotesUpdateInput, ProjectNotesUncheckedUpdateInput>
  }

  /**
   * ProjectNotes delete
   */
  export type ProjectNotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
    /**
     * Filter which ProjectNotes to delete.
     */
    where: ProjectNotesWhereUniqueInput
  }

  /**
   * ProjectNotes deleteMany
   */
  export type ProjectNotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotes to delete
     */
    where?: ProjectNotesWhereInput
  }

  /**
   * ProjectNotes without action
   */
  export type ProjectNotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotes
     */
    select?: ProjectNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectNotes
     */
    omit?: ProjectNotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotesInclude<ExtArgs> | null
  }


  /**
   * Model ProjectStatusValue
   */

  export type AggregateProjectStatusValue = {
    _count: ProjectStatusValueCountAggregateOutputType | null
    _avg: ProjectStatusValueAvgAggregateOutputType | null
    _sum: ProjectStatusValueSumAggregateOutputType | null
    _min: ProjectStatusValueMinAggregateOutputType | null
    _max: ProjectStatusValueMaxAggregateOutputType | null
  }

  export type ProjectStatusValueAvgAggregateOutputType = {
    id: number | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueSumAggregateOutputType = {
    id: number | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    label: string | null
    description: string | null
    color: string | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    label: string | null
    description: string | null
    color: string | null
    order: number | null
    organizationId: number | null
  }

  export type ProjectStatusValueCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    label: number
    description: number
    color: number
    order: number
    organizationId: number
    _all: number
  }


  export type ProjectStatusValueAvgAggregateInputType = {
    id?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueSumAggregateInputType = {
    id?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
  }

  export type ProjectStatusValueCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    label?: true
    description?: true
    color?: true
    order?: true
    organizationId?: true
    _all?: true
  }

  export type ProjectStatusValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatusValue to aggregate.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: ProjectStatusValueOrderByWithRelationInput | ProjectStatusValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStatusValues
    **/
    _count?: true | ProjectStatusValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatusValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatusValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatusValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatusValueMaxAggregateInputType
  }

  export type GetProjectStatusValueAggregateType<T extends ProjectStatusValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStatusValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStatusValue[P]>
      : GetScalarType<T[P], AggregateProjectStatusValue[P]>
  }




  export type ProjectStatusValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatusValueWhereInput
    orderBy?: ProjectStatusValueOrderByWithAggregationInput | ProjectStatusValueOrderByWithAggregationInput[]
    by: ProjectStatusValueScalarFieldEnum[] | ProjectStatusValueScalarFieldEnum
    having?: ProjectStatusValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatusValueCountAggregateInputType | true
    _avg?: ProjectStatusValueAvgAggregateInputType
    _sum?: ProjectStatusValueSumAggregateInputType
    _min?: ProjectStatusValueMinAggregateInputType
    _max?: ProjectStatusValueMaxAggregateInputType
  }

  export type ProjectStatusValueGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    label: string
    description: string
    color: string
    order: number | null
    organizationId: number
    _count: ProjectStatusValueCountAggregateOutputType | null
    _avg: ProjectStatusValueAvgAggregateOutputType | null
    _sum: ProjectStatusValueSumAggregateOutputType | null
    _min: ProjectStatusValueMinAggregateOutputType | null
    _max: ProjectStatusValueMaxAggregateOutputType | null
  }

  type GetProjectStatusValueGroupByPayload<T extends ProjectStatusValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatusValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatusValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatusValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatusValueGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatusValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    label?: boolean
    description?: boolean
    color?: boolean
    order?: boolean
    organizationId?: boolean
    projects?: boolean | ProjectStatusValue$projectsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProjectStatusValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStatusValue"]>

  export type ProjectStatusValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    label?: boolean
    description?: boolean
    color?: boolean
    order?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStatusValue"]>

  export type ProjectStatusValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    label?: boolean
    description?: boolean
    color?: boolean
    order?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStatusValue"]>

  export type ProjectStatusValueSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    label?: boolean
    description?: boolean
    color?: boolean
    order?: boolean
    organizationId?: boolean
  }

  export type ProjectStatusValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "publicId" | "label" | "description" | "color" | "order" | "organizationId", ExtArgs["result"]["projectStatusValue"]>
  export type ProjectStatusValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectStatusValue$projectsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProjectStatusValueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectStatusValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ProjectStatusValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ProjectStatusValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStatusValue"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      publicId: string
      label: string
      description: string
      color: string
      order: number | null
      organizationId: number
    }, ExtArgs["result"]["projectStatusValue"]>
    composites: {}
  }

  type ProjectStatusValueGetPayload<S extends boolean | null | undefined | ProjectStatusValueDefaultArgs> = $Result.GetResult<Prisma.$ProjectStatusValuePayload, S>

  type ProjectStatusValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStatusValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStatusValueCountAggregateInputType | true
    }

  export interface ProjectStatusValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStatusValue'], meta: { name: 'ProjectStatusValue' } }
    /**
     * Find zero or one ProjectStatusValue that matches the filter.
     * @param {ProjectStatusValueFindUniqueArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatusValueFindUniqueArgs>(args: SelectSubset<T, ProjectStatusValueFindUniqueArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProjectStatusValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStatusValueFindUniqueOrThrowArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatusValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStatusValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectStatusValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindFirstArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatusValueFindFirstArgs>(args?: SelectSubset<T, ProjectStatusValueFindFirstArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectStatusValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindFirstOrThrowArgs} args - Arguments to find a ProjectStatusValue
     * @example
     * // Get one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatusValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStatusValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProjectStatusValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStatusValues
     * const projectStatusValues = await prisma.projectStatusValue.findMany()
     * 
     * // Get first 10 ProjectStatusValues
     * const projectStatusValues = await prisma.projectStatusValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatusValueWithIdOnly = await prisma.projectStatusValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStatusValueFindManyArgs>(args?: SelectSubset<T, ProjectStatusValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProjectStatusValue.
     * @param {ProjectStatusValueCreateArgs} args - Arguments to create a ProjectStatusValue.
     * @example
     * // Create one ProjectStatusValue
     * const ProjectStatusValue = await prisma.projectStatusValue.create({
     *   data: {
     *     // ... data to create a ProjectStatusValue
     *   }
     * })
     * 
     */
    create<T extends ProjectStatusValueCreateArgs>(args: SelectSubset<T, ProjectStatusValueCreateArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProjectStatusValues.
     * @param {ProjectStatusValueCreateManyArgs} args - Arguments to create many ProjectStatusValues.
     * @example
     * // Create many ProjectStatusValues
     * const projectStatusValue = await prisma.projectStatusValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStatusValueCreateManyArgs>(args?: SelectSubset<T, ProjectStatusValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectStatusValues and returns the data saved in the database.
     * @param {ProjectStatusValueCreateManyAndReturnArgs} args - Arguments to create many ProjectStatusValues.
     * @example
     * // Create many ProjectStatusValues
     * const projectStatusValue = await prisma.projectStatusValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectStatusValues and only return the `id`
     * const projectStatusValueWithIdOnly = await prisma.projectStatusValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectStatusValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectStatusValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProjectStatusValue.
     * @param {ProjectStatusValueDeleteArgs} args - Arguments to delete one ProjectStatusValue.
     * @example
     * // Delete one ProjectStatusValue
     * const ProjectStatusValue = await prisma.projectStatusValue.delete({
     *   where: {
     *     // ... filter to delete one ProjectStatusValue
     *   }
     * })
     * 
     */
    delete<T extends ProjectStatusValueDeleteArgs>(args: SelectSubset<T, ProjectStatusValueDeleteArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProjectStatusValue.
     * @param {ProjectStatusValueUpdateArgs} args - Arguments to update one ProjectStatusValue.
     * @example
     * // Update one ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStatusValueUpdateArgs>(args: SelectSubset<T, ProjectStatusValueUpdateArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProjectStatusValues.
     * @param {ProjectStatusValueDeleteManyArgs} args - Arguments to filter ProjectStatusValues to delete.
     * @example
     * // Delete a few ProjectStatusValues
     * const { count } = await prisma.projectStatusValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStatusValueDeleteManyArgs>(args?: SelectSubset<T, ProjectStatusValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStatusValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStatusValues
     * const projectStatusValue = await prisma.projectStatusValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStatusValueUpdateManyArgs>(args: SelectSubset<T, ProjectStatusValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStatusValues and returns the data updated in the database.
     * @param {ProjectStatusValueUpdateManyAndReturnArgs} args - Arguments to update many ProjectStatusValues.
     * @example
     * // Update many ProjectStatusValues
     * const projectStatusValue = await prisma.projectStatusValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectStatusValues and only return the `id`
     * const projectStatusValueWithIdOnly = await prisma.projectStatusValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectStatusValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectStatusValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProjectStatusValue.
     * @param {ProjectStatusValueUpsertArgs} args - Arguments to update or create a ProjectStatusValue.
     * @example
     * // Update or create a ProjectStatusValue
     * const projectStatusValue = await prisma.projectStatusValue.upsert({
     *   create: {
     *     // ... data to create a ProjectStatusValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStatusValue we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatusValueUpsertArgs>(args: SelectSubset<T, ProjectStatusValueUpsertArgs<ExtArgs>>): Prisma__ProjectStatusValueClient<$Result.GetResult<Prisma.$ProjectStatusValuePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProjectStatusValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueCountArgs} args - Arguments to filter ProjectStatusValues to count.
     * @example
     * // Count the number of ProjectStatusValues
     * const count = await prisma.projectStatusValue.count({
     *   where: {
     *     // ... the filter for the ProjectStatusValues we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatusValueCountArgs>(
      args?: Subset<T, ProjectStatusValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatusValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStatusValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatusValueAggregateArgs>(args: Subset<T, ProjectStatusValueAggregateArgs>): Prisma.PrismaPromise<GetProjectStatusValueAggregateType<T>>

    /**
     * Group by ProjectStatusValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatusValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatusValueGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatusValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatusValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatusValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStatusValue model
   */
  readonly fields: ProjectStatusValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStatusValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatusValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectStatusValue$projectsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectStatusValue$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStatusValue model
   */ 
  interface ProjectStatusValueFieldRefs {
    readonly id: FieldRef<"ProjectStatusValue", 'Int'>
    readonly createdAt: FieldRef<"ProjectStatusValue", 'DateTime'>
    readonly isDeleted: FieldRef<"ProjectStatusValue", 'Boolean'>
    readonly publicId: FieldRef<"ProjectStatusValue", 'String'>
    readonly label: FieldRef<"ProjectStatusValue", 'String'>
    readonly description: FieldRef<"ProjectStatusValue", 'String'>
    readonly color: FieldRef<"ProjectStatusValue", 'String'>
    readonly order: FieldRef<"ProjectStatusValue", 'Int'>
    readonly organizationId: FieldRef<"ProjectStatusValue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStatusValue findUnique
   */
  export type ProjectStatusValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where: ProjectStatusValueWhereUniqueInput
  }

  /**
   * ProjectStatusValue findUniqueOrThrow
   */
  export type ProjectStatusValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where: ProjectStatusValueWhereUniqueInput
  }

  /**
   * ProjectStatusValue findFirst
   */
  export type ProjectStatusValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: ProjectStatusValueOrderByWithRelationInput | ProjectStatusValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusValues.
     */
    distinct?: ProjectStatusValueScalarFieldEnum | ProjectStatusValueScalarFieldEnum[]
  }

  /**
   * ProjectStatusValue findFirstOrThrow
   */
  export type ProjectStatusValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatusValue to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: ProjectStatusValueOrderByWithRelationInput | ProjectStatusValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusValues.
     */
    distinct?: ProjectStatusValueScalarFieldEnum | ProjectStatusValueScalarFieldEnum[]
  }

  /**
   * ProjectStatusValue findMany
   */
  export type ProjectStatusValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatusValues to fetch.
     */
    where?: ProjectStatusValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusValues to fetch.
     */
    orderBy?: ProjectStatusValueOrderByWithRelationInput | ProjectStatusValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStatusValues.
     */
    cursor?: ProjectStatusValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusValues.
     */
    skip?: number
    distinct?: ProjectStatusValueScalarFieldEnum | ProjectStatusValueScalarFieldEnum[]
  }

  /**
   * ProjectStatusValue create
   */
  export type ProjectStatusValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectStatusValue.
     */
    data: XOR<ProjectStatusValueCreateInput, ProjectStatusValueUncheckedCreateInput>
  }

  /**
   * ProjectStatusValue createMany
   */
  export type ProjectStatusValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStatusValues.
     */
    data: ProjectStatusValueCreateManyInput | ProjectStatusValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectStatusValue createManyAndReturn
   */
  export type ProjectStatusValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectStatusValues.
     */
    data: ProjectStatusValueCreateManyInput | ProjectStatusValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectStatusValue update
   */
  export type ProjectStatusValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectStatusValue.
     */
    data: XOR<ProjectStatusValueUpdateInput, ProjectStatusValueUncheckedUpdateInput>
    /**
     * Choose, which ProjectStatusValue to update.
     */
    where: ProjectStatusValueWhereUniqueInput
  }

  /**
   * ProjectStatusValue updateMany
   */
  export type ProjectStatusValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStatusValues.
     */
    data: XOR<ProjectStatusValueUpdateManyMutationInput, ProjectStatusValueUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStatusValues to update
     */
    where?: ProjectStatusValueWhereInput
  }

  /**
   * ProjectStatusValue updateManyAndReturn
   */
  export type ProjectStatusValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * The data used to update ProjectStatusValues.
     */
    data: XOR<ProjectStatusValueUpdateManyMutationInput, ProjectStatusValueUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStatusValues to update
     */
    where?: ProjectStatusValueWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectStatusValue upsert
   */
  export type ProjectStatusValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectStatusValue to update in case it exists.
     */
    where: ProjectStatusValueWhereUniqueInput
    /**
     * In case the ProjectStatusValue found by the `where` argument doesn't exist, create a new ProjectStatusValue with this data.
     */
    create: XOR<ProjectStatusValueCreateInput, ProjectStatusValueUncheckedCreateInput>
    /**
     * In case the ProjectStatusValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatusValueUpdateInput, ProjectStatusValueUncheckedUpdateInput>
  }

  /**
   * ProjectStatusValue delete
   */
  export type ProjectStatusValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
    /**
     * Filter which ProjectStatusValue to delete.
     */
    where: ProjectStatusValueWhereUniqueInput
  }

  /**
   * ProjectStatusValue deleteMany
   */
  export type ProjectStatusValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatusValues to delete
     */
    where?: ProjectStatusValueWhereInput
  }

  /**
   * ProjectStatusValue.projects
   */
  export type ProjectStatusValue$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * ProjectStatusValue without action
   */
  export type ProjectStatusValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusValue
     */
    select?: ProjectStatusValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusValue
     */
    omit?: ProjectStatusValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusValueInclude<ExtArgs> | null
  }


  /**
   * Model PendingRoofReports
   */

  export type AggregatePendingRoofReports = {
    _count: PendingRoofReportsCountAggregateOutputType | null
    _avg: PendingRoofReportsAvgAggregateOutputType | null
    _sum: PendingRoofReportsSumAggregateOutputType | null
    _min: PendingRoofReportsMinAggregateOutputType | null
    _max: PendingRoofReportsMaxAggregateOutputType | null
  }

  export type PendingRoofReportsAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PendingRoofReportsSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PendingRoofReportsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    isCompleted: boolean | null
  }

  export type PendingRoofReportsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    isCompleted: boolean | null
  }

  export type PendingRoofReportsCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    projectId: number
    isCompleted: number
    _all: number
  }


  export type PendingRoofReportsAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PendingRoofReportsSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PendingRoofReportsMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
  }

  export type PendingRoofReportsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
  }

  export type PendingRoofReportsCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    isCompleted?: true
    _all?: true
  }

  export type PendingRoofReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingRoofReports to aggregate.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: PendingRoofReportsOrderByWithRelationInput | PendingRoofReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingRoofReports
    **/
    _count?: true | PendingRoofReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingRoofReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingRoofReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingRoofReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingRoofReportsMaxAggregateInputType
  }

  export type GetPendingRoofReportsAggregateType<T extends PendingRoofReportsAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingRoofReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingRoofReports[P]>
      : GetScalarType<T[P], AggregatePendingRoofReports[P]>
  }




  export type PendingRoofReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingRoofReportsWhereInput
    orderBy?: PendingRoofReportsOrderByWithAggregationInput | PendingRoofReportsOrderByWithAggregationInput[]
    by: PendingRoofReportsScalarFieldEnum[] | PendingRoofReportsScalarFieldEnum
    having?: PendingRoofReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingRoofReportsCountAggregateInputType | true
    _avg?: PendingRoofReportsAvgAggregateInputType
    _sum?: PendingRoofReportsSumAggregateInputType
    _min?: PendingRoofReportsMinAggregateInputType
    _max?: PendingRoofReportsMaxAggregateInputType
  }

  export type PendingRoofReportsGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    projectId: number
    isCompleted: boolean
    _count: PendingRoofReportsCountAggregateOutputType | null
    _avg: PendingRoofReportsAvgAggregateOutputType | null
    _sum: PendingRoofReportsSumAggregateOutputType | null
    _min: PendingRoofReportsMinAggregateOutputType | null
    _max: PendingRoofReportsMaxAggregateOutputType | null
  }

  type GetPendingRoofReportsGroupByPayload<T extends PendingRoofReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingRoofReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingRoofReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingRoofReportsGroupByOutputType[P]>
            : GetScalarType<T[P], PendingRoofReportsGroupByOutputType[P]>
        }
      >
    >


  export type PendingRoofReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    isCompleted?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingRoofReports"]>

  export type PendingRoofReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    isCompleted?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingRoofReports"]>

  export type PendingRoofReportsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    isCompleted?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingRoofReports"]>

  export type PendingRoofReportsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    isCompleted?: boolean
  }

  export type PendingRoofReportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "projectId" | "isCompleted", ExtArgs["result"]["pendingRoofReports"]>
  export type PendingRoofReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PendingRoofReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PendingRoofReportsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PendingRoofReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingRoofReports"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      projectId: number
      isCompleted: boolean
    }, ExtArgs["result"]["pendingRoofReports"]>
    composites: {}
  }

  type PendingRoofReportsGetPayload<S extends boolean | null | undefined | PendingRoofReportsDefaultArgs> = $Result.GetResult<Prisma.$PendingRoofReportsPayload, S>

  type PendingRoofReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingRoofReportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingRoofReportsCountAggregateInputType | true
    }

  export interface PendingRoofReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingRoofReports'], meta: { name: 'PendingRoofReports' } }
    /**
     * Find zero or one PendingRoofReports that matches the filter.
     * @param {PendingRoofReportsFindUniqueArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingRoofReportsFindUniqueArgs>(args: SelectSubset<T, PendingRoofReportsFindUniqueArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PendingRoofReports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingRoofReportsFindUniqueOrThrowArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingRoofReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingRoofReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PendingRoofReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindFirstArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingRoofReportsFindFirstArgs>(args?: SelectSubset<T, PendingRoofReportsFindFirstArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PendingRoofReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindFirstOrThrowArgs} args - Arguments to find a PendingRoofReports
     * @example
     * // Get one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingRoofReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingRoofReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PendingRoofReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findMany()
     * 
     * // Get first 10 PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingRoofReportsWithIdOnly = await prisma.pendingRoofReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingRoofReportsFindManyArgs>(args?: SelectSubset<T, PendingRoofReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PendingRoofReports.
     * @param {PendingRoofReportsCreateArgs} args - Arguments to create a PendingRoofReports.
     * @example
     * // Create one PendingRoofReports
     * const PendingRoofReports = await prisma.pendingRoofReports.create({
     *   data: {
     *     // ... data to create a PendingRoofReports
     *   }
     * })
     * 
     */
    create<T extends PendingRoofReportsCreateArgs>(args: SelectSubset<T, PendingRoofReportsCreateArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PendingRoofReports.
     * @param {PendingRoofReportsCreateManyArgs} args - Arguments to create many PendingRoofReports.
     * @example
     * // Create many PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingRoofReportsCreateManyArgs>(args?: SelectSubset<T, PendingRoofReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingRoofReports and returns the data saved in the database.
     * @param {PendingRoofReportsCreateManyAndReturnArgs} args - Arguments to create many PendingRoofReports.
     * @example
     * // Create many PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingRoofReports and only return the `id`
     * const pendingRoofReportsWithIdOnly = await prisma.pendingRoofReports.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingRoofReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingRoofReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PendingRoofReports.
     * @param {PendingRoofReportsDeleteArgs} args - Arguments to delete one PendingRoofReports.
     * @example
     * // Delete one PendingRoofReports
     * const PendingRoofReports = await prisma.pendingRoofReports.delete({
     *   where: {
     *     // ... filter to delete one PendingRoofReports
     *   }
     * })
     * 
     */
    delete<T extends PendingRoofReportsDeleteArgs>(args: SelectSubset<T, PendingRoofReportsDeleteArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PendingRoofReports.
     * @param {PendingRoofReportsUpdateArgs} args - Arguments to update one PendingRoofReports.
     * @example
     * // Update one PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingRoofReportsUpdateArgs>(args: SelectSubset<T, PendingRoofReportsUpdateArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PendingRoofReports.
     * @param {PendingRoofReportsDeleteManyArgs} args - Arguments to filter PendingRoofReports to delete.
     * @example
     * // Delete a few PendingRoofReports
     * const { count } = await prisma.pendingRoofReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingRoofReportsDeleteManyArgs>(args?: SelectSubset<T, PendingRoofReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingRoofReportsUpdateManyArgs>(args: SelectSubset<T, PendingRoofReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingRoofReports and returns the data updated in the database.
     * @param {PendingRoofReportsUpdateManyAndReturnArgs} args - Arguments to update many PendingRoofReports.
     * @example
     * // Update many PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingRoofReports and only return the `id`
     * const pendingRoofReportsWithIdOnly = await prisma.pendingRoofReports.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingRoofReportsUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingRoofReportsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PendingRoofReports.
     * @param {PendingRoofReportsUpsertArgs} args - Arguments to update or create a PendingRoofReports.
     * @example
     * // Update or create a PendingRoofReports
     * const pendingRoofReports = await prisma.pendingRoofReports.upsert({
     *   create: {
     *     // ... data to create a PendingRoofReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingRoofReports we want to update
     *   }
     * })
     */
    upsert<T extends PendingRoofReportsUpsertArgs>(args: SelectSubset<T, PendingRoofReportsUpsertArgs<ExtArgs>>): Prisma__PendingRoofReportsClient<$Result.GetResult<Prisma.$PendingRoofReportsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsCountArgs} args - Arguments to filter PendingRoofReports to count.
     * @example
     * // Count the number of PendingRoofReports
     * const count = await prisma.pendingRoofReports.count({
     *   where: {
     *     // ... the filter for the PendingRoofReports we want to count
     *   }
     * })
    **/
    count<T extends PendingRoofReportsCountArgs>(
      args?: Subset<T, PendingRoofReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingRoofReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingRoofReportsAggregateArgs>(args: Subset<T, PendingRoofReportsAggregateArgs>): Prisma.PrismaPromise<GetPendingRoofReportsAggregateType<T>>

    /**
     * Group by PendingRoofReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingRoofReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingRoofReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingRoofReportsGroupByArgs['orderBy'] }
        : { orderBy?: PendingRoofReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingRoofReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingRoofReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingRoofReports model
   */
  readonly fields: PendingRoofReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingRoofReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingRoofReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingRoofReports model
   */ 
  interface PendingRoofReportsFieldRefs {
    readonly id: FieldRef<"PendingRoofReports", 'Int'>
    readonly createdAt: FieldRef<"PendingRoofReports", 'DateTime'>
    readonly isDeleted: FieldRef<"PendingRoofReports", 'Boolean'>
    readonly projectId: FieldRef<"PendingRoofReports", 'Int'>
    readonly isCompleted: FieldRef<"PendingRoofReports", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PendingRoofReports findUnique
   */
  export type PendingRoofReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where: PendingRoofReportsWhereUniqueInput
  }

  /**
   * PendingRoofReports findUniqueOrThrow
   */
  export type PendingRoofReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where: PendingRoofReportsWhereUniqueInput
  }

  /**
   * PendingRoofReports findFirst
   */
  export type PendingRoofReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: PendingRoofReportsOrderByWithRelationInput | PendingRoofReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingRoofReports.
     */
    distinct?: PendingRoofReportsScalarFieldEnum | PendingRoofReportsScalarFieldEnum[]
  }

  /**
   * PendingRoofReports findFirstOrThrow
   */
  export type PendingRoofReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: PendingRoofReportsOrderByWithRelationInput | PendingRoofReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingRoofReports.
     */
    distinct?: PendingRoofReportsScalarFieldEnum | PendingRoofReportsScalarFieldEnum[]
  }

  /**
   * PendingRoofReports findMany
   */
  export type PendingRoofReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter, which PendingRoofReports to fetch.
     */
    where?: PendingRoofReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingRoofReports to fetch.
     */
    orderBy?: PendingRoofReportsOrderByWithRelationInput | PendingRoofReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingRoofReports.
     */
    cursor?: PendingRoofReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingRoofReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingRoofReports.
     */
    skip?: number
    distinct?: PendingRoofReportsScalarFieldEnum | PendingRoofReportsScalarFieldEnum[]
  }

  /**
   * PendingRoofReports create
   */
  export type PendingRoofReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingRoofReports.
     */
    data: XOR<PendingRoofReportsCreateInput, PendingRoofReportsUncheckedCreateInput>
  }

  /**
   * PendingRoofReports createMany
   */
  export type PendingRoofReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingRoofReports.
     */
    data: PendingRoofReportsCreateManyInput | PendingRoofReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingRoofReports createManyAndReturn
   */
  export type PendingRoofReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * The data used to create many PendingRoofReports.
     */
    data: PendingRoofReportsCreateManyInput | PendingRoofReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingRoofReports update
   */
  export type PendingRoofReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingRoofReports.
     */
    data: XOR<PendingRoofReportsUpdateInput, PendingRoofReportsUncheckedUpdateInput>
    /**
     * Choose, which PendingRoofReports to update.
     */
    where: PendingRoofReportsWhereUniqueInput
  }

  /**
   * PendingRoofReports updateMany
   */
  export type PendingRoofReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingRoofReports.
     */
    data: XOR<PendingRoofReportsUpdateManyMutationInput, PendingRoofReportsUncheckedUpdateManyInput>
    /**
     * Filter which PendingRoofReports to update
     */
    where?: PendingRoofReportsWhereInput
  }

  /**
   * PendingRoofReports updateManyAndReturn
   */
  export type PendingRoofReportsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * The data used to update PendingRoofReports.
     */
    data: XOR<PendingRoofReportsUpdateManyMutationInput, PendingRoofReportsUncheckedUpdateManyInput>
    /**
     * Filter which PendingRoofReports to update
     */
    where?: PendingRoofReportsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingRoofReports upsert
   */
  export type PendingRoofReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingRoofReports to update in case it exists.
     */
    where: PendingRoofReportsWhereUniqueInput
    /**
     * In case the PendingRoofReports found by the `where` argument doesn't exist, create a new PendingRoofReports with this data.
     */
    create: XOR<PendingRoofReportsCreateInput, PendingRoofReportsUncheckedCreateInput>
    /**
     * In case the PendingRoofReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingRoofReportsUpdateInput, PendingRoofReportsUncheckedUpdateInput>
  }

  /**
   * PendingRoofReports delete
   */
  export type PendingRoofReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
    /**
     * Filter which PendingRoofReports to delete.
     */
    where: PendingRoofReportsWhereUniqueInput
  }

  /**
   * PendingRoofReports deleteMany
   */
  export type PendingRoofReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingRoofReports to delete
     */
    where?: PendingRoofReportsWhereInput
  }

  /**
   * PendingRoofReports without action
   */
  export type PendingRoofReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingRoofReports
     */
    select?: PendingRoofReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingRoofReports
     */
    omit?: PendingRoofReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingRoofReportsInclude<ExtArgs> | null
  }


  /**
   * Model WeatherReportItem
   */

  export type AggregateWeatherReportItem = {
    _count: WeatherReportItemCountAggregateOutputType | null
    _avg: WeatherReportItemAvgAggregateOutputType | null
    _sum: WeatherReportItemSumAggregateOutputType | null
    _min: WeatherReportItemMinAggregateOutputType | null
    _max: WeatherReportItemMaxAggregateOutputType | null
  }

  export type WeatherReportItemAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type WeatherReportItemSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type WeatherReportItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    date: Date | null
    time: string | null
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string | null
    county: string | null
    state: string | null
    lat: string | null
    lon: string | null
    comments: string | null
  }

  export type WeatherReportItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    projectId: number | null
    date: Date | null
    time: string | null
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string | null
    county: string | null
    state: string | null
    lat: string | null
    lon: string | null
    comments: string | null
  }

  export type WeatherReportItemCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    projectId: number
    date: number
    time: number
    f_scale: number
    speed: number
    size: number
    location: number
    county: number
    state: number
    lat: number
    lon: number
    comments: number
    _all: number
  }


  export type WeatherReportItemAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type WeatherReportItemSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type WeatherReportItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
  }

  export type WeatherReportItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
  }

  export type WeatherReportItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    projectId?: true
    date?: true
    time?: true
    f_scale?: true
    speed?: true
    size?: true
    location?: true
    county?: true
    state?: true
    lat?: true
    lon?: true
    comments?: true
    _all?: true
  }

  export type WeatherReportItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherReportItem to aggregate.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: WeatherReportItemOrderByWithRelationInput | WeatherReportItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherReportItems
    **/
    _count?: true | WeatherReportItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherReportItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherReportItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherReportItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherReportItemMaxAggregateInputType
  }

  export type GetWeatherReportItemAggregateType<T extends WeatherReportItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherReportItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherReportItem[P]>
      : GetScalarType<T[P], AggregateWeatherReportItem[P]>
  }




  export type WeatherReportItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherReportItemWhereInput
    orderBy?: WeatherReportItemOrderByWithAggregationInput | WeatherReportItemOrderByWithAggregationInput[]
    by: WeatherReportItemScalarFieldEnum[] | WeatherReportItemScalarFieldEnum
    having?: WeatherReportItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherReportItemCountAggregateInputType | true
    _avg?: WeatherReportItemAvgAggregateInputType
    _sum?: WeatherReportItemSumAggregateInputType
    _min?: WeatherReportItemMinAggregateInputType
    _max?: WeatherReportItemMaxAggregateInputType
  }

  export type WeatherReportItemGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    projectId: number
    date: Date
    time: string
    f_scale: string | null
    speed: string | null
    size: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
    _count: WeatherReportItemCountAggregateOutputType | null
    _avg: WeatherReportItemAvgAggregateOutputType | null
    _sum: WeatherReportItemSumAggregateOutputType | null
    _min: WeatherReportItemMinAggregateOutputType | null
    _max: WeatherReportItemMaxAggregateOutputType | null
  }

  type GetWeatherReportItemGroupByPayload<T extends WeatherReportItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherReportItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherReportItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherReportItemGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherReportItemGroupByOutputType[P]>
        }
      >
    >


  export type WeatherReportItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    date?: boolean
    time?: boolean
    f_scale?: boolean
    speed?: boolean
    size?: boolean
    location?: boolean
    county?: boolean
    state?: boolean
    lat?: boolean
    lon?: boolean
    comments?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherReportItem"]>

  export type WeatherReportItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    date?: boolean
    time?: boolean
    f_scale?: boolean
    speed?: boolean
    size?: boolean
    location?: boolean
    county?: boolean
    state?: boolean
    lat?: boolean
    lon?: boolean
    comments?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherReportItem"]>

  export type WeatherReportItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    date?: boolean
    time?: boolean
    f_scale?: boolean
    speed?: boolean
    size?: boolean
    location?: boolean
    county?: boolean
    state?: boolean
    lat?: boolean
    lon?: boolean
    comments?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherReportItem"]>

  export type WeatherReportItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    projectId?: boolean
    date?: boolean
    time?: boolean
    f_scale?: boolean
    speed?: boolean
    size?: boolean
    location?: boolean
    county?: boolean
    state?: boolean
    lat?: boolean
    lon?: boolean
    comments?: boolean
  }

  export type WeatherReportItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "projectId" | "date" | "time" | "f_scale" | "speed" | "size" | "location" | "county" | "state" | "lat" | "lon" | "comments", ExtArgs["result"]["weatherReportItem"]>
  export type WeatherReportItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WeatherReportItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WeatherReportItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WeatherReportItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherReportItem"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      projectId: number
      date: Date
      time: string
      f_scale: string | null
      speed: string | null
      size: string | null
      location: string
      county: string
      state: string
      lat: string
      lon: string
      comments: string
    }, ExtArgs["result"]["weatherReportItem"]>
    composites: {}
  }

  type WeatherReportItemGetPayload<S extends boolean | null | undefined | WeatherReportItemDefaultArgs> = $Result.GetResult<Prisma.$WeatherReportItemPayload, S>

  type WeatherReportItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherReportItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherReportItemCountAggregateInputType | true
    }

  export interface WeatherReportItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherReportItem'], meta: { name: 'WeatherReportItem' } }
    /**
     * Find zero or one WeatherReportItem that matches the filter.
     * @param {WeatherReportItemFindUniqueArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherReportItemFindUniqueArgs>(args: SelectSubset<T, WeatherReportItemFindUniqueArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WeatherReportItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherReportItemFindUniqueOrThrowArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherReportItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherReportItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherReportItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindFirstArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherReportItemFindFirstArgs>(args?: SelectSubset<T, WeatherReportItemFindFirstArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WeatherReportItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindFirstOrThrowArgs} args - Arguments to find a WeatherReportItem
     * @example
     * // Get one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherReportItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherReportItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WeatherReportItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherReportItems
     * const weatherReportItems = await prisma.weatherReportItem.findMany()
     * 
     * // Get first 10 WeatherReportItems
     * const weatherReportItems = await prisma.weatherReportItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherReportItemWithIdOnly = await prisma.weatherReportItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherReportItemFindManyArgs>(args?: SelectSubset<T, WeatherReportItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WeatherReportItem.
     * @param {WeatherReportItemCreateArgs} args - Arguments to create a WeatherReportItem.
     * @example
     * // Create one WeatherReportItem
     * const WeatherReportItem = await prisma.weatherReportItem.create({
     *   data: {
     *     // ... data to create a WeatherReportItem
     *   }
     * })
     * 
     */
    create<T extends WeatherReportItemCreateArgs>(args: SelectSubset<T, WeatherReportItemCreateArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WeatherReportItems.
     * @param {WeatherReportItemCreateManyArgs} args - Arguments to create many WeatherReportItems.
     * @example
     * // Create many WeatherReportItems
     * const weatherReportItem = await prisma.weatherReportItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherReportItemCreateManyArgs>(args?: SelectSubset<T, WeatherReportItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeatherReportItems and returns the data saved in the database.
     * @param {WeatherReportItemCreateManyAndReturnArgs} args - Arguments to create many WeatherReportItems.
     * @example
     * // Create many WeatherReportItems
     * const weatherReportItem = await prisma.weatherReportItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeatherReportItems and only return the `id`
     * const weatherReportItemWithIdOnly = await prisma.weatherReportItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherReportItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherReportItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WeatherReportItem.
     * @param {WeatherReportItemDeleteArgs} args - Arguments to delete one WeatherReportItem.
     * @example
     * // Delete one WeatherReportItem
     * const WeatherReportItem = await prisma.weatherReportItem.delete({
     *   where: {
     *     // ... filter to delete one WeatherReportItem
     *   }
     * })
     * 
     */
    delete<T extends WeatherReportItemDeleteArgs>(args: SelectSubset<T, WeatherReportItemDeleteArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WeatherReportItem.
     * @param {WeatherReportItemUpdateArgs} args - Arguments to update one WeatherReportItem.
     * @example
     * // Update one WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherReportItemUpdateArgs>(args: SelectSubset<T, WeatherReportItemUpdateArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WeatherReportItems.
     * @param {WeatherReportItemDeleteManyArgs} args - Arguments to filter WeatherReportItems to delete.
     * @example
     * // Delete a few WeatherReportItems
     * const { count } = await prisma.weatherReportItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherReportItemDeleteManyArgs>(args?: SelectSubset<T, WeatherReportItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherReportItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherReportItems
     * const weatherReportItem = await prisma.weatherReportItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherReportItemUpdateManyArgs>(args: SelectSubset<T, WeatherReportItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherReportItems and returns the data updated in the database.
     * @param {WeatherReportItemUpdateManyAndReturnArgs} args - Arguments to update many WeatherReportItems.
     * @example
     * // Update many WeatherReportItems
     * const weatherReportItem = await prisma.weatherReportItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeatherReportItems and only return the `id`
     * const weatherReportItemWithIdOnly = await prisma.weatherReportItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherReportItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherReportItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WeatherReportItem.
     * @param {WeatherReportItemUpsertArgs} args - Arguments to update or create a WeatherReportItem.
     * @example
     * // Update or create a WeatherReportItem
     * const weatherReportItem = await prisma.weatherReportItem.upsert({
     *   create: {
     *     // ... data to create a WeatherReportItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherReportItem we want to update
     *   }
     * })
     */
    upsert<T extends WeatherReportItemUpsertArgs>(args: SelectSubset<T, WeatherReportItemUpsertArgs<ExtArgs>>): Prisma__WeatherReportItemClient<$Result.GetResult<Prisma.$WeatherReportItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WeatherReportItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemCountArgs} args - Arguments to filter WeatherReportItems to count.
     * @example
     * // Count the number of WeatherReportItems
     * const count = await prisma.weatherReportItem.count({
     *   where: {
     *     // ... the filter for the WeatherReportItems we want to count
     *   }
     * })
    **/
    count<T extends WeatherReportItemCountArgs>(
      args?: Subset<T, WeatherReportItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherReportItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherReportItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherReportItemAggregateArgs>(args: Subset<T, WeatherReportItemAggregateArgs>): Prisma.PrismaPromise<GetWeatherReportItemAggregateType<T>>

    /**
     * Group by WeatherReportItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherReportItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherReportItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherReportItemGroupByArgs['orderBy'] }
        : { orderBy?: WeatherReportItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherReportItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherReportItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherReportItem model
   */
  readonly fields: WeatherReportItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherReportItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherReportItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherReportItem model
   */ 
  interface WeatherReportItemFieldRefs {
    readonly id: FieldRef<"WeatherReportItem", 'Int'>
    readonly createdAt: FieldRef<"WeatherReportItem", 'DateTime'>
    readonly isDeleted: FieldRef<"WeatherReportItem", 'Boolean'>
    readonly projectId: FieldRef<"WeatherReportItem", 'Int'>
    readonly date: FieldRef<"WeatherReportItem", 'DateTime'>
    readonly time: FieldRef<"WeatherReportItem", 'String'>
    readonly f_scale: FieldRef<"WeatherReportItem", 'String'>
    readonly speed: FieldRef<"WeatherReportItem", 'String'>
    readonly size: FieldRef<"WeatherReportItem", 'String'>
    readonly location: FieldRef<"WeatherReportItem", 'String'>
    readonly county: FieldRef<"WeatherReportItem", 'String'>
    readonly state: FieldRef<"WeatherReportItem", 'String'>
    readonly lat: FieldRef<"WeatherReportItem", 'String'>
    readonly lon: FieldRef<"WeatherReportItem", 'String'>
    readonly comments: FieldRef<"WeatherReportItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeatherReportItem findUnique
   */
  export type WeatherReportItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where: WeatherReportItemWhereUniqueInput
  }

  /**
   * WeatherReportItem findUniqueOrThrow
   */
  export type WeatherReportItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where: WeatherReportItemWhereUniqueInput
  }

  /**
   * WeatherReportItem findFirst
   */
  export type WeatherReportItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: WeatherReportItemOrderByWithRelationInput | WeatherReportItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherReportItems.
     */
    distinct?: WeatherReportItemScalarFieldEnum | WeatherReportItemScalarFieldEnum[]
  }

  /**
   * WeatherReportItem findFirstOrThrow
   */
  export type WeatherReportItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter, which WeatherReportItem to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: WeatherReportItemOrderByWithRelationInput | WeatherReportItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherReportItems.
     */
    distinct?: WeatherReportItemScalarFieldEnum | WeatherReportItemScalarFieldEnum[]
  }

  /**
   * WeatherReportItem findMany
   */
  export type WeatherReportItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter, which WeatherReportItems to fetch.
     */
    where?: WeatherReportItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherReportItems to fetch.
     */
    orderBy?: WeatherReportItemOrderByWithRelationInput | WeatherReportItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherReportItems.
     */
    cursor?: WeatherReportItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherReportItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherReportItems.
     */
    skip?: number
    distinct?: WeatherReportItemScalarFieldEnum | WeatherReportItemScalarFieldEnum[]
  }

  /**
   * WeatherReportItem create
   */
  export type WeatherReportItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WeatherReportItem.
     */
    data: XOR<WeatherReportItemCreateInput, WeatherReportItemUncheckedCreateInput>
  }

  /**
   * WeatherReportItem createMany
   */
  export type WeatherReportItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherReportItems.
     */
    data: WeatherReportItemCreateManyInput | WeatherReportItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherReportItem createManyAndReturn
   */
  export type WeatherReportItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * The data used to create many WeatherReportItems.
     */
    data: WeatherReportItemCreateManyInput | WeatherReportItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeatherReportItem update
   */
  export type WeatherReportItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WeatherReportItem.
     */
    data: XOR<WeatherReportItemUpdateInput, WeatherReportItemUncheckedUpdateInput>
    /**
     * Choose, which WeatherReportItem to update.
     */
    where: WeatherReportItemWhereUniqueInput
  }

  /**
   * WeatherReportItem updateMany
   */
  export type WeatherReportItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherReportItems.
     */
    data: XOR<WeatherReportItemUpdateManyMutationInput, WeatherReportItemUncheckedUpdateManyInput>
    /**
     * Filter which WeatherReportItems to update
     */
    where?: WeatherReportItemWhereInput
  }

  /**
   * WeatherReportItem updateManyAndReturn
   */
  export type WeatherReportItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * The data used to update WeatherReportItems.
     */
    data: XOR<WeatherReportItemUpdateManyMutationInput, WeatherReportItemUncheckedUpdateManyInput>
    /**
     * Filter which WeatherReportItems to update
     */
    where?: WeatherReportItemWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeatherReportItem upsert
   */
  export type WeatherReportItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WeatherReportItem to update in case it exists.
     */
    where: WeatherReportItemWhereUniqueInput
    /**
     * In case the WeatherReportItem found by the `where` argument doesn't exist, create a new WeatherReportItem with this data.
     */
    create: XOR<WeatherReportItemCreateInput, WeatherReportItemUncheckedCreateInput>
    /**
     * In case the WeatherReportItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherReportItemUpdateInput, WeatherReportItemUncheckedUpdateInput>
  }

  /**
   * WeatherReportItem delete
   */
  export type WeatherReportItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
    /**
     * Filter which WeatherReportItem to delete.
     */
    where: WeatherReportItemWhereUniqueInput
  }

  /**
   * WeatherReportItem deleteMany
   */
  export type WeatherReportItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherReportItems to delete
     */
    where?: WeatherReportItemWhereInput
  }

  /**
   * WeatherReportItem without action
   */
  export type WeatherReportItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherReportItem
     */
    select?: WeatherReportItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherReportItem
     */
    omit?: WeatherReportItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherReportItemInclude<ExtArgs> | null
  }


  /**
   * Model ProjectEquipment
   */

  export type AggregateProjectEquipment = {
    _count: ProjectEquipmentCountAggregateOutputType | null
    _avg: ProjectEquipmentAvgAggregateOutputType | null
    _sum: ProjectEquipmentSumAggregateOutputType | null
    _min: ProjectEquipmentMinAggregateOutputType | null
    _max: ProjectEquipmentMaxAggregateOutputType | null
  }

  export type ProjectEquipmentAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    isDeleted: boolean | null
    quantity: number | null
    projectId: number | null
    equipmentId: number | null
  }

  export type ProjectEquipmentCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    isDeleted: number
    quantity: number
    projectId: number
    equipmentId: number
    _all: number
  }


  export type ProjectEquipmentAvgAggregateInputType = {
    id?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentSumAggregateInputType = {
    id?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
  }

  export type ProjectEquipmentCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    isDeleted?: true
    quantity?: true
    projectId?: true
    equipmentId?: true
    _all?: true
  }

  export type ProjectEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectEquipment to aggregate.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectEquipments
    **/
    _count?: true | ProjectEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectEquipmentMaxAggregateInputType
  }

  export type GetProjectEquipmentAggregateType<T extends ProjectEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectEquipment[P]>
      : GetScalarType<T[P], AggregateProjectEquipment[P]>
  }




  export type ProjectEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEquipmentWhereInput
    orderBy?: ProjectEquipmentOrderByWithAggregationInput | ProjectEquipmentOrderByWithAggregationInput[]
    by: ProjectEquipmentScalarFieldEnum[] | ProjectEquipmentScalarFieldEnum
    having?: ProjectEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectEquipmentCountAggregateInputType | true
    _avg?: ProjectEquipmentAvgAggregateInputType
    _sum?: ProjectEquipmentSumAggregateInputType
    _min?: ProjectEquipmentMinAggregateInputType
    _max?: ProjectEquipmentMaxAggregateInputType
  }

  export type ProjectEquipmentGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    isDeleted: boolean
    quantity: number
    projectId: number
    equipmentId: number
    _count: ProjectEquipmentCountAggregateOutputType | null
    _avg: ProjectEquipmentAvgAggregateOutputType | null
    _sum: ProjectEquipmentSumAggregateOutputType | null
    _min: ProjectEquipmentMinAggregateOutputType | null
    _max: ProjectEquipmentMaxAggregateOutputType | null
  }

  type GetProjectEquipmentGroupByPayload<T extends ProjectEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    quantity?: boolean
    projectId?: boolean
    equipmentId?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEquipment"]>

  export type ProjectEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    quantity?: boolean
    projectId?: boolean
    equipmentId?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEquipment"]>

  export type ProjectEquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    quantity?: boolean
    projectId?: boolean
    equipmentId?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEquipment"]>

  export type ProjectEquipmentSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    quantity?: boolean
    projectId?: boolean
    equipmentId?: boolean
  }

  export type ProjectEquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "isDeleted" | "quantity" | "projectId" | "equipmentId", ExtArgs["result"]["projectEquipment"]>
  export type ProjectEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectEquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectEquipment"
    objects: {
      equipment: Prisma.$EquipmentPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      isDeleted: boolean
      quantity: number
      projectId: number
      equipmentId: number
    }, ExtArgs["result"]["projectEquipment"]>
    composites: {}
  }

  type ProjectEquipmentGetPayload<S extends boolean | null | undefined | ProjectEquipmentDefaultArgs> = $Result.GetResult<Prisma.$ProjectEquipmentPayload, S>

  type ProjectEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectEquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectEquipmentCountAggregateInputType | true
    }

  export interface ProjectEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectEquipment'], meta: { name: 'ProjectEquipment' } }
    /**
     * Find zero or one ProjectEquipment that matches the filter.
     * @param {ProjectEquipmentFindUniqueArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectEquipmentFindUniqueArgs>(args: SelectSubset<T, ProjectEquipmentFindUniqueArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProjectEquipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectEquipmentFindUniqueOrThrowArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindFirstArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectEquipmentFindFirstArgs>(args?: SelectSubset<T, ProjectEquipmentFindFirstArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProjectEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindFirstOrThrowArgs} args - Arguments to find a ProjectEquipment
     * @example
     * // Get one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProjectEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectEquipments
     * const projectEquipments = await prisma.projectEquipment.findMany()
     * 
     * // Get first 10 ProjectEquipments
     * const projectEquipments = await prisma.projectEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectEquipmentWithIdOnly = await prisma.projectEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectEquipmentFindManyArgs>(args?: SelectSubset<T, ProjectEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProjectEquipment.
     * @param {ProjectEquipmentCreateArgs} args - Arguments to create a ProjectEquipment.
     * @example
     * // Create one ProjectEquipment
     * const ProjectEquipment = await prisma.projectEquipment.create({
     *   data: {
     *     // ... data to create a ProjectEquipment
     *   }
     * })
     * 
     */
    create<T extends ProjectEquipmentCreateArgs>(args: SelectSubset<T, ProjectEquipmentCreateArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProjectEquipments.
     * @param {ProjectEquipmentCreateManyArgs} args - Arguments to create many ProjectEquipments.
     * @example
     * // Create many ProjectEquipments
     * const projectEquipment = await prisma.projectEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectEquipmentCreateManyArgs>(args?: SelectSubset<T, ProjectEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectEquipments and returns the data saved in the database.
     * @param {ProjectEquipmentCreateManyAndReturnArgs} args - Arguments to create many ProjectEquipments.
     * @example
     * // Create many ProjectEquipments
     * const projectEquipment = await prisma.projectEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectEquipments and only return the `id`
     * const projectEquipmentWithIdOnly = await prisma.projectEquipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProjectEquipment.
     * @param {ProjectEquipmentDeleteArgs} args - Arguments to delete one ProjectEquipment.
     * @example
     * // Delete one ProjectEquipment
     * const ProjectEquipment = await prisma.projectEquipment.delete({
     *   where: {
     *     // ... filter to delete one ProjectEquipment
     *   }
     * })
     * 
     */
    delete<T extends ProjectEquipmentDeleteArgs>(args: SelectSubset<T, ProjectEquipmentDeleteArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProjectEquipment.
     * @param {ProjectEquipmentUpdateArgs} args - Arguments to update one ProjectEquipment.
     * @example
     * // Update one ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectEquipmentUpdateArgs>(args: SelectSubset<T, ProjectEquipmentUpdateArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProjectEquipments.
     * @param {ProjectEquipmentDeleteManyArgs} args - Arguments to filter ProjectEquipments to delete.
     * @example
     * // Delete a few ProjectEquipments
     * const { count } = await prisma.projectEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectEquipmentDeleteManyArgs>(args?: SelectSubset<T, ProjectEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectEquipments
     * const projectEquipment = await prisma.projectEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectEquipmentUpdateManyArgs>(args: SelectSubset<T, ProjectEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectEquipments and returns the data updated in the database.
     * @param {ProjectEquipmentUpdateManyAndReturnArgs} args - Arguments to update many ProjectEquipments.
     * @example
     * // Update many ProjectEquipments
     * const projectEquipment = await prisma.projectEquipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectEquipments and only return the `id`
     * const projectEquipmentWithIdOnly = await prisma.projectEquipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectEquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectEquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProjectEquipment.
     * @param {ProjectEquipmentUpsertArgs} args - Arguments to update or create a ProjectEquipment.
     * @example
     * // Update or create a ProjectEquipment
     * const projectEquipment = await prisma.projectEquipment.upsert({
     *   create: {
     *     // ... data to create a ProjectEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectEquipment we want to update
     *   }
     * })
     */
    upsert<T extends ProjectEquipmentUpsertArgs>(args: SelectSubset<T, ProjectEquipmentUpsertArgs<ExtArgs>>): Prisma__ProjectEquipmentClient<$Result.GetResult<Prisma.$ProjectEquipmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProjectEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentCountArgs} args - Arguments to filter ProjectEquipments to count.
     * @example
     * // Count the number of ProjectEquipments
     * const count = await prisma.projectEquipment.count({
     *   where: {
     *     // ... the filter for the ProjectEquipments we want to count
     *   }
     * })
    **/
    count<T extends ProjectEquipmentCountArgs>(
      args?: Subset<T, ProjectEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectEquipmentAggregateArgs>(args: Subset<T, ProjectEquipmentAggregateArgs>): Prisma.PrismaPromise<GetProjectEquipmentAggregateType<T>>

    /**
     * Group by ProjectEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectEquipment model
   */
  readonly fields: ProjectEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectEquipment model
   */ 
  interface ProjectEquipmentFieldRefs {
    readonly id: FieldRef<"ProjectEquipment", 'Int'>
    readonly publicId: FieldRef<"ProjectEquipment", 'String'>
    readonly createdAt: FieldRef<"ProjectEquipment", 'DateTime'>
    readonly isDeleted: FieldRef<"ProjectEquipment", 'Boolean'>
    readonly quantity: FieldRef<"ProjectEquipment", 'Int'>
    readonly projectId: FieldRef<"ProjectEquipment", 'Int'>
    readonly equipmentId: FieldRef<"ProjectEquipment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectEquipment findUnique
   */
  export type ProjectEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where: ProjectEquipmentWhereUniqueInput
  }

  /**
   * ProjectEquipment findUniqueOrThrow
   */
  export type ProjectEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where: ProjectEquipmentWhereUniqueInput
  }

  /**
   * ProjectEquipment findFirst
   */
  export type ProjectEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEquipments.
     */
    distinct?: ProjectEquipmentScalarFieldEnum | ProjectEquipmentScalarFieldEnum[]
  }

  /**
   * ProjectEquipment findFirstOrThrow
   */
  export type ProjectEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEquipment to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEquipments.
     */
    distinct?: ProjectEquipmentScalarFieldEnum | ProjectEquipmentScalarFieldEnum[]
  }

  /**
   * ProjectEquipment findMany
   */
  export type ProjectEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEquipments to fetch.
     */
    where?: ProjectEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEquipments to fetch.
     */
    orderBy?: ProjectEquipmentOrderByWithRelationInput | ProjectEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectEquipments.
     */
    cursor?: ProjectEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEquipments.
     */
    skip?: number
    distinct?: ProjectEquipmentScalarFieldEnum | ProjectEquipmentScalarFieldEnum[]
  }

  /**
   * ProjectEquipment create
   */
  export type ProjectEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectEquipment.
     */
    data: XOR<ProjectEquipmentCreateInput, ProjectEquipmentUncheckedCreateInput>
  }

  /**
   * ProjectEquipment createMany
   */
  export type ProjectEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectEquipments.
     */
    data: ProjectEquipmentCreateManyInput | ProjectEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectEquipment createManyAndReturn
   */
  export type ProjectEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectEquipments.
     */
    data: ProjectEquipmentCreateManyInput | ProjectEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectEquipment update
   */
  export type ProjectEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectEquipment.
     */
    data: XOR<ProjectEquipmentUpdateInput, ProjectEquipmentUncheckedUpdateInput>
    /**
     * Choose, which ProjectEquipment to update.
     */
    where: ProjectEquipmentWhereUniqueInput
  }

  /**
   * ProjectEquipment updateMany
   */
  export type ProjectEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectEquipments.
     */
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectEquipments to update
     */
    where?: ProjectEquipmentWhereInput
  }

  /**
   * ProjectEquipment updateManyAndReturn
   */
  export type ProjectEquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * The data used to update ProjectEquipments.
     */
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectEquipments to update
     */
    where?: ProjectEquipmentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectEquipment upsert
   */
  export type ProjectEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectEquipment to update in case it exists.
     */
    where: ProjectEquipmentWhereUniqueInput
    /**
     * In case the ProjectEquipment found by the `where` argument doesn't exist, create a new ProjectEquipment with this data.
     */
    create: XOR<ProjectEquipmentCreateInput, ProjectEquipmentUncheckedCreateInput>
    /**
     * In case the ProjectEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectEquipmentUpdateInput, ProjectEquipmentUncheckedUpdateInput>
  }

  /**
   * ProjectEquipment delete
   */
  export type ProjectEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
    /**
     * Filter which ProjectEquipment to delete.
     */
    where: ProjectEquipmentWhereUniqueInput
  }

  /**
   * ProjectEquipment deleteMany
   */
  export type ProjectEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectEquipments to delete
     */
    where?: ProjectEquipmentWhereInput
  }

  /**
   * ProjectEquipment without action
   */
  export type ProjectEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEquipment
     */
    select?: ProjectEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEquipment
     */
    omit?: ProjectEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Cost
   */

  export type AggregateCost = {
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  export type CostAvgAggregateOutputType = {
    id: number | null
    estimatedCost: number | null
    actualCost: number | null
    projectId: number | null
  }

  export type CostSumAggregateOutputType = {
    id: number | null
    estimatedCost: number | null
    actualCost: number | null
    projectId: number | null
  }

  export type CostMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number | null
    isDeleted: boolean | null
    type: $Enums.CostType | null
  }

  export type CostMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number | null
    isDeleted: boolean | null
    type: $Enums.CostType | null
  }

  export type CostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    estimatedCost: number
    actualCost: number
    name: number
    projectId: number
    isDeleted: number
    type: number
    _all: number
  }


  export type CostAvgAggregateInputType = {
    id?: true
    estimatedCost?: true
    actualCost?: true
    projectId?: true
  }

  export type CostSumAggregateInputType = {
    id?: true
    estimatedCost?: true
    actualCost?: true
    projectId?: true
  }

  export type CostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
  }

  export type CostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
  }

  export type CostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    estimatedCost?: true
    actualCost?: true
    name?: true
    projectId?: true
    isDeleted?: true
    type?: true
    _all?: true
  }

  export type CostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cost to aggregate.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Costs
    **/
    _count?: true | CostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostMaxAggregateInputType
  }

  export type GetCostAggregateType<T extends CostAggregateArgs> = {
        [P in keyof T & keyof AggregateCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCost[P]>
      : GetScalarType<T[P], AggregateCost[P]>
  }




  export type CostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
    orderBy?: CostOrderByWithAggregationInput | CostOrderByWithAggregationInput[]
    by: CostScalarFieldEnum[] | CostScalarFieldEnum
    having?: CostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCountAggregateInputType | true
    _avg?: CostAvgAggregateInputType
    _sum?: CostSumAggregateInputType
    _min?: CostMinAggregateInputType
    _max?: CostMaxAggregateInputType
  }

  export type CostGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    estimatedCost: number | null
    actualCost: number | null
    name: string | null
    projectId: number
    isDeleted: boolean
    type: $Enums.CostType
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  type GetCostGroupByPayload<T extends CostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostGroupByOutputType[P]>
            : GetScalarType<T[P], CostGroupByOutputType[P]>
        }
      >
    >


  export type CostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    name?: boolean
    projectId?: boolean
    isDeleted?: boolean
    type?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    name?: boolean
    projectId?: boolean
    isDeleted?: boolean
    type?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    name?: boolean
    projectId?: boolean
    isDeleted?: boolean
    type?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    name?: boolean
    projectId?: boolean
    isDeleted?: boolean
    type?: boolean
  }

  export type CostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "estimatedCost" | "actualCost" | "name" | "projectId" | "isDeleted" | "type", ExtArgs["result"]["cost"]>
  export type CostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cost"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      estimatedCost: number | null
      actualCost: number | null
      name: string | null
      projectId: number
      isDeleted: boolean
      type: $Enums.CostType
    }, ExtArgs["result"]["cost"]>
    composites: {}
  }

  type CostGetPayload<S extends boolean | null | undefined | CostDefaultArgs> = $Result.GetResult<Prisma.$CostPayload, S>

  type CostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostCountAggregateInputType | true
    }

  export interface CostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cost'], meta: { name: 'Cost' } }
    /**
     * Find zero or one Cost that matches the filter.
     * @param {CostFindUniqueArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostFindUniqueArgs>(args: SelectSubset<T, CostFindUniqueArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostFindUniqueOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostFindUniqueOrThrowArgs>(args: SelectSubset<T, CostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostFindFirstArgs>(args?: SelectSubset<T, CostFindFirstArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostFindFirstOrThrowArgs>(args?: SelectSubset<T, CostFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Costs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costs
     * const costs = await prisma.cost.findMany()
     * 
     * // Get first 10 Costs
     * const costs = await prisma.cost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costWithIdOnly = await prisma.cost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostFindManyArgs>(args?: SelectSubset<T, CostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cost.
     * @param {CostCreateArgs} args - Arguments to create a Cost.
     * @example
     * // Create one Cost
     * const Cost = await prisma.cost.create({
     *   data: {
     *     // ... data to create a Cost
     *   }
     * })
     * 
     */
    create<T extends CostCreateArgs>(args: SelectSubset<T, CostCreateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Costs.
     * @param {CostCreateManyArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCreateManyArgs>(args?: SelectSubset<T, CostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Costs and returns the data saved in the database.
     * @param {CostCreateManyAndReturnArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cost.
     * @param {CostDeleteArgs} args - Arguments to delete one Cost.
     * @example
     * // Delete one Cost
     * const Cost = await prisma.cost.delete({
     *   where: {
     *     // ... filter to delete one Cost
     *   }
     * })
     * 
     */
    delete<T extends CostDeleteArgs>(args: SelectSubset<T, CostDeleteArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cost.
     * @param {CostUpdateArgs} args - Arguments to update one Cost.
     * @example
     * // Update one Cost
     * const cost = await prisma.cost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostUpdateArgs>(args: SelectSubset<T, CostUpdateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Costs.
     * @param {CostDeleteManyArgs} args - Arguments to filter Costs to delete.
     * @example
     * // Delete a few Costs
     * const { count } = await prisma.cost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostDeleteManyArgs>(args?: SelectSubset<T, CostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostUpdateManyArgs>(args: SelectSubset<T, CostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs and returns the data updated in the database.
     * @param {CostUpdateManyAndReturnArgs} args - Arguments to update many Costs.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostUpdateManyAndReturnArgs>(args: SelectSubset<T, CostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cost.
     * @param {CostUpsertArgs} args - Arguments to update or create a Cost.
     * @example
     * // Update or create a Cost
     * const cost = await prisma.cost.upsert({
     *   create: {
     *     // ... data to create a Cost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cost we want to update
     *   }
     * })
     */
    upsert<T extends CostUpsertArgs>(args: SelectSubset<T, CostUpsertArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCountArgs} args - Arguments to filter Costs to count.
     * @example
     * // Count the number of Costs
     * const count = await prisma.cost.count({
     *   where: {
     *     // ... the filter for the Costs we want to count
     *   }
     * })
    **/
    count<T extends CostCountArgs>(
      args?: Subset<T, CostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostAggregateArgs>(args: Subset<T, CostAggregateArgs>): Prisma.PrismaPromise<GetCostAggregateType<T>>

    /**
     * Group by Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostGroupByArgs['orderBy'] }
        : { orderBy?: CostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cost model
   */
  readonly fields: CostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cost model
   */ 
  interface CostFieldRefs {
    readonly id: FieldRef<"Cost", 'Int'>
    readonly createdAt: FieldRef<"Cost", 'DateTime'>
    readonly updatedAt: FieldRef<"Cost", 'DateTime'>
    readonly estimatedCost: FieldRef<"Cost", 'Float'>
    readonly actualCost: FieldRef<"Cost", 'Float'>
    readonly name: FieldRef<"Cost", 'String'>
    readonly projectId: FieldRef<"Cost", 'Int'>
    readonly isDeleted: FieldRef<"Cost", 'Boolean'>
    readonly type: FieldRef<"Cost", 'CostType'>
  }
    

  // Custom InputTypes
  /**
   * Cost findUnique
   */
  export type CostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findUniqueOrThrow
   */
  export type CostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findFirst
   */
  export type CostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findFirstOrThrow
   */
  export type CostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findMany
   */
  export type CostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Costs to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost create
   */
  export type CostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to create a Cost.
     */
    data: XOR<CostCreateInput, CostUncheckedCreateInput>
  }

  /**
   * Cost createMany
   */
  export type CostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cost createManyAndReturn
   */
  export type CostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost update
   */
  export type CostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to update a Cost.
     */
    data: XOR<CostUpdateInput, CostUncheckedUpdateInput>
    /**
     * Choose, which Cost to update.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost updateMany
   */
  export type CostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
  }

  /**
   * Cost updateManyAndReturn
   */
  export type CostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost upsert
   */
  export type CostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The filter to search for the Cost to update in case it exists.
     */
    where: CostWhereUniqueInput
    /**
     * In case the Cost found by the `where` argument doesn't exist, create a new Cost with this data.
     */
    create: XOR<CostCreateInput, CostUncheckedCreateInput>
    /**
     * In case the Cost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostUpdateInput, CostUncheckedUpdateInput>
  }

  /**
   * Cost delete
   */
  export type CostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter which Cost to delete.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost deleteMany
   */
  export type CostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Costs to delete
     */
    where?: CostWhereInput
  }

  /**
   * Cost without action
   */
  export type CostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
  }


  /**
   * Model PropertyData
   */

  export type AggregatePropertyData = {
    _count: PropertyDataCountAggregateOutputType | null
    _avg: PropertyDataAvgAggregateOutputType | null
    _sum: PropertyDataSumAggregateOutputType | null
    _min: PropertyDataMinAggregateOutputType | null
    _max: PropertyDataMaxAggregateOutputType | null
  }

  export type PropertyDataAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
  }

  export type PropertyDataSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
  }

  export type PropertyDataMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
  }

  export type PropertyDataMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
  }

  export type PropertyDataCountAggregateOutputType = {
    id: number
    createdAt: number
    projectId: number
    bathrooms: number
    bedrooms: number
    squareFootage: number
    realtyMoleId: number
    data: number
    _all: number
  }


  export type PropertyDataAvgAggregateInputType = {
    id?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
  }

  export type PropertyDataSumAggregateInputType = {
    id?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
  }

  export type PropertyDataMinAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
  }

  export type PropertyDataMaxAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
  }

  export type PropertyDataCountAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    bathrooms?: true
    bedrooms?: true
    squareFootage?: true
    realtyMoleId?: true
    data?: true
    _all?: true
  }

  export type PropertyDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyData to aggregate.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: PropertyDataOrderByWithRelationInput | PropertyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyData
    **/
    _count?: true | PropertyDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyDataMaxAggregateInputType
  }

  export type GetPropertyDataAggregateType<T extends PropertyDataAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyData[P]>
      : GetScalarType<T[P], AggregatePropertyData[P]>
  }




  export type PropertyDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyDataWhereInput
    orderBy?: PropertyDataOrderByWithAggregationInput | PropertyDataOrderByWithAggregationInput[]
    by: PropertyDataScalarFieldEnum[] | PropertyDataScalarFieldEnum
    having?: PropertyDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyDataCountAggregateInputType | true
    _avg?: PropertyDataAvgAggregateInputType
    _sum?: PropertyDataSumAggregateInputType
    _min?: PropertyDataMinAggregateInputType
    _max?: PropertyDataMaxAggregateInputType
  }

  export type PropertyDataGroupByOutputType = {
    id: number
    createdAt: Date
    projectId: number | null
    bathrooms: number | null
    bedrooms: number | null
    squareFootage: number | null
    realtyMoleId: string | null
    data: JsonValue | null
    _count: PropertyDataCountAggregateOutputType | null
    _avg: PropertyDataAvgAggregateOutputType | null
    _sum: PropertyDataSumAggregateOutputType | null
    _min: PropertyDataMinAggregateOutputType | null
    _max: PropertyDataMaxAggregateOutputType | null
  }

  type GetPropertyDataGroupByPayload<T extends PropertyDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyDataGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyDataGroupByOutputType[P]>
        }
      >
    >


  export type PropertyDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    squareFootage?: boolean
    realtyMoleId?: boolean
    data?: boolean
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }, ExtArgs["result"]["propertyData"]>

  export type PropertyDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    squareFootage?: boolean
    realtyMoleId?: boolean
    data?: boolean
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }, ExtArgs["result"]["propertyData"]>

  export type PropertyDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    squareFootage?: boolean
    realtyMoleId?: boolean
    data?: boolean
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }, ExtArgs["result"]["propertyData"]>

  export type PropertyDataSelectScalar = {
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    squareFootage?: boolean
    realtyMoleId?: boolean
    data?: boolean
  }

  export type PropertyDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "projectId" | "bathrooms" | "bedrooms" | "squareFootage" | "realtyMoleId" | "data", ExtArgs["result"]["propertyData"]>
  export type PropertyDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }
  export type PropertyDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }
  export type PropertyDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PropertyData$projectArgs<ExtArgs>
  }

  export type $PropertyDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyData"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      projectId: number | null
      bathrooms: number | null
      bedrooms: number | null
      squareFootage: number | null
      realtyMoleId: string | null
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["propertyData"]>
    composites: {}
  }

  type PropertyDataGetPayload<S extends boolean | null | undefined | PropertyDataDefaultArgs> = $Result.GetResult<Prisma.$PropertyDataPayload, S>

  type PropertyDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyDataCountAggregateInputType | true
    }

  export interface PropertyDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyData'], meta: { name: 'PropertyData' } }
    /**
     * Find zero or one PropertyData that matches the filter.
     * @param {PropertyDataFindUniqueArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyDataFindUniqueArgs>(args: SelectSubset<T, PropertyDataFindUniqueArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PropertyData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyDataFindUniqueOrThrowArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyDataFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PropertyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindFirstArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyDataFindFirstArgs>(args?: SelectSubset<T, PropertyDataFindFirstArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PropertyData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindFirstOrThrowArgs} args - Arguments to find a PropertyData
     * @example
     * // Get one PropertyData
     * const propertyData = await prisma.propertyData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyDataFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PropertyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyData
     * const propertyData = await prisma.propertyData.findMany()
     * 
     * // Get first 10 PropertyData
     * const propertyData = await prisma.propertyData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyDataWithIdOnly = await prisma.propertyData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyDataFindManyArgs>(args?: SelectSubset<T, PropertyDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PropertyData.
     * @param {PropertyDataCreateArgs} args - Arguments to create a PropertyData.
     * @example
     * // Create one PropertyData
     * const PropertyData = await prisma.propertyData.create({
     *   data: {
     *     // ... data to create a PropertyData
     *   }
     * })
     * 
     */
    create<T extends PropertyDataCreateArgs>(args: SelectSubset<T, PropertyDataCreateArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PropertyData.
     * @param {PropertyDataCreateManyArgs} args - Arguments to create many PropertyData.
     * @example
     * // Create many PropertyData
     * const propertyData = await prisma.propertyData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyDataCreateManyArgs>(args?: SelectSubset<T, PropertyDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyData and returns the data saved in the database.
     * @param {PropertyDataCreateManyAndReturnArgs} args - Arguments to create many PropertyData.
     * @example
     * // Create many PropertyData
     * const propertyData = await prisma.propertyData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyData and only return the `id`
     * const propertyDataWithIdOnly = await prisma.propertyData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyDataCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PropertyData.
     * @param {PropertyDataDeleteArgs} args - Arguments to delete one PropertyData.
     * @example
     * // Delete one PropertyData
     * const PropertyData = await prisma.propertyData.delete({
     *   where: {
     *     // ... filter to delete one PropertyData
     *   }
     * })
     * 
     */
    delete<T extends PropertyDataDeleteArgs>(args: SelectSubset<T, PropertyDataDeleteArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PropertyData.
     * @param {PropertyDataUpdateArgs} args - Arguments to update one PropertyData.
     * @example
     * // Update one PropertyData
     * const propertyData = await prisma.propertyData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyDataUpdateArgs>(args: SelectSubset<T, PropertyDataUpdateArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PropertyData.
     * @param {PropertyDataDeleteManyArgs} args - Arguments to filter PropertyData to delete.
     * @example
     * // Delete a few PropertyData
     * const { count } = await prisma.propertyData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDataDeleteManyArgs>(args?: SelectSubset<T, PropertyDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyData
     * const propertyData = await prisma.propertyData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyDataUpdateManyArgs>(args: SelectSubset<T, PropertyDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyData and returns the data updated in the database.
     * @param {PropertyDataUpdateManyAndReturnArgs} args - Arguments to update many PropertyData.
     * @example
     * // Update many PropertyData
     * const propertyData = await prisma.propertyData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyData and only return the `id`
     * const propertyDataWithIdOnly = await prisma.propertyData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyDataUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PropertyData.
     * @param {PropertyDataUpsertArgs} args - Arguments to update or create a PropertyData.
     * @example
     * // Update or create a PropertyData
     * const propertyData = await prisma.propertyData.upsert({
     *   create: {
     *     // ... data to create a PropertyData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyData we want to update
     *   }
     * })
     */
    upsert<T extends PropertyDataUpsertArgs>(args: SelectSubset<T, PropertyDataUpsertArgs<ExtArgs>>): Prisma__PropertyDataClient<$Result.GetResult<Prisma.$PropertyDataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataCountArgs} args - Arguments to filter PropertyData to count.
     * @example
     * // Count the number of PropertyData
     * const count = await prisma.propertyData.count({
     *   where: {
     *     // ... the filter for the PropertyData we want to count
     *   }
     * })
    **/
    count<T extends PropertyDataCountArgs>(
      args?: Subset<T, PropertyDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyDataAggregateArgs>(args: Subset<T, PropertyDataAggregateArgs>): Prisma.PrismaPromise<GetPropertyDataAggregateType<T>>

    /**
     * Group by PropertyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyDataGroupByArgs['orderBy'] }
        : { orderBy?: PropertyDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyData model
   */
  readonly fields: PropertyDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends PropertyData$projectArgs<ExtArgs> = {}>(args?: Subset<T, PropertyData$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyData model
   */ 
  interface PropertyDataFieldRefs {
    readonly id: FieldRef<"PropertyData", 'Int'>
    readonly createdAt: FieldRef<"PropertyData", 'DateTime'>
    readonly projectId: FieldRef<"PropertyData", 'Int'>
    readonly bathrooms: FieldRef<"PropertyData", 'Float'>
    readonly bedrooms: FieldRef<"PropertyData", 'Int'>
    readonly squareFootage: FieldRef<"PropertyData", 'Int'>
    readonly realtyMoleId: FieldRef<"PropertyData", 'String'>
    readonly data: FieldRef<"PropertyData", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PropertyData findUnique
   */
  export type PropertyDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where: PropertyDataWhereUniqueInput
  }

  /**
   * PropertyData findUniqueOrThrow
   */
  export type PropertyDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where: PropertyDataWhereUniqueInput
  }

  /**
   * PropertyData findFirst
   */
  export type PropertyDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: PropertyDataOrderByWithRelationInput | PropertyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyData.
     */
    distinct?: PropertyDataScalarFieldEnum | PropertyDataScalarFieldEnum[]
  }

  /**
   * PropertyData findFirstOrThrow
   */
  export type PropertyDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: PropertyDataOrderByWithRelationInput | PropertyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyData.
     */
    distinct?: PropertyDataScalarFieldEnum | PropertyDataScalarFieldEnum[]
  }

  /**
   * PropertyData findMany
   */
  export type PropertyDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter, which PropertyData to fetch.
     */
    where?: PropertyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyData to fetch.
     */
    orderBy?: PropertyDataOrderByWithRelationInput | PropertyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyData.
     */
    cursor?: PropertyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyData.
     */
    skip?: number
    distinct?: PropertyDataScalarFieldEnum | PropertyDataScalarFieldEnum[]
  }

  /**
   * PropertyData create
   */
  export type PropertyDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyData.
     */
    data?: XOR<PropertyDataCreateInput, PropertyDataUncheckedCreateInput>
  }

  /**
   * PropertyData createMany
   */
  export type PropertyDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyData.
     */
    data: PropertyDataCreateManyInput | PropertyDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyData createManyAndReturn
   */
  export type PropertyDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyData.
     */
    data: PropertyDataCreateManyInput | PropertyDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyData update
   */
  export type PropertyDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyData.
     */
    data: XOR<PropertyDataUpdateInput, PropertyDataUncheckedUpdateInput>
    /**
     * Choose, which PropertyData to update.
     */
    where: PropertyDataWhereUniqueInput
  }

  /**
   * PropertyData updateMany
   */
  export type PropertyDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyData.
     */
    data: XOR<PropertyDataUpdateManyMutationInput, PropertyDataUncheckedUpdateManyInput>
    /**
     * Filter which PropertyData to update
     */
    where?: PropertyDataWhereInput
  }

  /**
   * PropertyData updateManyAndReturn
   */
  export type PropertyDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * The data used to update PropertyData.
     */
    data: XOR<PropertyDataUpdateManyMutationInput, PropertyDataUncheckedUpdateManyInput>
    /**
     * Filter which PropertyData to update
     */
    where?: PropertyDataWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyData upsert
   */
  export type PropertyDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyData to update in case it exists.
     */
    where: PropertyDataWhereUniqueInput
    /**
     * In case the PropertyData found by the `where` argument doesn't exist, create a new PropertyData with this data.
     */
    create: XOR<PropertyDataCreateInput, PropertyDataUncheckedCreateInput>
    /**
     * In case the PropertyData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyDataUpdateInput, PropertyDataUncheckedUpdateInput>
  }

  /**
   * PropertyData delete
   */
  export type PropertyDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
    /**
     * Filter which PropertyData to delete.
     */
    where: PropertyDataWhereUniqueInput
  }

  /**
   * PropertyData deleteMany
   */
  export type PropertyDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyData to delete
     */
    where?: PropertyDataWhereInput
  }

  /**
   * PropertyData.project
   */
  export type PropertyData$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * PropertyData without action
   */
  export type PropertyDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyData
     */
    select?: PropertyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyData
     */
    omit?: PropertyDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyDataInclude<ExtArgs> | null
  }


  /**
   * Model DataDeletionRequest
   */

  export type AggregateDataDeletionRequest = {
    _count: DataDeletionRequestCountAggregateOutputType | null
    _avg: DataDeletionRequestAvgAggregateOutputType | null
    _sum: DataDeletionRequestSumAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  export type DataDeletionRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type DataDeletionRequestSumAggregateOutputType = {
    id: number | null
  }

  export type DataDeletionRequestMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    fullName: string | null
    email: string | null
    isVerified: boolean | null
  }

  export type DataDeletionRequestMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    fullName: string | null
    email: string | null
    isVerified: boolean | null
  }

  export type DataDeletionRequestCountAggregateOutputType = {
    id: number
    createdAt: number
    fullName: number
    email: number
    isVerified: number
    _all: number
  }


  export type DataDeletionRequestAvgAggregateInputType = {
    id?: true
  }

  export type DataDeletionRequestSumAggregateInputType = {
    id?: true
  }

  export type DataDeletionRequestMinAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
  }

  export type DataDeletionRequestMaxAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
  }

  export type DataDeletionRequestCountAggregateInputType = {
    id?: true
    createdAt?: true
    fullName?: true
    email?: true
    isVerified?: true
    _all?: true
  }

  export type DataDeletionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequest to aggregate.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataDeletionRequests
    **/
    _count?: true | DataDeletionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataDeletionRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataDeletionRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataDeletionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type GetDataDeletionRequestAggregateType<T extends DataDeletionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataDeletionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
      : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
  }




  export type DataDeletionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithAggregationInput | DataDeletionRequestOrderByWithAggregationInput[]
    by: DataDeletionRequestScalarFieldEnum[] | DataDeletionRequestScalarFieldEnum
    having?: DataDeletionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataDeletionRequestCountAggregateInputType | true
    _avg?: DataDeletionRequestAvgAggregateInputType
    _sum?: DataDeletionRequestSumAggregateInputType
    _min?: DataDeletionRequestMinAggregateInputType
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type DataDeletionRequestGroupByOutputType = {
    id: number
    createdAt: Date
    fullName: string
    email: string
    isVerified: boolean
    _count: DataDeletionRequestCountAggregateOutputType | null
    _avg: DataDeletionRequestAvgAggregateOutputType | null
    _sum: DataDeletionRequestSumAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  type GetDataDeletionRequestGroupByPayload<T extends DataDeletionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataDeletionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataDeletionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataDeletionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    fullName?: boolean
    email?: boolean
    isVerified?: boolean
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    fullName?: boolean
    email?: boolean
    isVerified?: boolean
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    fullName?: boolean
    email?: boolean
    isVerified?: boolean
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectScalar = {
    id?: boolean
    createdAt?: boolean
    fullName?: boolean
    email?: boolean
    isVerified?: boolean
  }

  export type DataDeletionRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "fullName" | "email" | "isVerified", ExtArgs["result"]["dataDeletionRequest"]>

  export type $DataDeletionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataDeletionRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      fullName: string
      email: string
      isVerified: boolean
    }, ExtArgs["result"]["dataDeletionRequest"]>
    composites: {}
  }

  type DataDeletionRequestGetPayload<S extends boolean | null | undefined | DataDeletionRequestDefaultArgs> = $Result.GetResult<Prisma.$DataDeletionRequestPayload, S>

  type DataDeletionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataDeletionRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataDeletionRequestCountAggregateInputType | true
    }

  export interface DataDeletionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataDeletionRequest'], meta: { name: 'DataDeletionRequest' } }
    /**
     * Find zero or one DataDeletionRequest that matches the filter.
     * @param {DataDeletionRequestFindUniqueArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataDeletionRequestFindUniqueArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataDeletionRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataDeletionRequestFindUniqueOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataDeletionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataDeletionRequestFindFirstArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataDeletionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataDeletionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
     * 
     * // Get first 10 DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataDeletionRequestFindManyArgs>(args?: SelectSubset<T, DataDeletionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataDeletionRequest.
     * @param {DataDeletionRequestCreateArgs} args - Arguments to create a DataDeletionRequest.
     * @example
     * // Create one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.create({
     *   data: {
     *     // ... data to create a DataDeletionRequest
     *   }
     * })
     * 
     */
    create<T extends DataDeletionRequestCreateArgs>(args: SelectSubset<T, DataDeletionRequestCreateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataDeletionRequests.
     * @param {DataDeletionRequestCreateManyArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataDeletionRequestCreateManyArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataDeletionRequests and returns the data saved in the database.
     * @param {DataDeletionRequestCreateManyAndReturnArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataDeletionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DataDeletionRequest.
     * @param {DataDeletionRequestDeleteArgs} args - Arguments to delete one DataDeletionRequest.
     * @example
     * // Delete one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.delete({
     *   where: {
     *     // ... filter to delete one DataDeletionRequest
     *   }
     * })
     * 
     */
    delete<T extends DataDeletionRequestDeleteArgs>(args: SelectSubset<T, DataDeletionRequestDeleteArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataDeletionRequest.
     * @param {DataDeletionRequestUpdateArgs} args - Arguments to update one DataDeletionRequest.
     * @example
     * // Update one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataDeletionRequestUpdateArgs>(args: SelectSubset<T, DataDeletionRequestUpdateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataDeletionRequests.
     * @param {DataDeletionRequestDeleteManyArgs} args - Arguments to filter DataDeletionRequests to delete.
     * @example
     * // Delete a few DataDeletionRequests
     * const { count } = await prisma.dataDeletionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataDeletionRequestDeleteManyArgs>(args?: SelectSubset<T, DataDeletionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataDeletionRequestUpdateManyArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests and returns the data updated in the database.
     * @param {DataDeletionRequestUpdateManyAndReturnArgs} args - Arguments to update many DataDeletionRequests.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataDeletionRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DataDeletionRequest.
     * @param {DataDeletionRequestUpsertArgs} args - Arguments to update or create a DataDeletionRequest.
     * @example
     * // Update or create a DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.upsert({
     *   create: {
     *     // ... data to create a DataDeletionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataDeletionRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataDeletionRequestUpsertArgs>(args: SelectSubset<T, DataDeletionRequestUpsertArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestCountArgs} args - Arguments to filter DataDeletionRequests to count.
     * @example
     * // Count the number of DataDeletionRequests
     * const count = await prisma.dataDeletionRequest.count({
     *   where: {
     *     // ... the filter for the DataDeletionRequests we want to count
     *   }
     * })
    **/
    count<T extends DataDeletionRequestCountArgs>(
      args?: Subset<T, DataDeletionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataDeletionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataDeletionRequestAggregateArgs>(args: Subset<T, DataDeletionRequestAggregateArgs>): Prisma.PrismaPromise<GetDataDeletionRequestAggregateType<T>>

    /**
     * Group by DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataDeletionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataDeletionRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataDeletionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataDeletionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataDeletionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataDeletionRequest model
   */
  readonly fields: DataDeletionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataDeletionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataDeletionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataDeletionRequest model
   */ 
  interface DataDeletionRequestFieldRefs {
    readonly id: FieldRef<"DataDeletionRequest", 'Int'>
    readonly createdAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly fullName: FieldRef<"DataDeletionRequest", 'String'>
    readonly email: FieldRef<"DataDeletionRequest", 'String'>
    readonly isVerified: FieldRef<"DataDeletionRequest", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DataDeletionRequest findUnique
   */
  export type DataDeletionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findUniqueOrThrow
   */
  export type DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findFirst
   */
  export type DataDeletionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findFirstOrThrow
   */
  export type DataDeletionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findMany
   */
  export type DataDeletionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequests to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest create
   */
  export type DataDeletionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
  }

  /**
   * DataDeletionRequest createMany
   */
  export type DataDeletionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDeletionRequest createManyAndReturn
   */
  export type DataDeletionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDeletionRequest update
   */
  export type DataDeletionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
    /**
     * Choose, which DataDeletionRequest to update.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest updateMany
   */
  export type DataDeletionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
  }

  /**
   * DataDeletionRequest updateManyAndReturn
   */
  export type DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
  }

  /**
   * DataDeletionRequest upsert
   */
  export type DataDeletionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the DataDeletionRequest to update in case it exists.
     */
    where: DataDeletionRequestWhereUniqueInput
    /**
     * In case the DataDeletionRequest found by the `where` argument doesn't exist, create a new DataDeletionRequest with this data.
     */
    create: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
    /**
     * In case the DataDeletionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
  }

  /**
   * DataDeletionRequest delete
   */
  export type DataDeletionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Filter which DataDeletionRequest to delete.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest deleteMany
   */
  export type DataDeletionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequests to delete
     */
    where?: DataDeletionRequestWhereInput
  }

  /**
   * DataDeletionRequest without action
   */
  export type DataDeletionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
  }


  /**
   * Model PhotoAccessLink
   */

  export type AggregatePhotoAccessLink = {
    _count: PhotoAccessLinkCountAggregateOutputType | null
    _avg: PhotoAccessLinkAvgAggregateOutputType | null
    _sum: PhotoAccessLinkSumAggregateOutputType | null
    _min: PhotoAccessLinkMinAggregateOutputType | null
    _max: PhotoAccessLinkMaxAggregateOutputType | null
  }

  export type PhotoAccessLinkAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PhotoAccessLinkSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PhotoAccessLinkMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    expiresAt: Date | null
    accessId: string | null
    email: string | null
    phoneNumber: string | null
    projectId: number | null
  }

  export type PhotoAccessLinkMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    expiresAt: Date | null
    accessId: string | null
    email: string | null
    phoneNumber: string | null
    projectId: number | null
  }

  export type PhotoAccessLinkCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    accessId: number
    email: number
    phoneNumber: number
    projectId: number
    _all: number
  }


  export type PhotoAccessLinkAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PhotoAccessLinkSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PhotoAccessLinkMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
  }

  export type PhotoAccessLinkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
  }

  export type PhotoAccessLinkCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    accessId?: true
    email?: true
    phoneNumber?: true
    projectId?: true
    _all?: true
  }

  export type PhotoAccessLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotoAccessLink to aggregate.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: PhotoAccessLinkOrderByWithRelationInput | PhotoAccessLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotoAccessLinks
    **/
    _count?: true | PhotoAccessLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAccessLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoAccessLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoAccessLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoAccessLinkMaxAggregateInputType
  }

  export type GetPhotoAccessLinkAggregateType<T extends PhotoAccessLinkAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotoAccessLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotoAccessLink[P]>
      : GetScalarType<T[P], AggregatePhotoAccessLink[P]>
  }




  export type PhotoAccessLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoAccessLinkWhereInput
    orderBy?: PhotoAccessLinkOrderByWithAggregationInput | PhotoAccessLinkOrderByWithAggregationInput[]
    by: PhotoAccessLinkScalarFieldEnum[] | PhotoAccessLinkScalarFieldEnum
    having?: PhotoAccessLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoAccessLinkCountAggregateInputType | true
    _avg?: PhotoAccessLinkAvgAggregateInputType
    _sum?: PhotoAccessLinkSumAggregateInputType
    _min?: PhotoAccessLinkMinAggregateInputType
    _max?: PhotoAccessLinkMaxAggregateInputType
  }

  export type PhotoAccessLinkGroupByOutputType = {
    id: number
    createdAt: Date
    expiresAt: Date | null
    accessId: string
    email: string | null
    phoneNumber: string | null
    projectId: number
    _count: PhotoAccessLinkCountAggregateOutputType | null
    _avg: PhotoAccessLinkAvgAggregateOutputType | null
    _sum: PhotoAccessLinkSumAggregateOutputType | null
    _min: PhotoAccessLinkMinAggregateOutputType | null
    _max: PhotoAccessLinkMaxAggregateOutputType | null
  }

  type GetPhotoAccessLinkGroupByPayload<T extends PhotoAccessLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoAccessLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoAccessLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoAccessLinkGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoAccessLinkGroupByOutputType[P]>
        }
      >
    >


  export type PhotoAccessLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    accessId?: boolean
    email?: boolean
    phoneNumber?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photoAccessLink"]>

  export type PhotoAccessLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    accessId?: boolean
    email?: boolean
    phoneNumber?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photoAccessLink"]>

  export type PhotoAccessLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    accessId?: boolean
    email?: boolean
    phoneNumber?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photoAccessLink"]>

  export type PhotoAccessLinkSelectScalar = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    accessId?: boolean
    email?: boolean
    phoneNumber?: boolean
    projectId?: boolean
  }

  export type PhotoAccessLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "expiresAt" | "accessId" | "email" | "phoneNumber" | "projectId", ExtArgs["result"]["photoAccessLink"]>
  export type PhotoAccessLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PhotoAccessLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PhotoAccessLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PhotoAccessLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhotoAccessLink"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      expiresAt: Date | null
      accessId: string
      email: string | null
      phoneNumber: string | null
      projectId: number
    }, ExtArgs["result"]["photoAccessLink"]>
    composites: {}
  }

  type PhotoAccessLinkGetPayload<S extends boolean | null | undefined | PhotoAccessLinkDefaultArgs> = $Result.GetResult<Prisma.$PhotoAccessLinkPayload, S>

  type PhotoAccessLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhotoAccessLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhotoAccessLinkCountAggregateInputType | true
    }

  export interface PhotoAccessLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhotoAccessLink'], meta: { name: 'PhotoAccessLink' } }
    /**
     * Find zero or one PhotoAccessLink that matches the filter.
     * @param {PhotoAccessLinkFindUniqueArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoAccessLinkFindUniqueArgs>(args: SelectSubset<T, PhotoAccessLinkFindUniqueArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PhotoAccessLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhotoAccessLinkFindUniqueOrThrowArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoAccessLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoAccessLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PhotoAccessLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindFirstArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoAccessLinkFindFirstArgs>(args?: SelectSubset<T, PhotoAccessLinkFindFirstArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PhotoAccessLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindFirstOrThrowArgs} args - Arguments to find a PhotoAccessLink
     * @example
     * // Get one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoAccessLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoAccessLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PhotoAccessLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotoAccessLinks
     * const photoAccessLinks = await prisma.photoAccessLink.findMany()
     * 
     * // Get first 10 PhotoAccessLinks
     * const photoAccessLinks = await prisma.photoAccessLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoAccessLinkWithIdOnly = await prisma.photoAccessLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoAccessLinkFindManyArgs>(args?: SelectSubset<T, PhotoAccessLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PhotoAccessLink.
     * @param {PhotoAccessLinkCreateArgs} args - Arguments to create a PhotoAccessLink.
     * @example
     * // Create one PhotoAccessLink
     * const PhotoAccessLink = await prisma.photoAccessLink.create({
     *   data: {
     *     // ... data to create a PhotoAccessLink
     *   }
     * })
     * 
     */
    create<T extends PhotoAccessLinkCreateArgs>(args: SelectSubset<T, PhotoAccessLinkCreateArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PhotoAccessLinks.
     * @param {PhotoAccessLinkCreateManyArgs} args - Arguments to create many PhotoAccessLinks.
     * @example
     * // Create many PhotoAccessLinks
     * const photoAccessLink = await prisma.photoAccessLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoAccessLinkCreateManyArgs>(args?: SelectSubset<T, PhotoAccessLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhotoAccessLinks and returns the data saved in the database.
     * @param {PhotoAccessLinkCreateManyAndReturnArgs} args - Arguments to create many PhotoAccessLinks.
     * @example
     * // Create many PhotoAccessLinks
     * const photoAccessLink = await prisma.photoAccessLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhotoAccessLinks and only return the `id`
     * const photoAccessLinkWithIdOnly = await prisma.photoAccessLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotoAccessLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotoAccessLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PhotoAccessLink.
     * @param {PhotoAccessLinkDeleteArgs} args - Arguments to delete one PhotoAccessLink.
     * @example
     * // Delete one PhotoAccessLink
     * const PhotoAccessLink = await prisma.photoAccessLink.delete({
     *   where: {
     *     // ... filter to delete one PhotoAccessLink
     *   }
     * })
     * 
     */
    delete<T extends PhotoAccessLinkDeleteArgs>(args: SelectSubset<T, PhotoAccessLinkDeleteArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PhotoAccessLink.
     * @param {PhotoAccessLinkUpdateArgs} args - Arguments to update one PhotoAccessLink.
     * @example
     * // Update one PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoAccessLinkUpdateArgs>(args: SelectSubset<T, PhotoAccessLinkUpdateArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PhotoAccessLinks.
     * @param {PhotoAccessLinkDeleteManyArgs} args - Arguments to filter PhotoAccessLinks to delete.
     * @example
     * // Delete a few PhotoAccessLinks
     * const { count } = await prisma.photoAccessLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoAccessLinkDeleteManyArgs>(args?: SelectSubset<T, PhotoAccessLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoAccessLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotoAccessLinks
     * const photoAccessLink = await prisma.photoAccessLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoAccessLinkUpdateManyArgs>(args: SelectSubset<T, PhotoAccessLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoAccessLinks and returns the data updated in the database.
     * @param {PhotoAccessLinkUpdateManyAndReturnArgs} args - Arguments to update many PhotoAccessLinks.
     * @example
     * // Update many PhotoAccessLinks
     * const photoAccessLink = await prisma.photoAccessLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhotoAccessLinks and only return the `id`
     * const photoAccessLinkWithIdOnly = await prisma.photoAccessLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhotoAccessLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, PhotoAccessLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PhotoAccessLink.
     * @param {PhotoAccessLinkUpsertArgs} args - Arguments to update or create a PhotoAccessLink.
     * @example
     * // Update or create a PhotoAccessLink
     * const photoAccessLink = await prisma.photoAccessLink.upsert({
     *   create: {
     *     // ... data to create a PhotoAccessLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotoAccessLink we want to update
     *   }
     * })
     */
    upsert<T extends PhotoAccessLinkUpsertArgs>(args: SelectSubset<T, PhotoAccessLinkUpsertArgs<ExtArgs>>): Prisma__PhotoAccessLinkClient<$Result.GetResult<Prisma.$PhotoAccessLinkPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PhotoAccessLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkCountArgs} args - Arguments to filter PhotoAccessLinks to count.
     * @example
     * // Count the number of PhotoAccessLinks
     * const count = await prisma.photoAccessLink.count({
     *   where: {
     *     // ... the filter for the PhotoAccessLinks we want to count
     *   }
     * })
    **/
    count<T extends PhotoAccessLinkCountArgs>(
      args?: Subset<T, PhotoAccessLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoAccessLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotoAccessLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAccessLinkAggregateArgs>(args: Subset<T, PhotoAccessLinkAggregateArgs>): Prisma.PrismaPromise<GetPhotoAccessLinkAggregateType<T>>

    /**
     * Group by PhotoAccessLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAccessLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoAccessLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoAccessLinkGroupByArgs['orderBy'] }
        : { orderBy?: PhotoAccessLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoAccessLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoAccessLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhotoAccessLink model
   */
  readonly fields: PhotoAccessLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotoAccessLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoAccessLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhotoAccessLink model
   */ 
  interface PhotoAccessLinkFieldRefs {
    readonly id: FieldRef<"PhotoAccessLink", 'Int'>
    readonly createdAt: FieldRef<"PhotoAccessLink", 'DateTime'>
    readonly expiresAt: FieldRef<"PhotoAccessLink", 'DateTime'>
    readonly accessId: FieldRef<"PhotoAccessLink", 'String'>
    readonly email: FieldRef<"PhotoAccessLink", 'String'>
    readonly phoneNumber: FieldRef<"PhotoAccessLink", 'String'>
    readonly projectId: FieldRef<"PhotoAccessLink", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PhotoAccessLink findUnique
   */
  export type PhotoAccessLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }

  /**
   * PhotoAccessLink findUniqueOrThrow
   */
  export type PhotoAccessLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }

  /**
   * PhotoAccessLink findFirst
   */
  export type PhotoAccessLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: PhotoAccessLinkOrderByWithRelationInput | PhotoAccessLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAccessLinks.
     */
    distinct?: PhotoAccessLinkScalarFieldEnum | PhotoAccessLinkScalarFieldEnum[]
  }

  /**
   * PhotoAccessLink findFirstOrThrow
   */
  export type PhotoAccessLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter, which PhotoAccessLink to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: PhotoAccessLinkOrderByWithRelationInput | PhotoAccessLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAccessLinks.
     */
    distinct?: PhotoAccessLinkScalarFieldEnum | PhotoAccessLinkScalarFieldEnum[]
  }

  /**
   * PhotoAccessLink findMany
   */
  export type PhotoAccessLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter, which PhotoAccessLinks to fetch.
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAccessLinks to fetch.
     */
    orderBy?: PhotoAccessLinkOrderByWithRelationInput | PhotoAccessLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotoAccessLinks.
     */
    cursor?: PhotoAccessLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAccessLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAccessLinks.
     */
    skip?: number
    distinct?: PhotoAccessLinkScalarFieldEnum | PhotoAccessLinkScalarFieldEnum[]
  }

  /**
   * PhotoAccessLink create
   */
  export type PhotoAccessLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a PhotoAccessLink.
     */
    data: XOR<PhotoAccessLinkCreateInput, PhotoAccessLinkUncheckedCreateInput>
  }

  /**
   * PhotoAccessLink createMany
   */
  export type PhotoAccessLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhotoAccessLinks.
     */
    data: PhotoAccessLinkCreateManyInput | PhotoAccessLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhotoAccessLink createManyAndReturn
   */
  export type PhotoAccessLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * The data used to create many PhotoAccessLinks.
     */
    data: PhotoAccessLinkCreateManyInput | PhotoAccessLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhotoAccessLink update
   */
  export type PhotoAccessLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a PhotoAccessLink.
     */
    data: XOR<PhotoAccessLinkUpdateInput, PhotoAccessLinkUncheckedUpdateInput>
    /**
     * Choose, which PhotoAccessLink to update.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }

  /**
   * PhotoAccessLink updateMany
   */
  export type PhotoAccessLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhotoAccessLinks.
     */
    data: XOR<PhotoAccessLinkUpdateManyMutationInput, PhotoAccessLinkUncheckedUpdateManyInput>
    /**
     * Filter which PhotoAccessLinks to update
     */
    where?: PhotoAccessLinkWhereInput
  }

  /**
   * PhotoAccessLink updateManyAndReturn
   */
  export type PhotoAccessLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * The data used to update PhotoAccessLinks.
     */
    data: XOR<PhotoAccessLinkUpdateManyMutationInput, PhotoAccessLinkUncheckedUpdateManyInput>
    /**
     * Filter which PhotoAccessLinks to update
     */
    where?: PhotoAccessLinkWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhotoAccessLink upsert
   */
  export type PhotoAccessLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the PhotoAccessLink to update in case it exists.
     */
    where: PhotoAccessLinkWhereUniqueInput
    /**
     * In case the PhotoAccessLink found by the `where` argument doesn't exist, create a new PhotoAccessLink with this data.
     */
    create: XOR<PhotoAccessLinkCreateInput, PhotoAccessLinkUncheckedCreateInput>
    /**
     * In case the PhotoAccessLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoAccessLinkUpdateInput, PhotoAccessLinkUncheckedUpdateInput>
  }

  /**
   * PhotoAccessLink delete
   */
  export type PhotoAccessLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
    /**
     * Filter which PhotoAccessLink to delete.
     */
    where: PhotoAccessLinkWhereUniqueInput
  }

  /**
   * PhotoAccessLink deleteMany
   */
  export type PhotoAccessLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotoAccessLinks to delete
     */
    where?: PhotoAccessLinkWhereInput
  }

  /**
   * PhotoAccessLink without action
   */
  export type PhotoAccessLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoAccessLink
     */
    select?: PhotoAccessLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoAccessLink
     */
    omit?: PhotoAccessLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoAccessLinkInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    organizationId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    organizationId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    key: string | null
    projectId: number | null
    organizationId: number | null
    includeInReport: boolean | null
    description: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    key: string | null
    projectId: number | null
    organizationId: number | null
    includeInReport: boolean | null
    description: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    key: number
    projectId: number
    organizationId: number
    includeInReport: number
    description: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    projectId?: true
    organizationId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    projectId?: true
    organizationId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    key?: true
    projectId?: true
    organizationId?: true
    includeInReport?: true
    description?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    key: string
    projectId: number
    organizationId: number | null
    includeInReport: boolean
    description: string | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    key?: boolean
    projectId?: boolean
    organizationId?: boolean
    includeInReport?: boolean
    description?: boolean
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inference?: boolean | Image$inferenceArgs<ExtArgs>
    ImageNote?: boolean | Image$ImageNoteArgs<ExtArgs>
    Annotation?: boolean | Image$AnnotationArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    key?: boolean
    projectId?: boolean
    organizationId?: boolean
    includeInReport?: boolean
    description?: boolean
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    key?: boolean
    projectId?: boolean
    organizationId?: boolean
    includeInReport?: boolean
    description?: boolean
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    key?: boolean
    projectId?: boolean
    organizationId?: boolean
    includeInReport?: boolean
    description?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "publicId" | "key" | "projectId" | "organizationId" | "includeInReport" | "description", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inference?: boolean | Image$inferenceArgs<ExtArgs>
    ImageNote?: boolean | Image$ImageNoteArgs<ExtArgs>
    Annotation?: boolean | Image$AnnotationArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Image$organizationArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
      inference: Prisma.$InferencePayload<ExtArgs> | null
      ImageNote: Prisma.$ImageNotePayload<ExtArgs>[]
      Annotation: Prisma.$AnnotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      publicId: string
      key: string
      projectId: number
      organizationId: number | null
      includeInReport: boolean
      description: string | null
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Image$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Image$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    inference<T extends Image$inferenceArgs<ExtArgs> = {}>(args?: Subset<T, Image$inferenceArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ImageNote<T extends Image$ImageNoteArgs<ExtArgs> = {}>(args?: Subset<T, Image$ImageNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Annotation<T extends Image$AnnotationArgs<ExtArgs> = {}>(args?: Subset<T, Image$AnnotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly isDeleted: FieldRef<"Image", 'Boolean'>
    readonly publicId: FieldRef<"Image", 'String'>
    readonly key: FieldRef<"Image", 'String'>
    readonly projectId: FieldRef<"Image", 'Int'>
    readonly organizationId: FieldRef<"Image", 'Int'>
    readonly includeInReport: FieldRef<"Image", 'Boolean'>
    readonly description: FieldRef<"Image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }

  /**
   * Image.organization
   */
  export type Image$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Image.inference
   */
  export type Image$inferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    where?: InferenceWhereInput
  }

  /**
   * Image.ImageNote
   */
  export type Image$ImageNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    where?: ImageNoteWhereInput
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    cursor?: ImageNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageNoteScalarFieldEnum | ImageNoteScalarFieldEnum[]
  }

  /**
   * Image.Annotation
   */
  export type Image$AnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Annotation
   */

  export type AggregateAnnotation = {
    _count: AnnotationCountAggregateOutputType | null
    _avg: AnnotationAvgAggregateOutputType | null
    _sum: AnnotationSumAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  export type AnnotationAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type AnnotationSumAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type AnnotationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type AnnotationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type AnnotationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    imageId: number
    coordinates: number
    userId: number
    isDeleted: number
    _all: number
  }


  export type AnnotationAvgAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type AnnotationSumAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type AnnotationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    userId?: true
    isDeleted?: true
  }

  export type AnnotationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    userId?: true
    isDeleted?: true
  }

  export type AnnotationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    coordinates?: true
    userId?: true
    isDeleted?: true
    _all?: true
  }

  export type AnnotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotation to aggregate.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annotations
    **/
    _count?: true | AnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationMaxAggregateInputType
  }

  export type GetAnnotationAggregateType<T extends AnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotation[P]>
      : GetScalarType<T[P], AggregateAnnotation[P]>
  }




  export type AnnotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithAggregationInput | AnnotationOrderByWithAggregationInput[]
    by: AnnotationScalarFieldEnum[] | AnnotationScalarFieldEnum
    having?: AnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationCountAggregateInputType | true
    _avg?: AnnotationAvgAggregateInputType
    _sum?: AnnotationSumAggregateInputType
    _min?: AnnotationMinAggregateInputType
    _max?: AnnotationMaxAggregateInputType
  }

  export type AnnotationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    imageId: number
    coordinates: JsonValue
    userId: string
    isDeleted: boolean
    _count: AnnotationCountAggregateOutputType | null
    _avg: AnnotationAvgAggregateOutputType | null
    _sum: AnnotationSumAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  type GetAnnotationGroupByPayload<T extends AnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    coordinates?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    coordinates?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    coordinates?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    coordinates?: boolean
    userId?: boolean
    isDeleted?: boolean
  }

  export type AnnotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "imageId" | "coordinates" | "userId" | "isDeleted", ExtArgs["result"]["annotation"]>
  export type AnnotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Annotation"
    objects: {
      Image: Prisma.$ImagePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      imageId: number
      coordinates: Prisma.JsonValue
      userId: string
      isDeleted: boolean
    }, ExtArgs["result"]["annotation"]>
    composites: {}
  }

  type AnnotationGetPayload<S extends boolean | null | undefined | AnnotationDefaultArgs> = $Result.GetResult<Prisma.$AnnotationPayload, S>

  type AnnotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnotationCountAggregateInputType | true
    }

  export interface AnnotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Annotation'], meta: { name: 'Annotation' } }
    /**
     * Find zero or one Annotation that matches the filter.
     * @param {AnnotationFindUniqueArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnotationFindUniqueArgs>(args: SelectSubset<T, AnnotationFindUniqueArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Annotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnotationFindUniqueOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnotationFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Annotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnotationFindFirstArgs>(args?: SelectSubset<T, AnnotationFindFirstArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Annotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnotationFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Annotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annotations
     * const annotations = await prisma.annotation.findMany()
     * 
     * // Get first 10 Annotations
     * const annotations = await prisma.annotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationWithIdOnly = await prisma.annotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnotationFindManyArgs>(args?: SelectSubset<T, AnnotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Annotation.
     * @param {AnnotationCreateArgs} args - Arguments to create a Annotation.
     * @example
     * // Create one Annotation
     * const Annotation = await prisma.annotation.create({
     *   data: {
     *     // ... data to create a Annotation
     *   }
     * })
     * 
     */
    create<T extends AnnotationCreateArgs>(args: SelectSubset<T, AnnotationCreateArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Annotations.
     * @param {AnnotationCreateManyArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnotationCreateManyArgs>(args?: SelectSubset<T, AnnotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Annotations and returns the data saved in the database.
     * @param {AnnotationCreateManyAndReturnArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Annotations and only return the `id`
     * const annotationWithIdOnly = await prisma.annotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnotationCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Annotation.
     * @param {AnnotationDeleteArgs} args - Arguments to delete one Annotation.
     * @example
     * // Delete one Annotation
     * const Annotation = await prisma.annotation.delete({
     *   where: {
     *     // ... filter to delete one Annotation
     *   }
     * })
     * 
     */
    delete<T extends AnnotationDeleteArgs>(args: SelectSubset<T, AnnotationDeleteArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Annotation.
     * @param {AnnotationUpdateArgs} args - Arguments to update one Annotation.
     * @example
     * // Update one Annotation
     * const annotation = await prisma.annotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnotationUpdateArgs>(args: SelectSubset<T, AnnotationUpdateArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Annotations.
     * @param {AnnotationDeleteManyArgs} args - Arguments to filter Annotations to delete.
     * @example
     * // Delete a few Annotations
     * const { count } = await prisma.annotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnotationDeleteManyArgs>(args?: SelectSubset<T, AnnotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnotationUpdateManyArgs>(args: SelectSubset<T, AnnotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations and returns the data updated in the database.
     * @param {AnnotationUpdateManyAndReturnArgs} args - Arguments to update many Annotations.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Annotations and only return the `id`
     * const annotationWithIdOnly = await prisma.annotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnotationUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Annotation.
     * @param {AnnotationUpsertArgs} args - Arguments to update or create a Annotation.
     * @example
     * // Update or create a Annotation
     * const annotation = await prisma.annotation.upsert({
     *   create: {
     *     // ... data to create a Annotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annotation we want to update
     *   }
     * })
     */
    upsert<T extends AnnotationUpsertArgs>(args: SelectSubset<T, AnnotationUpsertArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationCountArgs} args - Arguments to filter Annotations to count.
     * @example
     * // Count the number of Annotations
     * const count = await prisma.annotation.count({
     *   where: {
     *     // ... the filter for the Annotations we want to count
     *   }
     * })
    **/
    count<T extends AnnotationCountArgs>(
      args?: Subset<T, AnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationAggregateArgs>(args: Subset<T, AnnotationAggregateArgs>): Prisma.PrismaPromise<GetAnnotationAggregateType<T>>

    /**
     * Group by Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Annotation model
   */
  readonly fields: AnnotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Annotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Image<T extends ImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImageDefaultArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Annotation model
   */ 
  interface AnnotationFieldRefs {
    readonly id: FieldRef<"Annotation", 'Int'>
    readonly createdAt: FieldRef<"Annotation", 'DateTime'>
    readonly updatedAt: FieldRef<"Annotation", 'DateTime'>
    readonly imageId: FieldRef<"Annotation", 'Int'>
    readonly coordinates: FieldRef<"Annotation", 'Json'>
    readonly userId: FieldRef<"Annotation", 'String'>
    readonly isDeleted: FieldRef<"Annotation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Annotation findUnique
   */
  export type AnnotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findUniqueOrThrow
   */
  export type AnnotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findFirst
   */
  export type AnnotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findFirstOrThrow
   */
  export type AnnotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findMany
   */
  export type AnnotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotations to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation create
   */
  export type AnnotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Annotation.
     */
    data: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
  }

  /**
   * Annotation createMany
   */
  export type AnnotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Annotation createManyAndReturn
   */
  export type AnnotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Annotation update
   */
  export type AnnotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Annotation.
     */
    data: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
    /**
     * Choose, which Annotation to update.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation updateMany
   */
  export type AnnotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
  }

  /**
   * Annotation updateManyAndReturn
   */
  export type AnnotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Annotation upsert
   */
  export type AnnotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Annotation to update in case it exists.
     */
    where: AnnotationWhereUniqueInput
    /**
     * In case the Annotation found by the `where` argument doesn't exist, create a new Annotation with this data.
     */
    create: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
    /**
     * In case the Annotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
  }

  /**
   * Annotation delete
   */
  export type AnnotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter which Annotation to delete.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation deleteMany
   */
  export type AnnotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotations to delete
     */
    where?: AnnotationWhereInput
  }

  /**
   * Annotation without action
   */
  export type AnnotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
  }


  /**
   * Model ImageNote
   */

  export type AggregateImageNote = {
    _count: ImageNoteCountAggregateOutputType | null
    _avg: ImageNoteAvgAggregateOutputType | null
    _sum: ImageNoteSumAggregateOutputType | null
    _min: ImageNoteMinAggregateOutputType | null
    _max: ImageNoteMaxAggregateOutputType | null
  }

  export type ImageNoteAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type ImageNoteSumAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type ImageNoteMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    body: string | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type ImageNoteMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    imageId: number | null
    body: string | null
    userId: string | null
    isDeleted: boolean | null
  }

  export type ImageNoteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    imageId: number
    body: number
    mentions: number
    userId: number
    isDeleted: number
    _all: number
  }


  export type ImageNoteAvgAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type ImageNoteSumAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type ImageNoteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    userId?: true
    isDeleted?: true
  }

  export type ImageNoteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    userId?: true
    isDeleted?: true
  }

  export type ImageNoteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    imageId?: true
    body?: true
    mentions?: true
    userId?: true
    isDeleted?: true
    _all?: true
  }

  export type ImageNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageNote to aggregate.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageNotes
    **/
    _count?: true | ImageNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageNoteMaxAggregateInputType
  }

  export type GetImageNoteAggregateType<T extends ImageNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateImageNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageNote[P]>
      : GetScalarType<T[P], AggregateImageNote[P]>
  }




  export type ImageNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageNoteWhereInput
    orderBy?: ImageNoteOrderByWithAggregationInput | ImageNoteOrderByWithAggregationInput[]
    by: ImageNoteScalarFieldEnum[] | ImageNoteScalarFieldEnum
    having?: ImageNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageNoteCountAggregateInputType | true
    _avg?: ImageNoteAvgAggregateInputType
    _sum?: ImageNoteSumAggregateInputType
    _min?: ImageNoteMinAggregateInputType
    _max?: ImageNoteMaxAggregateInputType
  }

  export type ImageNoteGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    imageId: number
    body: string
    mentions: string[]
    userId: string
    isDeleted: boolean
    _count: ImageNoteCountAggregateOutputType | null
    _avg: ImageNoteAvgAggregateOutputType | null
    _sum: ImageNoteSumAggregateOutputType | null
    _min: ImageNoteMinAggregateOutputType | null
    _max: ImageNoteMaxAggregateOutputType | null
  }

  type GetImageNoteGroupByPayload<T extends ImageNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ImageNoteGroupByOutputType[P]>
        }
      >
    >


  export type ImageNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageNote"]>

  export type ImageNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageNote"]>

  export type ImageNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    isDeleted?: boolean
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageNote"]>

  export type ImageNoteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageId?: boolean
    body?: boolean
    mentions?: boolean
    userId?: boolean
    isDeleted?: boolean
  }

  export type ImageNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "imageId" | "body" | "mentions" | "userId" | "isDeleted", ExtArgs["result"]["imageNote"]>
  export type ImageNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ImageNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ImageNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Image?: boolean | ImageDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ImageNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageNote"
    objects: {
      Image: Prisma.$ImagePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      imageId: number
      body: string
      mentions: string[]
      userId: string
      isDeleted: boolean
    }, ExtArgs["result"]["imageNote"]>
    composites: {}
  }

  type ImageNoteGetPayload<S extends boolean | null | undefined | ImageNoteDefaultArgs> = $Result.GetResult<Prisma.$ImageNotePayload, S>

  type ImageNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageNoteCountAggregateInputType | true
    }

  export interface ImageNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageNote'], meta: { name: 'ImageNote' } }
    /**
     * Find zero or one ImageNote that matches the filter.
     * @param {ImageNoteFindUniqueArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageNoteFindUniqueArgs>(args: SelectSubset<T, ImageNoteFindUniqueArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ImageNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageNoteFindUniqueOrThrowArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ImageNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindFirstArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageNoteFindFirstArgs>(args?: SelectSubset<T, ImageNoteFindFirstArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ImageNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindFirstOrThrowArgs} args - Arguments to find a ImageNote
     * @example
     * // Get one ImageNote
     * const imageNote = await prisma.imageNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ImageNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageNotes
     * const imageNotes = await prisma.imageNote.findMany()
     * 
     * // Get first 10 ImageNotes
     * const imageNotes = await prisma.imageNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageNoteWithIdOnly = await prisma.imageNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageNoteFindManyArgs>(args?: SelectSubset<T, ImageNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ImageNote.
     * @param {ImageNoteCreateArgs} args - Arguments to create a ImageNote.
     * @example
     * // Create one ImageNote
     * const ImageNote = await prisma.imageNote.create({
     *   data: {
     *     // ... data to create a ImageNote
     *   }
     * })
     * 
     */
    create<T extends ImageNoteCreateArgs>(args: SelectSubset<T, ImageNoteCreateArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ImageNotes.
     * @param {ImageNoteCreateManyArgs} args - Arguments to create many ImageNotes.
     * @example
     * // Create many ImageNotes
     * const imageNote = await prisma.imageNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageNoteCreateManyArgs>(args?: SelectSubset<T, ImageNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImageNotes and returns the data saved in the database.
     * @param {ImageNoteCreateManyAndReturnArgs} args - Arguments to create many ImageNotes.
     * @example
     * // Create many ImageNotes
     * const imageNote = await prisma.imageNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImageNotes and only return the `id`
     * const imageNoteWithIdOnly = await prisma.imageNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ImageNote.
     * @param {ImageNoteDeleteArgs} args - Arguments to delete one ImageNote.
     * @example
     * // Delete one ImageNote
     * const ImageNote = await prisma.imageNote.delete({
     *   where: {
     *     // ... filter to delete one ImageNote
     *   }
     * })
     * 
     */
    delete<T extends ImageNoteDeleteArgs>(args: SelectSubset<T, ImageNoteDeleteArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ImageNote.
     * @param {ImageNoteUpdateArgs} args - Arguments to update one ImageNote.
     * @example
     * // Update one ImageNote
     * const imageNote = await prisma.imageNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageNoteUpdateArgs>(args: SelectSubset<T, ImageNoteUpdateArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ImageNotes.
     * @param {ImageNoteDeleteManyArgs} args - Arguments to filter ImageNotes to delete.
     * @example
     * // Delete a few ImageNotes
     * const { count } = await prisma.imageNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageNoteDeleteManyArgs>(args?: SelectSubset<T, ImageNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageNotes
     * const imageNote = await prisma.imageNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageNoteUpdateManyArgs>(args: SelectSubset<T, ImageNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageNotes and returns the data updated in the database.
     * @param {ImageNoteUpdateManyAndReturnArgs} args - Arguments to update many ImageNotes.
     * @example
     * // Update many ImageNotes
     * const imageNote = await prisma.imageNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImageNotes and only return the `id`
     * const imageNoteWithIdOnly = await prisma.imageNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ImageNote.
     * @param {ImageNoteUpsertArgs} args - Arguments to update or create a ImageNote.
     * @example
     * // Update or create a ImageNote
     * const imageNote = await prisma.imageNote.upsert({
     *   create: {
     *     // ... data to create a ImageNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageNote we want to update
     *   }
     * })
     */
    upsert<T extends ImageNoteUpsertArgs>(args: SelectSubset<T, ImageNoteUpsertArgs<ExtArgs>>): Prisma__ImageNoteClient<$Result.GetResult<Prisma.$ImageNotePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ImageNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteCountArgs} args - Arguments to filter ImageNotes to count.
     * @example
     * // Count the number of ImageNotes
     * const count = await prisma.imageNote.count({
     *   where: {
     *     // ... the filter for the ImageNotes we want to count
     *   }
     * })
    **/
    count<T extends ImageNoteCountArgs>(
      args?: Subset<T, ImageNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageNoteAggregateArgs>(args: Subset<T, ImageNoteAggregateArgs>): Prisma.PrismaPromise<GetImageNoteAggregateType<T>>

    /**
     * Group by ImageNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageNoteGroupByArgs['orderBy'] }
        : { orderBy?: ImageNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageNote model
   */
  readonly fields: ImageNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Image<T extends ImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImageDefaultArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageNote model
   */ 
  interface ImageNoteFieldRefs {
    readonly id: FieldRef<"ImageNote", 'Int'>
    readonly createdAt: FieldRef<"ImageNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ImageNote", 'DateTime'>
    readonly imageId: FieldRef<"ImageNote", 'Int'>
    readonly body: FieldRef<"ImageNote", 'String'>
    readonly mentions: FieldRef<"ImageNote", 'String[]'>
    readonly userId: FieldRef<"ImageNote", 'String'>
    readonly isDeleted: FieldRef<"ImageNote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ImageNote findUnique
   */
  export type ImageNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where: ImageNoteWhereUniqueInput
  }

  /**
   * ImageNote findUniqueOrThrow
   */
  export type ImageNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where: ImageNoteWhereUniqueInput
  }

  /**
   * ImageNote findFirst
   */
  export type ImageNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageNotes.
     */
    distinct?: ImageNoteScalarFieldEnum | ImageNoteScalarFieldEnum[]
  }

  /**
   * ImageNote findFirstOrThrow
   */
  export type ImageNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter, which ImageNote to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageNotes.
     */
    distinct?: ImageNoteScalarFieldEnum | ImageNoteScalarFieldEnum[]
  }

  /**
   * ImageNote findMany
   */
  export type ImageNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter, which ImageNotes to fetch.
     */
    where?: ImageNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageNotes to fetch.
     */
    orderBy?: ImageNoteOrderByWithRelationInput | ImageNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageNotes.
     */
    cursor?: ImageNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageNotes.
     */
    skip?: number
    distinct?: ImageNoteScalarFieldEnum | ImageNoteScalarFieldEnum[]
  }

  /**
   * ImageNote create
   */
  export type ImageNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ImageNote.
     */
    data: XOR<ImageNoteCreateInput, ImageNoteUncheckedCreateInput>
  }

  /**
   * ImageNote createMany
   */
  export type ImageNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageNotes.
     */
    data: ImageNoteCreateManyInput | ImageNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImageNote createManyAndReturn
   */
  export type ImageNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ImageNotes.
     */
    data: ImageNoteCreateManyInput | ImageNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageNote update
   */
  export type ImageNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ImageNote.
     */
    data: XOR<ImageNoteUpdateInput, ImageNoteUncheckedUpdateInput>
    /**
     * Choose, which ImageNote to update.
     */
    where: ImageNoteWhereUniqueInput
  }

  /**
   * ImageNote updateMany
   */
  export type ImageNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageNotes.
     */
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyInput>
    /**
     * Filter which ImageNotes to update
     */
    where?: ImageNoteWhereInput
  }

  /**
   * ImageNote updateManyAndReturn
   */
  export type ImageNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * The data used to update ImageNotes.
     */
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyInput>
    /**
     * Filter which ImageNotes to update
     */
    where?: ImageNoteWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageNote upsert
   */
  export type ImageNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ImageNote to update in case it exists.
     */
    where: ImageNoteWhereUniqueInput
    /**
     * In case the ImageNote found by the `where` argument doesn't exist, create a new ImageNote with this data.
     */
    create: XOR<ImageNoteCreateInput, ImageNoteUncheckedCreateInput>
    /**
     * In case the ImageNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageNoteUpdateInput, ImageNoteUncheckedUpdateInput>
  }

  /**
   * ImageNote delete
   */
  export type ImageNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
    /**
     * Filter which ImageNote to delete.
     */
    where: ImageNoteWhereUniqueInput
  }

  /**
   * ImageNote deleteMany
   */
  export type ImageNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageNotes to delete
     */
    where?: ImageNoteWhereInput
  }

  /**
   * ImageNote without action
   */
  export type ImageNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageNote
     */
    select?: ImageNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageNote
     */
    omit?: ImageNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageNoteInclude<ExtArgs> | null
  }


  /**
   * Model Inference
   */

  export type AggregateInference = {
    _count: InferenceCountAggregateOutputType | null
    _avg: InferenceAvgAggregateOutputType | null
    _sum: InferenceSumAggregateOutputType | null
    _min: InferenceMinAggregateOutputType | null
    _max: InferenceMaxAggregateOutputType | null
  }

  export type InferenceAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceSumAggregateOutputType = {
    id: number | null
    imageId: number | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    imageId: number | null
    imageKey: string | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    imageId: number | null
    imageKey: string | null
    projectId: number | null
    roomId: number | null
  }

  export type InferenceCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    imageId: number
    imageKey: number
    projectId: number
    roomId: number
    _all: number
  }


  export type InferenceAvgAggregateInputType = {
    id?: true
    imageId?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceSumAggregateInputType = {
    id?: true
    imageId?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
  }

  export type InferenceCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    imageId?: true
    imageKey?: true
    projectId?: true
    roomId?: true
    _all?: true
  }

  export type InferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inference to aggregate.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inferences
    **/
    _count?: true | InferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InferenceMaxAggregateInputType
  }

  export type GetInferenceAggregateType<T extends InferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInference[P]>
      : GetScalarType<T[P], AggregateInference[P]>
  }




  export type InferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InferenceWhereInput
    orderBy?: InferenceOrderByWithAggregationInput | InferenceOrderByWithAggregationInput[]
    by: InferenceScalarFieldEnum[] | InferenceScalarFieldEnum
    having?: InferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InferenceCountAggregateInputType | true
    _avg?: InferenceAvgAggregateInputType
    _sum?: InferenceSumAggregateInputType
    _min?: InferenceMinAggregateInputType
    _max?: InferenceMaxAggregateInputType
  }

  export type InferenceGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    imageId: number | null
    imageKey: string | null
    projectId: number
    roomId: number | null
    _count: InferenceCountAggregateOutputType | null
    _avg: InferenceAvgAggregateOutputType | null
    _sum: InferenceSumAggregateOutputType | null
    _min: InferenceMinAggregateOutputType | null
    _max: InferenceMaxAggregateOutputType | null
  }

  type GetInferenceGroupByPayload<T extends InferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InferenceGroupByOutputType[P]>
            : GetScalarType<T[P], InferenceGroupByOutputType[P]>
        }
      >
    >


  export type InferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    imageId?: boolean
    imageKey?: boolean
    projectId?: boolean
    roomId?: boolean
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
    detections?: boolean | Inference$detectionsArgs<ExtArgs>
    _count?: boolean | InferenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inference"]>

  export type InferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    imageId?: boolean
    imageKey?: boolean
    projectId?: boolean
    roomId?: boolean
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
  }, ExtArgs["result"]["inference"]>

  export type InferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    imageId?: boolean
    imageKey?: boolean
    projectId?: boolean
    roomId?: boolean
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
  }, ExtArgs["result"]["inference"]>

  export type InferenceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    imageId?: boolean
    imageKey?: boolean
    projectId?: boolean
    roomId?: boolean
  }

  export type InferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "publicId" | "imageId" | "imageKey" | "projectId" | "roomId", ExtArgs["result"]["inference"]>
  export type InferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
    detections?: boolean | Inference$detectionsArgs<ExtArgs>
    _count?: boolean | InferenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
  }
  export type InferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | Inference$imageArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    room?: boolean | Inference$roomArgs<ExtArgs>
  }

  export type $InferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inference"
    objects: {
      image: Prisma.$ImagePayload<ExtArgs> | null
      Project: Prisma.$ProjectPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs> | null
      detections: Prisma.$DetectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      publicId: string
      imageId: number | null
      imageKey: string | null
      projectId: number
      roomId: number | null
    }, ExtArgs["result"]["inference"]>
    composites: {}
  }

  type InferenceGetPayload<S extends boolean | null | undefined | InferenceDefaultArgs> = $Result.GetResult<Prisma.$InferencePayload, S>

  type InferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InferenceCountAggregateInputType | true
    }

  export interface InferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inference'], meta: { name: 'Inference' } }
    /**
     * Find zero or one Inference that matches the filter.
     * @param {InferenceFindUniqueArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InferenceFindUniqueArgs>(args: SelectSubset<T, InferenceFindUniqueArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Inference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InferenceFindUniqueOrThrowArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, InferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Inference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindFirstArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InferenceFindFirstArgs>(args?: SelectSubset<T, InferenceFindFirstArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Inference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindFirstOrThrowArgs} args - Arguments to find a Inference
     * @example
     * // Get one Inference
     * const inference = await prisma.inference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, InferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Inferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inferences
     * const inferences = await prisma.inference.findMany()
     * 
     * // Get first 10 Inferences
     * const inferences = await prisma.inference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inferenceWithIdOnly = await prisma.inference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InferenceFindManyArgs>(args?: SelectSubset<T, InferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Inference.
     * @param {InferenceCreateArgs} args - Arguments to create a Inference.
     * @example
     * // Create one Inference
     * const Inference = await prisma.inference.create({
     *   data: {
     *     // ... data to create a Inference
     *   }
     * })
     * 
     */
    create<T extends InferenceCreateArgs>(args: SelectSubset<T, InferenceCreateArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Inferences.
     * @param {InferenceCreateManyArgs} args - Arguments to create many Inferences.
     * @example
     * // Create many Inferences
     * const inference = await prisma.inference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InferenceCreateManyArgs>(args?: SelectSubset<T, InferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inferences and returns the data saved in the database.
     * @param {InferenceCreateManyAndReturnArgs} args - Arguments to create many Inferences.
     * @example
     * // Create many Inferences
     * const inference = await prisma.inference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inferences and only return the `id`
     * const inferenceWithIdOnly = await prisma.inference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, InferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Inference.
     * @param {InferenceDeleteArgs} args - Arguments to delete one Inference.
     * @example
     * // Delete one Inference
     * const Inference = await prisma.inference.delete({
     *   where: {
     *     // ... filter to delete one Inference
     *   }
     * })
     * 
     */
    delete<T extends InferenceDeleteArgs>(args: SelectSubset<T, InferenceDeleteArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Inference.
     * @param {InferenceUpdateArgs} args - Arguments to update one Inference.
     * @example
     * // Update one Inference
     * const inference = await prisma.inference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InferenceUpdateArgs>(args: SelectSubset<T, InferenceUpdateArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Inferences.
     * @param {InferenceDeleteManyArgs} args - Arguments to filter Inferences to delete.
     * @example
     * // Delete a few Inferences
     * const { count } = await prisma.inference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InferenceDeleteManyArgs>(args?: SelectSubset<T, InferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inferences
     * const inference = await prisma.inference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InferenceUpdateManyArgs>(args: SelectSubset<T, InferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inferences and returns the data updated in the database.
     * @param {InferenceUpdateManyAndReturnArgs} args - Arguments to update many Inferences.
     * @example
     * // Update many Inferences
     * const inference = await prisma.inference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inferences and only return the `id`
     * const inferenceWithIdOnly = await prisma.inference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, InferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Inference.
     * @param {InferenceUpsertArgs} args - Arguments to update or create a Inference.
     * @example
     * // Update or create a Inference
     * const inference = await prisma.inference.upsert({
     *   create: {
     *     // ... data to create a Inference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inference we want to update
     *   }
     * })
     */
    upsert<T extends InferenceUpsertArgs>(args: SelectSubset<T, InferenceUpsertArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Inferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceCountArgs} args - Arguments to filter Inferences to count.
     * @example
     * // Count the number of Inferences
     * const count = await prisma.inference.count({
     *   where: {
     *     // ... the filter for the Inferences we want to count
     *   }
     * })
    **/
    count<T extends InferenceCountArgs>(
      args?: Subset<T, InferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InferenceAggregateArgs>(args: Subset<T, InferenceAggregateArgs>): Prisma.PrismaPromise<GetInferenceAggregateType<T>>

    /**
     * Group by Inference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InferenceGroupByArgs['orderBy'] }
        : { orderBy?: InferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inference model
   */
  readonly fields: InferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image<T extends Inference$imageArgs<ExtArgs> = {}>(args?: Subset<T, Inference$imageArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    room<T extends Inference$roomArgs<ExtArgs> = {}>(args?: Subset<T, Inference$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    detections<T extends Inference$detectionsArgs<ExtArgs> = {}>(args?: Subset<T, Inference$detectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inference model
   */ 
  interface InferenceFieldRefs {
    readonly id: FieldRef<"Inference", 'Int'>
    readonly createdAt: FieldRef<"Inference", 'DateTime'>
    readonly isDeleted: FieldRef<"Inference", 'Boolean'>
    readonly publicId: FieldRef<"Inference", 'String'>
    readonly imageId: FieldRef<"Inference", 'Int'>
    readonly imageKey: FieldRef<"Inference", 'String'>
    readonly projectId: FieldRef<"Inference", 'Int'>
    readonly roomId: FieldRef<"Inference", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inference findUnique
   */
  export type InferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter, which Inference to fetch.
     */
    where: InferenceWhereUniqueInput
  }

  /**
   * Inference findUniqueOrThrow
   */
  export type InferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter, which Inference to fetch.
     */
    where: InferenceWhereUniqueInput
  }

  /**
   * Inference findFirst
   */
  export type InferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter, which Inference to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inferences.
     */
    distinct?: InferenceScalarFieldEnum | InferenceScalarFieldEnum[]
  }

  /**
   * Inference findFirstOrThrow
   */
  export type InferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter, which Inference to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inferences.
     */
    distinct?: InferenceScalarFieldEnum | InferenceScalarFieldEnum[]
  }

  /**
   * Inference findMany
   */
  export type InferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter, which Inferences to fetch.
     */
    where?: InferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inferences to fetch.
     */
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inferences.
     */
    cursor?: InferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inferences.
     */
    skip?: number
    distinct?: InferenceScalarFieldEnum | InferenceScalarFieldEnum[]
  }

  /**
   * Inference create
   */
  export type InferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Inference.
     */
    data: XOR<InferenceCreateInput, InferenceUncheckedCreateInput>
  }

  /**
   * Inference createMany
   */
  export type InferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inferences.
     */
    data: InferenceCreateManyInput | InferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inference createManyAndReturn
   */
  export type InferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * The data used to create many Inferences.
     */
    data: InferenceCreateManyInput | InferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inference update
   */
  export type InferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Inference.
     */
    data: XOR<InferenceUpdateInput, InferenceUncheckedUpdateInput>
    /**
     * Choose, which Inference to update.
     */
    where: InferenceWhereUniqueInput
  }

  /**
   * Inference updateMany
   */
  export type InferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inferences.
     */
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyInput>
    /**
     * Filter which Inferences to update
     */
    where?: InferenceWhereInput
  }

  /**
   * Inference updateManyAndReturn
   */
  export type InferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * The data used to update Inferences.
     */
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyInput>
    /**
     * Filter which Inferences to update
     */
    where?: InferenceWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inference upsert
   */
  export type InferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Inference to update in case it exists.
     */
    where: InferenceWhereUniqueInput
    /**
     * In case the Inference found by the `where` argument doesn't exist, create a new Inference with this data.
     */
    create: XOR<InferenceCreateInput, InferenceUncheckedCreateInput>
    /**
     * In case the Inference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InferenceUpdateInput, InferenceUncheckedUpdateInput>
  }

  /**
   * Inference delete
   */
  export type InferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    /**
     * Filter which Inference to delete.
     */
    where: InferenceWhereUniqueInput
  }

  /**
   * Inference deleteMany
   */
  export type InferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inferences to delete
     */
    where?: InferenceWhereInput
  }

  /**
   * Inference.image
   */
  export type Inference$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * Inference.room
   */
  export type Inference$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * Inference.detections
   */
  export type Inference$detectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    where?: DetectionWhereInput
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    cursor?: DetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetectionScalarFieldEnum | DetectionScalarFieldEnum[]
  }

  /**
   * Inference without action
   */
  export type InferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    windows: number | null
    doors: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    windows: number | null
    doors: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    name: string | null
    projectId: number | null
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    name: string | null
    projectId: number | null
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    name: number
    projectId: number
    gpp: number
    humidity: number
    dehuReading: number
    temperature: number
    length: number
    width: number
    height: number
    totalSqft: number
    windows: number
    doors: number
    equipmentUsed: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    projectId?: true
    windows?: true
    doors?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    projectId?: true
    windows?: true
    doors?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    name?: true
    projectId?: true
    gpp?: true
    humidity?: true
    dehuReading?: true
    temperature?: true
    length?: true
    width?: true
    height?: true
    totalSqft?: true
    windows?: true
    doors?: true
    equipmentUsed?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    name: string
    projectId: number
    gpp: string | null
    humidity: string | null
    dehuReading: string | null
    temperature: string | null
    length: string | null
    width: string | null
    height: string | null
    totalSqft: string | null
    windows: number | null
    doors: number | null
    equipmentUsed: string[]
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    name?: boolean
    projectId?: boolean
    gpp?: boolean
    humidity?: boolean
    dehuReading?: boolean
    temperature?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    totalSqft?: boolean
    windows?: boolean
    doors?: boolean
    equipmentUsed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detections?: boolean | Room$detectionsArgs<ExtArgs>
    inferences?: boolean | Room$inferencesArgs<ExtArgs>
    templates?: boolean | Room$templatesArgs<ExtArgs>
    roomReadings?: boolean | Room$roomReadingsArgs<ExtArgs>
    areasAffected?: boolean | Room$areasAffectedArgs<ExtArgs>
    notes?: boolean | Room$notesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    name?: boolean
    projectId?: boolean
    gpp?: boolean
    humidity?: boolean
    dehuReading?: boolean
    temperature?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    totalSqft?: boolean
    windows?: boolean
    doors?: boolean
    equipmentUsed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    name?: boolean
    projectId?: boolean
    gpp?: boolean
    humidity?: boolean
    dehuReading?: boolean
    temperature?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    totalSqft?: boolean
    windows?: boolean
    doors?: boolean
    equipmentUsed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    name?: boolean
    projectId?: boolean
    gpp?: boolean
    humidity?: boolean
    dehuReading?: boolean
    temperature?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    totalSqft?: boolean
    windows?: boolean
    doors?: boolean
    equipmentUsed?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "publicId" | "name" | "projectId" | "gpp" | "humidity" | "dehuReading" | "temperature" | "length" | "width" | "height" | "totalSqft" | "windows" | "doors" | "equipmentUsed", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detections?: boolean | Room$detectionsArgs<ExtArgs>
    inferences?: boolean | Room$inferencesArgs<ExtArgs>
    templates?: boolean | Room$templatesArgs<ExtArgs>
    roomReadings?: boolean | Room$roomReadingsArgs<ExtArgs>
    areasAffected?: boolean | Room$areasAffectedArgs<ExtArgs>
    notes?: boolean | Room$notesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      detections: Prisma.$DetectionPayload<ExtArgs>[]
      inferences: Prisma.$InferencePayload<ExtArgs>[]
      templates: Prisma.$TemplatesUsedPayload<ExtArgs>[]
      roomReadings: Prisma.$RoomReadingPayload<ExtArgs>[]
      areasAffected: Prisma.$AreaAffectedPayload<ExtArgs>[]
      notes: Prisma.$NotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      publicId: string
      name: string
      projectId: number
      gpp: string | null
      humidity: string | null
      dehuReading: string | null
      temperature: string | null
      length: string | null
      width: string | null
      height: string | null
      totalSqft: string | null
      windows: number | null
      doors: number | null
      equipmentUsed: string[]
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    detections<T extends Room$detectionsArgs<ExtArgs> = {}>(args?: Subset<T, Room$detectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    inferences<T extends Room$inferencesArgs<ExtArgs> = {}>(args?: Subset<T, Room$inferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    templates<T extends Room$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Room$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    roomReadings<T extends Room$roomReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Room$roomReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    areasAffected<T extends Room$areasAffectedArgs<ExtArgs> = {}>(args?: Subset<T, Room$areasAffectedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends Room$notesArgs<ExtArgs> = {}>(args?: Subset<T, Room$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly isDeleted: FieldRef<"Room", 'Boolean'>
    readonly publicId: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly projectId: FieldRef<"Room", 'Int'>
    readonly gpp: FieldRef<"Room", 'String'>
    readonly humidity: FieldRef<"Room", 'String'>
    readonly dehuReading: FieldRef<"Room", 'String'>
    readonly temperature: FieldRef<"Room", 'String'>
    readonly length: FieldRef<"Room", 'String'>
    readonly width: FieldRef<"Room", 'String'>
    readonly height: FieldRef<"Room", 'String'>
    readonly totalSqft: FieldRef<"Room", 'String'>
    readonly windows: FieldRef<"Room", 'Int'>
    readonly doors: FieldRef<"Room", 'Int'>
    readonly equipmentUsed: FieldRef<"Room", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.detections
   */
  export type Room$detectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    where?: DetectionWhereInput
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    cursor?: DetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetectionScalarFieldEnum | DetectionScalarFieldEnum[]
  }

  /**
   * Room.inferences
   */
  export type Room$inferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inference
     */
    select?: InferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inference
     */
    omit?: InferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InferenceInclude<ExtArgs> | null
    where?: InferenceWhereInput
    orderBy?: InferenceOrderByWithRelationInput | InferenceOrderByWithRelationInput[]
    cursor?: InferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InferenceScalarFieldEnum | InferenceScalarFieldEnum[]
  }

  /**
   * Room.templates
   */
  export type Room$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    where?: TemplatesUsedWhereInput
    orderBy?: TemplatesUsedOrderByWithRelationInput | TemplatesUsedOrderByWithRelationInput[]
    cursor?: TemplatesUsedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplatesUsedScalarFieldEnum | TemplatesUsedScalarFieldEnum[]
  }

  /**
   * Room.roomReadings
   */
  export type Room$roomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    where?: RoomReadingWhereInput
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    cursor?: RoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomReadingScalarFieldEnum | RoomReadingScalarFieldEnum[]
  }

  /**
   * Room.areasAffected
   */
  export type Room$areasAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    where?: AreaAffectedWhereInput
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    cursor?: AreaAffectedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaAffectedScalarFieldEnum | AreaAffectedScalarFieldEnum[]
  }

  /**
   * Room.notes
   */
  export type Room$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model RoomReading
   */

  export type AggregateRoomReading = {
    _count: RoomReadingCountAggregateOutputType | null
    _avg: RoomReadingAvgAggregateOutputType | null
    _sum: RoomReadingSumAggregateOutputType | null
    _min: RoomReadingMinAggregateOutputType | null
    _max: RoomReadingMaxAggregateOutputType | null
  }

  export type RoomReadingAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type RoomReadingSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type RoomReadingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    gpp: string | null
  }

  export type RoomReadingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    gpp: string | null
  }

  export type RoomReadingCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    humidity: number
    temperature: number
    moistureContentWall: number
    moistureContentFloor: number
    equipmentUsed: number
    roomId: number
    isDeleted: number
    publicId: number
    projectId: number
    gpp: number
    _all: number
  }


  export type RoomReadingAvgAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type RoomReadingSumAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type RoomReadingMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
  }

  export type RoomReadingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
  }

  export type RoomReadingCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    humidity?: true
    temperature?: true
    moistureContentWall?: true
    moistureContentFloor?: true
    equipmentUsed?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    gpp?: true
    _all?: true
  }

  export type RoomReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomReading to aggregate.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomReadings
    **/
    _count?: true | RoomReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomReadingMaxAggregateInputType
  }

  export type GetRoomReadingAggregateType<T extends RoomReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomReading[P]>
      : GetScalarType<T[P], AggregateRoomReading[P]>
  }




  export type RoomReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomReadingWhereInput
    orderBy?: RoomReadingOrderByWithAggregationInput | RoomReadingOrderByWithAggregationInput[]
    by: RoomReadingScalarFieldEnum[] | RoomReadingScalarFieldEnum
    having?: RoomReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomReadingCountAggregateInputType | true
    _avg?: RoomReadingAvgAggregateInputType
    _sum?: RoomReadingSumAggregateInputType
    _min?: RoomReadingMinAggregateInputType
    _max?: RoomReadingMaxAggregateInputType
  }

  export type RoomReadingGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    humidity: string | null
    temperature: string | null
    moistureContentWall: string | null
    moistureContentFloor: string | null
    equipmentUsed: string[]
    roomId: number
    isDeleted: boolean
    publicId: string
    projectId: number
    gpp: string | null
    _count: RoomReadingCountAggregateOutputType | null
    _avg: RoomReadingAvgAggregateOutputType | null
    _sum: RoomReadingSumAggregateOutputType | null
    _min: RoomReadingMinAggregateOutputType | null
    _max: RoomReadingMaxAggregateOutputType | null
  }

  type GetRoomReadingGroupByPayload<T extends RoomReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomReadingGroupByOutputType[P]>
            : GetScalarType<T[P], RoomReadingGroupByOutputType[P]>
        }
      >
    >


  export type RoomReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    humidity?: boolean
    temperature?: boolean
    moistureContentWall?: boolean
    moistureContentFloor?: boolean
    equipmentUsed?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    gpp?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    genericRoomReadings?: boolean | RoomReading$genericRoomReadingsArgs<ExtArgs>
    _count?: boolean | RoomReadingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomReading"]>

  export type RoomReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    humidity?: boolean
    temperature?: boolean
    moistureContentWall?: boolean
    moistureContentFloor?: boolean
    equipmentUsed?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    gpp?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomReading"]>

  export type RoomReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    humidity?: boolean
    temperature?: boolean
    moistureContentWall?: boolean
    moistureContentFloor?: boolean
    equipmentUsed?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    gpp?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomReading"]>

  export type RoomReadingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    humidity?: boolean
    temperature?: boolean
    moistureContentWall?: boolean
    moistureContentFloor?: boolean
    equipmentUsed?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    gpp?: boolean
  }

  export type RoomReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "date" | "humidity" | "temperature" | "moistureContentWall" | "moistureContentFloor" | "equipmentUsed" | "roomId" | "isDeleted" | "publicId" | "projectId" | "gpp", ExtArgs["result"]["roomReading"]>
  export type RoomReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    genericRoomReadings?: boolean | RoomReading$genericRoomReadingsArgs<ExtArgs>
    _count?: boolean | RoomReadingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type RoomReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $RoomReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomReading"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      genericRoomReadings: Prisma.$GenericRoomReadingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      date: Date
      humidity: string | null
      temperature: string | null
      moistureContentWall: string | null
      moistureContentFloor: string | null
      equipmentUsed: string[]
      roomId: number
      isDeleted: boolean
      publicId: string
      projectId: number
      gpp: string | null
    }, ExtArgs["result"]["roomReading"]>
    composites: {}
  }

  type RoomReadingGetPayload<S extends boolean | null | undefined | RoomReadingDefaultArgs> = $Result.GetResult<Prisma.$RoomReadingPayload, S>

  type RoomReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomReadingCountAggregateInputType | true
    }

  export interface RoomReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomReading'], meta: { name: 'RoomReading' } }
    /**
     * Find zero or one RoomReading that matches the filter.
     * @param {RoomReadingFindUniqueArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomReadingFindUniqueArgs>(args: SelectSubset<T, RoomReadingFindUniqueArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RoomReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomReadingFindUniqueOrThrowArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RoomReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindFirstArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomReadingFindFirstArgs>(args?: SelectSubset<T, RoomReadingFindFirstArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RoomReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindFirstOrThrowArgs} args - Arguments to find a RoomReading
     * @example
     * // Get one RoomReading
     * const roomReading = await prisma.roomReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RoomReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomReadings
     * const roomReadings = await prisma.roomReading.findMany()
     * 
     * // Get first 10 RoomReadings
     * const roomReadings = await prisma.roomReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomReadingWithIdOnly = await prisma.roomReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomReadingFindManyArgs>(args?: SelectSubset<T, RoomReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RoomReading.
     * @param {RoomReadingCreateArgs} args - Arguments to create a RoomReading.
     * @example
     * // Create one RoomReading
     * const RoomReading = await prisma.roomReading.create({
     *   data: {
     *     // ... data to create a RoomReading
     *   }
     * })
     * 
     */
    create<T extends RoomReadingCreateArgs>(args: SelectSubset<T, RoomReadingCreateArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RoomReadings.
     * @param {RoomReadingCreateManyArgs} args - Arguments to create many RoomReadings.
     * @example
     * // Create many RoomReadings
     * const roomReading = await prisma.roomReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomReadingCreateManyArgs>(args?: SelectSubset<T, RoomReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomReadings and returns the data saved in the database.
     * @param {RoomReadingCreateManyAndReturnArgs} args - Arguments to create many RoomReadings.
     * @example
     * // Create many RoomReadings
     * const roomReading = await prisma.roomReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomReadings and only return the `id`
     * const roomReadingWithIdOnly = await prisma.roomReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RoomReading.
     * @param {RoomReadingDeleteArgs} args - Arguments to delete one RoomReading.
     * @example
     * // Delete one RoomReading
     * const RoomReading = await prisma.roomReading.delete({
     *   where: {
     *     // ... filter to delete one RoomReading
     *   }
     * })
     * 
     */
    delete<T extends RoomReadingDeleteArgs>(args: SelectSubset<T, RoomReadingDeleteArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RoomReading.
     * @param {RoomReadingUpdateArgs} args - Arguments to update one RoomReading.
     * @example
     * // Update one RoomReading
     * const roomReading = await prisma.roomReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomReadingUpdateArgs>(args: SelectSubset<T, RoomReadingUpdateArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RoomReadings.
     * @param {RoomReadingDeleteManyArgs} args - Arguments to filter RoomReadings to delete.
     * @example
     * // Delete a few RoomReadings
     * const { count } = await prisma.roomReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomReadingDeleteManyArgs>(args?: SelectSubset<T, RoomReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomReadings
     * const roomReading = await prisma.roomReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomReadingUpdateManyArgs>(args: SelectSubset<T, RoomReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomReadings and returns the data updated in the database.
     * @param {RoomReadingUpdateManyAndReturnArgs} args - Arguments to update many RoomReadings.
     * @example
     * // Update many RoomReadings
     * const roomReading = await prisma.roomReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomReadings and only return the `id`
     * const roomReadingWithIdOnly = await prisma.roomReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RoomReading.
     * @param {RoomReadingUpsertArgs} args - Arguments to update or create a RoomReading.
     * @example
     * // Update or create a RoomReading
     * const roomReading = await prisma.roomReading.upsert({
     *   create: {
     *     // ... data to create a RoomReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomReading we want to update
     *   }
     * })
     */
    upsert<T extends RoomReadingUpsertArgs>(args: SelectSubset<T, RoomReadingUpsertArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingCountArgs} args - Arguments to filter RoomReadings to count.
     * @example
     * // Count the number of RoomReadings
     * const count = await prisma.roomReading.count({
     *   where: {
     *     // ... the filter for the RoomReadings we want to count
     *   }
     * })
    **/
    count<T extends RoomReadingCountArgs>(
      args?: Subset<T, RoomReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomReadingAggregateArgs>(args: Subset<T, RoomReadingAggregateArgs>): Prisma.PrismaPromise<GetRoomReadingAggregateType<T>>

    /**
     * Group by RoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomReadingGroupByArgs['orderBy'] }
        : { orderBy?: RoomReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomReading model
   */
  readonly fields: RoomReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    genericRoomReadings<T extends RoomReading$genericRoomReadingsArgs<ExtArgs> = {}>(args?: Subset<T, RoomReading$genericRoomReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomReading model
   */ 
  interface RoomReadingFieldRefs {
    readonly id: FieldRef<"RoomReading", 'Int'>
    readonly createdAt: FieldRef<"RoomReading", 'DateTime'>
    readonly date: FieldRef<"RoomReading", 'DateTime'>
    readonly humidity: FieldRef<"RoomReading", 'String'>
    readonly temperature: FieldRef<"RoomReading", 'String'>
    readonly moistureContentWall: FieldRef<"RoomReading", 'String'>
    readonly moistureContentFloor: FieldRef<"RoomReading", 'String'>
    readonly equipmentUsed: FieldRef<"RoomReading", 'String[]'>
    readonly roomId: FieldRef<"RoomReading", 'Int'>
    readonly isDeleted: FieldRef<"RoomReading", 'Boolean'>
    readonly publicId: FieldRef<"RoomReading", 'String'>
    readonly projectId: FieldRef<"RoomReading", 'Int'>
    readonly gpp: FieldRef<"RoomReading", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomReading findUnique
   */
  export type RoomReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where: RoomReadingWhereUniqueInput
  }

  /**
   * RoomReading findUniqueOrThrow
   */
  export type RoomReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where: RoomReadingWhereUniqueInput
  }

  /**
   * RoomReading findFirst
   */
  export type RoomReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReadings.
     */
    distinct?: RoomReadingScalarFieldEnum | RoomReadingScalarFieldEnum[]
  }

  /**
   * RoomReading findFirstOrThrow
   */
  export type RoomReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which RoomReading to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomReadings.
     */
    distinct?: RoomReadingScalarFieldEnum | RoomReadingScalarFieldEnum[]
  }

  /**
   * RoomReading findMany
   */
  export type RoomReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which RoomReadings to fetch.
     */
    where?: RoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomReadings to fetch.
     */
    orderBy?: RoomReadingOrderByWithRelationInput | RoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomReadings.
     */
    cursor?: RoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomReadings.
     */
    skip?: number
    distinct?: RoomReadingScalarFieldEnum | RoomReadingScalarFieldEnum[]
  }

  /**
   * RoomReading create
   */
  export type RoomReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomReading.
     */
    data: XOR<RoomReadingCreateInput, RoomReadingUncheckedCreateInput>
  }

  /**
   * RoomReading createMany
   */
  export type RoomReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomReadings.
     */
    data: RoomReadingCreateManyInput | RoomReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomReading createManyAndReturn
   */
  export type RoomReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * The data used to create many RoomReadings.
     */
    data: RoomReadingCreateManyInput | RoomReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomReading update
   */
  export type RoomReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomReading.
     */
    data: XOR<RoomReadingUpdateInput, RoomReadingUncheckedUpdateInput>
    /**
     * Choose, which RoomReading to update.
     */
    where: RoomReadingWhereUniqueInput
  }

  /**
   * RoomReading updateMany
   */
  export type RoomReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomReadings.
     */
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which RoomReadings to update
     */
    where?: RoomReadingWhereInput
  }

  /**
   * RoomReading updateManyAndReturn
   */
  export type RoomReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * The data used to update RoomReadings.
     */
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which RoomReadings to update
     */
    where?: RoomReadingWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomReading upsert
   */
  export type RoomReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomReading to update in case it exists.
     */
    where: RoomReadingWhereUniqueInput
    /**
     * In case the RoomReading found by the `where` argument doesn't exist, create a new RoomReading with this data.
     */
    create: XOR<RoomReadingCreateInput, RoomReadingUncheckedCreateInput>
    /**
     * In case the RoomReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomReadingUpdateInput, RoomReadingUncheckedUpdateInput>
  }

  /**
   * RoomReading delete
   */
  export type RoomReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
    /**
     * Filter which RoomReading to delete.
     */
    where: RoomReadingWhereUniqueInput
  }

  /**
   * RoomReading deleteMany
   */
  export type RoomReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomReadings to delete
     */
    where?: RoomReadingWhereInput
  }

  /**
   * RoomReading.genericRoomReadings
   */
  export type RoomReading$genericRoomReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    where?: GenericRoomReadingWhereInput
    orderBy?: GenericRoomReadingOrderByWithRelationInput | GenericRoomReadingOrderByWithRelationInput[]
    cursor?: GenericRoomReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenericRoomReadingScalarFieldEnum | GenericRoomReadingScalarFieldEnum[]
  }

  /**
   * RoomReading without action
   */
  export type RoomReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomReading
     */
    select?: RoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomReading
     */
    omit?: RoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomReadingInclude<ExtArgs> | null
  }


  /**
   * Model Notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    projectId: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    date: Date | null
    roomId: number | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    body: string | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    date: number
    roomId: number
    isDeleted: number
    publicId: number
    projectId: number
    body: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    roomId?: true
    projectId?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    date?: true
    roomId?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    body?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to aggregate.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type NotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithAggregationInput | NotesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: NotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    date: Date
    roomId: number
    isDeleted: boolean
    publicId: string
    projectId: number
    body: string
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends NotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type NotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    notesAuditTrail?: boolean | Notes$notesAuditTrailArgs<ExtArgs>
    _count?: boolean | NotesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    date?: boolean
    roomId?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    body?: boolean
  }

  export type NotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "date" | "roomId" | "isDeleted" | "publicId" | "projectId" | "body", ExtArgs["result"]["notes"]>
  export type NotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    notesAuditTrail?: boolean | Notes$notesAuditTrailArgs<ExtArgs>
    _count?: boolean | NotesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type NotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $NotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notes"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      notesAuditTrail: Prisma.$NotesAuditTrailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      date: Date
      roomId: number
      isDeleted: boolean
      publicId: string
      projectId: number
      body: string
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type NotesGetPayload<S extends boolean | null | undefined | NotesDefaultArgs> = $Result.GetResult<Prisma.$NotesPayload, S>

  type NotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface NotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notes'], meta: { name: 'Notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {NotesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotesFindUniqueArgs>(args: SelectSubset<T, NotesFindUniqueArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotesFindUniqueOrThrowArgs>(args: SelectSubset<T, NotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotesFindFirstArgs>(args?: SelectSubset<T, NotesFindFirstArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotesFindFirstOrThrowArgs>(args?: SelectSubset<T, NotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotesFindManyArgs>(args?: SelectSubset<T, NotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notes.
     * @param {NotesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends NotesCreateArgs>(args: SelectSubset<T, NotesCreateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notes.
     * @param {NotesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotesCreateManyArgs>(args?: SelectSubset<T, NotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NotesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotesCreateManyAndReturnArgs>(args?: SelectSubset<T, NotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notes.
     * @param {NotesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends NotesDeleteArgs>(args: SelectSubset<T, NotesDeleteArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notes.
     * @param {NotesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotesUpdateArgs>(args: SelectSubset<T, NotesUpdateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notes.
     * @param {NotesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotesDeleteManyArgs>(args?: SelectSubset<T, NotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotesUpdateManyArgs>(args: SelectSubset<T, NotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NotesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotesUpdateManyAndReturnArgs>(args: SelectSubset<T, NotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notes.
     * @param {NotesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends NotesUpsertArgs>(args: SelectSubset<T, NotesUpsertArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NotesCountArgs>(
      args?: Subset<T, NotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesGroupByArgs['orderBy'] }
        : { orderBy?: NotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notes model
   */
  readonly fields: NotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    notesAuditTrail<T extends Notes$notesAuditTrailArgs<ExtArgs> = {}>(args?: Subset<T, Notes$notesAuditTrailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notes model
   */ 
  interface NotesFieldRefs {
    readonly id: FieldRef<"Notes", 'Int'>
    readonly createdAt: FieldRef<"Notes", 'DateTime'>
    readonly updatedAt: FieldRef<"Notes", 'DateTime'>
    readonly date: FieldRef<"Notes", 'DateTime'>
    readonly roomId: FieldRef<"Notes", 'Int'>
    readonly isDeleted: FieldRef<"Notes", 'Boolean'>
    readonly publicId: FieldRef<"Notes", 'String'>
    readonly projectId: FieldRef<"Notes", 'Int'>
    readonly body: FieldRef<"Notes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notes findUnique
   */
  export type NotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findUniqueOrThrow
   */
  export type NotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findFirst
   */
  export type NotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findFirstOrThrow
   */
  export type NotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findMany
   */
  export type NotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes create
   */
  export type NotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to create a Notes.
     */
    data: XOR<NotesCreateInput, NotesUncheckedCreateInput>
  }

  /**
   * Notes createMany
   */
  export type NotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notes createManyAndReturn
   */
  export type NotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes update
   */
  export type NotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to update a Notes.
     */
    data: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
    /**
     * Choose, which Notes to update.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes updateMany
   */
  export type NotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
  }

  /**
   * Notes updateManyAndReturn
   */
  export type NotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes upsert
   */
  export type NotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The filter to search for the Notes to update in case it exists.
     */
    where: NotesWhereUniqueInput
    /**
     * In case the Notes found by the `where` argument doesn't exist, create a new Notes with this data.
     */
    create: XOR<NotesCreateInput, NotesUncheckedCreateInput>
    /**
     * In case the Notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
  }

  /**
   * Notes delete
   */
  export type NotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter which Notes to delete.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes deleteMany
   */
  export type NotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NotesWhereInput
  }

  /**
   * Notes.notesAuditTrail
   */
  export type Notes$notesAuditTrailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    where?: NotesAuditTrailWhereInput
    orderBy?: NotesAuditTrailOrderByWithRelationInput | NotesAuditTrailOrderByWithRelationInput[]
    cursor?: NotesAuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesAuditTrailScalarFieldEnum | NotesAuditTrailScalarFieldEnum[]
  }

  /**
   * Notes without action
   */
  export type NotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
  }


  /**
   * Model NotesAuditTrail
   */

  export type AggregateNotesAuditTrail = {
    _count: NotesAuditTrailCountAggregateOutputType | null
    _avg: NotesAuditTrailAvgAggregateOutputType | null
    _sum: NotesAuditTrailSumAggregateOutputType | null
    _min: NotesAuditTrailMinAggregateOutputType | null
    _max: NotesAuditTrailMaxAggregateOutputType | null
  }

  export type NotesAuditTrailAvgAggregateOutputType = {
    id: number | null
    notesId: number | null
  }

  export type NotesAuditTrailSumAggregateOutputType = {
    id: number | null
    notesId: number | null
  }

  export type NotesAuditTrailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    notesId: number | null
    userId: string | null
    userName: string | null
    action: $Enums.NotesAuditAction | null
    body: string | null
  }

  export type NotesAuditTrailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    notesId: number | null
    userId: string | null
    userName: string | null
    action: $Enums.NotesAuditAction | null
    body: string | null
  }

  export type NotesAuditTrailCountAggregateOutputType = {
    id: number
    createdAt: number
    notesId: number
    userId: number
    userName: number
    action: number
    body: number
    _all: number
  }


  export type NotesAuditTrailAvgAggregateInputType = {
    id?: true
    notesId?: true
  }

  export type NotesAuditTrailSumAggregateInputType = {
    id?: true
    notesId?: true
  }

  export type NotesAuditTrailMinAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
  }

  export type NotesAuditTrailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
  }

  export type NotesAuditTrailCountAggregateInputType = {
    id?: true
    createdAt?: true
    notesId?: true
    userId?: true
    userName?: true
    action?: true
    body?: true
    _all?: true
  }

  export type NotesAuditTrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotesAuditTrail to aggregate.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: NotesAuditTrailOrderByWithRelationInput | NotesAuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotesAuditTrails
    **/
    _count?: true | NotesAuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAuditTrailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesAuditTrailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesAuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesAuditTrailMaxAggregateInputType
  }

  export type GetNotesAuditTrailAggregateType<T extends NotesAuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateNotesAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotesAuditTrail[P]>
      : GetScalarType<T[P], AggregateNotesAuditTrail[P]>
  }




  export type NotesAuditTrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesAuditTrailWhereInput
    orderBy?: NotesAuditTrailOrderByWithAggregationInput | NotesAuditTrailOrderByWithAggregationInput[]
    by: NotesAuditTrailScalarFieldEnum[] | NotesAuditTrailScalarFieldEnum
    having?: NotesAuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesAuditTrailCountAggregateInputType | true
    _avg?: NotesAuditTrailAvgAggregateInputType
    _sum?: NotesAuditTrailSumAggregateInputType
    _min?: NotesAuditTrailMinAggregateInputType
    _max?: NotesAuditTrailMaxAggregateInputType
  }

  export type NotesAuditTrailGroupByOutputType = {
    id: number
    createdAt: Date
    notesId: number
    userId: string
    userName: string | null
    action: $Enums.NotesAuditAction
    body: string
    _count: NotesAuditTrailCountAggregateOutputType | null
    _avg: NotesAuditTrailAvgAggregateOutputType | null
    _sum: NotesAuditTrailSumAggregateOutputType | null
    _min: NotesAuditTrailMinAggregateOutputType | null
    _max: NotesAuditTrailMaxAggregateOutputType | null
  }

  type GetNotesAuditTrailGroupByPayload<T extends NotesAuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesAuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesAuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesAuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], NotesAuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type NotesAuditTrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    notesId?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    body?: boolean
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notesAuditTrail"]>

  export type NotesAuditTrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    notesId?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    body?: boolean
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notesAuditTrail"]>

  export type NotesAuditTrailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    notesId?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    body?: boolean
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notesAuditTrail"]>

  export type NotesAuditTrailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    notesId?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    body?: boolean
  }

  export type NotesAuditTrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "notesId" | "userId" | "userName" | "action" | "body", ExtArgs["result"]["notesAuditTrail"]>
  export type NotesAuditTrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }
  export type NotesAuditTrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }
  export type NotesAuditTrailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NotesDefaultArgs<ExtArgs>
  }

  export type $NotesAuditTrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotesAuditTrail"
    objects: {
      note: Prisma.$NotesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      notesId: number
      userId: string
      userName: string | null
      action: $Enums.NotesAuditAction
      body: string
    }, ExtArgs["result"]["notesAuditTrail"]>
    composites: {}
  }

  type NotesAuditTrailGetPayload<S extends boolean | null | undefined | NotesAuditTrailDefaultArgs> = $Result.GetResult<Prisma.$NotesAuditTrailPayload, S>

  type NotesAuditTrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotesAuditTrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesAuditTrailCountAggregateInputType | true
    }

  export interface NotesAuditTrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotesAuditTrail'], meta: { name: 'NotesAuditTrail' } }
    /**
     * Find zero or one NotesAuditTrail that matches the filter.
     * @param {NotesAuditTrailFindUniqueArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotesAuditTrailFindUniqueArgs>(args: SelectSubset<T, NotesAuditTrailFindUniqueArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NotesAuditTrail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotesAuditTrailFindUniqueOrThrowArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotesAuditTrailFindUniqueOrThrowArgs>(args: SelectSubset<T, NotesAuditTrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NotesAuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindFirstArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotesAuditTrailFindFirstArgs>(args?: SelectSubset<T, NotesAuditTrailFindFirstArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NotesAuditTrail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindFirstOrThrowArgs} args - Arguments to find a NotesAuditTrail
     * @example
     * // Get one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotesAuditTrailFindFirstOrThrowArgs>(args?: SelectSubset<T, NotesAuditTrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NotesAuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotesAuditTrails
     * const notesAuditTrails = await prisma.notesAuditTrail.findMany()
     * 
     * // Get first 10 NotesAuditTrails
     * const notesAuditTrails = await prisma.notesAuditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesAuditTrailWithIdOnly = await prisma.notesAuditTrail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotesAuditTrailFindManyArgs>(args?: SelectSubset<T, NotesAuditTrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NotesAuditTrail.
     * @param {NotesAuditTrailCreateArgs} args - Arguments to create a NotesAuditTrail.
     * @example
     * // Create one NotesAuditTrail
     * const NotesAuditTrail = await prisma.notesAuditTrail.create({
     *   data: {
     *     // ... data to create a NotesAuditTrail
     *   }
     * })
     * 
     */
    create<T extends NotesAuditTrailCreateArgs>(args: SelectSubset<T, NotesAuditTrailCreateArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NotesAuditTrails.
     * @param {NotesAuditTrailCreateManyArgs} args - Arguments to create many NotesAuditTrails.
     * @example
     * // Create many NotesAuditTrails
     * const notesAuditTrail = await prisma.notesAuditTrail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotesAuditTrailCreateManyArgs>(args?: SelectSubset<T, NotesAuditTrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotesAuditTrails and returns the data saved in the database.
     * @param {NotesAuditTrailCreateManyAndReturnArgs} args - Arguments to create many NotesAuditTrails.
     * @example
     * // Create many NotesAuditTrails
     * const notesAuditTrail = await prisma.notesAuditTrail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotesAuditTrails and only return the `id`
     * const notesAuditTrailWithIdOnly = await prisma.notesAuditTrail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotesAuditTrailCreateManyAndReturnArgs>(args?: SelectSubset<T, NotesAuditTrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NotesAuditTrail.
     * @param {NotesAuditTrailDeleteArgs} args - Arguments to delete one NotesAuditTrail.
     * @example
     * // Delete one NotesAuditTrail
     * const NotesAuditTrail = await prisma.notesAuditTrail.delete({
     *   where: {
     *     // ... filter to delete one NotesAuditTrail
     *   }
     * })
     * 
     */
    delete<T extends NotesAuditTrailDeleteArgs>(args: SelectSubset<T, NotesAuditTrailDeleteArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NotesAuditTrail.
     * @param {NotesAuditTrailUpdateArgs} args - Arguments to update one NotesAuditTrail.
     * @example
     * // Update one NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotesAuditTrailUpdateArgs>(args: SelectSubset<T, NotesAuditTrailUpdateArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NotesAuditTrails.
     * @param {NotesAuditTrailDeleteManyArgs} args - Arguments to filter NotesAuditTrails to delete.
     * @example
     * // Delete a few NotesAuditTrails
     * const { count } = await prisma.notesAuditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotesAuditTrailDeleteManyArgs>(args?: SelectSubset<T, NotesAuditTrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesAuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotesAuditTrails
     * const notesAuditTrail = await prisma.notesAuditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotesAuditTrailUpdateManyArgs>(args: SelectSubset<T, NotesAuditTrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesAuditTrails and returns the data updated in the database.
     * @param {NotesAuditTrailUpdateManyAndReturnArgs} args - Arguments to update many NotesAuditTrails.
     * @example
     * // Update many NotesAuditTrails
     * const notesAuditTrail = await prisma.notesAuditTrail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotesAuditTrails and only return the `id`
     * const notesAuditTrailWithIdOnly = await prisma.notesAuditTrail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotesAuditTrailUpdateManyAndReturnArgs>(args: SelectSubset<T, NotesAuditTrailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NotesAuditTrail.
     * @param {NotesAuditTrailUpsertArgs} args - Arguments to update or create a NotesAuditTrail.
     * @example
     * // Update or create a NotesAuditTrail
     * const notesAuditTrail = await prisma.notesAuditTrail.upsert({
     *   create: {
     *     // ... data to create a NotesAuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotesAuditTrail we want to update
     *   }
     * })
     */
    upsert<T extends NotesAuditTrailUpsertArgs>(args: SelectSubset<T, NotesAuditTrailUpsertArgs<ExtArgs>>): Prisma__NotesAuditTrailClient<$Result.GetResult<Prisma.$NotesAuditTrailPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NotesAuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailCountArgs} args - Arguments to filter NotesAuditTrails to count.
     * @example
     * // Count the number of NotesAuditTrails
     * const count = await prisma.notesAuditTrail.count({
     *   where: {
     *     // ... the filter for the NotesAuditTrails we want to count
     *   }
     * })
    **/
    count<T extends NotesAuditTrailCountArgs>(
      args?: Subset<T, NotesAuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesAuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotesAuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAuditTrailAggregateArgs>(args: Subset<T, NotesAuditTrailAggregateArgs>): Prisma.PrismaPromise<GetNotesAuditTrailAggregateType<T>>

    /**
     * Group by NotesAuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesAuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesAuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: NotesAuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesAuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotesAuditTrail model
   */
  readonly fields: NotesAuditTrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotesAuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotesAuditTrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends NotesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotesDefaultArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotesAuditTrail model
   */ 
  interface NotesAuditTrailFieldRefs {
    readonly id: FieldRef<"NotesAuditTrail", 'Int'>
    readonly createdAt: FieldRef<"NotesAuditTrail", 'DateTime'>
    readonly notesId: FieldRef<"NotesAuditTrail", 'Int'>
    readonly userId: FieldRef<"NotesAuditTrail", 'String'>
    readonly userName: FieldRef<"NotesAuditTrail", 'String'>
    readonly action: FieldRef<"NotesAuditTrail", 'NotesAuditAction'>
    readonly body: FieldRef<"NotesAuditTrail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotesAuditTrail findUnique
   */
  export type NotesAuditTrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where: NotesAuditTrailWhereUniqueInput
  }

  /**
   * NotesAuditTrail findUniqueOrThrow
   */
  export type NotesAuditTrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where: NotesAuditTrailWhereUniqueInput
  }

  /**
   * NotesAuditTrail findFirst
   */
  export type NotesAuditTrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: NotesAuditTrailOrderByWithRelationInput | NotesAuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesAuditTrails.
     */
    distinct?: NotesAuditTrailScalarFieldEnum | NotesAuditTrailScalarFieldEnum[]
  }

  /**
   * NotesAuditTrail findFirstOrThrow
   */
  export type NotesAuditTrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which NotesAuditTrail to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: NotesAuditTrailOrderByWithRelationInput | NotesAuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotesAuditTrails.
     */
    distinct?: NotesAuditTrailScalarFieldEnum | NotesAuditTrailScalarFieldEnum[]
  }

  /**
   * NotesAuditTrail findMany
   */
  export type NotesAuditTrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which NotesAuditTrails to fetch.
     */
    where?: NotesAuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotesAuditTrails to fetch.
     */
    orderBy?: NotesAuditTrailOrderByWithRelationInput | NotesAuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotesAuditTrails.
     */
    cursor?: NotesAuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotesAuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotesAuditTrails.
     */
    skip?: number
    distinct?: NotesAuditTrailScalarFieldEnum | NotesAuditTrailScalarFieldEnum[]
  }

  /**
   * NotesAuditTrail create
   */
  export type NotesAuditTrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to create a NotesAuditTrail.
     */
    data: XOR<NotesAuditTrailCreateInput, NotesAuditTrailUncheckedCreateInput>
  }

  /**
   * NotesAuditTrail createMany
   */
  export type NotesAuditTrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotesAuditTrails.
     */
    data: NotesAuditTrailCreateManyInput | NotesAuditTrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotesAuditTrail createManyAndReturn
   */
  export type NotesAuditTrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * The data used to create many NotesAuditTrails.
     */
    data: NotesAuditTrailCreateManyInput | NotesAuditTrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotesAuditTrail update
   */
  export type NotesAuditTrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to update a NotesAuditTrail.
     */
    data: XOR<NotesAuditTrailUpdateInput, NotesAuditTrailUncheckedUpdateInput>
    /**
     * Choose, which NotesAuditTrail to update.
     */
    where: NotesAuditTrailWhereUniqueInput
  }

  /**
   * NotesAuditTrail updateMany
   */
  export type NotesAuditTrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotesAuditTrails.
     */
    data: XOR<NotesAuditTrailUpdateManyMutationInput, NotesAuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which NotesAuditTrails to update
     */
    where?: NotesAuditTrailWhereInput
  }

  /**
   * NotesAuditTrail updateManyAndReturn
   */
  export type NotesAuditTrailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * The data used to update NotesAuditTrails.
     */
    data: XOR<NotesAuditTrailUpdateManyMutationInput, NotesAuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which NotesAuditTrails to update
     */
    where?: NotesAuditTrailWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotesAuditTrail upsert
   */
  export type NotesAuditTrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * The filter to search for the NotesAuditTrail to update in case it exists.
     */
    where: NotesAuditTrailWhereUniqueInput
    /**
     * In case the NotesAuditTrail found by the `where` argument doesn't exist, create a new NotesAuditTrail with this data.
     */
    create: XOR<NotesAuditTrailCreateInput, NotesAuditTrailUncheckedCreateInput>
    /**
     * In case the NotesAuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesAuditTrailUpdateInput, NotesAuditTrailUncheckedUpdateInput>
  }

  /**
   * NotesAuditTrail delete
   */
  export type NotesAuditTrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
    /**
     * Filter which NotesAuditTrail to delete.
     */
    where: NotesAuditTrailWhereUniqueInput
  }

  /**
   * NotesAuditTrail deleteMany
   */
  export type NotesAuditTrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotesAuditTrails to delete
     */
    where?: NotesAuditTrailWhereInput
  }

  /**
   * NotesAuditTrail without action
   */
  export type NotesAuditTrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesAuditTrail
     */
    select?: NotesAuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotesAuditTrail
     */
    omit?: NotesAuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesAuditTrailInclude<ExtArgs> | null
  }


  /**
   * Model AreaAffected
   */

  export type AggregateAreaAffected = {
    _count: AreaAffectedCountAggregateOutputType | null
    _avg: AreaAffectedAvgAggregateOutputType | null
    _sum: AreaAffectedSumAggregateOutputType | null
    _min: AreaAffectedMinAggregateOutputType | null
    _max: AreaAffectedMaxAggregateOutputType | null
  }

  export type AreaAffectedAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    category: number | null
    projectId: number | null
  }

  export type AreaAffectedSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    category: number | null
    projectId: number | null
  }

  export type AreaAffectedMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    roomId: number | null
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    type: $Enums.AreaAffectedType | null
  }

  export type AreaAffectedMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    roomId: number | null
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean | null
    publicId: string | null
    projectId: number | null
    type: $Enums.AreaAffectedType | null
  }

  export type AreaAffectedCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    roomId: number
    material: number
    totalAreaRemoved: number
    totalAreaMicrobialApplied: number
    cause: number
    category: number
    cabinetryRemoved: number
    isDeleted: number
    publicId: number
    projectId: number
    type: number
    _all: number
  }


  export type AreaAffectedAvgAggregateInputType = {
    id?: true
    roomId?: true
    category?: true
    projectId?: true
  }

  export type AreaAffectedSumAggregateInputType = {
    id?: true
    roomId?: true
    category?: true
    projectId?: true
  }

  export type AreaAffectedMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
  }

  export type AreaAffectedMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
  }

  export type AreaAffectedCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    roomId?: true
    material?: true
    totalAreaRemoved?: true
    totalAreaMicrobialApplied?: true
    cause?: true
    category?: true
    cabinetryRemoved?: true
    isDeleted?: true
    publicId?: true
    projectId?: true
    type?: true
    _all?: true
  }

  export type AreaAffectedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaAffected to aggregate.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaAffecteds
    **/
    _count?: true | AreaAffectedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAffectedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaAffectedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaAffectedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaAffectedMaxAggregateInputType
  }

  export type GetAreaAffectedAggregateType<T extends AreaAffectedAggregateArgs> = {
        [P in keyof T & keyof AggregateAreaAffected]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaAffected[P]>
      : GetScalarType<T[P], AggregateAreaAffected[P]>
  }




  export type AreaAffectedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaAffectedWhereInput
    orderBy?: AreaAffectedOrderByWithAggregationInput | AreaAffectedOrderByWithAggregationInput[]
    by: AreaAffectedScalarFieldEnum[] | AreaAffectedScalarFieldEnum
    having?: AreaAffectedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaAffectedCountAggregateInputType | true
    _avg?: AreaAffectedAvgAggregateInputType
    _sum?: AreaAffectedSumAggregateInputType
    _min?: AreaAffectedMinAggregateInputType
    _max?: AreaAffectedMaxAggregateInputType
  }

  export type AreaAffectedGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    roomId: number
    material: string | null
    totalAreaRemoved: string | null
    totalAreaMicrobialApplied: string | null
    cause: string | null
    category: number | null
    cabinetryRemoved: string | null
    isDeleted: boolean
    publicId: string
    projectId: number
    type: $Enums.AreaAffectedType
    _count: AreaAffectedCountAggregateOutputType | null
    _avg: AreaAffectedAvgAggregateOutputType | null
    _sum: AreaAffectedSumAggregateOutputType | null
    _min: AreaAffectedMinAggregateOutputType | null
    _max: AreaAffectedMaxAggregateOutputType | null
  }

  type GetAreaAffectedGroupByPayload<T extends AreaAffectedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaAffectedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaAffectedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaAffectedGroupByOutputType[P]>
            : GetScalarType<T[P], AreaAffectedGroupByOutputType[P]>
        }
      >
    >


  export type AreaAffectedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    roomId?: boolean
    material?: boolean
    totalAreaRemoved?: boolean
    totalAreaMicrobialApplied?: boolean
    cause?: boolean
    category?: boolean
    cabinetryRemoved?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    type?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaAffected"]>

  export type AreaAffectedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    roomId?: boolean
    material?: boolean
    totalAreaRemoved?: boolean
    totalAreaMicrobialApplied?: boolean
    cause?: boolean
    category?: boolean
    cabinetryRemoved?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    type?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaAffected"]>

  export type AreaAffectedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    roomId?: boolean
    material?: boolean
    totalAreaRemoved?: boolean
    totalAreaMicrobialApplied?: boolean
    cause?: boolean
    category?: boolean
    cabinetryRemoved?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    type?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaAffected"]>

  export type AreaAffectedSelectScalar = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    roomId?: boolean
    material?: boolean
    totalAreaRemoved?: boolean
    totalAreaMicrobialApplied?: boolean
    cause?: boolean
    category?: boolean
    cabinetryRemoved?: boolean
    isDeleted?: boolean
    publicId?: boolean
    projectId?: boolean
    type?: boolean
  }

  export type AreaAffectedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "date" | "roomId" | "material" | "totalAreaRemoved" | "totalAreaMicrobialApplied" | "cause" | "category" | "cabinetryRemoved" | "isDeleted" | "publicId" | "projectId" | "type", ExtArgs["result"]["areaAffected"]>
  export type AreaAffectedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type AreaAffectedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type AreaAffectedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $AreaAffectedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AreaAffected"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      date: Date
      roomId: number
      material: string | null
      totalAreaRemoved: string | null
      totalAreaMicrobialApplied: string | null
      cause: string | null
      category: number | null
      cabinetryRemoved: string | null
      isDeleted: boolean
      publicId: string
      projectId: number
      type: $Enums.AreaAffectedType
    }, ExtArgs["result"]["areaAffected"]>
    composites: {}
  }

  type AreaAffectedGetPayload<S extends boolean | null | undefined | AreaAffectedDefaultArgs> = $Result.GetResult<Prisma.$AreaAffectedPayload, S>

  type AreaAffectedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaAffectedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaAffectedCountAggregateInputType | true
    }

  export interface AreaAffectedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AreaAffected'], meta: { name: 'AreaAffected' } }
    /**
     * Find zero or one AreaAffected that matches the filter.
     * @param {AreaAffectedFindUniqueArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaAffectedFindUniqueArgs>(args: SelectSubset<T, AreaAffectedFindUniqueArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AreaAffected that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaAffectedFindUniqueOrThrowArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaAffectedFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaAffectedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AreaAffected that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindFirstArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaAffectedFindFirstArgs>(args?: SelectSubset<T, AreaAffectedFindFirstArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AreaAffected that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindFirstOrThrowArgs} args - Arguments to find a AreaAffected
     * @example
     * // Get one AreaAffected
     * const areaAffected = await prisma.areaAffected.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaAffectedFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaAffectedFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AreaAffecteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaAffecteds
     * const areaAffecteds = await prisma.areaAffected.findMany()
     * 
     * // Get first 10 AreaAffecteds
     * const areaAffecteds = await prisma.areaAffected.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaAffectedWithIdOnly = await prisma.areaAffected.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaAffectedFindManyArgs>(args?: SelectSubset<T, AreaAffectedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AreaAffected.
     * @param {AreaAffectedCreateArgs} args - Arguments to create a AreaAffected.
     * @example
     * // Create one AreaAffected
     * const AreaAffected = await prisma.areaAffected.create({
     *   data: {
     *     // ... data to create a AreaAffected
     *   }
     * })
     * 
     */
    create<T extends AreaAffectedCreateArgs>(args: SelectSubset<T, AreaAffectedCreateArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AreaAffecteds.
     * @param {AreaAffectedCreateManyArgs} args - Arguments to create many AreaAffecteds.
     * @example
     * // Create many AreaAffecteds
     * const areaAffected = await prisma.areaAffected.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaAffectedCreateManyArgs>(args?: SelectSubset<T, AreaAffectedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AreaAffecteds and returns the data saved in the database.
     * @param {AreaAffectedCreateManyAndReturnArgs} args - Arguments to create many AreaAffecteds.
     * @example
     * // Create many AreaAffecteds
     * const areaAffected = await prisma.areaAffected.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AreaAffecteds and only return the `id`
     * const areaAffectedWithIdOnly = await prisma.areaAffected.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaAffectedCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaAffectedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AreaAffected.
     * @param {AreaAffectedDeleteArgs} args - Arguments to delete one AreaAffected.
     * @example
     * // Delete one AreaAffected
     * const AreaAffected = await prisma.areaAffected.delete({
     *   where: {
     *     // ... filter to delete one AreaAffected
     *   }
     * })
     * 
     */
    delete<T extends AreaAffectedDeleteArgs>(args: SelectSubset<T, AreaAffectedDeleteArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AreaAffected.
     * @param {AreaAffectedUpdateArgs} args - Arguments to update one AreaAffected.
     * @example
     * // Update one AreaAffected
     * const areaAffected = await prisma.areaAffected.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaAffectedUpdateArgs>(args: SelectSubset<T, AreaAffectedUpdateArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AreaAffecteds.
     * @param {AreaAffectedDeleteManyArgs} args - Arguments to filter AreaAffecteds to delete.
     * @example
     * // Delete a few AreaAffecteds
     * const { count } = await prisma.areaAffected.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaAffectedDeleteManyArgs>(args?: SelectSubset<T, AreaAffectedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaAffecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaAffecteds
     * const areaAffected = await prisma.areaAffected.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaAffectedUpdateManyArgs>(args: SelectSubset<T, AreaAffectedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaAffecteds and returns the data updated in the database.
     * @param {AreaAffectedUpdateManyAndReturnArgs} args - Arguments to update many AreaAffecteds.
     * @example
     * // Update many AreaAffecteds
     * const areaAffected = await prisma.areaAffected.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AreaAffecteds and only return the `id`
     * const areaAffectedWithIdOnly = await prisma.areaAffected.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaAffectedUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaAffectedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AreaAffected.
     * @param {AreaAffectedUpsertArgs} args - Arguments to update or create a AreaAffected.
     * @example
     * // Update or create a AreaAffected
     * const areaAffected = await prisma.areaAffected.upsert({
     *   create: {
     *     // ... data to create a AreaAffected
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaAffected we want to update
     *   }
     * })
     */
    upsert<T extends AreaAffectedUpsertArgs>(args: SelectSubset<T, AreaAffectedUpsertArgs<ExtArgs>>): Prisma__AreaAffectedClient<$Result.GetResult<Prisma.$AreaAffectedPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AreaAffecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedCountArgs} args - Arguments to filter AreaAffecteds to count.
     * @example
     * // Count the number of AreaAffecteds
     * const count = await prisma.areaAffected.count({
     *   where: {
     *     // ... the filter for the AreaAffecteds we want to count
     *   }
     * })
    **/
    count<T extends AreaAffectedCountArgs>(
      args?: Subset<T, AreaAffectedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaAffectedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaAffected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAffectedAggregateArgs>(args: Subset<T, AreaAffectedAggregateArgs>): Prisma.PrismaPromise<GetAreaAffectedAggregateType<T>>

    /**
     * Group by AreaAffected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAffectedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaAffectedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaAffectedGroupByArgs['orderBy'] }
        : { orderBy?: AreaAffectedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaAffectedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaAffectedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AreaAffected model
   */
  readonly fields: AreaAffectedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaAffected.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaAffectedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AreaAffected model
   */ 
  interface AreaAffectedFieldRefs {
    readonly id: FieldRef<"AreaAffected", 'Int'>
    readonly createdAt: FieldRef<"AreaAffected", 'DateTime'>
    readonly date: FieldRef<"AreaAffected", 'DateTime'>
    readonly roomId: FieldRef<"AreaAffected", 'Int'>
    readonly material: FieldRef<"AreaAffected", 'String'>
    readonly totalAreaRemoved: FieldRef<"AreaAffected", 'String'>
    readonly totalAreaMicrobialApplied: FieldRef<"AreaAffected", 'String'>
    readonly cause: FieldRef<"AreaAffected", 'String'>
    readonly category: FieldRef<"AreaAffected", 'Int'>
    readonly cabinetryRemoved: FieldRef<"AreaAffected", 'String'>
    readonly isDeleted: FieldRef<"AreaAffected", 'Boolean'>
    readonly publicId: FieldRef<"AreaAffected", 'String'>
    readonly projectId: FieldRef<"AreaAffected", 'Int'>
    readonly type: FieldRef<"AreaAffected", 'AreaAffectedType'>
  }
    

  // Custom InputTypes
  /**
   * AreaAffected findUnique
   */
  export type AreaAffectedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where: AreaAffectedWhereUniqueInput
  }

  /**
   * AreaAffected findUniqueOrThrow
   */
  export type AreaAffectedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where: AreaAffectedWhereUniqueInput
  }

  /**
   * AreaAffected findFirst
   */
  export type AreaAffectedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaAffecteds.
     */
    distinct?: AreaAffectedScalarFieldEnum | AreaAffectedScalarFieldEnum[]
  }

  /**
   * AreaAffected findFirstOrThrow
   */
  export type AreaAffectedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter, which AreaAffected to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaAffecteds.
     */
    distinct?: AreaAffectedScalarFieldEnum | AreaAffectedScalarFieldEnum[]
  }

  /**
   * AreaAffected findMany
   */
  export type AreaAffectedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter, which AreaAffecteds to fetch.
     */
    where?: AreaAffectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaAffecteds to fetch.
     */
    orderBy?: AreaAffectedOrderByWithRelationInput | AreaAffectedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaAffecteds.
     */
    cursor?: AreaAffectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaAffecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaAffecteds.
     */
    skip?: number
    distinct?: AreaAffectedScalarFieldEnum | AreaAffectedScalarFieldEnum[]
  }

  /**
   * AreaAffected create
   */
  export type AreaAffectedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * The data needed to create a AreaAffected.
     */
    data: XOR<AreaAffectedCreateInput, AreaAffectedUncheckedCreateInput>
  }

  /**
   * AreaAffected createMany
   */
  export type AreaAffectedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AreaAffecteds.
     */
    data: AreaAffectedCreateManyInput | AreaAffectedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AreaAffected createManyAndReturn
   */
  export type AreaAffectedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * The data used to create many AreaAffecteds.
     */
    data: AreaAffectedCreateManyInput | AreaAffectedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AreaAffected update
   */
  export type AreaAffectedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * The data needed to update a AreaAffected.
     */
    data: XOR<AreaAffectedUpdateInput, AreaAffectedUncheckedUpdateInput>
    /**
     * Choose, which AreaAffected to update.
     */
    where: AreaAffectedWhereUniqueInput
  }

  /**
   * AreaAffected updateMany
   */
  export type AreaAffectedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AreaAffecteds.
     */
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyInput>
    /**
     * Filter which AreaAffecteds to update
     */
    where?: AreaAffectedWhereInput
  }

  /**
   * AreaAffected updateManyAndReturn
   */
  export type AreaAffectedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * The data used to update AreaAffecteds.
     */
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyInput>
    /**
     * Filter which AreaAffecteds to update
     */
    where?: AreaAffectedWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AreaAffected upsert
   */
  export type AreaAffectedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * The filter to search for the AreaAffected to update in case it exists.
     */
    where: AreaAffectedWhereUniqueInput
    /**
     * In case the AreaAffected found by the `where` argument doesn't exist, create a new AreaAffected with this data.
     */
    create: XOR<AreaAffectedCreateInput, AreaAffectedUncheckedCreateInput>
    /**
     * In case the AreaAffected was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaAffectedUpdateInput, AreaAffectedUncheckedUpdateInput>
  }

  /**
   * AreaAffected delete
   */
  export type AreaAffectedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
    /**
     * Filter which AreaAffected to delete.
     */
    where: AreaAffectedWhereUniqueInput
  }

  /**
   * AreaAffected deleteMany
   */
  export type AreaAffectedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaAffecteds to delete
     */
    where?: AreaAffectedWhereInput
  }

  /**
   * AreaAffected without action
   */
  export type AreaAffectedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaAffected
     */
    select?: AreaAffectedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AreaAffected
     */
    omit?: AreaAffectedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaAffectedInclude<ExtArgs> | null
  }


  /**
   * Model GenericRoomReading
   */

  export type AggregateGenericRoomReading = {
    _count: GenericRoomReadingCountAggregateOutputType | null
    _avg: GenericRoomReadingAvgAggregateOutputType | null
    _sum: GenericRoomReadingSumAggregateOutputType | null
    _min: GenericRoomReadingMinAggregateOutputType | null
    _max: GenericRoomReadingMaxAggregateOutputType | null
  }

  export type GenericRoomReadingAvgAggregateOutputType = {
    id: number | null
    roomReadingId: number | null
  }

  export type GenericRoomReadingSumAggregateOutputType = {
    id: number | null
    roomReadingId: number | null
  }

  export type GenericRoomReadingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    publicId: string | null
    type: $Enums.RoomReadingType | null
    value: string | null
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number | null
    isDeleted: boolean | null
  }

  export type GenericRoomReadingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    publicId: string | null
    type: $Enums.RoomReadingType | null
    value: string | null
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number | null
    isDeleted: boolean | null
  }

  export type GenericRoomReadingCountAggregateOutputType = {
    id: number
    createdAt: number
    publicId: number
    type: number
    value: number
    humidity: number
    temperature: number
    gpp: number
    roomReadingId: number
    isDeleted: number
    _all: number
  }


  export type GenericRoomReadingAvgAggregateInputType = {
    id?: true
    roomReadingId?: true
  }

  export type GenericRoomReadingSumAggregateInputType = {
    id?: true
    roomReadingId?: true
  }

  export type GenericRoomReadingMinAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
  }

  export type GenericRoomReadingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
  }

  export type GenericRoomReadingCountAggregateInputType = {
    id?: true
    createdAt?: true
    publicId?: true
    type?: true
    value?: true
    humidity?: true
    temperature?: true
    gpp?: true
    roomReadingId?: true
    isDeleted?: true
    _all?: true
  }

  export type GenericRoomReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenericRoomReading to aggregate.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: GenericRoomReadingOrderByWithRelationInput | GenericRoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenericRoomReadings
    **/
    _count?: true | GenericRoomReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenericRoomReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenericRoomReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenericRoomReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenericRoomReadingMaxAggregateInputType
  }

  export type GetGenericRoomReadingAggregateType<T extends GenericRoomReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateGenericRoomReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenericRoomReading[P]>
      : GetScalarType<T[P], AggregateGenericRoomReading[P]>
  }




  export type GenericRoomReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenericRoomReadingWhereInput
    orderBy?: GenericRoomReadingOrderByWithAggregationInput | GenericRoomReadingOrderByWithAggregationInput[]
    by: GenericRoomReadingScalarFieldEnum[] | GenericRoomReadingScalarFieldEnum
    having?: GenericRoomReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenericRoomReadingCountAggregateInputType | true
    _avg?: GenericRoomReadingAvgAggregateInputType
    _sum?: GenericRoomReadingSumAggregateInputType
    _min?: GenericRoomReadingMinAggregateInputType
    _max?: GenericRoomReadingMaxAggregateInputType
  }

  export type GenericRoomReadingGroupByOutputType = {
    id: number
    createdAt: Date
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity: string | null
    temperature: string | null
    gpp: string | null
    roomReadingId: number
    isDeleted: boolean
    _count: GenericRoomReadingCountAggregateOutputType | null
    _avg: GenericRoomReadingAvgAggregateOutputType | null
    _sum: GenericRoomReadingSumAggregateOutputType | null
    _min: GenericRoomReadingMinAggregateOutputType | null
    _max: GenericRoomReadingMaxAggregateOutputType | null
  }

  type GetGenericRoomReadingGroupByPayload<T extends GenericRoomReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenericRoomReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenericRoomReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenericRoomReadingGroupByOutputType[P]>
            : GetScalarType<T[P], GenericRoomReadingGroupByOutputType[P]>
        }
      >
    >


  export type GenericRoomReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    publicId?: boolean
    type?: boolean
    value?: boolean
    humidity?: boolean
    temperature?: boolean
    gpp?: boolean
    roomReadingId?: boolean
    isDeleted?: boolean
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genericRoomReading"]>

  export type GenericRoomReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    publicId?: boolean
    type?: boolean
    value?: boolean
    humidity?: boolean
    temperature?: boolean
    gpp?: boolean
    roomReadingId?: boolean
    isDeleted?: boolean
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genericRoomReading"]>

  export type GenericRoomReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    publicId?: boolean
    type?: boolean
    value?: boolean
    humidity?: boolean
    temperature?: boolean
    gpp?: boolean
    roomReadingId?: boolean
    isDeleted?: boolean
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genericRoomReading"]>

  export type GenericRoomReadingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    publicId?: boolean
    type?: boolean
    value?: boolean
    humidity?: boolean
    temperature?: boolean
    gpp?: boolean
    roomReadingId?: boolean
    isDeleted?: boolean
  }

  export type GenericRoomReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "publicId" | "type" | "value" | "humidity" | "temperature" | "gpp" | "roomReadingId" | "isDeleted", ExtArgs["result"]["genericRoomReading"]>
  export type GenericRoomReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }
  export type GenericRoomReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }
  export type GenericRoomReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomReading?: boolean | RoomReadingDefaultArgs<ExtArgs>
  }

  export type $GenericRoomReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenericRoomReading"
    objects: {
      roomReading: Prisma.$RoomReadingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      publicId: string
      type: $Enums.RoomReadingType
      value: string
      humidity: string | null
      temperature: string | null
      gpp: string | null
      roomReadingId: number
      isDeleted: boolean
    }, ExtArgs["result"]["genericRoomReading"]>
    composites: {}
  }

  type GenericRoomReadingGetPayload<S extends boolean | null | undefined | GenericRoomReadingDefaultArgs> = $Result.GetResult<Prisma.$GenericRoomReadingPayload, S>

  type GenericRoomReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenericRoomReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenericRoomReadingCountAggregateInputType | true
    }

  export interface GenericRoomReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenericRoomReading'], meta: { name: 'GenericRoomReading' } }
    /**
     * Find zero or one GenericRoomReading that matches the filter.
     * @param {GenericRoomReadingFindUniqueArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenericRoomReadingFindUniqueArgs>(args: SelectSubset<T, GenericRoomReadingFindUniqueArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GenericRoomReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenericRoomReadingFindUniqueOrThrowArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenericRoomReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, GenericRoomReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GenericRoomReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindFirstArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenericRoomReadingFindFirstArgs>(args?: SelectSubset<T, GenericRoomReadingFindFirstArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GenericRoomReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindFirstOrThrowArgs} args - Arguments to find a GenericRoomReading
     * @example
     * // Get one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenericRoomReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, GenericRoomReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GenericRoomReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenericRoomReadings
     * const genericRoomReadings = await prisma.genericRoomReading.findMany()
     * 
     * // Get first 10 GenericRoomReadings
     * const genericRoomReadings = await prisma.genericRoomReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genericRoomReadingWithIdOnly = await prisma.genericRoomReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenericRoomReadingFindManyArgs>(args?: SelectSubset<T, GenericRoomReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GenericRoomReading.
     * @param {GenericRoomReadingCreateArgs} args - Arguments to create a GenericRoomReading.
     * @example
     * // Create one GenericRoomReading
     * const GenericRoomReading = await prisma.genericRoomReading.create({
     *   data: {
     *     // ... data to create a GenericRoomReading
     *   }
     * })
     * 
     */
    create<T extends GenericRoomReadingCreateArgs>(args: SelectSubset<T, GenericRoomReadingCreateArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GenericRoomReadings.
     * @param {GenericRoomReadingCreateManyArgs} args - Arguments to create many GenericRoomReadings.
     * @example
     * // Create many GenericRoomReadings
     * const genericRoomReading = await prisma.genericRoomReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenericRoomReadingCreateManyArgs>(args?: SelectSubset<T, GenericRoomReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GenericRoomReadings and returns the data saved in the database.
     * @param {GenericRoomReadingCreateManyAndReturnArgs} args - Arguments to create many GenericRoomReadings.
     * @example
     * // Create many GenericRoomReadings
     * const genericRoomReading = await prisma.genericRoomReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GenericRoomReadings and only return the `id`
     * const genericRoomReadingWithIdOnly = await prisma.genericRoomReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenericRoomReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, GenericRoomReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GenericRoomReading.
     * @param {GenericRoomReadingDeleteArgs} args - Arguments to delete one GenericRoomReading.
     * @example
     * // Delete one GenericRoomReading
     * const GenericRoomReading = await prisma.genericRoomReading.delete({
     *   where: {
     *     // ... filter to delete one GenericRoomReading
     *   }
     * })
     * 
     */
    delete<T extends GenericRoomReadingDeleteArgs>(args: SelectSubset<T, GenericRoomReadingDeleteArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GenericRoomReading.
     * @param {GenericRoomReadingUpdateArgs} args - Arguments to update one GenericRoomReading.
     * @example
     * // Update one GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenericRoomReadingUpdateArgs>(args: SelectSubset<T, GenericRoomReadingUpdateArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GenericRoomReadings.
     * @param {GenericRoomReadingDeleteManyArgs} args - Arguments to filter GenericRoomReadings to delete.
     * @example
     * // Delete a few GenericRoomReadings
     * const { count } = await prisma.genericRoomReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenericRoomReadingDeleteManyArgs>(args?: SelectSubset<T, GenericRoomReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenericRoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenericRoomReadings
     * const genericRoomReading = await prisma.genericRoomReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenericRoomReadingUpdateManyArgs>(args: SelectSubset<T, GenericRoomReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenericRoomReadings and returns the data updated in the database.
     * @param {GenericRoomReadingUpdateManyAndReturnArgs} args - Arguments to update many GenericRoomReadings.
     * @example
     * // Update many GenericRoomReadings
     * const genericRoomReading = await prisma.genericRoomReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GenericRoomReadings and only return the `id`
     * const genericRoomReadingWithIdOnly = await prisma.genericRoomReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenericRoomReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, GenericRoomReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GenericRoomReading.
     * @param {GenericRoomReadingUpsertArgs} args - Arguments to update or create a GenericRoomReading.
     * @example
     * // Update or create a GenericRoomReading
     * const genericRoomReading = await prisma.genericRoomReading.upsert({
     *   create: {
     *     // ... data to create a GenericRoomReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenericRoomReading we want to update
     *   }
     * })
     */
    upsert<T extends GenericRoomReadingUpsertArgs>(args: SelectSubset<T, GenericRoomReadingUpsertArgs<ExtArgs>>): Prisma__GenericRoomReadingClient<$Result.GetResult<Prisma.$GenericRoomReadingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GenericRoomReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingCountArgs} args - Arguments to filter GenericRoomReadings to count.
     * @example
     * // Count the number of GenericRoomReadings
     * const count = await prisma.genericRoomReading.count({
     *   where: {
     *     // ... the filter for the GenericRoomReadings we want to count
     *   }
     * })
    **/
    count<T extends GenericRoomReadingCountArgs>(
      args?: Subset<T, GenericRoomReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenericRoomReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenericRoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenericRoomReadingAggregateArgs>(args: Subset<T, GenericRoomReadingAggregateArgs>): Prisma.PrismaPromise<GetGenericRoomReadingAggregateType<T>>

    /**
     * Group by GenericRoomReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericRoomReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenericRoomReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenericRoomReadingGroupByArgs['orderBy'] }
        : { orderBy?: GenericRoomReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenericRoomReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenericRoomReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenericRoomReading model
   */
  readonly fields: GenericRoomReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenericRoomReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenericRoomReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roomReading<T extends RoomReadingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomReadingDefaultArgs<ExtArgs>>): Prisma__RoomReadingClient<$Result.GetResult<Prisma.$RoomReadingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GenericRoomReading model
   */ 
  interface GenericRoomReadingFieldRefs {
    readonly id: FieldRef<"GenericRoomReading", 'Int'>
    readonly createdAt: FieldRef<"GenericRoomReading", 'DateTime'>
    readonly publicId: FieldRef<"GenericRoomReading", 'String'>
    readonly type: FieldRef<"GenericRoomReading", 'RoomReadingType'>
    readonly value: FieldRef<"GenericRoomReading", 'String'>
    readonly humidity: FieldRef<"GenericRoomReading", 'String'>
    readonly temperature: FieldRef<"GenericRoomReading", 'String'>
    readonly gpp: FieldRef<"GenericRoomReading", 'String'>
    readonly roomReadingId: FieldRef<"GenericRoomReading", 'Int'>
    readonly isDeleted: FieldRef<"GenericRoomReading", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GenericRoomReading findUnique
   */
  export type GenericRoomReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where: GenericRoomReadingWhereUniqueInput
  }

  /**
   * GenericRoomReading findUniqueOrThrow
   */
  export type GenericRoomReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where: GenericRoomReadingWhereUniqueInput
  }

  /**
   * GenericRoomReading findFirst
   */
  export type GenericRoomReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: GenericRoomReadingOrderByWithRelationInput | GenericRoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericRoomReadings.
     */
    distinct?: GenericRoomReadingScalarFieldEnum | GenericRoomReadingScalarFieldEnum[]
  }

  /**
   * GenericRoomReading findFirstOrThrow
   */
  export type GenericRoomReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which GenericRoomReading to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: GenericRoomReadingOrderByWithRelationInput | GenericRoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericRoomReadings.
     */
    distinct?: GenericRoomReadingScalarFieldEnum | GenericRoomReadingScalarFieldEnum[]
  }

  /**
   * GenericRoomReading findMany
   */
  export type GenericRoomReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter, which GenericRoomReadings to fetch.
     */
    where?: GenericRoomReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericRoomReadings to fetch.
     */
    orderBy?: GenericRoomReadingOrderByWithRelationInput | GenericRoomReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenericRoomReadings.
     */
    cursor?: GenericRoomReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericRoomReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericRoomReadings.
     */
    skip?: number
    distinct?: GenericRoomReadingScalarFieldEnum | GenericRoomReadingScalarFieldEnum[]
  }

  /**
   * GenericRoomReading create
   */
  export type GenericRoomReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a GenericRoomReading.
     */
    data: XOR<GenericRoomReadingCreateInput, GenericRoomReadingUncheckedCreateInput>
  }

  /**
   * GenericRoomReading createMany
   */
  export type GenericRoomReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenericRoomReadings.
     */
    data: GenericRoomReadingCreateManyInput | GenericRoomReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenericRoomReading createManyAndReturn
   */
  export type GenericRoomReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * The data used to create many GenericRoomReadings.
     */
    data: GenericRoomReadingCreateManyInput | GenericRoomReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GenericRoomReading update
   */
  export type GenericRoomReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a GenericRoomReading.
     */
    data: XOR<GenericRoomReadingUpdateInput, GenericRoomReadingUncheckedUpdateInput>
    /**
     * Choose, which GenericRoomReading to update.
     */
    where: GenericRoomReadingWhereUniqueInput
  }

  /**
   * GenericRoomReading updateMany
   */
  export type GenericRoomReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenericRoomReadings.
     */
    data: XOR<GenericRoomReadingUpdateManyMutationInput, GenericRoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which GenericRoomReadings to update
     */
    where?: GenericRoomReadingWhereInput
  }

  /**
   * GenericRoomReading updateManyAndReturn
   */
  export type GenericRoomReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * The data used to update GenericRoomReadings.
     */
    data: XOR<GenericRoomReadingUpdateManyMutationInput, GenericRoomReadingUncheckedUpdateManyInput>
    /**
     * Filter which GenericRoomReadings to update
     */
    where?: GenericRoomReadingWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GenericRoomReading upsert
   */
  export type GenericRoomReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the GenericRoomReading to update in case it exists.
     */
    where: GenericRoomReadingWhereUniqueInput
    /**
     * In case the GenericRoomReading found by the `where` argument doesn't exist, create a new GenericRoomReading with this data.
     */
    create: XOR<GenericRoomReadingCreateInput, GenericRoomReadingUncheckedCreateInput>
    /**
     * In case the GenericRoomReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenericRoomReadingUpdateInput, GenericRoomReadingUncheckedUpdateInput>
  }

  /**
   * GenericRoomReading delete
   */
  export type GenericRoomReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
    /**
     * Filter which GenericRoomReading to delete.
     */
    where: GenericRoomReadingWhereUniqueInput
  }

  /**
   * GenericRoomReading deleteMany
   */
  export type GenericRoomReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenericRoomReadings to delete
     */
    where?: GenericRoomReadingWhereInput
  }

  /**
   * GenericRoomReading without action
   */
  export type GenericRoomReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericRoomReading
     */
    select?: GenericRoomReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenericRoomReading
     */
    omit?: GenericRoomReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenericRoomReadingInclude<ExtArgs> | null
  }


  /**
   * Model Detection
   */

  export type AggregateDetection = {
    _count: DetectionCountAggregateOutputType | null
    _avg: DetectionAvgAggregateOutputType | null
    _sum: DetectionSumAggregateOutputType | null
    _min: DetectionMinAggregateOutputType | null
    _max: DetectionMaxAggregateOutputType | null
  }

  export type DetectionAvgAggregateOutputType = {
    id: number | null
    inferenceId: number | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    roomId: number | null
    dimension: number | null
  }

  export type DetectionSumAggregateOutputType = {
    id: number | null
    inferenceId: number | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    roomId: number | null
    dimension: number | null
  }

  export type DetectionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    inferenceId: number | null
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    category: string | null
    code: string | null
    item: string | null
    quality: string | null
    roomId: number | null
    dimension: number | null
    unit: $Enums.DimensionUnit | null
  }

  export type DetectionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDeleted: boolean | null
    publicId: string | null
    inferenceId: number | null
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number | null
    category: string | null
    code: string | null
    item: string | null
    quality: string | null
    roomId: number | null
    dimension: number | null
    unit: $Enums.DimensionUnit | null
  }

  export type DetectionCountAggregateOutputType = {
    id: number
    createdAt: number
    isDeleted: number
    publicId: number
    inferenceId: number
    imageKey: number
    xMinCord: number
    yMinCord: number
    confidence: number
    xMaxCord: number
    yMaxCord: number
    projectId: number
    category: number
    code: number
    item: number
    quality: number
    roomId: number
    dimension: number
    unit: number
    _all: number
  }


  export type DetectionAvgAggregateInputType = {
    id?: true
    inferenceId?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    roomId?: true
    dimension?: true
  }

  export type DetectionSumAggregateInputType = {
    id?: true
    inferenceId?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    roomId?: true
    dimension?: true
  }

  export type DetectionMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
  }

  export type DetectionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
  }

  export type DetectionCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDeleted?: true
    publicId?: true
    inferenceId?: true
    imageKey?: true
    xMinCord?: true
    yMinCord?: true
    confidence?: true
    xMaxCord?: true
    yMaxCord?: true
    projectId?: true
    category?: true
    code?: true
    item?: true
    quality?: true
    roomId?: true
    dimension?: true
    unit?: true
    _all?: true
  }

  export type DetectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Detection to aggregate.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Detections
    **/
    _count?: true | DetectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectionMaxAggregateInputType
  }

  export type GetDetectionAggregateType<T extends DetectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDetection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetection[P]>
      : GetScalarType<T[P], AggregateDetection[P]>
  }




  export type DetectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectionWhereInput
    orderBy?: DetectionOrderByWithAggregationInput | DetectionOrderByWithAggregationInput[]
    by: DetectionScalarFieldEnum[] | DetectionScalarFieldEnum
    having?: DetectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectionCountAggregateInputType | true
    _avg?: DetectionAvgAggregateInputType
    _sum?: DetectionSumAggregateInputType
    _min?: DetectionMinAggregateInputType
    _max?: DetectionMaxAggregateInputType
  }

  export type DetectionGroupByOutputType = {
    id: number
    createdAt: Date
    isDeleted: boolean
    publicId: string
    inferenceId: number
    imageKey: string | null
    xMinCord: number | null
    yMinCord: number | null
    confidence: number | null
    xMaxCord: number | null
    yMaxCord: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId: number | null
    dimension: number | null
    unit: $Enums.DimensionUnit | null
    _count: DetectionCountAggregateOutputType | null
    _avg: DetectionAvgAggregateOutputType | null
    _sum: DetectionSumAggregateOutputType | null
    _min: DetectionMinAggregateOutputType | null
    _max: DetectionMaxAggregateOutputType | null
  }

  type GetDetectionGroupByPayload<T extends DetectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectionGroupByOutputType[P]>
            : GetScalarType<T[P], DetectionGroupByOutputType[P]>
        }
      >
    >


  export type DetectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    inferenceId?: boolean
    imageKey?: boolean
    xMinCord?: boolean
    yMinCord?: boolean
    confidence?: boolean
    xMaxCord?: boolean
    yMaxCord?: boolean
    projectId?: boolean
    category?: boolean
    code?: boolean
    item?: boolean
    quality?: boolean
    roomId?: boolean
    dimension?: boolean
    unit?: boolean
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }, ExtArgs["result"]["detection"]>

  export type DetectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    inferenceId?: boolean
    imageKey?: boolean
    xMinCord?: boolean
    yMinCord?: boolean
    confidence?: boolean
    xMaxCord?: boolean
    yMaxCord?: boolean
    projectId?: boolean
    category?: boolean
    code?: boolean
    item?: boolean
    quality?: boolean
    roomId?: boolean
    dimension?: boolean
    unit?: boolean
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }, ExtArgs["result"]["detection"]>

  export type DetectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    inferenceId?: boolean
    imageKey?: boolean
    xMinCord?: boolean
    yMinCord?: boolean
    confidence?: boolean
    xMaxCord?: boolean
    yMaxCord?: boolean
    projectId?: boolean
    category?: boolean
    code?: boolean
    item?: boolean
    quality?: boolean
    roomId?: boolean
    dimension?: boolean
    unit?: boolean
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }, ExtArgs["result"]["detection"]>

  export type DetectionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    publicId?: boolean
    inferenceId?: boolean
    imageKey?: boolean
    xMinCord?: boolean
    yMinCord?: boolean
    confidence?: boolean
    xMaxCord?: boolean
    yMaxCord?: boolean
    projectId?: boolean
    category?: boolean
    code?: boolean
    item?: boolean
    quality?: boolean
    roomId?: boolean
    dimension?: boolean
    unit?: boolean
  }

  export type DetectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDeleted" | "publicId" | "inferenceId" | "imageKey" | "xMinCord" | "yMinCord" | "confidence" | "xMaxCord" | "yMaxCord" | "projectId" | "category" | "code" | "item" | "quality" | "roomId" | "dimension" | "unit", ExtArgs["result"]["detection"]>
  export type DetectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }
  export type DetectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }
  export type DetectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inference?: boolean | InferenceDefaultArgs<ExtArgs>
    room?: boolean | Detection$roomArgs<ExtArgs>
  }

  export type $DetectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Detection"
    objects: {
      inference: Prisma.$InferencePayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDeleted: boolean
      publicId: string
      inferenceId: number
      imageKey: string | null
      xMinCord: number | null
      yMinCord: number | null
      confidence: number | null
      xMaxCord: number | null
      yMaxCord: number | null
      projectId: number
      category: string
      code: string
      item: string
      quality: string
      roomId: number | null
      dimension: number | null
      unit: $Enums.DimensionUnit | null
    }, ExtArgs["result"]["detection"]>
    composites: {}
  }

  type DetectionGetPayload<S extends boolean | null | undefined | DetectionDefaultArgs> = $Result.GetResult<Prisma.$DetectionPayload, S>

  type DetectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetectionCountAggregateInputType | true
    }

  export interface DetectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Detection'], meta: { name: 'Detection' } }
    /**
     * Find zero or one Detection that matches the filter.
     * @param {DetectionFindUniqueArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetectionFindUniqueArgs>(args: SelectSubset<T, DetectionFindUniqueArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Detection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetectionFindUniqueOrThrowArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetectionFindUniqueOrThrowArgs>(args: SelectSubset<T, DetectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Detection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindFirstArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetectionFindFirstArgs>(args?: SelectSubset<T, DetectionFindFirstArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Detection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindFirstOrThrowArgs} args - Arguments to find a Detection
     * @example
     * // Get one Detection
     * const detection = await prisma.detection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetectionFindFirstOrThrowArgs>(args?: SelectSubset<T, DetectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Detections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detections
     * const detections = await prisma.detection.findMany()
     * 
     * // Get first 10 Detections
     * const detections = await prisma.detection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectionWithIdOnly = await prisma.detection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetectionFindManyArgs>(args?: SelectSubset<T, DetectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Detection.
     * @param {DetectionCreateArgs} args - Arguments to create a Detection.
     * @example
     * // Create one Detection
     * const Detection = await prisma.detection.create({
     *   data: {
     *     // ... data to create a Detection
     *   }
     * })
     * 
     */
    create<T extends DetectionCreateArgs>(args: SelectSubset<T, DetectionCreateArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Detections.
     * @param {DetectionCreateManyArgs} args - Arguments to create many Detections.
     * @example
     * // Create many Detections
     * const detection = await prisma.detection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetectionCreateManyArgs>(args?: SelectSubset<T, DetectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detections and returns the data saved in the database.
     * @param {DetectionCreateManyAndReturnArgs} args - Arguments to create many Detections.
     * @example
     * // Create many Detections
     * const detection = await prisma.detection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detections and only return the `id`
     * const detectionWithIdOnly = await prisma.detection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetectionCreateManyAndReturnArgs>(args?: SelectSubset<T, DetectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Detection.
     * @param {DetectionDeleteArgs} args - Arguments to delete one Detection.
     * @example
     * // Delete one Detection
     * const Detection = await prisma.detection.delete({
     *   where: {
     *     // ... filter to delete one Detection
     *   }
     * })
     * 
     */
    delete<T extends DetectionDeleteArgs>(args: SelectSubset<T, DetectionDeleteArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Detection.
     * @param {DetectionUpdateArgs} args - Arguments to update one Detection.
     * @example
     * // Update one Detection
     * const detection = await prisma.detection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetectionUpdateArgs>(args: SelectSubset<T, DetectionUpdateArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Detections.
     * @param {DetectionDeleteManyArgs} args - Arguments to filter Detections to delete.
     * @example
     * // Delete a few Detections
     * const { count } = await prisma.detection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetectionDeleteManyArgs>(args?: SelectSubset<T, DetectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detections
     * const detection = await prisma.detection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetectionUpdateManyArgs>(args: SelectSubset<T, DetectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detections and returns the data updated in the database.
     * @param {DetectionUpdateManyAndReturnArgs} args - Arguments to update many Detections.
     * @example
     * // Update many Detections
     * const detection = await prisma.detection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Detections and only return the `id`
     * const detectionWithIdOnly = await prisma.detection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetectionUpdateManyAndReturnArgs>(args: SelectSubset<T, DetectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Detection.
     * @param {DetectionUpsertArgs} args - Arguments to update or create a Detection.
     * @example
     * // Update or create a Detection
     * const detection = await prisma.detection.upsert({
     *   create: {
     *     // ... data to create a Detection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detection we want to update
     *   }
     * })
     */
    upsert<T extends DetectionUpsertArgs>(args: SelectSubset<T, DetectionUpsertArgs<ExtArgs>>): Prisma__DetectionClient<$Result.GetResult<Prisma.$DetectionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Detections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionCountArgs} args - Arguments to filter Detections to count.
     * @example
     * // Count the number of Detections
     * const count = await prisma.detection.count({
     *   where: {
     *     // ... the filter for the Detections we want to count
     *   }
     * })
    **/
    count<T extends DetectionCountArgs>(
      args?: Subset<T, DetectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectionAggregateArgs>(args: Subset<T, DetectionAggregateArgs>): Prisma.PrismaPromise<GetDetectionAggregateType<T>>

    /**
     * Group by Detection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectionGroupByArgs['orderBy'] }
        : { orderBy?: DetectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Detection model
   */
  readonly fields: DetectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Detection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inference<T extends InferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InferenceDefaultArgs<ExtArgs>>): Prisma__InferenceClient<$Result.GetResult<Prisma.$InferencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    room<T extends Detection$roomArgs<ExtArgs> = {}>(args?: Subset<T, Detection$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Detection model
   */ 
  interface DetectionFieldRefs {
    readonly id: FieldRef<"Detection", 'Int'>
    readonly createdAt: FieldRef<"Detection", 'DateTime'>
    readonly isDeleted: FieldRef<"Detection", 'Boolean'>
    readonly publicId: FieldRef<"Detection", 'String'>
    readonly inferenceId: FieldRef<"Detection", 'Int'>
    readonly imageKey: FieldRef<"Detection", 'String'>
    readonly xMinCord: FieldRef<"Detection", 'Float'>
    readonly yMinCord: FieldRef<"Detection", 'Float'>
    readonly confidence: FieldRef<"Detection", 'Float'>
    readonly xMaxCord: FieldRef<"Detection", 'Float'>
    readonly yMaxCord: FieldRef<"Detection", 'Float'>
    readonly projectId: FieldRef<"Detection", 'Int'>
    readonly category: FieldRef<"Detection", 'String'>
    readonly code: FieldRef<"Detection", 'String'>
    readonly item: FieldRef<"Detection", 'String'>
    readonly quality: FieldRef<"Detection", 'String'>
    readonly roomId: FieldRef<"Detection", 'Int'>
    readonly dimension: FieldRef<"Detection", 'Int'>
    readonly unit: FieldRef<"Detection", 'DimensionUnit'>
  }
    

  // Custom InputTypes
  /**
   * Detection findUnique
   */
  export type DetectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter, which Detection to fetch.
     */
    where: DetectionWhereUniqueInput
  }

  /**
   * Detection findUniqueOrThrow
   */
  export type DetectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter, which Detection to fetch.
     */
    where: DetectionWhereUniqueInput
  }

  /**
   * Detection findFirst
   */
  export type DetectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter, which Detection to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Detections.
     */
    distinct?: DetectionScalarFieldEnum | DetectionScalarFieldEnum[]
  }

  /**
   * Detection findFirstOrThrow
   */
  export type DetectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter, which Detection to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Detections.
     */
    distinct?: DetectionScalarFieldEnum | DetectionScalarFieldEnum[]
  }

  /**
   * Detection findMany
   */
  export type DetectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter, which Detections to fetch.
     */
    where?: DetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Detections to fetch.
     */
    orderBy?: DetectionOrderByWithRelationInput | DetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Detections.
     */
    cursor?: DetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Detections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Detections.
     */
    skip?: number
    distinct?: DetectionScalarFieldEnum | DetectionScalarFieldEnum[]
  }

  /**
   * Detection create
   */
  export type DetectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Detection.
     */
    data: XOR<DetectionCreateInput, DetectionUncheckedCreateInput>
  }

  /**
   * Detection createMany
   */
  export type DetectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Detections.
     */
    data: DetectionCreateManyInput | DetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Detection createManyAndReturn
   */
  export type DetectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * The data used to create many Detections.
     */
    data: DetectionCreateManyInput | DetectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Detection update
   */
  export type DetectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Detection.
     */
    data: XOR<DetectionUpdateInput, DetectionUncheckedUpdateInput>
    /**
     * Choose, which Detection to update.
     */
    where: DetectionWhereUniqueInput
  }

  /**
   * Detection updateMany
   */
  export type DetectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Detections.
     */
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyInput>
    /**
     * Filter which Detections to update
     */
    where?: DetectionWhereInput
  }

  /**
   * Detection updateManyAndReturn
   */
  export type DetectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * The data used to update Detections.
     */
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyInput>
    /**
     * Filter which Detections to update
     */
    where?: DetectionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Detection upsert
   */
  export type DetectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Detection to update in case it exists.
     */
    where: DetectionWhereUniqueInput
    /**
     * In case the Detection found by the `where` argument doesn't exist, create a new Detection with this data.
     */
    create: XOR<DetectionCreateInput, DetectionUncheckedCreateInput>
    /**
     * In case the Detection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectionUpdateInput, DetectionUncheckedUpdateInput>
  }

  /**
   * Detection delete
   */
  export type DetectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
    /**
     * Filter which Detection to delete.
     */
    where: DetectionWhereUniqueInput
  }

  /**
   * Detection deleteMany
   */
  export type DetectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Detections to delete
     */
    where?: DetectionWhereInput
  }

  /**
   * Detection.room
   */
  export type Detection$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * Detection without action
   */
  export type DetectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Detection
     */
    select?: DetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Detection
     */
    omit?: DetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectionInclude<ExtArgs> | null
  }


  /**
   * Model TemplatesUsed
   */

  export type AggregateTemplatesUsed = {
    _count: TemplatesUsedCountAggregateOutputType | null
    _avg: TemplatesUsedAvgAggregateOutputType | null
    _sum: TemplatesUsedSumAggregateOutputType | null
    _min: TemplatesUsedMinAggregateOutputType | null
    _max: TemplatesUsedMaxAggregateOutputType | null
  }

  export type TemplatesUsedAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
  }

  export type TemplatesUsedSumAggregateOutputType = {
    id: number | null
    roomId: number | null
  }

  export type TemplatesUsedMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    templateCode: string | null
    roomId: number | null
  }

  export type TemplatesUsedMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    templateCode: string | null
    roomId: number | null
  }

  export type TemplatesUsedCountAggregateOutputType = {
    id: number
    createdAt: number
    templateCode: number
    roomId: number
    _all: number
  }


  export type TemplatesUsedAvgAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type TemplatesUsedSumAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type TemplatesUsedMinAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
  }

  export type TemplatesUsedMaxAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
  }

  export type TemplatesUsedCountAggregateInputType = {
    id?: true
    createdAt?: true
    templateCode?: true
    roomId?: true
    _all?: true
  }

  export type TemplatesUsedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatesUsed to aggregate.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: TemplatesUsedOrderByWithRelationInput | TemplatesUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplatesUseds
    **/
    _count?: true | TemplatesUsedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplatesUsedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplatesUsedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplatesUsedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplatesUsedMaxAggregateInputType
  }

  export type GetTemplatesUsedAggregateType<T extends TemplatesUsedAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplatesUsed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplatesUsed[P]>
      : GetScalarType<T[P], AggregateTemplatesUsed[P]>
  }




  export type TemplatesUsedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplatesUsedWhereInput
    orderBy?: TemplatesUsedOrderByWithAggregationInput | TemplatesUsedOrderByWithAggregationInput[]
    by: TemplatesUsedScalarFieldEnum[] | TemplatesUsedScalarFieldEnum
    having?: TemplatesUsedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplatesUsedCountAggregateInputType | true
    _avg?: TemplatesUsedAvgAggregateInputType
    _sum?: TemplatesUsedSumAggregateInputType
    _min?: TemplatesUsedMinAggregateInputType
    _max?: TemplatesUsedMaxAggregateInputType
  }

  export type TemplatesUsedGroupByOutputType = {
    id: number
    createdAt: Date
    templateCode: string
    roomId: number | null
    _count: TemplatesUsedCountAggregateOutputType | null
    _avg: TemplatesUsedAvgAggregateOutputType | null
    _sum: TemplatesUsedSumAggregateOutputType | null
    _min: TemplatesUsedMinAggregateOutputType | null
    _max: TemplatesUsedMaxAggregateOutputType | null
  }

  type GetTemplatesUsedGroupByPayload<T extends TemplatesUsedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplatesUsedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplatesUsedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplatesUsedGroupByOutputType[P]>
            : GetScalarType<T[P], TemplatesUsedGroupByOutputType[P]>
        }
      >
    >


  export type TemplatesUsedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    templateCode?: boolean
    roomId?: boolean
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }, ExtArgs["result"]["templatesUsed"]>

  export type TemplatesUsedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    templateCode?: boolean
    roomId?: boolean
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }, ExtArgs["result"]["templatesUsed"]>

  export type TemplatesUsedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    templateCode?: boolean
    roomId?: boolean
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }, ExtArgs["result"]["templatesUsed"]>

  export type TemplatesUsedSelectScalar = {
    id?: boolean
    createdAt?: boolean
    templateCode?: boolean
    roomId?: boolean
  }

  export type TemplatesUsedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "templateCode" | "roomId", ExtArgs["result"]["templatesUsed"]>
  export type TemplatesUsedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }
  export type TemplatesUsedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }
  export type TemplatesUsedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | TemplatesUsed$roomArgs<ExtArgs>
  }

  export type $TemplatesUsedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplatesUsed"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      templateCode: string
      roomId: number | null
    }, ExtArgs["result"]["templatesUsed"]>
    composites: {}
  }

  type TemplatesUsedGetPayload<S extends boolean | null | undefined | TemplatesUsedDefaultArgs> = $Result.GetResult<Prisma.$TemplatesUsedPayload, S>

  type TemplatesUsedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplatesUsedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplatesUsedCountAggregateInputType | true
    }

  export interface TemplatesUsedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplatesUsed'], meta: { name: 'TemplatesUsed' } }
    /**
     * Find zero or one TemplatesUsed that matches the filter.
     * @param {TemplatesUsedFindUniqueArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplatesUsedFindUniqueArgs>(args: SelectSubset<T, TemplatesUsedFindUniqueArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TemplatesUsed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplatesUsedFindUniqueOrThrowArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplatesUsedFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplatesUsedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TemplatesUsed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindFirstArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplatesUsedFindFirstArgs>(args?: SelectSubset<T, TemplatesUsedFindFirstArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TemplatesUsed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindFirstOrThrowArgs} args - Arguments to find a TemplatesUsed
     * @example
     * // Get one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplatesUsedFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplatesUsedFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TemplatesUseds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplatesUseds
     * const templatesUseds = await prisma.templatesUsed.findMany()
     * 
     * // Get first 10 TemplatesUseds
     * const templatesUseds = await prisma.templatesUsed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templatesUsedWithIdOnly = await prisma.templatesUsed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplatesUsedFindManyArgs>(args?: SelectSubset<T, TemplatesUsedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TemplatesUsed.
     * @param {TemplatesUsedCreateArgs} args - Arguments to create a TemplatesUsed.
     * @example
     * // Create one TemplatesUsed
     * const TemplatesUsed = await prisma.templatesUsed.create({
     *   data: {
     *     // ... data to create a TemplatesUsed
     *   }
     * })
     * 
     */
    create<T extends TemplatesUsedCreateArgs>(args: SelectSubset<T, TemplatesUsedCreateArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TemplatesUseds.
     * @param {TemplatesUsedCreateManyArgs} args - Arguments to create many TemplatesUseds.
     * @example
     * // Create many TemplatesUseds
     * const templatesUsed = await prisma.templatesUsed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplatesUsedCreateManyArgs>(args?: SelectSubset<T, TemplatesUsedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplatesUseds and returns the data saved in the database.
     * @param {TemplatesUsedCreateManyAndReturnArgs} args - Arguments to create many TemplatesUseds.
     * @example
     * // Create many TemplatesUseds
     * const templatesUsed = await prisma.templatesUsed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplatesUseds and only return the `id`
     * const templatesUsedWithIdOnly = await prisma.templatesUsed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplatesUsedCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplatesUsedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TemplatesUsed.
     * @param {TemplatesUsedDeleteArgs} args - Arguments to delete one TemplatesUsed.
     * @example
     * // Delete one TemplatesUsed
     * const TemplatesUsed = await prisma.templatesUsed.delete({
     *   where: {
     *     // ... filter to delete one TemplatesUsed
     *   }
     * })
     * 
     */
    delete<T extends TemplatesUsedDeleteArgs>(args: SelectSubset<T, TemplatesUsedDeleteArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TemplatesUsed.
     * @param {TemplatesUsedUpdateArgs} args - Arguments to update one TemplatesUsed.
     * @example
     * // Update one TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplatesUsedUpdateArgs>(args: SelectSubset<T, TemplatesUsedUpdateArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TemplatesUseds.
     * @param {TemplatesUsedDeleteManyArgs} args - Arguments to filter TemplatesUseds to delete.
     * @example
     * // Delete a few TemplatesUseds
     * const { count } = await prisma.templatesUsed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplatesUsedDeleteManyArgs>(args?: SelectSubset<T, TemplatesUsedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplatesUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplatesUseds
     * const templatesUsed = await prisma.templatesUsed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplatesUsedUpdateManyArgs>(args: SelectSubset<T, TemplatesUsedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplatesUseds and returns the data updated in the database.
     * @param {TemplatesUsedUpdateManyAndReturnArgs} args - Arguments to update many TemplatesUseds.
     * @example
     * // Update many TemplatesUseds
     * const templatesUsed = await prisma.templatesUsed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplatesUseds and only return the `id`
     * const templatesUsedWithIdOnly = await prisma.templatesUsed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplatesUsedUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplatesUsedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TemplatesUsed.
     * @param {TemplatesUsedUpsertArgs} args - Arguments to update or create a TemplatesUsed.
     * @example
     * // Update or create a TemplatesUsed
     * const templatesUsed = await prisma.templatesUsed.upsert({
     *   create: {
     *     // ... data to create a TemplatesUsed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplatesUsed we want to update
     *   }
     * })
     */
    upsert<T extends TemplatesUsedUpsertArgs>(args: SelectSubset<T, TemplatesUsedUpsertArgs<ExtArgs>>): Prisma__TemplatesUsedClient<$Result.GetResult<Prisma.$TemplatesUsedPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TemplatesUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedCountArgs} args - Arguments to filter TemplatesUseds to count.
     * @example
     * // Count the number of TemplatesUseds
     * const count = await prisma.templatesUsed.count({
     *   where: {
     *     // ... the filter for the TemplatesUseds we want to count
     *   }
     * })
    **/
    count<T extends TemplatesUsedCountArgs>(
      args?: Subset<T, TemplatesUsedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplatesUsedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplatesUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplatesUsedAggregateArgs>(args: Subset<T, TemplatesUsedAggregateArgs>): Prisma.PrismaPromise<GetTemplatesUsedAggregateType<T>>

    /**
     * Group by TemplatesUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesUsedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplatesUsedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplatesUsedGroupByArgs['orderBy'] }
        : { orderBy?: TemplatesUsedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplatesUsedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplatesUsedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplatesUsed model
   */
  readonly fields: TemplatesUsedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplatesUsed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplatesUsedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends TemplatesUsed$roomArgs<ExtArgs> = {}>(args?: Subset<T, TemplatesUsed$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplatesUsed model
   */ 
  interface TemplatesUsedFieldRefs {
    readonly id: FieldRef<"TemplatesUsed", 'Int'>
    readonly createdAt: FieldRef<"TemplatesUsed", 'DateTime'>
    readonly templateCode: FieldRef<"TemplatesUsed", 'String'>
    readonly roomId: FieldRef<"TemplatesUsed", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplatesUsed findUnique
   */
  export type TemplatesUsedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where: TemplatesUsedWhereUniqueInput
  }

  /**
   * TemplatesUsed findUniqueOrThrow
   */
  export type TemplatesUsedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where: TemplatesUsedWhereUniqueInput
  }

  /**
   * TemplatesUsed findFirst
   */
  export type TemplatesUsedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: TemplatesUsedOrderByWithRelationInput | TemplatesUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatesUseds.
     */
    distinct?: TemplatesUsedScalarFieldEnum | TemplatesUsedScalarFieldEnum[]
  }

  /**
   * TemplatesUsed findFirstOrThrow
   */
  export type TemplatesUsedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter, which TemplatesUsed to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: TemplatesUsedOrderByWithRelationInput | TemplatesUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatesUseds.
     */
    distinct?: TemplatesUsedScalarFieldEnum | TemplatesUsedScalarFieldEnum[]
  }

  /**
   * TemplatesUsed findMany
   */
  export type TemplatesUsedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter, which TemplatesUseds to fetch.
     */
    where?: TemplatesUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatesUseds to fetch.
     */
    orderBy?: TemplatesUsedOrderByWithRelationInput | TemplatesUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplatesUseds.
     */
    cursor?: TemplatesUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatesUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatesUseds.
     */
    skip?: number
    distinct?: TemplatesUsedScalarFieldEnum | TemplatesUsedScalarFieldEnum[]
  }

  /**
   * TemplatesUsed create
   */
  export type TemplatesUsedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplatesUsed.
     */
    data: XOR<TemplatesUsedCreateInput, TemplatesUsedUncheckedCreateInput>
  }

  /**
   * TemplatesUsed createMany
   */
  export type TemplatesUsedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplatesUseds.
     */
    data: TemplatesUsedCreateManyInput | TemplatesUsedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplatesUsed createManyAndReturn
   */
  export type TemplatesUsedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * The data used to create many TemplatesUseds.
     */
    data: TemplatesUsedCreateManyInput | TemplatesUsedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplatesUsed update
   */
  export type TemplatesUsedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplatesUsed.
     */
    data: XOR<TemplatesUsedUpdateInput, TemplatesUsedUncheckedUpdateInput>
    /**
     * Choose, which TemplatesUsed to update.
     */
    where: TemplatesUsedWhereUniqueInput
  }

  /**
   * TemplatesUsed updateMany
   */
  export type TemplatesUsedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplatesUseds.
     */
    data: XOR<TemplatesUsedUpdateManyMutationInput, TemplatesUsedUncheckedUpdateManyInput>
    /**
     * Filter which TemplatesUseds to update
     */
    where?: TemplatesUsedWhereInput
  }

  /**
   * TemplatesUsed updateManyAndReturn
   */
  export type TemplatesUsedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * The data used to update TemplatesUseds.
     */
    data: XOR<TemplatesUsedUpdateManyMutationInput, TemplatesUsedUncheckedUpdateManyInput>
    /**
     * Filter which TemplatesUseds to update
     */
    where?: TemplatesUsedWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplatesUsed upsert
   */
  export type TemplatesUsedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplatesUsed to update in case it exists.
     */
    where: TemplatesUsedWhereUniqueInput
    /**
     * In case the TemplatesUsed found by the `where` argument doesn't exist, create a new TemplatesUsed with this data.
     */
    create: XOR<TemplatesUsedCreateInput, TemplatesUsedUncheckedCreateInput>
    /**
     * In case the TemplatesUsed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplatesUsedUpdateInput, TemplatesUsedUncheckedUpdateInput>
  }

  /**
   * TemplatesUsed delete
   */
  export type TemplatesUsedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
    /**
     * Filter which TemplatesUsed to delete.
     */
    where: TemplatesUsedWhereUniqueInput
  }

  /**
   * TemplatesUsed deleteMany
   */
  export type TemplatesUsedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatesUseds to delete
     */
    where?: TemplatesUsedWhereInput
  }

  /**
   * TemplatesUsed.room
   */
  export type TemplatesUsed$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }

  /**
   * TemplatesUsed without action
   */
  export type TemplatesUsedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatesUsed
     */
    select?: TemplatesUsedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplatesUsed
     */
    omit?: TemplatesUsedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplatesUsedInclude<ExtArgs> | null
  }


  /**
   * Model WaitList
   */

  export type AggregateWaitList = {
    _count: WaitListCountAggregateOutputType | null
    _avg: WaitListAvgAggregateOutputType | null
    _sum: WaitListSumAggregateOutputType | null
    _min: WaitListMinAggregateOutputType | null
    _max: WaitListMaxAggregateOutputType | null
  }

  export type WaitListAvgAggregateOutputType = {
    id: number | null
  }

  export type WaitListSumAggregateOutputType = {
    id: number | null
  }

  export type WaitListMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
  }

  export type WaitListMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    email: string | null
  }

  export type WaitListCountAggregateOutputType = {
    id: number
    createdAt: number
    email: number
    _all: number
  }


  export type WaitListAvgAggregateInputType = {
    id?: true
  }

  export type WaitListSumAggregateInputType = {
    id?: true
  }

  export type WaitListMinAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
  }

  export type WaitListMaxAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
  }

  export type WaitListCountAggregateInputType = {
    id?: true
    createdAt?: true
    email?: true
    _all?: true
  }

  export type WaitListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaitList to aggregate.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: WaitListOrderByWithRelationInput | WaitListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaitLists
    **/
    _count?: true | WaitListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaitListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaitListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaitListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaitListMaxAggregateInputType
  }

  export type GetWaitListAggregateType<T extends WaitListAggregateArgs> = {
        [P in keyof T & keyof AggregateWaitList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaitList[P]>
      : GetScalarType<T[P], AggregateWaitList[P]>
  }




  export type WaitListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaitListWhereInput
    orderBy?: WaitListOrderByWithAggregationInput | WaitListOrderByWithAggregationInput[]
    by: WaitListScalarFieldEnum[] | WaitListScalarFieldEnum
    having?: WaitListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaitListCountAggregateInputType | true
    _avg?: WaitListAvgAggregateInputType
    _sum?: WaitListSumAggregateInputType
    _min?: WaitListMinAggregateInputType
    _max?: WaitListMaxAggregateInputType
  }

  export type WaitListGroupByOutputType = {
    id: number
    createdAt: Date
    email: string
    _count: WaitListCountAggregateOutputType | null
    _avg: WaitListAvgAggregateOutputType | null
    _sum: WaitListSumAggregateOutputType | null
    _min: WaitListMinAggregateOutputType | null
    _max: WaitListMaxAggregateOutputType | null
  }

  type GetWaitListGroupByPayload<T extends WaitListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaitListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaitListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaitListGroupByOutputType[P]>
            : GetScalarType<T[P], WaitListGroupByOutputType[P]>
        }
      >
    >


  export type WaitListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    email?: boolean
  }, ExtArgs["result"]["waitList"]>

  export type WaitListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    email?: boolean
  }, ExtArgs["result"]["waitList"]>

  export type WaitListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    email?: boolean
  }, ExtArgs["result"]["waitList"]>

  export type WaitListSelectScalar = {
    id?: boolean
    createdAt?: boolean
    email?: boolean
  }

  export type WaitListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "email", ExtArgs["result"]["waitList"]>

  export type $WaitListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WaitList"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      email: string
    }, ExtArgs["result"]["waitList"]>
    composites: {}
  }

  type WaitListGetPayload<S extends boolean | null | undefined | WaitListDefaultArgs> = $Result.GetResult<Prisma.$WaitListPayload, S>

  type WaitListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WaitListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WaitListCountAggregateInputType | true
    }

  export interface WaitListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WaitList'], meta: { name: 'WaitList' } }
    /**
     * Find zero or one WaitList that matches the filter.
     * @param {WaitListFindUniqueArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaitListFindUniqueArgs>(args: SelectSubset<T, WaitListFindUniqueArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WaitList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WaitListFindUniqueOrThrowArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaitListFindUniqueOrThrowArgs>(args: SelectSubset<T, WaitListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WaitList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindFirstArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaitListFindFirstArgs>(args?: SelectSubset<T, WaitListFindFirstArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WaitList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindFirstOrThrowArgs} args - Arguments to find a WaitList
     * @example
     * // Get one WaitList
     * const waitList = await prisma.waitList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaitListFindFirstOrThrowArgs>(args?: SelectSubset<T, WaitListFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WaitLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaitLists
     * const waitLists = await prisma.waitList.findMany()
     * 
     * // Get first 10 WaitLists
     * const waitLists = await prisma.waitList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waitListWithIdOnly = await prisma.waitList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaitListFindManyArgs>(args?: SelectSubset<T, WaitListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WaitList.
     * @param {WaitListCreateArgs} args - Arguments to create a WaitList.
     * @example
     * // Create one WaitList
     * const WaitList = await prisma.waitList.create({
     *   data: {
     *     // ... data to create a WaitList
     *   }
     * })
     * 
     */
    create<T extends WaitListCreateArgs>(args: SelectSubset<T, WaitListCreateArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WaitLists.
     * @param {WaitListCreateManyArgs} args - Arguments to create many WaitLists.
     * @example
     * // Create many WaitLists
     * const waitList = await prisma.waitList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaitListCreateManyArgs>(args?: SelectSubset<T, WaitListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WaitLists and returns the data saved in the database.
     * @param {WaitListCreateManyAndReturnArgs} args - Arguments to create many WaitLists.
     * @example
     * // Create many WaitLists
     * const waitList = await prisma.waitList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WaitLists and only return the `id`
     * const waitListWithIdOnly = await prisma.waitList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaitListCreateManyAndReturnArgs>(args?: SelectSubset<T, WaitListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WaitList.
     * @param {WaitListDeleteArgs} args - Arguments to delete one WaitList.
     * @example
     * // Delete one WaitList
     * const WaitList = await prisma.waitList.delete({
     *   where: {
     *     // ... filter to delete one WaitList
     *   }
     * })
     * 
     */
    delete<T extends WaitListDeleteArgs>(args: SelectSubset<T, WaitListDeleteArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WaitList.
     * @param {WaitListUpdateArgs} args - Arguments to update one WaitList.
     * @example
     * // Update one WaitList
     * const waitList = await prisma.waitList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaitListUpdateArgs>(args: SelectSubset<T, WaitListUpdateArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WaitLists.
     * @param {WaitListDeleteManyArgs} args - Arguments to filter WaitLists to delete.
     * @example
     * // Delete a few WaitLists
     * const { count } = await prisma.waitList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaitListDeleteManyArgs>(args?: SelectSubset<T, WaitListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaitLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaitLists
     * const waitList = await prisma.waitList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaitListUpdateManyArgs>(args: SelectSubset<T, WaitListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaitLists and returns the data updated in the database.
     * @param {WaitListUpdateManyAndReturnArgs} args - Arguments to update many WaitLists.
     * @example
     * // Update many WaitLists
     * const waitList = await prisma.waitList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WaitLists and only return the `id`
     * const waitListWithIdOnly = await prisma.waitList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WaitListUpdateManyAndReturnArgs>(args: SelectSubset<T, WaitListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WaitList.
     * @param {WaitListUpsertArgs} args - Arguments to update or create a WaitList.
     * @example
     * // Update or create a WaitList
     * const waitList = await prisma.waitList.upsert({
     *   create: {
     *     // ... data to create a WaitList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaitList we want to update
     *   }
     * })
     */
    upsert<T extends WaitListUpsertArgs>(args: SelectSubset<T, WaitListUpsertArgs<ExtArgs>>): Prisma__WaitListClient<$Result.GetResult<Prisma.$WaitListPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WaitLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListCountArgs} args - Arguments to filter WaitLists to count.
     * @example
     * // Count the number of WaitLists
     * const count = await prisma.waitList.count({
     *   where: {
     *     // ... the filter for the WaitLists we want to count
     *   }
     * })
    **/
    count<T extends WaitListCountArgs>(
      args?: Subset<T, WaitListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaitListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaitList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaitListAggregateArgs>(args: Subset<T, WaitListAggregateArgs>): Prisma.PrismaPromise<GetWaitListAggregateType<T>>

    /**
     * Group by WaitList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaitListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaitListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaitListGroupByArgs['orderBy'] }
        : { orderBy?: WaitListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaitListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaitListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WaitList model
   */
  readonly fields: WaitListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WaitList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaitListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WaitList model
   */ 
  interface WaitListFieldRefs {
    readonly id: FieldRef<"WaitList", 'Int'>
    readonly createdAt: FieldRef<"WaitList", 'DateTime'>
    readonly email: FieldRef<"WaitList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WaitList findUnique
   */
  export type WaitListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter, which WaitList to fetch.
     */
    where: WaitListWhereUniqueInput
  }

  /**
   * WaitList findUniqueOrThrow
   */
  export type WaitListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter, which WaitList to fetch.
     */
    where: WaitListWhereUniqueInput
  }

  /**
   * WaitList findFirst
   */
  export type WaitListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter, which WaitList to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: WaitListOrderByWithRelationInput | WaitListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitLists.
     */
    distinct?: WaitListScalarFieldEnum | WaitListScalarFieldEnum[]
  }

  /**
   * WaitList findFirstOrThrow
   */
  export type WaitListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter, which WaitList to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: WaitListOrderByWithRelationInput | WaitListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaitLists.
     */
    distinct?: WaitListScalarFieldEnum | WaitListScalarFieldEnum[]
  }

  /**
   * WaitList findMany
   */
  export type WaitListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter, which WaitLists to fetch.
     */
    where?: WaitListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaitLists to fetch.
     */
    orderBy?: WaitListOrderByWithRelationInput | WaitListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaitLists.
     */
    cursor?: WaitListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaitLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaitLists.
     */
    skip?: number
    distinct?: WaitListScalarFieldEnum | WaitListScalarFieldEnum[]
  }

  /**
   * WaitList create
   */
  export type WaitListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * The data needed to create a WaitList.
     */
    data: XOR<WaitListCreateInput, WaitListUncheckedCreateInput>
  }

  /**
   * WaitList createMany
   */
  export type WaitListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WaitLists.
     */
    data: WaitListCreateManyInput | WaitListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaitList createManyAndReturn
   */
  export type WaitListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * The data used to create many WaitLists.
     */
    data: WaitListCreateManyInput | WaitListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaitList update
   */
  export type WaitListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * The data needed to update a WaitList.
     */
    data: XOR<WaitListUpdateInput, WaitListUncheckedUpdateInput>
    /**
     * Choose, which WaitList to update.
     */
    where: WaitListWhereUniqueInput
  }

  /**
   * WaitList updateMany
   */
  export type WaitListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WaitLists.
     */
    data: XOR<WaitListUpdateManyMutationInput, WaitListUncheckedUpdateManyInput>
    /**
     * Filter which WaitLists to update
     */
    where?: WaitListWhereInput
  }

  /**
   * WaitList updateManyAndReturn
   */
  export type WaitListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * The data used to update WaitLists.
     */
    data: XOR<WaitListUpdateManyMutationInput, WaitListUncheckedUpdateManyInput>
    /**
     * Filter which WaitLists to update
     */
    where?: WaitListWhereInput
  }

  /**
   * WaitList upsert
   */
  export type WaitListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * The filter to search for the WaitList to update in case it exists.
     */
    where: WaitListWhereUniqueInput
    /**
     * In case the WaitList found by the `where` argument doesn't exist, create a new WaitList with this data.
     */
    create: XOR<WaitListCreateInput, WaitListUncheckedCreateInput>
    /**
     * In case the WaitList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaitListUpdateInput, WaitListUncheckedUpdateInput>
  }

  /**
   * WaitList delete
   */
  export type WaitListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
    /**
     * Filter which WaitList to delete.
     */
    where: WaitListWhereUniqueInput
  }

  /**
   * WaitList deleteMany
   */
  export type WaitListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaitLists to delete
     */
    where?: WaitListWhereInput
  }

  /**
   * WaitList without action
   */
  export type WaitListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaitList
     */
    select?: WaitListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WaitList
     */
    omit?: WaitListOmit<ExtArgs> | null
  }


  /**
   * Model RekognitionRuns
   */

  export type AggregateRekognitionRuns = {
    _count: RekognitionRunsCountAggregateOutputType | null
    _avg: RekognitionRunsAvgAggregateOutputType | null
    _sum: RekognitionRunsSumAggregateOutputType | null
    _min: RekognitionRunsMinAggregateOutputType | null
    _max: RekognitionRunsMaxAggregateOutputType | null
  }

  export type RekognitionRunsAvgAggregateOutputType = {
    id: number | null
  }

  export type RekognitionRunsSumAggregateOutputType = {
    id: number | null
  }

  export type RekognitionRunsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type RekognitionRunsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type RekognitionRunsCountAggregateOutputType = {
    id: number
    createdAt: number
    _all: number
  }


  export type RekognitionRunsAvgAggregateInputType = {
    id?: true
  }

  export type RekognitionRunsSumAggregateInputType = {
    id?: true
  }

  export type RekognitionRunsMinAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type RekognitionRunsMaxAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type RekognitionRunsCountAggregateInputType = {
    id?: true
    createdAt?: true
    _all?: true
  }

  export type RekognitionRunsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RekognitionRuns to aggregate.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: RekognitionRunsOrderByWithRelationInput | RekognitionRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RekognitionRuns
    **/
    _count?: true | RekognitionRunsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RekognitionRunsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RekognitionRunsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RekognitionRunsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RekognitionRunsMaxAggregateInputType
  }

  export type GetRekognitionRunsAggregateType<T extends RekognitionRunsAggregateArgs> = {
        [P in keyof T & keyof AggregateRekognitionRuns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRekognitionRuns[P]>
      : GetScalarType<T[P], AggregateRekognitionRuns[P]>
  }




  export type RekognitionRunsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RekognitionRunsWhereInput
    orderBy?: RekognitionRunsOrderByWithAggregationInput | RekognitionRunsOrderByWithAggregationInput[]
    by: RekognitionRunsScalarFieldEnum[] | RekognitionRunsScalarFieldEnum
    having?: RekognitionRunsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RekognitionRunsCountAggregateInputType | true
    _avg?: RekognitionRunsAvgAggregateInputType
    _sum?: RekognitionRunsSumAggregateInputType
    _min?: RekognitionRunsMinAggregateInputType
    _max?: RekognitionRunsMaxAggregateInputType
  }

  export type RekognitionRunsGroupByOutputType = {
    id: number
    createdAt: Date
    _count: RekognitionRunsCountAggregateOutputType | null
    _avg: RekognitionRunsAvgAggregateOutputType | null
    _sum: RekognitionRunsSumAggregateOutputType | null
    _min: RekognitionRunsMinAggregateOutputType | null
    _max: RekognitionRunsMaxAggregateOutputType | null
  }

  type GetRekognitionRunsGroupByPayload<T extends RekognitionRunsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RekognitionRunsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RekognitionRunsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RekognitionRunsGroupByOutputType[P]>
            : GetScalarType<T[P], RekognitionRunsGroupByOutputType[P]>
        }
      >
    >


  export type RekognitionRunsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rekognitionRuns"]>

  export type RekognitionRunsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rekognitionRuns"]>

  export type RekognitionRunsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rekognitionRuns"]>

  export type RekognitionRunsSelectScalar = {
    id?: boolean
    createdAt?: boolean
  }

  export type RekognitionRunsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt", ExtArgs["result"]["rekognitionRuns"]>

  export type $RekognitionRunsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RekognitionRuns"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
    }, ExtArgs["result"]["rekognitionRuns"]>
    composites: {}
  }

  type RekognitionRunsGetPayload<S extends boolean | null | undefined | RekognitionRunsDefaultArgs> = $Result.GetResult<Prisma.$RekognitionRunsPayload, S>

  type RekognitionRunsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RekognitionRunsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RekognitionRunsCountAggregateInputType | true
    }

  export interface RekognitionRunsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RekognitionRuns'], meta: { name: 'RekognitionRuns' } }
    /**
     * Find zero or one RekognitionRuns that matches the filter.
     * @param {RekognitionRunsFindUniqueArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RekognitionRunsFindUniqueArgs>(args: SelectSubset<T, RekognitionRunsFindUniqueArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RekognitionRuns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RekognitionRunsFindUniqueOrThrowArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RekognitionRunsFindUniqueOrThrowArgs>(args: SelectSubset<T, RekognitionRunsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RekognitionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindFirstArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RekognitionRunsFindFirstArgs>(args?: SelectSubset<T, RekognitionRunsFindFirstArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RekognitionRuns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindFirstOrThrowArgs} args - Arguments to find a RekognitionRuns
     * @example
     * // Get one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RekognitionRunsFindFirstOrThrowArgs>(args?: SelectSubset<T, RekognitionRunsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RekognitionRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findMany()
     * 
     * // Get first 10 RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rekognitionRunsWithIdOnly = await prisma.rekognitionRuns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RekognitionRunsFindManyArgs>(args?: SelectSubset<T, RekognitionRunsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RekognitionRuns.
     * @param {RekognitionRunsCreateArgs} args - Arguments to create a RekognitionRuns.
     * @example
     * // Create one RekognitionRuns
     * const RekognitionRuns = await prisma.rekognitionRuns.create({
     *   data: {
     *     // ... data to create a RekognitionRuns
     *   }
     * })
     * 
     */
    create<T extends RekognitionRunsCreateArgs>(args: SelectSubset<T, RekognitionRunsCreateArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RekognitionRuns.
     * @param {RekognitionRunsCreateManyArgs} args - Arguments to create many RekognitionRuns.
     * @example
     * // Create many RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RekognitionRunsCreateManyArgs>(args?: SelectSubset<T, RekognitionRunsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RekognitionRuns and returns the data saved in the database.
     * @param {RekognitionRunsCreateManyAndReturnArgs} args - Arguments to create many RekognitionRuns.
     * @example
     * // Create many RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RekognitionRuns and only return the `id`
     * const rekognitionRunsWithIdOnly = await prisma.rekognitionRuns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RekognitionRunsCreateManyAndReturnArgs>(args?: SelectSubset<T, RekognitionRunsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RekognitionRuns.
     * @param {RekognitionRunsDeleteArgs} args - Arguments to delete one RekognitionRuns.
     * @example
     * // Delete one RekognitionRuns
     * const RekognitionRuns = await prisma.rekognitionRuns.delete({
     *   where: {
     *     // ... filter to delete one RekognitionRuns
     *   }
     * })
     * 
     */
    delete<T extends RekognitionRunsDeleteArgs>(args: SelectSubset<T, RekognitionRunsDeleteArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RekognitionRuns.
     * @param {RekognitionRunsUpdateArgs} args - Arguments to update one RekognitionRuns.
     * @example
     * // Update one RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RekognitionRunsUpdateArgs>(args: SelectSubset<T, RekognitionRunsUpdateArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RekognitionRuns.
     * @param {RekognitionRunsDeleteManyArgs} args - Arguments to filter RekognitionRuns to delete.
     * @example
     * // Delete a few RekognitionRuns
     * const { count } = await prisma.rekognitionRuns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RekognitionRunsDeleteManyArgs>(args?: SelectSubset<T, RekognitionRunsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RekognitionRunsUpdateManyArgs>(args: SelectSubset<T, RekognitionRunsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RekognitionRuns and returns the data updated in the database.
     * @param {RekognitionRunsUpdateManyAndReturnArgs} args - Arguments to update many RekognitionRuns.
     * @example
     * // Update many RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RekognitionRuns and only return the `id`
     * const rekognitionRunsWithIdOnly = await prisma.rekognitionRuns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RekognitionRunsUpdateManyAndReturnArgs>(args: SelectSubset<T, RekognitionRunsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RekognitionRuns.
     * @param {RekognitionRunsUpsertArgs} args - Arguments to update or create a RekognitionRuns.
     * @example
     * // Update or create a RekognitionRuns
     * const rekognitionRuns = await prisma.rekognitionRuns.upsert({
     *   create: {
     *     // ... data to create a RekognitionRuns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RekognitionRuns we want to update
     *   }
     * })
     */
    upsert<T extends RekognitionRunsUpsertArgs>(args: SelectSubset<T, RekognitionRunsUpsertArgs<ExtArgs>>): Prisma__RekognitionRunsClient<$Result.GetResult<Prisma.$RekognitionRunsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsCountArgs} args - Arguments to filter RekognitionRuns to count.
     * @example
     * // Count the number of RekognitionRuns
     * const count = await prisma.rekognitionRuns.count({
     *   where: {
     *     // ... the filter for the RekognitionRuns we want to count
     *   }
     * })
    **/
    count<T extends RekognitionRunsCountArgs>(
      args?: Subset<T, RekognitionRunsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RekognitionRunsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RekognitionRunsAggregateArgs>(args: Subset<T, RekognitionRunsAggregateArgs>): Prisma.PrismaPromise<GetRekognitionRunsAggregateType<T>>

    /**
     * Group by RekognitionRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RekognitionRunsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RekognitionRunsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RekognitionRunsGroupByArgs['orderBy'] }
        : { orderBy?: RekognitionRunsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RekognitionRunsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRekognitionRunsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RekognitionRuns model
   */
  readonly fields: RekognitionRunsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RekognitionRuns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RekognitionRunsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RekognitionRuns model
   */ 
  interface RekognitionRunsFieldRefs {
    readonly id: FieldRef<"RekognitionRuns", 'Int'>
    readonly createdAt: FieldRef<"RekognitionRuns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RekognitionRuns findUnique
   */
  export type RekognitionRunsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where: RekognitionRunsWhereUniqueInput
  }

  /**
   * RekognitionRuns findUniqueOrThrow
   */
  export type RekognitionRunsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where: RekognitionRunsWhereUniqueInput
  }

  /**
   * RekognitionRuns findFirst
   */
  export type RekognitionRunsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: RekognitionRunsOrderByWithRelationInput | RekognitionRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RekognitionRuns.
     */
    distinct?: RekognitionRunsScalarFieldEnum | RekognitionRunsScalarFieldEnum[]
  }

  /**
   * RekognitionRuns findFirstOrThrow
   */
  export type RekognitionRunsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: RekognitionRunsOrderByWithRelationInput | RekognitionRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RekognitionRuns.
     */
    distinct?: RekognitionRunsScalarFieldEnum | RekognitionRunsScalarFieldEnum[]
  }

  /**
   * RekognitionRuns findMany
   */
  export type RekognitionRunsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter, which RekognitionRuns to fetch.
     */
    where?: RekognitionRunsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RekognitionRuns to fetch.
     */
    orderBy?: RekognitionRunsOrderByWithRelationInput | RekognitionRunsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RekognitionRuns.
     */
    cursor?: RekognitionRunsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RekognitionRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RekognitionRuns.
     */
    skip?: number
    distinct?: RekognitionRunsScalarFieldEnum | RekognitionRunsScalarFieldEnum[]
  }

  /**
   * RekognitionRuns create
   */
  export type RekognitionRunsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * The data needed to create a RekognitionRuns.
     */
    data?: XOR<RekognitionRunsCreateInput, RekognitionRunsUncheckedCreateInput>
  }

  /**
   * RekognitionRuns createMany
   */
  export type RekognitionRunsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RekognitionRuns.
     */
    data: RekognitionRunsCreateManyInput | RekognitionRunsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RekognitionRuns createManyAndReturn
   */
  export type RekognitionRunsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * The data used to create many RekognitionRuns.
     */
    data: RekognitionRunsCreateManyInput | RekognitionRunsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RekognitionRuns update
   */
  export type RekognitionRunsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * The data needed to update a RekognitionRuns.
     */
    data: XOR<RekognitionRunsUpdateInput, RekognitionRunsUncheckedUpdateInput>
    /**
     * Choose, which RekognitionRuns to update.
     */
    where: RekognitionRunsWhereUniqueInput
  }

  /**
   * RekognitionRuns updateMany
   */
  export type RekognitionRunsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RekognitionRuns.
     */
    data: XOR<RekognitionRunsUpdateManyMutationInput, RekognitionRunsUncheckedUpdateManyInput>
    /**
     * Filter which RekognitionRuns to update
     */
    where?: RekognitionRunsWhereInput
  }

  /**
   * RekognitionRuns updateManyAndReturn
   */
  export type RekognitionRunsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * The data used to update RekognitionRuns.
     */
    data: XOR<RekognitionRunsUpdateManyMutationInput, RekognitionRunsUncheckedUpdateManyInput>
    /**
     * Filter which RekognitionRuns to update
     */
    where?: RekognitionRunsWhereInput
  }

  /**
   * RekognitionRuns upsert
   */
  export type RekognitionRunsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * The filter to search for the RekognitionRuns to update in case it exists.
     */
    where: RekognitionRunsWhereUniqueInput
    /**
     * In case the RekognitionRuns found by the `where` argument doesn't exist, create a new RekognitionRuns with this data.
     */
    create: XOR<RekognitionRunsCreateInput, RekognitionRunsUncheckedCreateInput>
    /**
     * In case the RekognitionRuns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RekognitionRunsUpdateInput, RekognitionRunsUncheckedUpdateInput>
  }

  /**
   * RekognitionRuns delete
   */
  export type RekognitionRunsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
    /**
     * Filter which RekognitionRuns to delete.
     */
    where: RekognitionRunsWhereUniqueInput
  }

  /**
   * RekognitionRuns deleteMany
   */
  export type RekognitionRunsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RekognitionRuns to delete
     */
    where?: RekognitionRunsWhereInput
  }

  /**
   * RekognitionRuns without action
   */
  export type RekognitionRunsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RekognitionRuns
     */
    select?: RekognitionRunsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RekognitionRuns
     */
    omit?: RekognitionRunsOmit<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CalendarEventSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    payload: string | null
    projectId: number | null
    date: Date | null
    dynamicId: string | null
    isDeleted: boolean | null
    remindClient: boolean | null
    remindProjectOwners: boolean | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    payload: string | null
    projectId: number | null
    date: Date | null
    dynamicId: string | null
    isDeleted: boolean | null
    remindClient: boolean | null
    remindProjectOwners: boolean | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    publicId: number
    createdAt: number
    updatedAt: number
    subject: number
    payload: number
    projectId: number
    date: number
    dynamicId: number
    isDeleted: number
    remindClient: number
    remindProjectOwners: number
    _all: number
  }


  export type CalendarEventAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CalendarEventSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CalendarEventMinAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    payload?: true
    projectId?: true
    date?: true
    dynamicId?: true
    isDeleted?: true
    remindClient?: true
    remindProjectOwners?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _avg?: CalendarEventAvgAggregateInputType
    _sum?: CalendarEventSumAggregateInputType
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: number
    publicId: string
    createdAt: Date
    updatedAt: Date
    subject: string
    payload: string
    projectId: number | null
    date: Date
    dynamicId: string
    isDeleted: boolean
    remindClient: boolean
    remindProjectOwners: boolean
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    payload?: boolean
    projectId?: boolean
    date?: boolean
    dynamicId?: boolean
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: boolean | CalendarEvent$remindersArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    payload?: boolean
    projectId?: boolean
    date?: boolean
    dynamicId?: boolean
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    payload?: boolean
    projectId?: boolean
    date?: boolean
    dynamicId?: boolean
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    payload?: boolean
    projectId?: boolean
    date?: boolean
    dynamicId?: boolean
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type CalendarEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicId" | "createdAt" | "updatedAt" | "subject" | "payload" | "projectId" | "date" | "dynamicId" | "isDeleted" | "remindClient" | "remindProjectOwners", ExtArgs["result"]["calendarEvent"]>
  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reminders?: boolean | CalendarEvent$remindersArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }
  export type CalendarEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      reminders: Prisma.$CalendarEventReminderPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicId: string
      createdAt: Date
      updatedAt: Date
      subject: string
      payload: string
      projectId: number | null
      date: Date
      dynamicId: string
      isDeleted: boolean
      remindClient: boolean
      remindProjectOwners: boolean
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents and returns the data updated in the database.
     * @param {CalendarEventUpdateManyAndReturnArgs} args - Arguments to update many CalendarEvents.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reminders<T extends CalendarEvent$remindersArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    project<T extends CalendarEvent$projectArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */ 
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'Int'>
    readonly publicId: FieldRef<"CalendarEvent", 'String'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly subject: FieldRef<"CalendarEvent", 'String'>
    readonly payload: FieldRef<"CalendarEvent", 'String'>
    readonly projectId: FieldRef<"CalendarEvent", 'Int'>
    readonly date: FieldRef<"CalendarEvent", 'DateTime'>
    readonly dynamicId: FieldRef<"CalendarEvent", 'String'>
    readonly isDeleted: FieldRef<"CalendarEvent", 'Boolean'>
    readonly remindClient: FieldRef<"CalendarEvent", 'Boolean'>
    readonly remindProjectOwners: FieldRef<"CalendarEvent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent updateManyAndReturn
   */
  export type CalendarEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent.reminders
   */
  export type CalendarEvent$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    where?: CalendarEventReminderWhereInput
    orderBy?: CalendarEventReminderOrderByWithRelationInput | CalendarEventReminderOrderByWithRelationInput[]
    cursor?: CalendarEventReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventReminderScalarFieldEnum | CalendarEventReminderScalarFieldEnum[]
  }

  /**
   * CalendarEvent.project
   */
  export type CalendarEvent$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEventReminder
   */

  export type AggregateCalendarEventReminder = {
    _count: CalendarEventReminderCountAggregateOutputType | null
    _avg: CalendarEventReminderAvgAggregateOutputType | null
    _sum: CalendarEventReminderSumAggregateOutputType | null
    _min: CalendarEventReminderMinAggregateOutputType | null
    _max: CalendarEventReminderMaxAggregateOutputType | null
  }

  export type CalendarEventReminderAvgAggregateOutputType = {
    id: number | null
    calendarEventId: number | null
  }

  export type CalendarEventReminderSumAggregateOutputType = {
    id: number | null
    calendarEventId: number | null
  }

  export type CalendarEventReminderMinAggregateOutputType = {
    id: number | null
    reminderTarget: $Enums.ReminderTarget | null
    createdAt: Date | null
    updatedAt: Date | null
    sendText: boolean | null
    sendEmail: boolean | null
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date | null
  }

  export type CalendarEventReminderMaxAggregateOutputType = {
    id: number | null
    reminderTarget: $Enums.ReminderTarget | null
    createdAt: Date | null
    updatedAt: Date | null
    sendText: boolean | null
    sendEmail: boolean | null
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date | null
  }

  export type CalendarEventReminderCountAggregateOutputType = {
    id: number
    reminderTarget: number
    createdAt: number
    updatedAt: number
    sendText: number
    sendEmail: number
    textSentAt: number
    emailSentAt: number
    calendarEventId: number
    date: number
    _all: number
  }


  export type CalendarEventReminderAvgAggregateInputType = {
    id?: true
    calendarEventId?: true
  }

  export type CalendarEventReminderSumAggregateInputType = {
    id?: true
    calendarEventId?: true
  }

  export type CalendarEventReminderMinAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
  }

  export type CalendarEventReminderMaxAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
  }

  export type CalendarEventReminderCountAggregateInputType = {
    id?: true
    reminderTarget?: true
    createdAt?: true
    updatedAt?: true
    sendText?: true
    sendEmail?: true
    textSentAt?: true
    emailSentAt?: true
    calendarEventId?: true
    date?: true
    _all?: true
  }

  export type CalendarEventReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventReminder to aggregate.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: CalendarEventReminderOrderByWithRelationInput | CalendarEventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEventReminders
    **/
    _count?: true | CalendarEventReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEventReminderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEventReminderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventReminderMaxAggregateInputType
  }

  export type GetCalendarEventReminderAggregateType<T extends CalendarEventReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEventReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEventReminder[P]>
      : GetScalarType<T[P], AggregateCalendarEventReminder[P]>
  }




  export type CalendarEventReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventReminderWhereInput
    orderBy?: CalendarEventReminderOrderByWithAggregationInput | CalendarEventReminderOrderByWithAggregationInput[]
    by: CalendarEventReminderScalarFieldEnum[] | CalendarEventReminderScalarFieldEnum
    having?: CalendarEventReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventReminderCountAggregateInputType | true
    _avg?: CalendarEventReminderAvgAggregateInputType
    _sum?: CalendarEventReminderSumAggregateInputType
    _min?: CalendarEventReminderMinAggregateInputType
    _max?: CalendarEventReminderMaxAggregateInputType
  }

  export type CalendarEventReminderGroupByOutputType = {
    id: number
    reminderTarget: $Enums.ReminderTarget
    createdAt: Date
    updatedAt: Date
    sendText: boolean
    sendEmail: boolean
    textSentAt: Date | null
    emailSentAt: Date | null
    calendarEventId: number | null
    date: Date
    _count: CalendarEventReminderCountAggregateOutputType | null
    _avg: CalendarEventReminderAvgAggregateOutputType | null
    _sum: CalendarEventReminderSumAggregateOutputType | null
    _min: CalendarEventReminderMinAggregateOutputType | null
    _max: CalendarEventReminderMaxAggregateOutputType | null
  }

  type GetCalendarEventReminderGroupByPayload<T extends CalendarEventReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventReminderGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventReminderGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reminderTarget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: boolean
    emailSentAt?: boolean
    calendarEventId?: boolean
    date?: boolean
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventReminder"]>

  export type CalendarEventReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reminderTarget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: boolean
    emailSentAt?: boolean
    calendarEventId?: boolean
    date?: boolean
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventReminder"]>

  export type CalendarEventReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reminderTarget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: boolean
    emailSentAt?: boolean
    calendarEventId?: boolean
    date?: boolean
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventReminder"]>

  export type CalendarEventReminderSelectScalar = {
    id?: boolean
    reminderTarget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: boolean
    emailSentAt?: boolean
    calendarEventId?: boolean
    date?: boolean
  }

  export type CalendarEventReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reminderTarget" | "createdAt" | "updatedAt" | "sendText" | "sendEmail" | "textSentAt" | "emailSentAt" | "calendarEventId" | "date", ExtArgs["result"]["calendarEventReminder"]>
  export type CalendarEventReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }
  export type CalendarEventReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }
  export type CalendarEventReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendarEvent?: boolean | CalendarEventReminder$calendarEventArgs<ExtArgs>
  }

  export type $CalendarEventReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEventReminder"
    objects: {
      calendarEvent: Prisma.$CalendarEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reminderTarget: $Enums.ReminderTarget
      createdAt: Date
      updatedAt: Date
      sendText: boolean
      sendEmail: boolean
      textSentAt: Date | null
      emailSentAt: Date | null
      calendarEventId: number | null
      date: Date
    }, ExtArgs["result"]["calendarEventReminder"]>
    composites: {}
  }

  type CalendarEventReminderGetPayload<S extends boolean | null | undefined | CalendarEventReminderDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventReminderPayload, S>

  type CalendarEventReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventReminderCountAggregateInputType | true
    }

  export interface CalendarEventReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEventReminder'], meta: { name: 'CalendarEventReminder' } }
    /**
     * Find zero or one CalendarEventReminder that matches the filter.
     * @param {CalendarEventReminderFindUniqueArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventReminderFindUniqueArgs>(args: SelectSubset<T, CalendarEventReminderFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CalendarEventReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventReminderFindUniqueOrThrowArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CalendarEventReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindFirstArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventReminderFindFirstArgs>(args?: SelectSubset<T, CalendarEventReminderFindFirstArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CalendarEventReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindFirstOrThrowArgs} args - Arguments to find a CalendarEventReminder
     * @example
     * // Get one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CalendarEventReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEventReminders
     * const calendarEventReminders = await prisma.calendarEventReminder.findMany()
     * 
     * // Get first 10 CalendarEventReminders
     * const calendarEventReminders = await prisma.calendarEventReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventReminderWithIdOnly = await prisma.calendarEventReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventReminderFindManyArgs>(args?: SelectSubset<T, CalendarEventReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CalendarEventReminder.
     * @param {CalendarEventReminderCreateArgs} args - Arguments to create a CalendarEventReminder.
     * @example
     * // Create one CalendarEventReminder
     * const CalendarEventReminder = await prisma.calendarEventReminder.create({
     *   data: {
     *     // ... data to create a CalendarEventReminder
     *   }
     * })
     * 
     */
    create<T extends CalendarEventReminderCreateArgs>(args: SelectSubset<T, CalendarEventReminderCreateArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CalendarEventReminders.
     * @param {CalendarEventReminderCreateManyArgs} args - Arguments to create many CalendarEventReminders.
     * @example
     * // Create many CalendarEventReminders
     * const calendarEventReminder = await prisma.calendarEventReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventReminderCreateManyArgs>(args?: SelectSubset<T, CalendarEventReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEventReminders and returns the data saved in the database.
     * @param {CalendarEventReminderCreateManyAndReturnArgs} args - Arguments to create many CalendarEventReminders.
     * @example
     * // Create many CalendarEventReminders
     * const calendarEventReminder = await prisma.calendarEventReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEventReminders and only return the `id`
     * const calendarEventReminderWithIdOnly = await prisma.calendarEventReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CalendarEventReminder.
     * @param {CalendarEventReminderDeleteArgs} args - Arguments to delete one CalendarEventReminder.
     * @example
     * // Delete one CalendarEventReminder
     * const CalendarEventReminder = await prisma.calendarEventReminder.delete({
     *   where: {
     *     // ... filter to delete one CalendarEventReminder
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventReminderDeleteArgs>(args: SelectSubset<T, CalendarEventReminderDeleteArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CalendarEventReminder.
     * @param {CalendarEventReminderUpdateArgs} args - Arguments to update one CalendarEventReminder.
     * @example
     * // Update one CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventReminderUpdateArgs>(args: SelectSubset<T, CalendarEventReminderUpdateArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CalendarEventReminders.
     * @param {CalendarEventReminderDeleteManyArgs} args - Arguments to filter CalendarEventReminders to delete.
     * @example
     * // Delete a few CalendarEventReminders
     * const { count } = await prisma.calendarEventReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventReminderDeleteManyArgs>(args?: SelectSubset<T, CalendarEventReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEventReminders
     * const calendarEventReminder = await prisma.calendarEventReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventReminderUpdateManyArgs>(args: SelectSubset<T, CalendarEventReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventReminders and returns the data updated in the database.
     * @param {CalendarEventReminderUpdateManyAndReturnArgs} args - Arguments to update many CalendarEventReminders.
     * @example
     * // Update many CalendarEventReminders
     * const calendarEventReminder = await prisma.calendarEventReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEventReminders and only return the `id`
     * const calendarEventReminderWithIdOnly = await prisma.calendarEventReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEventReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEventReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CalendarEventReminder.
     * @param {CalendarEventReminderUpsertArgs} args - Arguments to update or create a CalendarEventReminder.
     * @example
     * // Update or create a CalendarEventReminder
     * const calendarEventReminder = await prisma.calendarEventReminder.upsert({
     *   create: {
     *     // ... data to create a CalendarEventReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEventReminder we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventReminderUpsertArgs>(args: SelectSubset<T, CalendarEventReminderUpsertArgs<ExtArgs>>): Prisma__CalendarEventReminderClient<$Result.GetResult<Prisma.$CalendarEventReminderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CalendarEventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderCountArgs} args - Arguments to filter CalendarEventReminders to count.
     * @example
     * // Count the number of CalendarEventReminders
     * const count = await prisma.calendarEventReminder.count({
     *   where: {
     *     // ... the filter for the CalendarEventReminders we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventReminderCountArgs>(
      args?: Subset<T, CalendarEventReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventReminderAggregateArgs>(args: Subset<T, CalendarEventReminderAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventReminderAggregateType<T>>

    /**
     * Group by CalendarEventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventReminderGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEventReminder model
   */
  readonly fields: CalendarEventReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEventReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendarEvent<T extends CalendarEventReminder$calendarEventArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEventReminder$calendarEventArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEventReminder model
   */ 
  interface CalendarEventReminderFieldRefs {
    readonly id: FieldRef<"CalendarEventReminder", 'Int'>
    readonly reminderTarget: FieldRef<"CalendarEventReminder", 'ReminderTarget'>
    readonly createdAt: FieldRef<"CalendarEventReminder", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEventReminder", 'DateTime'>
    readonly sendText: FieldRef<"CalendarEventReminder", 'Boolean'>
    readonly sendEmail: FieldRef<"CalendarEventReminder", 'Boolean'>
    readonly textSentAt: FieldRef<"CalendarEventReminder", 'DateTime'>
    readonly emailSentAt: FieldRef<"CalendarEventReminder", 'DateTime'>
    readonly calendarEventId: FieldRef<"CalendarEventReminder", 'Int'>
    readonly date: FieldRef<"CalendarEventReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEventReminder findUnique
   */
  export type CalendarEventReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where: CalendarEventReminderWhereUniqueInput
  }

  /**
   * CalendarEventReminder findUniqueOrThrow
   */
  export type CalendarEventReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where: CalendarEventReminderWhereUniqueInput
  }

  /**
   * CalendarEventReminder findFirst
   */
  export type CalendarEventReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: CalendarEventReminderOrderByWithRelationInput | CalendarEventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventReminders.
     */
    distinct?: CalendarEventReminderScalarFieldEnum | CalendarEventReminderScalarFieldEnum[]
  }

  /**
   * CalendarEventReminder findFirstOrThrow
   */
  export type CalendarEventReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventReminder to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: CalendarEventReminderOrderByWithRelationInput | CalendarEventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventReminders.
     */
    distinct?: CalendarEventReminderScalarFieldEnum | CalendarEventReminderScalarFieldEnum[]
  }

  /**
   * CalendarEventReminder findMany
   */
  export type CalendarEventReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventReminders to fetch.
     */
    where?: CalendarEventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventReminders to fetch.
     */
    orderBy?: CalendarEventReminderOrderByWithRelationInput | CalendarEventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEventReminders.
     */
    cursor?: CalendarEventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventReminders.
     */
    skip?: number
    distinct?: CalendarEventReminderScalarFieldEnum | CalendarEventReminderScalarFieldEnum[]
  }

  /**
   * CalendarEventReminder create
   */
  export type CalendarEventReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEventReminder.
     */
    data: XOR<CalendarEventReminderCreateInput, CalendarEventReminderUncheckedCreateInput>
  }

  /**
   * CalendarEventReminder createMany
   */
  export type CalendarEventReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEventReminders.
     */
    data: CalendarEventReminderCreateManyInput | CalendarEventReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEventReminder createManyAndReturn
   */
  export type CalendarEventReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEventReminders.
     */
    data: CalendarEventReminderCreateManyInput | CalendarEventReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEventReminder update
   */
  export type CalendarEventReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEventReminder.
     */
    data: XOR<CalendarEventReminderUpdateInput, CalendarEventReminderUncheckedUpdateInput>
    /**
     * Choose, which CalendarEventReminder to update.
     */
    where: CalendarEventReminderWhereUniqueInput
  }

  /**
   * CalendarEventReminder updateMany
   */
  export type CalendarEventReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEventReminders.
     */
    data: XOR<CalendarEventReminderUpdateManyMutationInput, CalendarEventReminderUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventReminders to update
     */
    where?: CalendarEventReminderWhereInput
  }

  /**
   * CalendarEventReminder updateManyAndReturn
   */
  export type CalendarEventReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEventReminders.
     */
    data: XOR<CalendarEventReminderUpdateManyMutationInput, CalendarEventReminderUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventReminders to update
     */
    where?: CalendarEventReminderWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEventReminder upsert
   */
  export type CalendarEventReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEventReminder to update in case it exists.
     */
    where: CalendarEventReminderWhereUniqueInput
    /**
     * In case the CalendarEventReminder found by the `where` argument doesn't exist, create a new CalendarEventReminder with this data.
     */
    create: XOR<CalendarEventReminderCreateInput, CalendarEventReminderUncheckedCreateInput>
    /**
     * In case the CalendarEventReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventReminderUpdateInput, CalendarEventReminderUncheckedUpdateInput>
  }

  /**
   * CalendarEventReminder delete
   */
  export type CalendarEventReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
    /**
     * Filter which CalendarEventReminder to delete.
     */
    where: CalendarEventReminderWhereUniqueInput
  }

  /**
   * CalendarEventReminder deleteMany
   */
  export type CalendarEventReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventReminders to delete
     */
    where?: CalendarEventReminderWhereInput
  }

  /**
   * CalendarEventReminder.calendarEvent
   */
  export type CalendarEventReminder$calendarEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEvent
     */
    omit?: CalendarEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEventReminder without action
   */
  export type CalendarEventReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventReminder
     */
    select?: CalendarEventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventReminder
     */
    omit?: CalendarEventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventReminderInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: number | null
    xactimateKey: string | null
    xactimateDescription: string | null
    hasItems: boolean | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: number | null
    xactimateKey: string | null
    xactimateDescription: string | null
    hasItems: boolean | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    xactimateKey: number
    xactimateDescription: number
    hasItems: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ItemCategorySumAggregateInputType = {
    id?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    xactimateKey?: true
    xactimateDescription?: true
    hasItems?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    id: number
    xactimateKey: string
    xactimateDescription: string
    hasItems: boolean
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateKey?: boolean
    xactimateDescription?: boolean
    hasItems?: boolean
    LineItem?: boolean | ItemCategory$LineItemArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateKey?: boolean
    xactimateDescription?: boolean
    hasItems?: boolean
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateKey?: boolean
    xactimateDescription?: boolean
    hasItems?: boolean
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectScalar = {
    id?: boolean
    xactimateKey?: boolean
    xactimateDescription?: boolean
    hasItems?: boolean
  }

  export type ItemCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xactimateKey" | "xactimateDescription" | "hasItems", ExtArgs["result"]["itemCategory"]>
  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LineItem?: boolean | ItemCategory$LineItemArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      LineItem: Prisma.$LineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      xactimateKey: string
      xactimateDescription: string
      hasItems: boolean
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategories and returns the data saved in the database.
     * @param {ItemCategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories and returns the data updated in the database.
     * @param {ItemCategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemCategories.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LineItem<T extends ItemCategory$LineItemArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$LineItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */ 
  interface ItemCategoryFieldRefs {
    readonly id: FieldRef<"ItemCategory", 'Int'>
    readonly xactimateKey: FieldRef<"ItemCategory", 'String'>
    readonly xactimateDescription: FieldRef<"ItemCategory", 'String'>
    readonly hasItems: FieldRef<"ItemCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory createManyAndReturn
   */
  export type ItemCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory updateManyAndReturn
   */
  export type ItemCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory.LineItem
   */
  export type ItemCategory$LineItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    where?: LineItemWhereInput
    orderBy?: LineItemOrderByWithRelationInput | LineItemOrderByWithRelationInput[]
    cursor?: LineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineItemScalarFieldEnum | LineItemScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model LineItem
   */

  export type AggregateLineItem = {
    _count: LineItemCountAggregateOutputType | null
    _avg: LineItemAvgAggregateOutputType | null
    _sum: LineItemSumAggregateOutputType | null
    _min: LineItemMinAggregateOutputType | null
    _max: LineItemMaxAggregateOutputType | null
  }

  export type LineItemAvgAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
  }

  export type LineItemSumAggregateOutputType = {
    id: number | null
    itemCategoryId: number | null
  }

  export type LineItemMinAggregateOutputType = {
    id: number | null
    xactimateCode: string | null
    xactimateDescription: string | null
    unit: string | null
    itemCategoryId: number | null
  }

  export type LineItemMaxAggregateOutputType = {
    id: number | null
    xactimateCode: string | null
    xactimateDescription: string | null
    unit: string | null
    itemCategoryId: number | null
  }

  export type LineItemCountAggregateOutputType = {
    id: number
    xactimateCode: number
    xactimateDescription: number
    unit: number
    itemCategoryId: number
    _all: number
  }


  export type LineItemAvgAggregateInputType = {
    id?: true
    itemCategoryId?: true
  }

  export type LineItemSumAggregateInputType = {
    id?: true
    itemCategoryId?: true
  }

  export type LineItemMinAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
  }

  export type LineItemMaxAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
  }

  export type LineItemCountAggregateInputType = {
    id?: true
    xactimateCode?: true
    xactimateDescription?: true
    unit?: true
    itemCategoryId?: true
    _all?: true
  }

  export type LineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineItem to aggregate.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: LineItemOrderByWithRelationInput | LineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineItems
    **/
    _count?: true | LineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineItemMaxAggregateInputType
  }

  export type GetLineItemAggregateType<T extends LineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineItem[P]>
      : GetScalarType<T[P], AggregateLineItem[P]>
  }




  export type LineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineItemWhereInput
    orderBy?: LineItemOrderByWithAggregationInput | LineItemOrderByWithAggregationInput[]
    by: LineItemScalarFieldEnum[] | LineItemScalarFieldEnum
    having?: LineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineItemCountAggregateInputType | true
    _avg?: LineItemAvgAggregateInputType
    _sum?: LineItemSumAggregateInputType
    _min?: LineItemMinAggregateInputType
    _max?: LineItemMaxAggregateInputType
  }

  export type LineItemGroupByOutputType = {
    id: number
    xactimateCode: string
    xactimateDescription: string
    unit: string | null
    itemCategoryId: number
    _count: LineItemCountAggregateOutputType | null
    _avg: LineItemAvgAggregateOutputType | null
    _sum: LineItemSumAggregateOutputType | null
    _min: LineItemMinAggregateOutputType | null
    _max: LineItemMaxAggregateOutputType | null
  }

  type GetLineItemGroupByPayload<T extends LineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemGroupByOutputType[P]>
        }
      >
    >


  export type LineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateCode?: boolean
    xactimateDescription?: boolean
    unit?: boolean
    itemCategoryId?: boolean
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    alternateItem?: boolean | LineItem$alternateItemArgs<ExtArgs>
    relatedItem?: boolean | LineItem$relatedItemArgs<ExtArgs>
    _count?: boolean | LineItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineItem"]>

  export type LineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateCode?: boolean
    xactimateDescription?: boolean
    unit?: boolean
    itemCategoryId?: boolean
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineItem"]>

  export type LineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xactimateCode?: boolean
    xactimateDescription?: boolean
    unit?: boolean
    itemCategoryId?: boolean
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineItem"]>

  export type LineItemSelectScalar = {
    id?: boolean
    xactimateCode?: boolean
    xactimateDescription?: boolean
    unit?: boolean
    itemCategoryId?: boolean
  }

  export type LineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xactimateCode" | "xactimateDescription" | "unit" | "itemCategoryId", ExtArgs["result"]["lineItem"]>
  export type LineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
    alternateItem?: boolean | LineItem$alternateItemArgs<ExtArgs>
    relatedItem?: boolean | LineItem$relatedItemArgs<ExtArgs>
    _count?: boolean | LineItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }
  export type LineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    xactimateCategory?: boolean | ItemCategoryDefaultArgs<ExtArgs>
  }

  export type $LineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LineItem"
    objects: {
      xactimateCategory: Prisma.$ItemCategoryPayload<ExtArgs>
      alternateItem: Prisma.$AlternateItemPayload<ExtArgs>[]
      relatedItem: Prisma.$RelatedItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      xactimateCode: string
      xactimateDescription: string
      unit: string | null
      itemCategoryId: number
    }, ExtArgs["result"]["lineItem"]>
    composites: {}
  }

  type LineItemGetPayload<S extends boolean | null | undefined | LineItemDefaultArgs> = $Result.GetResult<Prisma.$LineItemPayload, S>

  type LineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LineItemCountAggregateInputType | true
    }

  export interface LineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LineItem'], meta: { name: 'LineItem' } }
    /**
     * Find zero or one LineItem that matches the filter.
     * @param {LineItemFindUniqueArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineItemFindUniqueArgs>(args: SelectSubset<T, LineItemFindUniqueArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LineItemFindUniqueOrThrowArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, LineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindFirstArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineItemFindFirstArgs>(args?: SelectSubset<T, LineItemFindFirstArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindFirstOrThrowArgs} args - Arguments to find a LineItem
     * @example
     * // Get one LineItem
     * const lineItem = await prisma.lineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, LineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItems
     * const lineItems = await prisma.lineItem.findMany()
     * 
     * // Get first 10 LineItems
     * const lineItems = await prisma.lineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineItemWithIdOnly = await prisma.lineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineItemFindManyArgs>(args?: SelectSubset<T, LineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LineItem.
     * @param {LineItemCreateArgs} args - Arguments to create a LineItem.
     * @example
     * // Create one LineItem
     * const LineItem = await prisma.lineItem.create({
     *   data: {
     *     // ... data to create a LineItem
     *   }
     * })
     * 
     */
    create<T extends LineItemCreateArgs>(args: SelectSubset<T, LineItemCreateArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LineItems.
     * @param {LineItemCreateManyArgs} args - Arguments to create many LineItems.
     * @example
     * // Create many LineItems
     * const lineItem = await prisma.lineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineItemCreateManyArgs>(args?: SelectSubset<T, LineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LineItems and returns the data saved in the database.
     * @param {LineItemCreateManyAndReturnArgs} args - Arguments to create many LineItems.
     * @example
     * // Create many LineItems
     * const lineItem = await prisma.lineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LineItems and only return the `id`
     * const lineItemWithIdOnly = await prisma.lineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, LineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LineItem.
     * @param {LineItemDeleteArgs} args - Arguments to delete one LineItem.
     * @example
     * // Delete one LineItem
     * const LineItem = await prisma.lineItem.delete({
     *   where: {
     *     // ... filter to delete one LineItem
     *   }
     * })
     * 
     */
    delete<T extends LineItemDeleteArgs>(args: SelectSubset<T, LineItemDeleteArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LineItem.
     * @param {LineItemUpdateArgs} args - Arguments to update one LineItem.
     * @example
     * // Update one LineItem
     * const lineItem = await prisma.lineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineItemUpdateArgs>(args: SelectSubset<T, LineItemUpdateArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LineItems.
     * @param {LineItemDeleteManyArgs} args - Arguments to filter LineItems to delete.
     * @example
     * // Delete a few LineItems
     * const { count } = await prisma.lineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineItemDeleteManyArgs>(args?: SelectSubset<T, LineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItems
     * const lineItem = await prisma.lineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineItemUpdateManyArgs>(args: SelectSubset<T, LineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineItems and returns the data updated in the database.
     * @param {LineItemUpdateManyAndReturnArgs} args - Arguments to update many LineItems.
     * @example
     * // Update many LineItems
     * const lineItem = await prisma.lineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LineItems and only return the `id`
     * const lineItemWithIdOnly = await prisma.lineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, LineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LineItem.
     * @param {LineItemUpsertArgs} args - Arguments to update or create a LineItem.
     * @example
     * // Update or create a LineItem
     * const lineItem = await prisma.lineItem.upsert({
     *   create: {
     *     // ... data to create a LineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItem we want to update
     *   }
     * })
     */
    upsert<T extends LineItemUpsertArgs>(args: SelectSubset<T, LineItemUpsertArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemCountArgs} args - Arguments to filter LineItems to count.
     * @example
     * // Count the number of LineItems
     * const count = await prisma.lineItem.count({
     *   where: {
     *     // ... the filter for the LineItems we want to count
     *   }
     * })
    **/
    count<T extends LineItemCountArgs>(
      args?: Subset<T, LineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineItemAggregateArgs>(args: Subset<T, LineItemAggregateArgs>): Prisma.PrismaPromise<GetLineItemAggregateType<T>>

    /**
     * Group by LineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemGroupByArgs['orderBy'] }
        : { orderBy?: LineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LineItem model
   */
  readonly fields: LineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    xactimateCategory<T extends ItemCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryDefaultArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    alternateItem<T extends LineItem$alternateItemArgs<ExtArgs> = {}>(args?: Subset<T, LineItem$alternateItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    relatedItem<T extends LineItem$relatedItemArgs<ExtArgs> = {}>(args?: Subset<T, LineItem$relatedItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LineItem model
   */ 
  interface LineItemFieldRefs {
    readonly id: FieldRef<"LineItem", 'Int'>
    readonly xactimateCode: FieldRef<"LineItem", 'String'>
    readonly xactimateDescription: FieldRef<"LineItem", 'String'>
    readonly unit: FieldRef<"LineItem", 'String'>
    readonly itemCategoryId: FieldRef<"LineItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LineItem findUnique
   */
  export type LineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter, which LineItem to fetch.
     */
    where: LineItemWhereUniqueInput
  }

  /**
   * LineItem findUniqueOrThrow
   */
  export type LineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter, which LineItem to fetch.
     */
    where: LineItemWhereUniqueInput
  }

  /**
   * LineItem findFirst
   */
  export type LineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter, which LineItem to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: LineItemOrderByWithRelationInput | LineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineItems.
     */
    distinct?: LineItemScalarFieldEnum | LineItemScalarFieldEnum[]
  }

  /**
   * LineItem findFirstOrThrow
   */
  export type LineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter, which LineItem to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: LineItemOrderByWithRelationInput | LineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineItems.
     */
    distinct?: LineItemScalarFieldEnum | LineItemScalarFieldEnum[]
  }

  /**
   * LineItem findMany
   */
  export type LineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter, which LineItems to fetch.
     */
    where?: LineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineItems to fetch.
     */
    orderBy?: LineItemOrderByWithRelationInput | LineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineItems.
     */
    cursor?: LineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineItems.
     */
    skip?: number
    distinct?: LineItemScalarFieldEnum | LineItemScalarFieldEnum[]
  }

  /**
   * LineItem create
   */
  export type LineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a LineItem.
     */
    data: XOR<LineItemCreateInput, LineItemUncheckedCreateInput>
  }

  /**
   * LineItem createMany
   */
  export type LineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LineItems.
     */
    data: LineItemCreateManyInput | LineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineItem createManyAndReturn
   */
  export type LineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * The data used to create many LineItems.
     */
    data: LineItemCreateManyInput | LineItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineItem update
   */
  export type LineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a LineItem.
     */
    data: XOR<LineItemUpdateInput, LineItemUncheckedUpdateInput>
    /**
     * Choose, which LineItem to update.
     */
    where: LineItemWhereUniqueInput
  }

  /**
   * LineItem updateMany
   */
  export type LineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LineItems.
     */
    data: XOR<LineItemUpdateManyMutationInput, LineItemUncheckedUpdateManyInput>
    /**
     * Filter which LineItems to update
     */
    where?: LineItemWhereInput
  }

  /**
   * LineItem updateManyAndReturn
   */
  export type LineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * The data used to update LineItems.
     */
    data: XOR<LineItemUpdateManyMutationInput, LineItemUncheckedUpdateManyInput>
    /**
     * Filter which LineItems to update
     */
    where?: LineItemWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineItem upsert
   */
  export type LineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the LineItem to update in case it exists.
     */
    where: LineItemWhereUniqueInput
    /**
     * In case the LineItem found by the `where` argument doesn't exist, create a new LineItem with this data.
     */
    create: XOR<LineItemCreateInput, LineItemUncheckedCreateInput>
    /**
     * In case the LineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineItemUpdateInput, LineItemUncheckedUpdateInput>
  }

  /**
   * LineItem delete
   */
  export type LineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
    /**
     * Filter which LineItem to delete.
     */
    where: LineItemWhereUniqueInput
  }

  /**
   * LineItem deleteMany
   */
  export type LineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineItems to delete
     */
    where?: LineItemWhereInput
  }

  /**
   * LineItem.alternateItem
   */
  export type LineItem$alternateItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    where?: AlternateItemWhereInput
    orderBy?: AlternateItemOrderByWithRelationInput | AlternateItemOrderByWithRelationInput[]
    cursor?: AlternateItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlternateItemScalarFieldEnum | AlternateItemScalarFieldEnum[]
  }

  /**
   * LineItem.relatedItem
   */
  export type LineItem$relatedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    where?: RelatedItemWhereInput
    orderBy?: RelatedItemOrderByWithRelationInput | RelatedItemOrderByWithRelationInput[]
    cursor?: RelatedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatedItemScalarFieldEnum | RelatedItemScalarFieldEnum[]
  }

  /**
   * LineItem without action
   */
  export type LineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineItem
     */
    select?: LineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineItem
     */
    omit?: LineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineItemInclude<ExtArgs> | null
  }


  /**
   * Model RelatedItem
   */

  export type AggregateRelatedItem = {
    _count: RelatedItemCountAggregateOutputType | null
    _avg: RelatedItemAvgAggregateOutputType | null
    _sum: RelatedItemSumAggregateOutputType | null
    _min: RelatedItemMinAggregateOutputType | null
    _max: RelatedItemMaxAggregateOutputType | null
  }

  export type RelatedItemAvgAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type RelatedItemSumAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type RelatedItemMinAggregateOutputType = {
    id: number | null
    relationId: string | null
    lineItemId: number | null
  }

  export type RelatedItemMaxAggregateOutputType = {
    id: number | null
    relationId: string | null
    lineItemId: number | null
  }

  export type RelatedItemCountAggregateOutputType = {
    id: number
    relationId: number
    lineItemId: number
    _all: number
  }


  export type RelatedItemAvgAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type RelatedItemSumAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type RelatedItemMinAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
  }

  export type RelatedItemMaxAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
  }

  export type RelatedItemCountAggregateInputType = {
    id?: true
    relationId?: true
    lineItemId?: true
    _all?: true
  }

  export type RelatedItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedItem to aggregate.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: RelatedItemOrderByWithRelationInput | RelatedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelatedItems
    **/
    _count?: true | RelatedItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelatedItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelatedItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatedItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatedItemMaxAggregateInputType
  }

  export type GetRelatedItemAggregateType<T extends RelatedItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatedItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatedItem[P]>
      : GetScalarType<T[P], AggregateRelatedItem[P]>
  }




  export type RelatedItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedItemWhereInput
    orderBy?: RelatedItemOrderByWithAggregationInput | RelatedItemOrderByWithAggregationInput[]
    by: RelatedItemScalarFieldEnum[] | RelatedItemScalarFieldEnum
    having?: RelatedItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatedItemCountAggregateInputType | true
    _avg?: RelatedItemAvgAggregateInputType
    _sum?: RelatedItemSumAggregateInputType
    _min?: RelatedItemMinAggregateInputType
    _max?: RelatedItemMaxAggregateInputType
  }

  export type RelatedItemGroupByOutputType = {
    id: number
    relationId: string
    lineItemId: number
    _count: RelatedItemCountAggregateOutputType | null
    _avg: RelatedItemAvgAggregateOutputType | null
    _sum: RelatedItemSumAggregateOutputType | null
    _min: RelatedItemMinAggregateOutputType | null
    _max: RelatedItemMaxAggregateOutputType | null
  }

  type GetRelatedItemGroupByPayload<T extends RelatedItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelatedItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatedItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatedItemGroupByOutputType[P]>
            : GetScalarType<T[P], RelatedItemGroupByOutputType[P]>
        }
      >
    >


  export type RelatedItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedItem"]>

  export type RelatedItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedItem"]>

  export type RelatedItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedItem"]>

  export type RelatedItemSelectScalar = {
    id?: boolean
    relationId?: boolean
    lineItemId?: boolean
  }

  export type RelatedItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationId" | "lineItemId", ExtArgs["result"]["relatedItem"]>
  export type RelatedItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }
  export type RelatedItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }
  export type RelatedItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }

  export type $RelatedItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelatedItem"
    objects: {
      lineItem: Prisma.$LineItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      relationId: string
      lineItemId: number
    }, ExtArgs["result"]["relatedItem"]>
    composites: {}
  }

  type RelatedItemGetPayload<S extends boolean | null | undefined | RelatedItemDefaultArgs> = $Result.GetResult<Prisma.$RelatedItemPayload, S>

  type RelatedItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelatedItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelatedItemCountAggregateInputType | true
    }

  export interface RelatedItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelatedItem'], meta: { name: 'RelatedItem' } }
    /**
     * Find zero or one RelatedItem that matches the filter.
     * @param {RelatedItemFindUniqueArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelatedItemFindUniqueArgs>(args: SelectSubset<T, RelatedItemFindUniqueArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RelatedItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelatedItemFindUniqueOrThrowArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelatedItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RelatedItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RelatedItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindFirstArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelatedItemFindFirstArgs>(args?: SelectSubset<T, RelatedItemFindFirstArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RelatedItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindFirstOrThrowArgs} args - Arguments to find a RelatedItem
     * @example
     * // Get one RelatedItem
     * const relatedItem = await prisma.relatedItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelatedItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RelatedItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RelatedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelatedItems
     * const relatedItems = await prisma.relatedItem.findMany()
     * 
     * // Get first 10 RelatedItems
     * const relatedItems = await prisma.relatedItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatedItemWithIdOnly = await prisma.relatedItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelatedItemFindManyArgs>(args?: SelectSubset<T, RelatedItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RelatedItem.
     * @param {RelatedItemCreateArgs} args - Arguments to create a RelatedItem.
     * @example
     * // Create one RelatedItem
     * const RelatedItem = await prisma.relatedItem.create({
     *   data: {
     *     // ... data to create a RelatedItem
     *   }
     * })
     * 
     */
    create<T extends RelatedItemCreateArgs>(args: SelectSubset<T, RelatedItemCreateArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RelatedItems.
     * @param {RelatedItemCreateManyArgs} args - Arguments to create many RelatedItems.
     * @example
     * // Create many RelatedItems
     * const relatedItem = await prisma.relatedItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelatedItemCreateManyArgs>(args?: SelectSubset<T, RelatedItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelatedItems and returns the data saved in the database.
     * @param {RelatedItemCreateManyAndReturnArgs} args - Arguments to create many RelatedItems.
     * @example
     * // Create many RelatedItems
     * const relatedItem = await prisma.relatedItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelatedItems and only return the `id`
     * const relatedItemWithIdOnly = await prisma.relatedItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelatedItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RelatedItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RelatedItem.
     * @param {RelatedItemDeleteArgs} args - Arguments to delete one RelatedItem.
     * @example
     * // Delete one RelatedItem
     * const RelatedItem = await prisma.relatedItem.delete({
     *   where: {
     *     // ... filter to delete one RelatedItem
     *   }
     * })
     * 
     */
    delete<T extends RelatedItemDeleteArgs>(args: SelectSubset<T, RelatedItemDeleteArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RelatedItem.
     * @param {RelatedItemUpdateArgs} args - Arguments to update one RelatedItem.
     * @example
     * // Update one RelatedItem
     * const relatedItem = await prisma.relatedItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelatedItemUpdateArgs>(args: SelectSubset<T, RelatedItemUpdateArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RelatedItems.
     * @param {RelatedItemDeleteManyArgs} args - Arguments to filter RelatedItems to delete.
     * @example
     * // Delete a few RelatedItems
     * const { count } = await prisma.relatedItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelatedItemDeleteManyArgs>(args?: SelectSubset<T, RelatedItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelatedItems
     * const relatedItem = await prisma.relatedItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelatedItemUpdateManyArgs>(args: SelectSubset<T, RelatedItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedItems and returns the data updated in the database.
     * @param {RelatedItemUpdateManyAndReturnArgs} args - Arguments to update many RelatedItems.
     * @example
     * // Update many RelatedItems
     * const relatedItem = await prisma.relatedItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelatedItems and only return the `id`
     * const relatedItemWithIdOnly = await prisma.relatedItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelatedItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RelatedItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RelatedItem.
     * @param {RelatedItemUpsertArgs} args - Arguments to update or create a RelatedItem.
     * @example
     * // Update or create a RelatedItem
     * const relatedItem = await prisma.relatedItem.upsert({
     *   create: {
     *     // ... data to create a RelatedItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelatedItem we want to update
     *   }
     * })
     */
    upsert<T extends RelatedItemUpsertArgs>(args: SelectSubset<T, RelatedItemUpsertArgs<ExtArgs>>): Prisma__RelatedItemClient<$Result.GetResult<Prisma.$RelatedItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RelatedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemCountArgs} args - Arguments to filter RelatedItems to count.
     * @example
     * // Count the number of RelatedItems
     * const count = await prisma.relatedItem.count({
     *   where: {
     *     // ... the filter for the RelatedItems we want to count
     *   }
     * })
    **/
    count<T extends RelatedItemCountArgs>(
      args?: Subset<T, RelatedItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatedItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelatedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatedItemAggregateArgs>(args: Subset<T, RelatedItemAggregateArgs>): Prisma.PrismaPromise<GetRelatedItemAggregateType<T>>

    /**
     * Group by RelatedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatedItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatedItemGroupByArgs['orderBy'] }
        : { orderBy?: RelatedItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatedItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatedItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelatedItem model
   */
  readonly fields: RelatedItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelatedItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelatedItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItem<T extends LineItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LineItemDefaultArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelatedItem model
   */ 
  interface RelatedItemFieldRefs {
    readonly id: FieldRef<"RelatedItem", 'Int'>
    readonly relationId: FieldRef<"RelatedItem", 'String'>
    readonly lineItemId: FieldRef<"RelatedItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RelatedItem findUnique
   */
  export type RelatedItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where: RelatedItemWhereUniqueInput
  }

  /**
   * RelatedItem findUniqueOrThrow
   */
  export type RelatedItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where: RelatedItemWhereUniqueInput
  }

  /**
   * RelatedItem findFirst
   */
  export type RelatedItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: RelatedItemOrderByWithRelationInput | RelatedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedItems.
     */
    distinct?: RelatedItemScalarFieldEnum | RelatedItemScalarFieldEnum[]
  }

  /**
   * RelatedItem findFirstOrThrow
   */
  export type RelatedItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter, which RelatedItem to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: RelatedItemOrderByWithRelationInput | RelatedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedItems.
     */
    distinct?: RelatedItemScalarFieldEnum | RelatedItemScalarFieldEnum[]
  }

  /**
   * RelatedItem findMany
   */
  export type RelatedItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter, which RelatedItems to fetch.
     */
    where?: RelatedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedItems to fetch.
     */
    orderBy?: RelatedItemOrderByWithRelationInput | RelatedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelatedItems.
     */
    cursor?: RelatedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedItems.
     */
    skip?: number
    distinct?: RelatedItemScalarFieldEnum | RelatedItemScalarFieldEnum[]
  }

  /**
   * RelatedItem create
   */
  export type RelatedItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RelatedItem.
     */
    data: XOR<RelatedItemCreateInput, RelatedItemUncheckedCreateInput>
  }

  /**
   * RelatedItem createMany
   */
  export type RelatedItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelatedItems.
     */
    data: RelatedItemCreateManyInput | RelatedItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelatedItem createManyAndReturn
   */
  export type RelatedItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * The data used to create many RelatedItems.
     */
    data: RelatedItemCreateManyInput | RelatedItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedItem update
   */
  export type RelatedItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RelatedItem.
     */
    data: XOR<RelatedItemUpdateInput, RelatedItemUncheckedUpdateInput>
    /**
     * Choose, which RelatedItem to update.
     */
    where: RelatedItemWhereUniqueInput
  }

  /**
   * RelatedItem updateMany
   */
  export type RelatedItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelatedItems.
     */
    data: XOR<RelatedItemUpdateManyMutationInput, RelatedItemUncheckedUpdateManyInput>
    /**
     * Filter which RelatedItems to update
     */
    where?: RelatedItemWhereInput
  }

  /**
   * RelatedItem updateManyAndReturn
   */
  export type RelatedItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * The data used to update RelatedItems.
     */
    data: XOR<RelatedItemUpdateManyMutationInput, RelatedItemUncheckedUpdateManyInput>
    /**
     * Filter which RelatedItems to update
     */
    where?: RelatedItemWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedItem upsert
   */
  export type RelatedItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RelatedItem to update in case it exists.
     */
    where: RelatedItemWhereUniqueInput
    /**
     * In case the RelatedItem found by the `where` argument doesn't exist, create a new RelatedItem with this data.
     */
    create: XOR<RelatedItemCreateInput, RelatedItemUncheckedCreateInput>
    /**
     * In case the RelatedItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatedItemUpdateInput, RelatedItemUncheckedUpdateInput>
  }

  /**
   * RelatedItem delete
   */
  export type RelatedItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
    /**
     * Filter which RelatedItem to delete.
     */
    where: RelatedItemWhereUniqueInput
  }

  /**
   * RelatedItem deleteMany
   */
  export type RelatedItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedItems to delete
     */
    where?: RelatedItemWhereInput
  }

  /**
   * RelatedItem without action
   */
  export type RelatedItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedItem
     */
    select?: RelatedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedItem
     */
    omit?: RelatedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedItemInclude<ExtArgs> | null
  }


  /**
   * Model AlternateItem
   */

  export type AggregateAlternateItem = {
    _count: AlternateItemCountAggregateOutputType | null
    _avg: AlternateItemAvgAggregateOutputType | null
    _sum: AlternateItemSumAggregateOutputType | null
    _min: AlternateItemMinAggregateOutputType | null
    _max: AlternateItemMaxAggregateOutputType | null
  }

  export type AlternateItemAvgAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type AlternateItemSumAggregateOutputType = {
    id: number | null
    lineItemId: number | null
  }

  export type AlternateItemMinAggregateOutputType = {
    id: number | null
    alternateId: string | null
    lineItemId: number | null
  }

  export type AlternateItemMaxAggregateOutputType = {
    id: number | null
    alternateId: string | null
    lineItemId: number | null
  }

  export type AlternateItemCountAggregateOutputType = {
    id: number
    alternateId: number
    lineItemId: number
    _all: number
  }


  export type AlternateItemAvgAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type AlternateItemSumAggregateInputType = {
    id?: true
    lineItemId?: true
  }

  export type AlternateItemMinAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
  }

  export type AlternateItemMaxAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
  }

  export type AlternateItemCountAggregateInputType = {
    id?: true
    alternateId?: true
    lineItemId?: true
    _all?: true
  }

  export type AlternateItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlternateItem to aggregate.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: AlternateItemOrderByWithRelationInput | AlternateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlternateItems
    **/
    _count?: true | AlternateItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlternateItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlternateItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlternateItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlternateItemMaxAggregateInputType
  }

  export type GetAlternateItemAggregateType<T extends AlternateItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAlternateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlternateItem[P]>
      : GetScalarType<T[P], AggregateAlternateItem[P]>
  }




  export type AlternateItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternateItemWhereInput
    orderBy?: AlternateItemOrderByWithAggregationInput | AlternateItemOrderByWithAggregationInput[]
    by: AlternateItemScalarFieldEnum[] | AlternateItemScalarFieldEnum
    having?: AlternateItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlternateItemCountAggregateInputType | true
    _avg?: AlternateItemAvgAggregateInputType
    _sum?: AlternateItemSumAggregateInputType
    _min?: AlternateItemMinAggregateInputType
    _max?: AlternateItemMaxAggregateInputType
  }

  export type AlternateItemGroupByOutputType = {
    id: number
    alternateId: string
    lineItemId: number
    _count: AlternateItemCountAggregateOutputType | null
    _avg: AlternateItemAvgAggregateOutputType | null
    _sum: AlternateItemSumAggregateOutputType | null
    _min: AlternateItemMinAggregateOutputType | null
    _max: AlternateItemMaxAggregateOutputType | null
  }

  type GetAlternateItemGroupByPayload<T extends AlternateItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlternateItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlternateItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlternateItemGroupByOutputType[P]>
            : GetScalarType<T[P], AlternateItemGroupByOutputType[P]>
        }
      >
    >


  export type AlternateItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alternateId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternateItem"]>

  export type AlternateItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alternateId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternateItem"]>

  export type AlternateItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alternateId?: boolean
    lineItemId?: boolean
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternateItem"]>

  export type AlternateItemSelectScalar = {
    id?: boolean
    alternateId?: boolean
    lineItemId?: boolean
  }

  export type AlternateItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alternateId" | "lineItemId", ExtArgs["result"]["alternateItem"]>
  export type AlternateItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }
  export type AlternateItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }
  export type AlternateItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItem?: boolean | LineItemDefaultArgs<ExtArgs>
  }

  export type $AlternateItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlternateItem"
    objects: {
      lineItem: Prisma.$LineItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alternateId: string
      lineItemId: number
    }, ExtArgs["result"]["alternateItem"]>
    composites: {}
  }

  type AlternateItemGetPayload<S extends boolean | null | undefined | AlternateItemDefaultArgs> = $Result.GetResult<Prisma.$AlternateItemPayload, S>

  type AlternateItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlternateItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlternateItemCountAggregateInputType | true
    }

  export interface AlternateItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlternateItem'], meta: { name: 'AlternateItem' } }
    /**
     * Find zero or one AlternateItem that matches the filter.
     * @param {AlternateItemFindUniqueArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlternateItemFindUniqueArgs>(args: SelectSubset<T, AlternateItemFindUniqueArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AlternateItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlternateItemFindUniqueOrThrowArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlternateItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AlternateItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AlternateItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindFirstArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlternateItemFindFirstArgs>(args?: SelectSubset<T, AlternateItemFindFirstArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AlternateItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindFirstOrThrowArgs} args - Arguments to find a AlternateItem
     * @example
     * // Get one AlternateItem
     * const alternateItem = await prisma.alternateItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlternateItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AlternateItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AlternateItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlternateItems
     * const alternateItems = await prisma.alternateItem.findMany()
     * 
     * // Get first 10 AlternateItems
     * const alternateItems = await prisma.alternateItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alternateItemWithIdOnly = await prisma.alternateItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlternateItemFindManyArgs>(args?: SelectSubset<T, AlternateItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AlternateItem.
     * @param {AlternateItemCreateArgs} args - Arguments to create a AlternateItem.
     * @example
     * // Create one AlternateItem
     * const AlternateItem = await prisma.alternateItem.create({
     *   data: {
     *     // ... data to create a AlternateItem
     *   }
     * })
     * 
     */
    create<T extends AlternateItemCreateArgs>(args: SelectSubset<T, AlternateItemCreateArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AlternateItems.
     * @param {AlternateItemCreateManyArgs} args - Arguments to create many AlternateItems.
     * @example
     * // Create many AlternateItems
     * const alternateItem = await prisma.alternateItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlternateItemCreateManyArgs>(args?: SelectSubset<T, AlternateItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlternateItems and returns the data saved in the database.
     * @param {AlternateItemCreateManyAndReturnArgs} args - Arguments to create many AlternateItems.
     * @example
     * // Create many AlternateItems
     * const alternateItem = await prisma.alternateItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlternateItems and only return the `id`
     * const alternateItemWithIdOnly = await prisma.alternateItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlternateItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AlternateItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AlternateItem.
     * @param {AlternateItemDeleteArgs} args - Arguments to delete one AlternateItem.
     * @example
     * // Delete one AlternateItem
     * const AlternateItem = await prisma.alternateItem.delete({
     *   where: {
     *     // ... filter to delete one AlternateItem
     *   }
     * })
     * 
     */
    delete<T extends AlternateItemDeleteArgs>(args: SelectSubset<T, AlternateItemDeleteArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AlternateItem.
     * @param {AlternateItemUpdateArgs} args - Arguments to update one AlternateItem.
     * @example
     * // Update one AlternateItem
     * const alternateItem = await prisma.alternateItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlternateItemUpdateArgs>(args: SelectSubset<T, AlternateItemUpdateArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AlternateItems.
     * @param {AlternateItemDeleteManyArgs} args - Arguments to filter AlternateItems to delete.
     * @example
     * // Delete a few AlternateItems
     * const { count } = await prisma.alternateItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlternateItemDeleteManyArgs>(args?: SelectSubset<T, AlternateItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlternateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlternateItems
     * const alternateItem = await prisma.alternateItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlternateItemUpdateManyArgs>(args: SelectSubset<T, AlternateItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlternateItems and returns the data updated in the database.
     * @param {AlternateItemUpdateManyAndReturnArgs} args - Arguments to update many AlternateItems.
     * @example
     * // Update many AlternateItems
     * const alternateItem = await prisma.alternateItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlternateItems and only return the `id`
     * const alternateItemWithIdOnly = await prisma.alternateItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlternateItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AlternateItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AlternateItem.
     * @param {AlternateItemUpsertArgs} args - Arguments to update or create a AlternateItem.
     * @example
     * // Update or create a AlternateItem
     * const alternateItem = await prisma.alternateItem.upsert({
     *   create: {
     *     // ... data to create a AlternateItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlternateItem we want to update
     *   }
     * })
     */
    upsert<T extends AlternateItemUpsertArgs>(args: SelectSubset<T, AlternateItemUpsertArgs<ExtArgs>>): Prisma__AlternateItemClient<$Result.GetResult<Prisma.$AlternateItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AlternateItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemCountArgs} args - Arguments to filter AlternateItems to count.
     * @example
     * // Count the number of AlternateItems
     * const count = await prisma.alternateItem.count({
     *   where: {
     *     // ... the filter for the AlternateItems we want to count
     *   }
     * })
    **/
    count<T extends AlternateItemCountArgs>(
      args?: Subset<T, AlternateItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlternateItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlternateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlternateItemAggregateArgs>(args: Subset<T, AlternateItemAggregateArgs>): Prisma.PrismaPromise<GetAlternateItemAggregateType<T>>

    /**
     * Group by AlternateItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternateItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlternateItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlternateItemGroupByArgs['orderBy'] }
        : { orderBy?: AlternateItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlternateItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlternateItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlternateItem model
   */
  readonly fields: AlternateItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlternateItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlternateItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItem<T extends LineItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LineItemDefaultArgs<ExtArgs>>): Prisma__LineItemClient<$Result.GetResult<Prisma.$LineItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlternateItem model
   */ 
  interface AlternateItemFieldRefs {
    readonly id: FieldRef<"AlternateItem", 'Int'>
    readonly alternateId: FieldRef<"AlternateItem", 'String'>
    readonly lineItemId: FieldRef<"AlternateItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AlternateItem findUnique
   */
  export type AlternateItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where: AlternateItemWhereUniqueInput
  }

  /**
   * AlternateItem findUniqueOrThrow
   */
  export type AlternateItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where: AlternateItemWhereUniqueInput
  }

  /**
   * AlternateItem findFirst
   */
  export type AlternateItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: AlternateItemOrderByWithRelationInput | AlternateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternateItems.
     */
    distinct?: AlternateItemScalarFieldEnum | AlternateItemScalarFieldEnum[]
  }

  /**
   * AlternateItem findFirstOrThrow
   */
  export type AlternateItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter, which AlternateItem to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: AlternateItemOrderByWithRelationInput | AlternateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlternateItems.
     */
    distinct?: AlternateItemScalarFieldEnum | AlternateItemScalarFieldEnum[]
  }

  /**
   * AlternateItem findMany
   */
  export type AlternateItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter, which AlternateItems to fetch.
     */
    where?: AlternateItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlternateItems to fetch.
     */
    orderBy?: AlternateItemOrderByWithRelationInput | AlternateItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlternateItems.
     */
    cursor?: AlternateItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlternateItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlternateItems.
     */
    skip?: number
    distinct?: AlternateItemScalarFieldEnum | AlternateItemScalarFieldEnum[]
  }

  /**
   * AlternateItem create
   */
  export type AlternateItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AlternateItem.
     */
    data: XOR<AlternateItemCreateInput, AlternateItemUncheckedCreateInput>
  }

  /**
   * AlternateItem createMany
   */
  export type AlternateItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlternateItems.
     */
    data: AlternateItemCreateManyInput | AlternateItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlternateItem createManyAndReturn
   */
  export type AlternateItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * The data used to create many AlternateItems.
     */
    data: AlternateItemCreateManyInput | AlternateItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlternateItem update
   */
  export type AlternateItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AlternateItem.
     */
    data: XOR<AlternateItemUpdateInput, AlternateItemUncheckedUpdateInput>
    /**
     * Choose, which AlternateItem to update.
     */
    where: AlternateItemWhereUniqueInput
  }

  /**
   * AlternateItem updateMany
   */
  export type AlternateItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlternateItems.
     */
    data: XOR<AlternateItemUpdateManyMutationInput, AlternateItemUncheckedUpdateManyInput>
    /**
     * Filter which AlternateItems to update
     */
    where?: AlternateItemWhereInput
  }

  /**
   * AlternateItem updateManyAndReturn
   */
  export type AlternateItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * The data used to update AlternateItems.
     */
    data: XOR<AlternateItemUpdateManyMutationInput, AlternateItemUncheckedUpdateManyInput>
    /**
     * Filter which AlternateItems to update
     */
    where?: AlternateItemWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlternateItem upsert
   */
  export type AlternateItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AlternateItem to update in case it exists.
     */
    where: AlternateItemWhereUniqueInput
    /**
     * In case the AlternateItem found by the `where` argument doesn't exist, create a new AlternateItem with this data.
     */
    create: XOR<AlternateItemCreateInput, AlternateItemUncheckedCreateInput>
    /**
     * In case the AlternateItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlternateItemUpdateInput, AlternateItemUncheckedUpdateInput>
  }

  /**
   * AlternateItem delete
   */
  export type AlternateItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
    /**
     * Filter which AlternateItem to delete.
     */
    where: AlternateItemWhereUniqueInput
  }

  /**
   * AlternateItem deleteMany
   */
  export type AlternateItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlternateItems to delete
     */
    where?: AlternateItemWhereInput
  }

  /**
   * AlternateItem without action
   */
  export type AlternateItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternateItem
     */
    select?: AlternateItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlternateItem
     */
    omit?: AlternateItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternateItemInclude<ExtArgs> | null
  }


  /**
   * Model PlanEntitlements
   */

  export type AggregatePlanEntitlements = {
    _count: PlanEntitlementsCountAggregateOutputType | null
    _avg: PlanEntitlementsAvgAggregateOutputType | null
    _sum: PlanEntitlementsSumAggregateOutputType | null
    _min: PlanEntitlementsMinAggregateOutputType | null
    _max: PlanEntitlementsMaxAggregateOutputType | null
  }

  export type PlanEntitlementsAvgAggregateOutputType = {
    id: number | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    price: number | null
  }

  export type PlanEntitlementsSumAggregateOutputType = {
    id: number | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    price: number | null
  }

  export type PlanEntitlementsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    extPlanId: string | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    description: string | null
    period: string | null
    price: number | null
  }

  export type PlanEntitlementsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    extPlanId: string | null
    maxImages: number | null
    maxProjects: number | null
    maxSeats: number | null
    description: string | null
    period: string | null
    price: number | null
  }

  export type PlanEntitlementsCountAggregateOutputType = {
    id: number
    createdAt: number
    extPlanId: number
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: number
    period: number
    price: number
    _all: number
  }


  export type PlanEntitlementsAvgAggregateInputType = {
    id?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    price?: true
  }

  export type PlanEntitlementsSumAggregateInputType = {
    id?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    price?: true
  }

  export type PlanEntitlementsMinAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
  }

  export type PlanEntitlementsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
  }

  export type PlanEntitlementsCountAggregateInputType = {
    id?: true
    createdAt?: true
    extPlanId?: true
    maxImages?: true
    maxProjects?: true
    maxSeats?: true
    description?: true
    period?: true
    price?: true
    _all?: true
  }

  export type PlanEntitlementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanEntitlements to aggregate.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: PlanEntitlementsOrderByWithRelationInput | PlanEntitlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanEntitlements
    **/
    _count?: true | PlanEntitlementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanEntitlementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanEntitlementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanEntitlementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanEntitlementsMaxAggregateInputType
  }

  export type GetPlanEntitlementsAggregateType<T extends PlanEntitlementsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanEntitlements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanEntitlements[P]>
      : GetScalarType<T[P], AggregatePlanEntitlements[P]>
  }




  export type PlanEntitlementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanEntitlementsWhereInput
    orderBy?: PlanEntitlementsOrderByWithAggregationInput | PlanEntitlementsOrderByWithAggregationInput[]
    by: PlanEntitlementsScalarFieldEnum[] | PlanEntitlementsScalarFieldEnum
    having?: PlanEntitlementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanEntitlementsCountAggregateInputType | true
    _avg?: PlanEntitlementsAvgAggregateInputType
    _sum?: PlanEntitlementsSumAggregateInputType
    _min?: PlanEntitlementsMinAggregateInputType
    _max?: PlanEntitlementsMaxAggregateInputType
  }

  export type PlanEntitlementsGroupByOutputType = {
    id: number
    createdAt: Date
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
    _count: PlanEntitlementsCountAggregateOutputType | null
    _avg: PlanEntitlementsAvgAggregateOutputType | null
    _sum: PlanEntitlementsSumAggregateOutputType | null
    _min: PlanEntitlementsMinAggregateOutputType | null
    _max: PlanEntitlementsMaxAggregateOutputType | null
  }

  type GetPlanEntitlementsGroupByPayload<T extends PlanEntitlementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanEntitlementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanEntitlementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanEntitlementsGroupByOutputType[P]>
            : GetScalarType<T[P], PlanEntitlementsGroupByOutputType[P]>
        }
      >
    >


  export type PlanEntitlementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    extPlanId?: boolean
    maxImages?: boolean
    maxProjects?: boolean
    maxSeats?: boolean
    description?: boolean
    period?: boolean
    price?: boolean
  }, ExtArgs["result"]["planEntitlements"]>

  export type PlanEntitlementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    extPlanId?: boolean
    maxImages?: boolean
    maxProjects?: boolean
    maxSeats?: boolean
    description?: boolean
    period?: boolean
    price?: boolean
  }, ExtArgs["result"]["planEntitlements"]>

  export type PlanEntitlementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    extPlanId?: boolean
    maxImages?: boolean
    maxProjects?: boolean
    maxSeats?: boolean
    description?: boolean
    period?: boolean
    price?: boolean
  }, ExtArgs["result"]["planEntitlements"]>

  export type PlanEntitlementsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    extPlanId?: boolean
    maxImages?: boolean
    maxProjects?: boolean
    maxSeats?: boolean
    description?: boolean
    period?: boolean
    price?: boolean
  }

  export type PlanEntitlementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "extPlanId" | "maxImages" | "maxProjects" | "maxSeats" | "description" | "period" | "price", ExtArgs["result"]["planEntitlements"]>

  export type $PlanEntitlementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanEntitlements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      extPlanId: string
      maxImages: number
      maxProjects: number
      maxSeats: number
      description: string
      period: string
      price: number
    }, ExtArgs["result"]["planEntitlements"]>
    composites: {}
  }

  type PlanEntitlementsGetPayload<S extends boolean | null | undefined | PlanEntitlementsDefaultArgs> = $Result.GetResult<Prisma.$PlanEntitlementsPayload, S>

  type PlanEntitlementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanEntitlementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanEntitlementsCountAggregateInputType | true
    }

  export interface PlanEntitlementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanEntitlements'], meta: { name: 'PlanEntitlements' } }
    /**
     * Find zero or one PlanEntitlements that matches the filter.
     * @param {PlanEntitlementsFindUniqueArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanEntitlementsFindUniqueArgs>(args: SelectSubset<T, PlanEntitlementsFindUniqueArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PlanEntitlements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanEntitlementsFindUniqueOrThrowArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanEntitlementsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanEntitlementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PlanEntitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindFirstArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanEntitlementsFindFirstArgs>(args?: SelectSubset<T, PlanEntitlementsFindFirstArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PlanEntitlements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindFirstOrThrowArgs} args - Arguments to find a PlanEntitlements
     * @example
     * // Get one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanEntitlementsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanEntitlementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PlanEntitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findMany()
     * 
     * // Get first 10 PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planEntitlementsWithIdOnly = await prisma.planEntitlements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanEntitlementsFindManyArgs>(args?: SelectSubset<T, PlanEntitlementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PlanEntitlements.
     * @param {PlanEntitlementsCreateArgs} args - Arguments to create a PlanEntitlements.
     * @example
     * // Create one PlanEntitlements
     * const PlanEntitlements = await prisma.planEntitlements.create({
     *   data: {
     *     // ... data to create a PlanEntitlements
     *   }
     * })
     * 
     */
    create<T extends PlanEntitlementsCreateArgs>(args: SelectSubset<T, PlanEntitlementsCreateArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PlanEntitlements.
     * @param {PlanEntitlementsCreateManyArgs} args - Arguments to create many PlanEntitlements.
     * @example
     * // Create many PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanEntitlementsCreateManyArgs>(args?: SelectSubset<T, PlanEntitlementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanEntitlements and returns the data saved in the database.
     * @param {PlanEntitlementsCreateManyAndReturnArgs} args - Arguments to create many PlanEntitlements.
     * @example
     * // Create many PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanEntitlements and only return the `id`
     * const planEntitlementsWithIdOnly = await prisma.planEntitlements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanEntitlementsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanEntitlementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PlanEntitlements.
     * @param {PlanEntitlementsDeleteArgs} args - Arguments to delete one PlanEntitlements.
     * @example
     * // Delete one PlanEntitlements
     * const PlanEntitlements = await prisma.planEntitlements.delete({
     *   where: {
     *     // ... filter to delete one PlanEntitlements
     *   }
     * })
     * 
     */
    delete<T extends PlanEntitlementsDeleteArgs>(args: SelectSubset<T, PlanEntitlementsDeleteArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PlanEntitlements.
     * @param {PlanEntitlementsUpdateArgs} args - Arguments to update one PlanEntitlements.
     * @example
     * // Update one PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanEntitlementsUpdateArgs>(args: SelectSubset<T, PlanEntitlementsUpdateArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PlanEntitlements.
     * @param {PlanEntitlementsDeleteManyArgs} args - Arguments to filter PlanEntitlements to delete.
     * @example
     * // Delete a few PlanEntitlements
     * const { count } = await prisma.planEntitlements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanEntitlementsDeleteManyArgs>(args?: SelectSubset<T, PlanEntitlementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanEntitlementsUpdateManyArgs>(args: SelectSubset<T, PlanEntitlementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanEntitlements and returns the data updated in the database.
     * @param {PlanEntitlementsUpdateManyAndReturnArgs} args - Arguments to update many PlanEntitlements.
     * @example
     * // Update many PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanEntitlements and only return the `id`
     * const planEntitlementsWithIdOnly = await prisma.planEntitlements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanEntitlementsUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanEntitlementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PlanEntitlements.
     * @param {PlanEntitlementsUpsertArgs} args - Arguments to update or create a PlanEntitlements.
     * @example
     * // Update or create a PlanEntitlements
     * const planEntitlements = await prisma.planEntitlements.upsert({
     *   create: {
     *     // ... data to create a PlanEntitlements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanEntitlements we want to update
     *   }
     * })
     */
    upsert<T extends PlanEntitlementsUpsertArgs>(args: SelectSubset<T, PlanEntitlementsUpsertArgs<ExtArgs>>): Prisma__PlanEntitlementsClient<$Result.GetResult<Prisma.$PlanEntitlementsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsCountArgs} args - Arguments to filter PlanEntitlements to count.
     * @example
     * // Count the number of PlanEntitlements
     * const count = await prisma.planEntitlements.count({
     *   where: {
     *     // ... the filter for the PlanEntitlements we want to count
     *   }
     * })
    **/
    count<T extends PlanEntitlementsCountArgs>(
      args?: Subset<T, PlanEntitlementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanEntitlementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanEntitlementsAggregateArgs>(args: Subset<T, PlanEntitlementsAggregateArgs>): Prisma.PrismaPromise<GetPlanEntitlementsAggregateType<T>>

    /**
     * Group by PlanEntitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEntitlementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanEntitlementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanEntitlementsGroupByArgs['orderBy'] }
        : { orderBy?: PlanEntitlementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanEntitlementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanEntitlementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanEntitlements model
   */
  readonly fields: PlanEntitlementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanEntitlements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanEntitlementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanEntitlements model
   */ 
  interface PlanEntitlementsFieldRefs {
    readonly id: FieldRef<"PlanEntitlements", 'Int'>
    readonly createdAt: FieldRef<"PlanEntitlements", 'DateTime'>
    readonly extPlanId: FieldRef<"PlanEntitlements", 'String'>
    readonly maxImages: FieldRef<"PlanEntitlements", 'Int'>
    readonly maxProjects: FieldRef<"PlanEntitlements", 'Int'>
    readonly maxSeats: FieldRef<"PlanEntitlements", 'Int'>
    readonly description: FieldRef<"PlanEntitlements", 'String'>
    readonly period: FieldRef<"PlanEntitlements", 'String'>
    readonly price: FieldRef<"PlanEntitlements", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PlanEntitlements findUnique
   */
  export type PlanEntitlementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where: PlanEntitlementsWhereUniqueInput
  }

  /**
   * PlanEntitlements findUniqueOrThrow
   */
  export type PlanEntitlementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where: PlanEntitlementsWhereUniqueInput
  }

  /**
   * PlanEntitlements findFirst
   */
  export type PlanEntitlementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: PlanEntitlementsOrderByWithRelationInput | PlanEntitlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEntitlements.
     */
    distinct?: PlanEntitlementsScalarFieldEnum | PlanEntitlementsScalarFieldEnum[]
  }

  /**
   * PlanEntitlements findFirstOrThrow
   */
  export type PlanEntitlementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: PlanEntitlementsOrderByWithRelationInput | PlanEntitlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEntitlements.
     */
    distinct?: PlanEntitlementsScalarFieldEnum | PlanEntitlementsScalarFieldEnum[]
  }

  /**
   * PlanEntitlements findMany
   */
  export type PlanEntitlementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter, which PlanEntitlements to fetch.
     */
    where?: PlanEntitlementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEntitlements to fetch.
     */
    orderBy?: PlanEntitlementsOrderByWithRelationInput | PlanEntitlementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanEntitlements.
     */
    cursor?: PlanEntitlementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEntitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEntitlements.
     */
    skip?: number
    distinct?: PlanEntitlementsScalarFieldEnum | PlanEntitlementsScalarFieldEnum[]
  }

  /**
   * PlanEntitlements create
   */
  export type PlanEntitlementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * The data needed to create a PlanEntitlements.
     */
    data: XOR<PlanEntitlementsCreateInput, PlanEntitlementsUncheckedCreateInput>
  }

  /**
   * PlanEntitlements createMany
   */
  export type PlanEntitlementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanEntitlements.
     */
    data: PlanEntitlementsCreateManyInput | PlanEntitlementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanEntitlements createManyAndReturn
   */
  export type PlanEntitlementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * The data used to create many PlanEntitlements.
     */
    data: PlanEntitlementsCreateManyInput | PlanEntitlementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanEntitlements update
   */
  export type PlanEntitlementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * The data needed to update a PlanEntitlements.
     */
    data: XOR<PlanEntitlementsUpdateInput, PlanEntitlementsUncheckedUpdateInput>
    /**
     * Choose, which PlanEntitlements to update.
     */
    where: PlanEntitlementsWhereUniqueInput
  }

  /**
   * PlanEntitlements updateMany
   */
  export type PlanEntitlementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanEntitlements.
     */
    data: XOR<PlanEntitlementsUpdateManyMutationInput, PlanEntitlementsUncheckedUpdateManyInput>
    /**
     * Filter which PlanEntitlements to update
     */
    where?: PlanEntitlementsWhereInput
  }

  /**
   * PlanEntitlements updateManyAndReturn
   */
  export type PlanEntitlementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * The data used to update PlanEntitlements.
     */
    data: XOR<PlanEntitlementsUpdateManyMutationInput, PlanEntitlementsUncheckedUpdateManyInput>
    /**
     * Filter which PlanEntitlements to update
     */
    where?: PlanEntitlementsWhereInput
  }

  /**
   * PlanEntitlements upsert
   */
  export type PlanEntitlementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * The filter to search for the PlanEntitlements to update in case it exists.
     */
    where: PlanEntitlementsWhereUniqueInput
    /**
     * In case the PlanEntitlements found by the `where` argument doesn't exist, create a new PlanEntitlements with this data.
     */
    create: XOR<PlanEntitlementsCreateInput, PlanEntitlementsUncheckedCreateInput>
    /**
     * In case the PlanEntitlements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanEntitlementsUpdateInput, PlanEntitlementsUncheckedUpdateInput>
  }

  /**
   * PlanEntitlements delete
   */
  export type PlanEntitlementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
    /**
     * Filter which PlanEntitlements to delete.
     */
    where: PlanEntitlementsWhereUniqueInput
  }

  /**
   * PlanEntitlements deleteMany
   */
  export type PlanEntitlementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanEntitlements to delete
     */
    where?: PlanEntitlementsWhereInput
  }

  /**
   * PlanEntitlements without action
   */
  export type PlanEntitlementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEntitlements
     */
    select?: PlanEntitlementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEntitlements
     */
    omit?: PlanEntitlementsOmit<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    customerId: string | null
    organizationId: number | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    customerId: string | null
    organizationId: number | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    customerId: number
    billingAddress: number
    paymentMethod: number
    organizationId: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    customerId?: true
    organizationId?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    customerId?: true
    organizationId?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    customerId?: true
    billingAddress?: true
    paymentMethod?: true
    organizationId?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    customerId: string
    billingAddress: JsonValue | null
    paymentMethod: JsonValue | null
    organizationId: number
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    billingAddress?: boolean
    paymentMethod?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    billingAddress?: boolean
    paymentMethod?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    billingAddress?: boolean
    paymentMethod?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectScalar = {
    id?: boolean
    customerId?: boolean
    billingAddress?: boolean
    paymentMethod?: boolean
    organizationId?: boolean
  }

  export type CustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "billingAddress" | "paymentMethod" | "organizationId", ExtArgs["result"]["customers"]>
  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: string
      billingAddress: Prisma.JsonValue | null
      paymentMethod: Prisma.JsonValue | null
      organizationId: number
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */ 
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'Int'>
    readonly customerId: FieldRef<"Customers", 'String'>
    readonly billingAddress: FieldRef<"Customers", 'Json'>
    readonly paymentMethod: FieldRef<"Customers", 'Json'>
    readonly organizationId: FieldRef<"Customers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers createManyAndReturn
   */
  export type CustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
  }

  /**
   * Customers updateManyAndReturn
   */
  export type CustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    active: number
    name: number
    description: number
    image: number
    metadata: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
    metadata?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: string
    active: boolean
    name: string
    description: string | null
    image: string | null
    metadata: JsonValue | null
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
    prices?: boolean | Products$pricesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectScalar = {
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
  }

  export type ProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "active" | "name" | "description" | "image" | "metadata", ExtArgs["result"]["products"]>
  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | Products$pricesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      prices: Prisma.$PricesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      active: boolean
      name: string
      description: string | null
      image: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prices<T extends Products$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Products$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */ 
  interface ProductsFieldRefs {
    readonly id: FieldRef<"Products", 'String'>
    readonly active: FieldRef<"Products", 'Boolean'>
    readonly name: FieldRef<"Products", 'String'>
    readonly description: FieldRef<"Products", 'String'>
    readonly image: FieldRef<"Products", 'String'>
    readonly metadata: FieldRef<"Products", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products createManyAndReturn
   */
  export type ProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
  }

  /**
   * Products updateManyAndReturn
   */
  export type ProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
  }

  /**
   * Products.prices
   */
  export type Products$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    where?: PricesWhereInput
    orderBy?: PricesOrderByWithRelationInput | PricesOrderByWithRelationInput[]
    cursor?: PricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricesScalarFieldEnum | PricesScalarFieldEnum[]
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model Prices
   */

  export type AggregatePrices = {
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  export type PricesAvgAggregateOutputType = {
    unitAmount: number | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PricesSumAggregateOutputType = {
    unitAmount: bigint | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PricesMinAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    unitAmount: bigint | null
    currency: string | null
    type: $Enums.PricingType | null
    interval: $Enums.PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    description: string | null
  }

  export type PricesMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    unitAmount: bigint | null
    currency: string | null
    type: $Enums.PricingType | null
    interval: $Enums.PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    description: string | null
  }

  export type PricesCountAggregateOutputType = {
    id: number
    productId: number
    active: number
    unitAmount: number
    currency: number
    type: number
    interval: number
    intervalCount: number
    trialPeriodDays: number
    metadata: number
    description: number
    _all: number
  }


  export type PricesAvgAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PricesSumAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PricesMinAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    description?: true
  }

  export type PricesMaxAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    description?: true
  }

  export type PricesCountAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    unitAmount?: true
    currency?: true
    type?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    metadata?: true
    description?: true
    _all?: true
  }

  export type PricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to aggregate.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PricesOrderByWithRelationInput | PricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricesMaxAggregateInputType
  }

  export type GetPricesAggregateType<T extends PricesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrices[P]>
      : GetScalarType<T[P], AggregatePrices[P]>
  }




  export type PricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricesWhereInput
    orderBy?: PricesOrderByWithAggregationInput | PricesOrderByWithAggregationInput[]
    by: PricesScalarFieldEnum[] | PricesScalarFieldEnum
    having?: PricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricesCountAggregateInputType | true
    _avg?: PricesAvgAggregateInputType
    _sum?: PricesSumAggregateInputType
    _min?: PricesMinAggregateInputType
    _max?: PricesMaxAggregateInputType
  }

  export type PricesGroupByOutputType = {
    id: string
    productId: string
    active: boolean
    unitAmount: bigint | null
    currency: string
    type: $Enums.PricingType
    interval: $Enums.PricingPlanInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    metadata: JsonValue | null
    description: string
    _count: PricesCountAggregateOutputType | null
    _avg: PricesAvgAggregateOutputType | null
    _sum: PricesSumAggregateOutputType | null
    _min: PricesMinAggregateOutputType | null
    _max: PricesMaxAggregateOutputType | null
  }

  type GetPricesGroupByPayload<T extends PricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricesGroupByOutputType[P]>
            : GetScalarType<T[P], PricesGroupByOutputType[P]>
        }
      >
    >


  export type PricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    active?: boolean
    unitAmount?: boolean
    currency?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    metadata?: boolean
    description?: boolean
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    Subscriptions?: boolean | Prices$SubscriptionsArgs<ExtArgs>
    _count?: boolean | PricesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prices"]>

  export type PricesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    active?: boolean
    unitAmount?: boolean
    currency?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    metadata?: boolean
    description?: boolean
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prices"]>

  export type PricesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    active?: boolean
    unitAmount?: boolean
    currency?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    metadata?: boolean
    description?: boolean
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prices"]>

  export type PricesSelectScalar = {
    id?: boolean
    productId?: boolean
    active?: boolean
    unitAmount?: boolean
    currency?: boolean
    type?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    metadata?: boolean
    description?: boolean
  }

  export type PricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "active" | "unitAmount" | "currency" | "type" | "interval" | "intervalCount" | "trialPeriodDays" | "metadata" | "description", ExtArgs["result"]["prices"]>
  export type PricesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    Subscriptions?: boolean | Prices$SubscriptionsArgs<ExtArgs>
    _count?: boolean | PricesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PricesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }
  export type PricesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $PricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prices"
    objects: {
      product: Prisma.$ProductsPayload<ExtArgs>
      Subscriptions: Prisma.$SubscriptionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      active: boolean
      unitAmount: bigint | null
      currency: string
      type: $Enums.PricingType
      interval: $Enums.PricingPlanInterval | null
      intervalCount: number | null
      trialPeriodDays: number | null
      metadata: Prisma.JsonValue | null
      description: string
    }, ExtArgs["result"]["prices"]>
    composites: {}
  }

  type PricesGetPayload<S extends boolean | null | undefined | PricesDefaultArgs> = $Result.GetResult<Prisma.$PricesPayload, S>

  type PricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricesCountAggregateInputType | true
    }

  export interface PricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prices'], meta: { name: 'Prices' } }
    /**
     * Find zero or one Prices that matches the filter.
     * @param {PricesFindUniqueArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricesFindUniqueArgs>(args: SelectSubset<T, PricesFindUniqueArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricesFindUniqueOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricesFindUniqueOrThrowArgs>(args: SelectSubset<T, PricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricesFindFirstArgs>(args?: SelectSubset<T, PricesFindFirstArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindFirstOrThrowArgs} args - Arguments to find a Prices
     * @example
     * // Get one Prices
     * const prices = await prisma.prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricesFindFirstOrThrowArgs>(args?: SelectSubset<T, PricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.prices.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricesWithIdOnly = await prisma.prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricesFindManyArgs>(args?: SelectSubset<T, PricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Prices.
     * @param {PricesCreateArgs} args - Arguments to create a Prices.
     * @example
     * // Create one Prices
     * const Prices = await prisma.prices.create({
     *   data: {
     *     // ... data to create a Prices
     *   }
     * })
     * 
     */
    create<T extends PricesCreateArgs>(args: SelectSubset<T, PricesCreateArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Prices.
     * @param {PricesCreateManyArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const prices = await prisma.prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricesCreateManyArgs>(args?: SelectSubset<T, PricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prices and returns the data saved in the database.
     * @param {PricesCreateManyAndReturnArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const prices = await prisma.prices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prices and only return the `id`
     * const pricesWithIdOnly = await prisma.prices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricesCreateManyAndReturnArgs>(args?: SelectSubset<T, PricesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Prices.
     * @param {PricesDeleteArgs} args - Arguments to delete one Prices.
     * @example
     * // Delete one Prices
     * const Prices = await prisma.prices.delete({
     *   where: {
     *     // ... filter to delete one Prices
     *   }
     * })
     * 
     */
    delete<T extends PricesDeleteArgs>(args: SelectSubset<T, PricesDeleteArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Prices.
     * @param {PricesUpdateArgs} args - Arguments to update one Prices.
     * @example
     * // Update one Prices
     * const prices = await prisma.prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricesUpdateArgs>(args: SelectSubset<T, PricesUpdateArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Prices.
     * @param {PricesDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricesDeleteManyArgs>(args?: SelectSubset<T, PricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const prices = await prisma.prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricesUpdateManyArgs>(args: SelectSubset<T, PricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices and returns the data updated in the database.
     * @param {PricesUpdateManyAndReturnArgs} args - Arguments to update many Prices.
     * @example
     * // Update many Prices
     * const prices = await prisma.prices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prices and only return the `id`
     * const pricesWithIdOnly = await prisma.prices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricesUpdateManyAndReturnArgs>(args: SelectSubset<T, PricesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Prices.
     * @param {PricesUpsertArgs} args - Arguments to update or create a Prices.
     * @example
     * // Update or create a Prices
     * const prices = await prisma.prices.upsert({
     *   create: {
     *     // ... data to create a Prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prices we want to update
     *   }
     * })
     */
    upsert<T extends PricesUpsertArgs>(args: SelectSubset<T, PricesUpsertArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.prices.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PricesCountArgs>(
      args?: Subset<T, PricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricesAggregateArgs>(args: Subset<T, PricesAggregateArgs>): Prisma.PrismaPromise<GetPricesAggregateType<T>>

    /**
     * Group by Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricesGroupByArgs['orderBy'] }
        : { orderBy?: PricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prices model
   */
  readonly fields: PricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Subscriptions<T extends Prices$SubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Prices$SubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prices model
   */ 
  interface PricesFieldRefs {
    readonly id: FieldRef<"Prices", 'String'>
    readonly productId: FieldRef<"Prices", 'String'>
    readonly active: FieldRef<"Prices", 'Boolean'>
    readonly unitAmount: FieldRef<"Prices", 'BigInt'>
    readonly currency: FieldRef<"Prices", 'String'>
    readonly type: FieldRef<"Prices", 'PricingType'>
    readonly interval: FieldRef<"Prices", 'PricingPlanInterval'>
    readonly intervalCount: FieldRef<"Prices", 'Int'>
    readonly trialPeriodDays: FieldRef<"Prices", 'Int'>
    readonly metadata: FieldRef<"Prices", 'Json'>
    readonly description: FieldRef<"Prices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prices findUnique
   */
  export type PricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where: PricesWhereUniqueInput
  }

  /**
   * Prices findUniqueOrThrow
   */
  export type PricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where: PricesWhereUniqueInput
  }

  /**
   * Prices findFirst
   */
  export type PricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PricesOrderByWithRelationInput | PricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PricesScalarFieldEnum | PricesScalarFieldEnum[]
  }

  /**
   * Prices findFirstOrThrow
   */
  export type PricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PricesOrderByWithRelationInput | PricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PricesScalarFieldEnum | PricesScalarFieldEnum[]
  }

  /**
   * Prices findMany
   */
  export type PricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PricesOrderByWithRelationInput | PricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: PricesScalarFieldEnum | PricesScalarFieldEnum[]
  }

  /**
   * Prices create
   */
  export type PricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * The data needed to create a Prices.
     */
    data: XOR<PricesCreateInput, PricesUncheckedCreateInput>
  }

  /**
   * Prices createMany
   */
  export type PricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prices.
     */
    data: PricesCreateManyInput | PricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prices createManyAndReturn
   */
  export type PricesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * The data used to create many Prices.
     */
    data: PricesCreateManyInput | PricesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prices update
   */
  export type PricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * The data needed to update a Prices.
     */
    data: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
    /**
     * Choose, which Prices to update.
     */
    where: PricesWhereUniqueInput
  }

  /**
   * Prices updateMany
   */
  export type PricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PricesWhereInput
  }

  /**
   * Prices updateManyAndReturn
   */
  export type PricesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * The data used to update Prices.
     */
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PricesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prices upsert
   */
  export type PricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * The filter to search for the Prices to update in case it exists.
     */
    where: PricesWhereUniqueInput
    /**
     * In case the Prices found by the `where` argument doesn't exist, create a new Prices with this data.
     */
    create: XOR<PricesCreateInput, PricesUncheckedCreateInput>
    /**
     * In case the Prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricesUpdateInput, PricesUncheckedUpdateInput>
  }

  /**
   * Prices delete
   */
  export type PricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
    /**
     * Filter which Prices to delete.
     */
    where: PricesWhereUniqueInput
  }

  /**
   * Prices deleteMany
   */
  export type PricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to delete
     */
    where?: PricesWhereInput
  }

  /**
   * Prices.Subscriptions
   */
  export type Prices$SubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Prices without action
   */
  export type PricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prices
     */
    select?: PricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prices
     */
    omit?: PricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricesInclude<ExtArgs> | null
  }


  /**
   * Model Subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    organizationId: number | null
    quantity: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    organizationId: number | null
    quantity: number | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    status: $Enums.SubscriptionStatus | null
    pricesId: string | null
    quantity: number | null
    cancelAtPeriodEnd: boolean | null
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    status: $Enums.SubscriptionStatus | null
    pricesId: string | null
    quantity: number | null
    cancelAtPeriodEnd: boolean | null
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    organizationId: number
    status: number
    metadata: number
    pricesId: number
    quantity: number
    cancelAtPeriodEnd: number
    created: number
    currentPeriodStart: number
    currentPeriodEnd: number
    endedAt: number
    cancelAt: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    organizationId?: true
    quantity?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    organizationId?: true
    quantity?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    organizationId?: true
    status?: true
    metadata?: true
    pricesId?: true
    quantity?: true
    cancelAtPeriodEnd?: true
    created?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    endedAt?: true
    cancelAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to aggregate.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type SubscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithAggregationInput | SubscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: SubscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    organizationId: number
    status: $Enums.SubscriptionStatus
    metadata: JsonValue | null
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    endedAt: Date | null
    cancelAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends SubscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    status?: boolean
    metadata?: boolean
    pricesId?: boolean
    quantity?: boolean
    cancelAtPeriodEnd?: boolean
    created?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    endedAt?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    status?: boolean
    metadata?: boolean
    pricesId?: boolean
    quantity?: boolean
    cancelAtPeriodEnd?: boolean
    created?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    endedAt?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    status?: boolean
    metadata?: boolean
    pricesId?: boolean
    quantity?: boolean
    cancelAtPeriodEnd?: boolean
    created?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    endedAt?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectScalar = {
    id?: boolean
    organizationId?: boolean
    status?: boolean
    metadata?: boolean
    pricesId?: boolean
    quantity?: boolean
    cancelAtPeriodEnd?: boolean
    created?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    endedAt?: boolean
    cancelAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
  }

  export type SubscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "status" | "metadata" | "pricesId" | "quantity" | "cancelAtPeriodEnd" | "created" | "currentPeriodStart" | "currentPeriodEnd" | "endedAt" | "cancelAt" | "canceledAt" | "trialStart" | "trialEnd", ExtArgs["result"]["subscriptions"]>
  export type SubscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    price?: boolean | PricesDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SubscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriptions"
    objects: {
      price: Prisma.$PricesPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: number
      status: $Enums.SubscriptionStatus
      metadata: Prisma.JsonValue | null
      pricesId: string
      quantity: number
      cancelAtPeriodEnd: boolean
      created: Date | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      endedAt: Date | null
      cancelAt: Date | null
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type SubscriptionsGetPayload<S extends boolean | null | undefined | SubscriptionsDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionsPayload, S>

  type SubscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface SubscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriptions'], meta: { name: 'Subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {SubscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionsFindUniqueArgs>(args: SelectSubset<T, SubscriptionsFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionsFindFirstArgs>(args?: SelectSubset<T, SubscriptionsFindFirstArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionsFindManyArgs>(args?: SelectSubset<T, SubscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Subscriptions.
     * @param {SubscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends SubscriptionsCreateArgs>(args: SelectSubset<T, SubscriptionsCreateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionsCreateManyArgs>(args?: SelectSubset<T, SubscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Subscriptions.
     * @param {SubscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionsDeleteArgs>(args: SelectSubset<T, SubscriptionsDeleteArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Subscriptions.
     * @param {SubscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionsUpdateArgs>(args: SelectSubset<T, SubscriptionsUpdateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionsDeleteManyArgs>(args?: SelectSubset<T, SubscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionsUpdateManyArgs>(args: SelectSubset<T, SubscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Subscriptions.
     * @param {SubscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionsUpsertArgs>(args: SelectSubset<T, SubscriptionsUpsertArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionsCountArgs>(
      args?: Subset<T, SubscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriptions model
   */
  readonly fields: SubscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    price<T extends PricesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PricesDefaultArgs<ExtArgs>>): Prisma__PricesClient<$Result.GetResult<Prisma.$PricesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriptions model
   */ 
  interface SubscriptionsFieldRefs {
    readonly id: FieldRef<"Subscriptions", 'String'>
    readonly organizationId: FieldRef<"Subscriptions", 'Int'>
    readonly status: FieldRef<"Subscriptions", 'SubscriptionStatus'>
    readonly metadata: FieldRef<"Subscriptions", 'Json'>
    readonly pricesId: FieldRef<"Subscriptions", 'String'>
    readonly quantity: FieldRef<"Subscriptions", 'Int'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscriptions", 'Boolean'>
    readonly created: FieldRef<"Subscriptions", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscriptions", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscriptions", 'DateTime'>
    readonly endedAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly cancelAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly trialStart: FieldRef<"Subscriptions", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriptions findUnique
   */
  export type SubscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findUniqueOrThrow
   */
  export type SubscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findFirst
   */
  export type SubscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findFirstOrThrow
   */
  export type SubscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findMany
   */
  export type SubscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions create
   */
  export type SubscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriptions.
     */
    data: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
  }

  /**
   * Subscriptions createMany
   */
  export type SubscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriptions createManyAndReturn
   */
  export type SubscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions update
   */
  export type SubscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriptions.
     */
    data: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
    /**
     * Choose, which Subscriptions to update.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions updateMany
   */
  export type SubscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
  }

  /**
   * Subscriptions updateManyAndReturn
   */
  export type SubscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions upsert
   */
  export type SubscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriptions to update in case it exists.
     */
    where: SubscriptionsWhereUniqueInput
    /**
     * In case the Subscriptions found by the `where` argument doesn't exist, create a new Subscriptions with this data.
     */
    create: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
    /**
     * In case the Subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
  }

  /**
   * Subscriptions delete
   */
  export type SubscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter which Subscriptions to delete.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions deleteMany
   */
  export type SubscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionsWhereInput
  }

  /**
   * Subscriptions without action
   */
  export type SubscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    email: 'email',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    inviteId: 'inviteId',
    isSupportUser: 'isSupportUser',
    hasSeenProductTour: 'hasSeenProductTour',
    productTourData: 'productTourData',
    savedDashboardView: 'savedDashboardView',
    photoView: 'photoView',
    groupView: 'groupView',
    onboardingStatus: 'onboardingStatus',
    organizationId: 'organizationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    name: 'name',
    address: 'address',
    faxNumber: 'faxNumber',
    size: 'size',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    logoId: 'logoId',
    lat: 'lat',
    lng: 'lng'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    name: 'name',
    quantity: 'quantity',
    organizationId: 'organizationId'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    title: 'title',
    content: 'content',
    isSeen: 'isSeen',
    link: 'link',
    linkText: 'linkText',
    type: 'type',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OrganizationSavedOptionScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    label: 'label',
    value: 'value',
    isDeleted: 'isDeleted',
    type: 'type',
    organizationId: 'organizationId'
  };

  export type OrganizationSavedOptionScalarFieldEnum = (typeof OrganizationSavedOptionScalarFieldEnum)[keyof typeof OrganizationSavedOptionScalarFieldEnum]


  export const UserToOrganizationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isAdmin: 'isAdmin',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    role: 'role',
    accessLevel: 'accessLevel',
    userId: 'userId'
  };

  export type UserToOrganizationScalarFieldEnum = (typeof UserToOrganizationScalarFieldEnum)[keyof typeof UserToOrganizationScalarFieldEnum]


  export const OrganizationInvitationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    email: 'email',
    invitationId: 'invitationId',
    isAccepted: 'isAccepted'
  };

  export type OrganizationInvitationScalarFieldEnum = (typeof OrganizationInvitationScalarFieldEnum)[keyof typeof OrganizationInvitationScalarFieldEnum]


  export const UserToProjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    projectId: 'projectId'
  };

  export type UserToProjectScalarFieldEnum = (typeof UserToProjectScalarFieldEnum)[keyof typeof UserToProjectScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    closedAt: 'closedAt',
    isDeleted: 'isDeleted',
    organizationId: 'organizationId',
    assignmentNumber: 'assignmentNumber',
    publicId: 'publicId',
    name: 'name',
    location: 'location',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    clientPhoneNumber: 'clientPhoneNumber',
    companyName: 'companyName',
    managerName: 'managerName',
    adjusterEmail: 'adjusterEmail',
    adjusterName: 'adjusterName',
    adjusterPhoneNumber: 'adjusterPhoneNumber',
    insuranceCompanyName: 'insuranceCompanyName',
    insuranceClaimId: 'insuranceClaimId',
    lossType: 'lossType',
    catCode: 'catCode',
    humidity: 'humidity',
    lastTimeWeatherFetched: 'lastTimeWeatherFetched',
    temperature: 'temperature',
    wind: 'wind',
    lat: 'lat',
    lng: 'lng',
    forecast: 'forecast',
    claimSummary: 'claimSummary',
    roofSegments: 'roofSegments',
    roofSpecs: 'roofSpecs',
    rcvValue: 'rcvValue',
    actualValue: 'actualValue',
    status: 'status',
    projectStatusValueId: 'projectStatusValueId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectNotesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ProjectNotesScalarFieldEnum = (typeof ProjectNotesScalarFieldEnum)[keyof typeof ProjectNotesScalarFieldEnum]


  export const ProjectStatusValueScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    label: 'label',
    description: 'description',
    color: 'color',
    order: 'order',
    organizationId: 'organizationId'
  };

  export type ProjectStatusValueScalarFieldEnum = (typeof ProjectStatusValueScalarFieldEnum)[keyof typeof ProjectStatusValueScalarFieldEnum]


  export const PendingRoofReportsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    projectId: 'projectId',
    isCompleted: 'isCompleted'
  };

  export type PendingRoofReportsScalarFieldEnum = (typeof PendingRoofReportsScalarFieldEnum)[keyof typeof PendingRoofReportsScalarFieldEnum]


  export const WeatherReportItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    projectId: 'projectId',
    date: 'date',
    time: 'time',
    f_scale: 'f_scale',
    speed: 'speed',
    size: 'size',
    location: 'location',
    county: 'county',
    state: 'state',
    lat: 'lat',
    lon: 'lon',
    comments: 'comments'
  };

  export type WeatherReportItemScalarFieldEnum = (typeof WeatherReportItemScalarFieldEnum)[keyof typeof WeatherReportItemScalarFieldEnum]


  export const ProjectEquipmentScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    quantity: 'quantity',
    projectId: 'projectId',
    equipmentId: 'equipmentId'
  };

  export type ProjectEquipmentScalarFieldEnum = (typeof ProjectEquipmentScalarFieldEnum)[keyof typeof ProjectEquipmentScalarFieldEnum]


  export const CostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    estimatedCost: 'estimatedCost',
    actualCost: 'actualCost',
    name: 'name',
    projectId: 'projectId',
    isDeleted: 'isDeleted',
    type: 'type'
  };

  export type CostScalarFieldEnum = (typeof CostScalarFieldEnum)[keyof typeof CostScalarFieldEnum]


  export const PropertyDataScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    projectId: 'projectId',
    bathrooms: 'bathrooms',
    bedrooms: 'bedrooms',
    squareFootage: 'squareFootage',
    realtyMoleId: 'realtyMoleId',
    data: 'data'
  };

  export type PropertyDataScalarFieldEnum = (typeof PropertyDataScalarFieldEnum)[keyof typeof PropertyDataScalarFieldEnum]


  export const DataDeletionRequestScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    fullName: 'fullName',
    email: 'email',
    isVerified: 'isVerified'
  };

  export type DataDeletionRequestScalarFieldEnum = (typeof DataDeletionRequestScalarFieldEnum)[keyof typeof DataDeletionRequestScalarFieldEnum]


  export const PhotoAccessLinkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    accessId: 'accessId',
    email: 'email',
    phoneNumber: 'phoneNumber',
    projectId: 'projectId'
  };

  export type PhotoAccessLinkScalarFieldEnum = (typeof PhotoAccessLinkScalarFieldEnum)[keyof typeof PhotoAccessLinkScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    key: 'key',
    projectId: 'projectId',
    organizationId: 'organizationId',
    includeInReport: 'includeInReport',
    description: 'description'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const AnnotationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageId: 'imageId',
    coordinates: 'coordinates',
    userId: 'userId',
    isDeleted: 'isDeleted'
  };

  export type AnnotationScalarFieldEnum = (typeof AnnotationScalarFieldEnum)[keyof typeof AnnotationScalarFieldEnum]


  export const ImageNoteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageId: 'imageId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId',
    isDeleted: 'isDeleted'
  };

  export type ImageNoteScalarFieldEnum = (typeof ImageNoteScalarFieldEnum)[keyof typeof ImageNoteScalarFieldEnum]


  export const InferenceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    imageId: 'imageId',
    imageKey: 'imageKey',
    projectId: 'projectId',
    roomId: 'roomId'
  };

  export type InferenceScalarFieldEnum = (typeof InferenceScalarFieldEnum)[keyof typeof InferenceScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    name: 'name',
    projectId: 'projectId',
    gpp: 'gpp',
    humidity: 'humidity',
    dehuReading: 'dehuReading',
    temperature: 'temperature',
    length: 'length',
    width: 'width',
    height: 'height',
    totalSqft: 'totalSqft',
    windows: 'windows',
    doors: 'doors',
    equipmentUsed: 'equipmentUsed'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomReadingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    humidity: 'humidity',
    temperature: 'temperature',
    moistureContentWall: 'moistureContentWall',
    moistureContentFloor: 'moistureContentFloor',
    equipmentUsed: 'equipmentUsed',
    roomId: 'roomId',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    gpp: 'gpp'
  };

  export type RoomReadingScalarFieldEnum = (typeof RoomReadingScalarFieldEnum)[keyof typeof RoomReadingScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    date: 'date',
    roomId: 'roomId',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    body: 'body'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const NotesAuditTrailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    notesId: 'notesId',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    body: 'body'
  };

  export type NotesAuditTrailScalarFieldEnum = (typeof NotesAuditTrailScalarFieldEnum)[keyof typeof NotesAuditTrailScalarFieldEnum]


  export const AreaAffectedScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    roomId: 'roomId',
    material: 'material',
    totalAreaRemoved: 'totalAreaRemoved',
    totalAreaMicrobialApplied: 'totalAreaMicrobialApplied',
    cause: 'cause',
    category: 'category',
    cabinetryRemoved: 'cabinetryRemoved',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    projectId: 'projectId',
    type: 'type'
  };

  export type AreaAffectedScalarFieldEnum = (typeof AreaAffectedScalarFieldEnum)[keyof typeof AreaAffectedScalarFieldEnum]


  export const GenericRoomReadingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    publicId: 'publicId',
    type: 'type',
    value: 'value',
    humidity: 'humidity',
    temperature: 'temperature',
    gpp: 'gpp',
    roomReadingId: 'roomReadingId',
    isDeleted: 'isDeleted'
  };

  export type GenericRoomReadingScalarFieldEnum = (typeof GenericRoomReadingScalarFieldEnum)[keyof typeof GenericRoomReadingScalarFieldEnum]


  export const DetectionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted',
    publicId: 'publicId',
    inferenceId: 'inferenceId',
    imageKey: 'imageKey',
    xMinCord: 'xMinCord',
    yMinCord: 'yMinCord',
    confidence: 'confidence',
    xMaxCord: 'xMaxCord',
    yMaxCord: 'yMaxCord',
    projectId: 'projectId',
    category: 'category',
    code: 'code',
    item: 'item',
    quality: 'quality',
    roomId: 'roomId',
    dimension: 'dimension',
    unit: 'unit'
  };

  export type DetectionScalarFieldEnum = (typeof DetectionScalarFieldEnum)[keyof typeof DetectionScalarFieldEnum]


  export const TemplatesUsedScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    templateCode: 'templateCode',
    roomId: 'roomId'
  };

  export type TemplatesUsedScalarFieldEnum = (typeof TemplatesUsedScalarFieldEnum)[keyof typeof TemplatesUsedScalarFieldEnum]


  export const WaitListScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    email: 'email'
  };

  export type WaitListScalarFieldEnum = (typeof WaitListScalarFieldEnum)[keyof typeof WaitListScalarFieldEnum]


  export const RekognitionRunsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt'
  };

  export type RekognitionRunsScalarFieldEnum = (typeof RekognitionRunsScalarFieldEnum)[keyof typeof RekognitionRunsScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subject: 'subject',
    payload: 'payload',
    projectId: 'projectId',
    date: 'date',
    dynamicId: 'dynamicId',
    isDeleted: 'isDeleted',
    remindClient: 'remindClient',
    remindProjectOwners: 'remindProjectOwners'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const CalendarEventReminderScalarFieldEnum: {
    id: 'id',
    reminderTarget: 'reminderTarget',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sendText: 'sendText',
    sendEmail: 'sendEmail',
    textSentAt: 'textSentAt',
    emailSentAt: 'emailSentAt',
    calendarEventId: 'calendarEventId',
    date: 'date'
  };

  export type CalendarEventReminderScalarFieldEnum = (typeof CalendarEventReminderScalarFieldEnum)[keyof typeof CalendarEventReminderScalarFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    xactimateKey: 'xactimateKey',
    xactimateDescription: 'xactimateDescription',
    hasItems: 'hasItems'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const LineItemScalarFieldEnum: {
    id: 'id',
    xactimateCode: 'xactimateCode',
    xactimateDescription: 'xactimateDescription',
    unit: 'unit',
    itemCategoryId: 'itemCategoryId'
  };

  export type LineItemScalarFieldEnum = (typeof LineItemScalarFieldEnum)[keyof typeof LineItemScalarFieldEnum]


  export const RelatedItemScalarFieldEnum: {
    id: 'id',
    relationId: 'relationId',
    lineItemId: 'lineItemId'
  };

  export type RelatedItemScalarFieldEnum = (typeof RelatedItemScalarFieldEnum)[keyof typeof RelatedItemScalarFieldEnum]


  export const AlternateItemScalarFieldEnum: {
    id: 'id',
    alternateId: 'alternateId',
    lineItemId: 'lineItemId'
  };

  export type AlternateItemScalarFieldEnum = (typeof AlternateItemScalarFieldEnum)[keyof typeof AlternateItemScalarFieldEnum]


  export const PlanEntitlementsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    extPlanId: 'extPlanId',
    maxImages: 'maxImages',
    maxProjects: 'maxProjects',
    maxSeats: 'maxSeats',
    description: 'description',
    period: 'period',
    price: 'price'
  };

  export type PlanEntitlementsScalarFieldEnum = (typeof PlanEntitlementsScalarFieldEnum)[keyof typeof PlanEntitlementsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    billingAddress: 'billingAddress',
    paymentMethod: 'paymentMethod',
    organizationId: 'organizationId'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    active: 'active',
    name: 'name',
    description: 'description',
    image: 'image',
    metadata: 'metadata'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const PricesScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    active: 'active',
    unitAmount: 'unitAmount',
    currency: 'currency',
    type: 'type',
    interval: 'interval',
    intervalCount: 'intervalCount',
    trialPeriodDays: 'trialPeriodDays',
    metadata: 'metadata',
    description: 'description'
  };

  export type PricesScalarFieldEnum = (typeof PricesScalarFieldEnum)[keyof typeof PricesScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    status: 'status',
    metadata: 'metadata',
    pricesId: 'pricesId',
    quantity: 'quantity',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    created: 'created',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    endedAt: 'endedAt',
    cancelAt: 'cancelAt',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    inviteId: 'inviteId',
    organizationId: 'organizationId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const OrganizationOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name',
    address: 'address',
    faxNumber: 'faxNumber',
    size: 'size',
    logoId: 'logoId'
  };

  export type OrganizationOrderByRelevanceFieldEnum = (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum]


  export const EquipmentOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name'
  };

  export type EquipmentOrderByRelevanceFieldEnum = (typeof EquipmentOrderByRelevanceFieldEnum)[keyof typeof EquipmentOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    title: 'title',
    content: 'content',
    link: 'link',
    linkText: 'linkText',
    userId: 'userId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const OrganizationSavedOptionOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    label: 'label',
    value: 'value'
  };

  export type OrganizationSavedOptionOrderByRelevanceFieldEnum = (typeof OrganizationSavedOptionOrderByRelevanceFieldEnum)[keyof typeof OrganizationSavedOptionOrderByRelevanceFieldEnum]


  export const UserToOrganizationOrderByRelevanceFieldEnum: {
    role: 'role',
    userId: 'userId'
  };

  export type UserToOrganizationOrderByRelevanceFieldEnum = (typeof UserToOrganizationOrderByRelevanceFieldEnum)[keyof typeof UserToOrganizationOrderByRelevanceFieldEnum]


  export const OrganizationInvitationOrderByRelevanceFieldEnum: {
    email: 'email',
    invitationId: 'invitationId'
  };

  export type OrganizationInvitationOrderByRelevanceFieldEnum = (typeof OrganizationInvitationOrderByRelevanceFieldEnum)[keyof typeof OrganizationInvitationOrderByRelevanceFieldEnum]


  export const UserToProjectOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type UserToProjectOrderByRelevanceFieldEnum = (typeof UserToProjectOrderByRelevanceFieldEnum)[keyof typeof UserToProjectOrderByRelevanceFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    assignmentNumber: 'assignmentNumber',
    publicId: 'publicId',
    name: 'name',
    location: 'location',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    clientPhoneNumber: 'clientPhoneNumber',
    companyName: 'companyName',
    managerName: 'managerName',
    adjusterEmail: 'adjusterEmail',
    adjusterName: 'adjusterName',
    adjusterPhoneNumber: 'adjusterPhoneNumber',
    insuranceCompanyName: 'insuranceCompanyName',
    insuranceClaimId: 'insuranceClaimId',
    lossType: 'lossType',
    humidity: 'humidity',
    temperature: 'temperature',
    wind: 'wind',
    lat: 'lat',
    lng: 'lng',
    forecast: 'forecast',
    claimSummary: 'claimSummary'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const ProjectNotesOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ProjectNotesOrderByRelevanceFieldEnum = (typeof ProjectNotesOrderByRelevanceFieldEnum)[keyof typeof ProjectNotesOrderByRelevanceFieldEnum]


  export const ProjectStatusValueOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    label: 'label',
    description: 'description',
    color: 'color'
  };

  export type ProjectStatusValueOrderByRelevanceFieldEnum = (typeof ProjectStatusValueOrderByRelevanceFieldEnum)[keyof typeof ProjectStatusValueOrderByRelevanceFieldEnum]


  export const WeatherReportItemOrderByRelevanceFieldEnum: {
    time: 'time',
    f_scale: 'f_scale',
    speed: 'speed',
    size: 'size',
    location: 'location',
    county: 'county',
    state: 'state',
    lat: 'lat',
    lon: 'lon',
    comments: 'comments'
  };

  export type WeatherReportItemOrderByRelevanceFieldEnum = (typeof WeatherReportItemOrderByRelevanceFieldEnum)[keyof typeof WeatherReportItemOrderByRelevanceFieldEnum]


  export const ProjectEquipmentOrderByRelevanceFieldEnum: {
    publicId: 'publicId'
  };

  export type ProjectEquipmentOrderByRelevanceFieldEnum = (typeof ProjectEquipmentOrderByRelevanceFieldEnum)[keyof typeof ProjectEquipmentOrderByRelevanceFieldEnum]


  export const CostOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CostOrderByRelevanceFieldEnum = (typeof CostOrderByRelevanceFieldEnum)[keyof typeof CostOrderByRelevanceFieldEnum]


  export const PropertyDataOrderByRelevanceFieldEnum: {
    realtyMoleId: 'realtyMoleId'
  };

  export type PropertyDataOrderByRelevanceFieldEnum = (typeof PropertyDataOrderByRelevanceFieldEnum)[keyof typeof PropertyDataOrderByRelevanceFieldEnum]


  export const DataDeletionRequestOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    email: 'email'
  };

  export type DataDeletionRequestOrderByRelevanceFieldEnum = (typeof DataDeletionRequestOrderByRelevanceFieldEnum)[keyof typeof DataDeletionRequestOrderByRelevanceFieldEnum]


  export const PhotoAccessLinkOrderByRelevanceFieldEnum: {
    accessId: 'accessId',
    email: 'email',
    phoneNumber: 'phoneNumber'
  };

  export type PhotoAccessLinkOrderByRelevanceFieldEnum = (typeof PhotoAccessLinkOrderByRelevanceFieldEnum)[keyof typeof PhotoAccessLinkOrderByRelevanceFieldEnum]


  export const ImageOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    key: 'key',
    description: 'description'
  };

  export type ImageOrderByRelevanceFieldEnum = (typeof ImageOrderByRelevanceFieldEnum)[keyof typeof ImageOrderByRelevanceFieldEnum]


  export const AnnotationOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type AnnotationOrderByRelevanceFieldEnum = (typeof AnnotationOrderByRelevanceFieldEnum)[keyof typeof AnnotationOrderByRelevanceFieldEnum]


  export const ImageNoteOrderByRelevanceFieldEnum: {
    body: 'body',
    mentions: 'mentions',
    userId: 'userId'
  };

  export type ImageNoteOrderByRelevanceFieldEnum = (typeof ImageNoteOrderByRelevanceFieldEnum)[keyof typeof ImageNoteOrderByRelevanceFieldEnum]


  export const InferenceOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    imageKey: 'imageKey'
  };

  export type InferenceOrderByRelevanceFieldEnum = (typeof InferenceOrderByRelevanceFieldEnum)[keyof typeof InferenceOrderByRelevanceFieldEnum]


  export const RoomOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    name: 'name',
    gpp: 'gpp',
    humidity: 'humidity',
    dehuReading: 'dehuReading',
    temperature: 'temperature',
    length: 'length',
    width: 'width',
    height: 'height',
    totalSqft: 'totalSqft',
    equipmentUsed: 'equipmentUsed'
  };

  export type RoomOrderByRelevanceFieldEnum = (typeof RoomOrderByRelevanceFieldEnum)[keyof typeof RoomOrderByRelevanceFieldEnum]


  export const RoomReadingOrderByRelevanceFieldEnum: {
    humidity: 'humidity',
    temperature: 'temperature',
    moistureContentWall: 'moistureContentWall',
    moistureContentFloor: 'moistureContentFloor',
    equipmentUsed: 'equipmentUsed',
    publicId: 'publicId',
    gpp: 'gpp'
  };

  export type RoomReadingOrderByRelevanceFieldEnum = (typeof RoomReadingOrderByRelevanceFieldEnum)[keyof typeof RoomReadingOrderByRelevanceFieldEnum]


  export const NotesOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    body: 'body'
  };

  export type NotesOrderByRelevanceFieldEnum = (typeof NotesOrderByRelevanceFieldEnum)[keyof typeof NotesOrderByRelevanceFieldEnum]


  export const NotesAuditTrailOrderByRelevanceFieldEnum: {
    userId: 'userId',
    userName: 'userName',
    body: 'body'
  };

  export type NotesAuditTrailOrderByRelevanceFieldEnum = (typeof NotesAuditTrailOrderByRelevanceFieldEnum)[keyof typeof NotesAuditTrailOrderByRelevanceFieldEnum]


  export const AreaAffectedOrderByRelevanceFieldEnum: {
    material: 'material',
    totalAreaRemoved: 'totalAreaRemoved',
    totalAreaMicrobialApplied: 'totalAreaMicrobialApplied',
    cause: 'cause',
    cabinetryRemoved: 'cabinetryRemoved',
    publicId: 'publicId'
  };

  export type AreaAffectedOrderByRelevanceFieldEnum = (typeof AreaAffectedOrderByRelevanceFieldEnum)[keyof typeof AreaAffectedOrderByRelevanceFieldEnum]


  export const GenericRoomReadingOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    value: 'value',
    humidity: 'humidity',
    temperature: 'temperature',
    gpp: 'gpp'
  };

  export type GenericRoomReadingOrderByRelevanceFieldEnum = (typeof GenericRoomReadingOrderByRelevanceFieldEnum)[keyof typeof GenericRoomReadingOrderByRelevanceFieldEnum]


  export const DetectionOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    imageKey: 'imageKey',
    category: 'category',
    code: 'code',
    item: 'item',
    quality: 'quality'
  };

  export type DetectionOrderByRelevanceFieldEnum = (typeof DetectionOrderByRelevanceFieldEnum)[keyof typeof DetectionOrderByRelevanceFieldEnum]


  export const TemplatesUsedOrderByRelevanceFieldEnum: {
    templateCode: 'templateCode'
  };

  export type TemplatesUsedOrderByRelevanceFieldEnum = (typeof TemplatesUsedOrderByRelevanceFieldEnum)[keyof typeof TemplatesUsedOrderByRelevanceFieldEnum]


  export const WaitListOrderByRelevanceFieldEnum: {
    email: 'email'
  };

  export type WaitListOrderByRelevanceFieldEnum = (typeof WaitListOrderByRelevanceFieldEnum)[keyof typeof WaitListOrderByRelevanceFieldEnum]


  export const CalendarEventOrderByRelevanceFieldEnum: {
    publicId: 'publicId',
    subject: 'subject',
    payload: 'payload',
    dynamicId: 'dynamicId'
  };

  export type CalendarEventOrderByRelevanceFieldEnum = (typeof CalendarEventOrderByRelevanceFieldEnum)[keyof typeof CalendarEventOrderByRelevanceFieldEnum]


  export const ItemCategoryOrderByRelevanceFieldEnum: {
    xactimateKey: 'xactimateKey',
    xactimateDescription: 'xactimateDescription'
  };

  export type ItemCategoryOrderByRelevanceFieldEnum = (typeof ItemCategoryOrderByRelevanceFieldEnum)[keyof typeof ItemCategoryOrderByRelevanceFieldEnum]


  export const LineItemOrderByRelevanceFieldEnum: {
    xactimateCode: 'xactimateCode',
    xactimateDescription: 'xactimateDescription',
    unit: 'unit'
  };

  export type LineItemOrderByRelevanceFieldEnum = (typeof LineItemOrderByRelevanceFieldEnum)[keyof typeof LineItemOrderByRelevanceFieldEnum]


  export const RelatedItemOrderByRelevanceFieldEnum: {
    relationId: 'relationId'
  };

  export type RelatedItemOrderByRelevanceFieldEnum = (typeof RelatedItemOrderByRelevanceFieldEnum)[keyof typeof RelatedItemOrderByRelevanceFieldEnum]


  export const AlternateItemOrderByRelevanceFieldEnum: {
    alternateId: 'alternateId'
  };

  export type AlternateItemOrderByRelevanceFieldEnum = (typeof AlternateItemOrderByRelevanceFieldEnum)[keyof typeof AlternateItemOrderByRelevanceFieldEnum]


  export const PlanEntitlementsOrderByRelevanceFieldEnum: {
    extPlanId: 'extPlanId',
    description: 'description',
    period: 'period'
  };

  export type PlanEntitlementsOrderByRelevanceFieldEnum = (typeof PlanEntitlementsOrderByRelevanceFieldEnum)[keyof typeof PlanEntitlementsOrderByRelevanceFieldEnum]


  export const CustomersOrderByRelevanceFieldEnum: {
    customerId: 'customerId'
  };

  export type CustomersOrderByRelevanceFieldEnum = (typeof CustomersOrderByRelevanceFieldEnum)[keyof typeof CustomersOrderByRelevanceFieldEnum]


  export const ProductsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image'
  };

  export type ProductsOrderByRelevanceFieldEnum = (typeof ProductsOrderByRelevanceFieldEnum)[keyof typeof ProductsOrderByRelevanceFieldEnum]


  export const PricesOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    currency: 'currency',
    description: 'description'
  };

  export type PricesOrderByRelevanceFieldEnum = (typeof PricesOrderByRelevanceFieldEnum)[keyof typeof PricesOrderByRelevanceFieldEnum]


  export const SubscriptionsOrderByRelevanceFieldEnum: {
    id: 'id',
    pricesId: 'pricesId'
  };

  export type SubscriptionsOrderByRelevanceFieldEnum = (typeof SubscriptionsOrderByRelevanceFieldEnum)[keyof typeof SubscriptionsOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DashboardViews'
   */
  export type EnumDashboardViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DashboardViews'>
    


  /**
   * Reference to a field of type 'DashboardViews[]'
   */
  export type ListEnumDashboardViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DashboardViews[]'>
    


  /**
   * Reference to a field of type 'PhotoViews'
   */
  export type EnumPhotoViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhotoViews'>
    


  /**
   * Reference to a field of type 'PhotoViews[]'
   */
  export type ListEnumPhotoViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhotoViews[]'>
    


  /**
   * Reference to a field of type 'GroupByViews'
   */
  export type EnumGroupByViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupByViews'>
    


  /**
   * Reference to a field of type 'GroupByViews[]'
   */
  export type ListEnumGroupByViewsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupByViews[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'SavedOptionType'
   */
  export type EnumSavedOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SavedOptionType'>
    


  /**
   * Reference to a field of type 'SavedOptionType[]'
   */
  export type ListEnumSavedOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SavedOptionType[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'CostType'
   */
  export type EnumCostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostType'>
    


  /**
   * Reference to a field of type 'CostType[]'
   */
  export type ListEnumCostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostType[]'>
    


  /**
   * Reference to a field of type 'NotesAuditAction'
   */
  export type EnumNotesAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotesAuditAction'>
    


  /**
   * Reference to a field of type 'NotesAuditAction[]'
   */
  export type ListEnumNotesAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotesAuditAction[]'>
    


  /**
   * Reference to a field of type 'AreaAffectedType'
   */
  export type EnumAreaAffectedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AreaAffectedType'>
    


  /**
   * Reference to a field of type 'AreaAffectedType[]'
   */
  export type ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AreaAffectedType[]'>
    


  /**
   * Reference to a field of type 'RoomReadingType'
   */
  export type EnumRoomReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomReadingType'>
    


  /**
   * Reference to a field of type 'RoomReadingType[]'
   */
  export type ListEnumRoomReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomReadingType[]'>
    


  /**
   * Reference to a field of type 'DimensionUnit'
   */
  export type EnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit'>
    


  /**
   * Reference to a field of type 'DimensionUnit[]'
   */
  export type ListEnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit[]'>
    


  /**
   * Reference to a field of type 'ReminderTarget'
   */
  export type EnumReminderTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderTarget'>
    


  /**
   * Reference to a field of type 'ReminderTarget[]'
   */
  export type ListEnumReminderTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderTarget[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'PricingType'
   */
  export type EnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType'>
    


  /**
   * Reference to a field of type 'PricingType[]'
   */
  export type ListEnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType[]'>
    


  /**
   * Reference to a field of type 'PricingPlanInterval'
   */
  export type EnumPricingPlanIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingPlanInterval'>
    


  /**
   * Reference to a field of type 'PricingPlanInterval[]'
   */
  export type ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingPlanInterval[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    token?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    isDeleted?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    inviteId?: StringNullableFilter<"User"> | string | null
    isSupportUser?: BoolFilter<"User"> | boolean
    hasSeenProductTour?: BoolFilter<"User"> | boolean
    productTourData?: JsonNullableFilter<"User">
    savedDashboardView?: EnumDashboardViewsFilter<"User"> | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFilter<"User"> | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFilter<"User"> | $Enums.GroupByViews
    onboardingStatus?: JsonNullableFilter<"User">
    organizationId?: UuidFilter<"User"> | string
    org?: XOR<UserToOrganizationNullableScalarRelationFilter, UserToOrganizationWhereInput> | null
    UserToProject?: UserToProjectListRelationFilter
    Notification?: NotificationListRelationFilter
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrderInput | SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrderInput | SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    org?: UserToOrganizationOrderByWithRelationInput
    UserToProject?: UserToProjectOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    ImageNote?: ImageNoteOrderByRelationAggregateInput
    Annotation?: AnnotationOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    isDeleted?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    inviteId?: StringNullableFilter<"User"> | string | null
    isSupportUser?: BoolFilter<"User"> | boolean
    hasSeenProductTour?: BoolFilter<"User"> | boolean
    productTourData?: JsonNullableFilter<"User">
    savedDashboardView?: EnumDashboardViewsFilter<"User"> | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFilter<"User"> | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFilter<"User"> | $Enums.GroupByViews
    onboardingStatus?: JsonNullableFilter<"User">
    organizationId?: UuidFilter<"User"> | string
    org?: XOR<UserToOrganizationNullableScalarRelationFilter, UserToOrganizationWhereInput> | null
    UserToProject?: UserToProjectListRelationFilter
    Notification?: NotificationListRelationFilter
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id" | "token">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrderInput | SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrderInput | SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    token?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    inviteId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isSupportUser?: BoolWithAggregatesFilter<"User"> | boolean
    hasSeenProductTour?: BoolWithAggregatesFilter<"User"> | boolean
    productTourData?: JsonNullableWithAggregatesFilter<"User">
    savedDashboardView?: EnumDashboardViewsWithAggregatesFilter<"User"> | $Enums.DashboardViews
    photoView?: EnumPhotoViewsWithAggregatesFilter<"User"> | $Enums.PhotoViews
    groupView?: EnumGroupByViewsWithAggregatesFilter<"User"> | $Enums.GroupByViews
    onboardingStatus?: JsonNullableWithAggregatesFilter<"User">
    organizationId?: UuidWithAggregatesFilter<"User"> | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    publicId?: UuidFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    name?: StringFilter<"Organization"> | string
    address?: StringFilter<"Organization"> | string
    faxNumber?: StringFilter<"Organization"> | string
    size?: StringFilter<"Organization"> | string
    isDeleted?: BoolFilter<"Organization"> | boolean
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    logoId?: StringNullableFilter<"Organization"> | string | null
    lat?: FloatFilter<"Organization"> | number
    lng?: FloatFilter<"Organization"> | number
    Image?: ImageListRelationFilter
    invitations?: OrganizationInvitationListRelationFilter
    projects?: ProjectListRelationFilter
    users?: UserToOrganizationListRelationFilter
    Customers?: CustomersListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
    OrganizationSavedOption?: OrganizationSavedOptionListRelationFilter
    equipment?: EquipmentListRelationFilter
    ProjectStatusValue?: ProjectStatusValueListRelationFilter
    User?: UserListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrderInput | SortOrder
    lat?: SortOrder
    lng?: SortOrder
    Image?: ImageOrderByRelationAggregateInput
    invitations?: OrganizationInvitationOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    users?: UserToOrganizationOrderByRelationAggregateInput
    Customers?: CustomersOrderByRelationAggregateInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
    OrganizationSavedOption?: OrganizationSavedOptionOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    ProjectStatusValue?: ProjectStatusValueOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    _relevance?: OrganizationOrderByRelevanceInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    name?: StringFilter<"Organization"> | string
    address?: StringFilter<"Organization"> | string
    faxNumber?: StringFilter<"Organization"> | string
    size?: StringFilter<"Organization"> | string
    isDeleted?: BoolFilter<"Organization"> | boolean
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    logoId?: StringNullableFilter<"Organization"> | string | null
    lat?: FloatFilter<"Organization"> | number
    lng?: FloatFilter<"Organization"> | number
    Image?: ImageListRelationFilter
    invitations?: OrganizationInvitationListRelationFilter
    projects?: ProjectListRelationFilter
    users?: UserToOrganizationListRelationFilter
    Customers?: CustomersListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
    OrganizationSavedOption?: OrganizationSavedOptionListRelationFilter
    equipment?: EquipmentListRelationFilter
    ProjectStatusValue?: ProjectStatusValueListRelationFilter
    User?: UserListRelationFilter
  }, "id" | "publicId">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrderInput | SortOrder
    lat?: SortOrder
    lng?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    publicId?: UuidWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    address?: StringWithAggregatesFilter<"Organization"> | string
    faxNumber?: StringWithAggregatesFilter<"Organization"> | string
    size?: StringWithAggregatesFilter<"Organization"> | string
    isDeleted?: BoolWithAggregatesFilter<"Organization"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    logoId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    lat?: FloatWithAggregatesFilter<"Organization"> | number
    lng?: FloatWithAggregatesFilter<"Organization"> | number
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: IntFilter<"Equipment"> | number
    publicId?: UuidFilter<"Equipment"> | string
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    isDeleted?: BoolFilter<"Equipment"> | boolean
    name?: StringFilter<"Equipment"> | string
    quantity?: IntFilter<"Equipment"> | number
    organizationId?: IntFilter<"Equipment"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ProjectEquipment?: ProjectEquipmentListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    ProjectEquipment?: ProjectEquipmentOrderByRelationAggregateInput
    _relevance?: EquipmentOrderByRelevanceInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    isDeleted?: BoolFilter<"Equipment"> | boolean
    name?: StringFilter<"Equipment"> | string
    quantity?: IntFilter<"Equipment"> | number
    organizationId?: IntFilter<"Equipment"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ProjectEquipment?: ProjectEquipmentListRelationFilter
  }, "id" | "publicId">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Equipment"> | number
    publicId?: UuidWithAggregatesFilter<"Equipment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Equipment"> | boolean
    name?: StringWithAggregatesFilter<"Equipment"> | string
    quantity?: IntWithAggregatesFilter<"Equipment"> | number
    organizationId?: IntWithAggregatesFilter<"Equipment"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    publicId?: UuidFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isSeen?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    linkText?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrderInput | SortOrder
    linkText?: SortOrderInput | SortOrder
    type?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isSeen?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    linkText?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "publicId">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrderInput | SortOrder
    linkText?: SortOrderInput | SortOrder
    type?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    publicId?: UuidWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Notification"> | boolean
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isSeen?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    linkText?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type OrganizationSavedOptionWhereInput = {
    AND?: OrganizationSavedOptionWhereInput | OrganizationSavedOptionWhereInput[]
    OR?: OrganizationSavedOptionWhereInput[]
    NOT?: OrganizationSavedOptionWhereInput | OrganizationSavedOptionWhereInput[]
    id?: IntFilter<"OrganizationSavedOption"> | number
    publicId?: UuidFilter<"OrganizationSavedOption"> | string
    createdAt?: DateTimeFilter<"OrganizationSavedOption"> | Date | string
    label?: StringFilter<"OrganizationSavedOption"> | string
    value?: StringFilter<"OrganizationSavedOption"> | string
    isDeleted?: BoolFilter<"OrganizationSavedOption"> | boolean
    type?: EnumSavedOptionTypeFilter<"OrganizationSavedOption"> | $Enums.SavedOptionType
    organizationId?: IntFilter<"OrganizationSavedOption"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationSavedOptionOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: OrganizationSavedOptionOrderByRelevanceInput
  }

  export type OrganizationSavedOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    AND?: OrganizationSavedOptionWhereInput | OrganizationSavedOptionWhereInput[]
    OR?: OrganizationSavedOptionWhereInput[]
    NOT?: OrganizationSavedOptionWhereInput | OrganizationSavedOptionWhereInput[]
    createdAt?: DateTimeFilter<"OrganizationSavedOption"> | Date | string
    label?: StringFilter<"OrganizationSavedOption"> | string
    value?: StringFilter<"OrganizationSavedOption"> | string
    isDeleted?: BoolFilter<"OrganizationSavedOption"> | boolean
    type?: EnumSavedOptionTypeFilter<"OrganizationSavedOption"> | $Enums.SavedOptionType
    organizationId?: IntFilter<"OrganizationSavedOption"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "publicId">

  export type OrganizationSavedOptionOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    _count?: OrganizationSavedOptionCountOrderByAggregateInput
    _avg?: OrganizationSavedOptionAvgOrderByAggregateInput
    _max?: OrganizationSavedOptionMaxOrderByAggregateInput
    _min?: OrganizationSavedOptionMinOrderByAggregateInput
    _sum?: OrganizationSavedOptionSumOrderByAggregateInput
  }

  export type OrganizationSavedOptionScalarWhereWithAggregatesInput = {
    AND?: OrganizationSavedOptionScalarWhereWithAggregatesInput | OrganizationSavedOptionScalarWhereWithAggregatesInput[]
    OR?: OrganizationSavedOptionScalarWhereWithAggregatesInput[]
    NOT?: OrganizationSavedOptionScalarWhereWithAggregatesInput | OrganizationSavedOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrganizationSavedOption"> | number
    publicId?: UuidWithAggregatesFilter<"OrganizationSavedOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationSavedOption"> | Date | string
    label?: StringWithAggregatesFilter<"OrganizationSavedOption"> | string
    value?: StringWithAggregatesFilter<"OrganizationSavedOption"> | string
    isDeleted?: BoolWithAggregatesFilter<"OrganizationSavedOption"> | boolean
    type?: EnumSavedOptionTypeWithAggregatesFilter<"OrganizationSavedOption"> | $Enums.SavedOptionType
    organizationId?: IntWithAggregatesFilter<"OrganizationSavedOption"> | number
  }

  export type UserToOrganizationWhereInput = {
    AND?: UserToOrganizationWhereInput | UserToOrganizationWhereInput[]
    OR?: UserToOrganizationWhereInput[]
    NOT?: UserToOrganizationWhereInput | UserToOrganizationWhereInput[]
    id?: IntFilter<"UserToOrganization"> | number
    createdAt?: DateTimeFilter<"UserToOrganization"> | Date | string
    isAdmin?: BoolFilter<"UserToOrganization"> | boolean
    isDeleted?: BoolFilter<"UserToOrganization"> | boolean
    organizationId?: IntFilter<"UserToOrganization"> | number
    role?: StringNullableFilter<"UserToOrganization"> | string | null
    accessLevel?: EnumAccessLevelNullableFilter<"UserToOrganization"> | $Enums.AccessLevel | null
    userId?: StringFilter<"UserToOrganization"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserToOrganizationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrderInput | SortOrder
    accessLevel?: SortOrderInput | SortOrder
    userId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: UserToOrganizationOrderByRelevanceInput
  }

  export type UserToOrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    AND?: UserToOrganizationWhereInput | UserToOrganizationWhereInput[]
    OR?: UserToOrganizationWhereInput[]
    NOT?: UserToOrganizationWhereInput | UserToOrganizationWhereInput[]
    createdAt?: DateTimeFilter<"UserToOrganization"> | Date | string
    isAdmin?: BoolFilter<"UserToOrganization"> | boolean
    isDeleted?: BoolFilter<"UserToOrganization"> | boolean
    organizationId?: IntFilter<"UserToOrganization"> | number
    role?: StringNullableFilter<"UserToOrganization"> | string | null
    accessLevel?: EnumAccessLevelNullableFilter<"UserToOrganization"> | $Enums.AccessLevel | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserToOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrderInput | SortOrder
    accessLevel?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: UserToOrganizationCountOrderByAggregateInput
    _avg?: UserToOrganizationAvgOrderByAggregateInput
    _max?: UserToOrganizationMaxOrderByAggregateInput
    _min?: UserToOrganizationMinOrderByAggregateInput
    _sum?: UserToOrganizationSumOrderByAggregateInput
  }

  export type UserToOrganizationScalarWhereWithAggregatesInput = {
    AND?: UserToOrganizationScalarWhereWithAggregatesInput | UserToOrganizationScalarWhereWithAggregatesInput[]
    OR?: UserToOrganizationScalarWhereWithAggregatesInput[]
    NOT?: UserToOrganizationScalarWhereWithAggregatesInput | UserToOrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserToOrganization"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserToOrganization"> | Date | string
    isAdmin?: BoolWithAggregatesFilter<"UserToOrganization"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"UserToOrganization"> | boolean
    organizationId?: IntWithAggregatesFilter<"UserToOrganization"> | number
    role?: StringNullableWithAggregatesFilter<"UserToOrganization"> | string | null
    accessLevel?: EnumAccessLevelNullableWithAggregatesFilter<"UserToOrganization"> | $Enums.AccessLevel | null
    userId?: StringWithAggregatesFilter<"UserToOrganization"> | string
  }

  export type OrganizationInvitationWhereInput = {
    AND?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    OR?: OrganizationInvitationWhereInput[]
    NOT?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    id?: IntFilter<"OrganizationInvitation"> | number
    createdAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    isDeleted?: BoolFilter<"OrganizationInvitation"> | boolean
    organizationId?: IntFilter<"OrganizationInvitation"> | number
    email?: StringFilter<"OrganizationInvitation"> | string
    invitationId?: StringFilter<"OrganizationInvitation"> | string
    isAccepted?: BoolFilter<"OrganizationInvitation"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationInvitationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: OrganizationInvitationOrderByRelevanceInput
  }

  export type OrganizationInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invitationId?: string
    AND?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    OR?: OrganizationInvitationWhereInput[]
    NOT?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    createdAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    isDeleted?: BoolFilter<"OrganizationInvitation"> | boolean
    organizationId?: IntFilter<"OrganizationInvitation"> | number
    email?: StringFilter<"OrganizationInvitation"> | string
    isAccepted?: BoolFilter<"OrganizationInvitation"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "invitationId">

  export type OrganizationInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
    _count?: OrganizationInvitationCountOrderByAggregateInput
    _avg?: OrganizationInvitationAvgOrderByAggregateInput
    _max?: OrganizationInvitationMaxOrderByAggregateInput
    _min?: OrganizationInvitationMinOrderByAggregateInput
    _sum?: OrganizationInvitationSumOrderByAggregateInput
  }

  export type OrganizationInvitationScalarWhereWithAggregatesInput = {
    AND?: OrganizationInvitationScalarWhereWithAggregatesInput | OrganizationInvitationScalarWhereWithAggregatesInput[]
    OR?: OrganizationInvitationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationInvitationScalarWhereWithAggregatesInput | OrganizationInvitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrganizationInvitation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationInvitation"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"OrganizationInvitation"> | boolean
    organizationId?: IntWithAggregatesFilter<"OrganizationInvitation"> | number
    email?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    invitationId?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    isAccepted?: BoolWithAggregatesFilter<"OrganizationInvitation"> | boolean
  }

  export type UserToProjectWhereInput = {
    AND?: UserToProjectWhereInput | UserToProjectWhereInput[]
    OR?: UserToProjectWhereInput[]
    NOT?: UserToProjectWhereInput | UserToProjectWhereInput[]
    id?: IntFilter<"UserToProject"> | number
    createdAt?: DateTimeFilter<"UserToProject"> | Date | string
    userId?: StringFilter<"UserToProject"> | string
    projectId?: IntFilter<"UserToProject"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type UserToProjectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: UserToProjectOrderByRelevanceInput
  }

  export type UserToProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_projectId?: UserToProjectUserIdProjectIdCompoundUniqueInput
    AND?: UserToProjectWhereInput | UserToProjectWhereInput[]
    OR?: UserToProjectWhereInput[]
    NOT?: UserToProjectWhereInput | UserToProjectWhereInput[]
    createdAt?: DateTimeFilter<"UserToProject"> | Date | string
    userId?: StringFilter<"UserToProject"> | string
    projectId?: IntFilter<"UserToProject"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "userId_projectId">

  export type UserToProjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    _count?: UserToProjectCountOrderByAggregateInput
    _avg?: UserToProjectAvgOrderByAggregateInput
    _max?: UserToProjectMaxOrderByAggregateInput
    _min?: UserToProjectMinOrderByAggregateInput
    _sum?: UserToProjectSumOrderByAggregateInput
  }

  export type UserToProjectScalarWhereWithAggregatesInput = {
    AND?: UserToProjectScalarWhereWithAggregatesInput | UserToProjectScalarWhereWithAggregatesInput[]
    OR?: UserToProjectScalarWhereWithAggregatesInput[]
    NOT?: UserToProjectScalarWhereWithAggregatesInput | UserToProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserToProject"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserToProject"> | Date | string
    userId?: StringWithAggregatesFilter<"UserToProject"> | string
    projectId?: IntWithAggregatesFilter<"UserToProject"> | number
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    closedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isDeleted?: BoolFilter<"Project"> | boolean
    organizationId?: IntFilter<"Project"> | number
    assignmentNumber?: StringFilter<"Project"> | string
    publicId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    location?: StringFilter<"Project"> | string
    clientName?: StringFilter<"Project"> | string
    clientEmail?: StringFilter<"Project"> | string
    clientPhoneNumber?: StringFilter<"Project"> | string
    companyName?: StringFilter<"Project"> | string
    managerName?: StringFilter<"Project"> | string
    adjusterEmail?: StringFilter<"Project"> | string
    adjusterName?: StringFilter<"Project"> | string
    adjusterPhoneNumber?: StringFilter<"Project"> | string
    insuranceCompanyName?: StringFilter<"Project"> | string
    insuranceClaimId?: StringFilter<"Project"> | string
    lossType?: StringFilter<"Project"> | string
    catCode?: IntNullableFilter<"Project"> | number | null
    humidity?: StringFilter<"Project"> | string
    lastTimeWeatherFetched?: DateTimeNullableFilter<"Project"> | Date | string | null
    temperature?: StringFilter<"Project"> | string
    wind?: StringFilter<"Project"> | string
    lat?: StringFilter<"Project"> | string
    lng?: StringFilter<"Project"> | string
    forecast?: StringFilter<"Project"> | string
    claimSummary?: StringFilter<"Project"> | string
    roofSegments?: JsonNullableListFilter<"Project">
    roofSpecs?: JsonNullableFilter<"Project">
    rcvValue?: FloatNullableFilter<"Project"> | number | null
    actualValue?: FloatNullableFilter<"Project"> | number | null
    status?: EnumProjectStatusNullableFilter<"Project"> | $Enums.ProjectStatus | null
    projectStatusValueId?: IntNullableFilter<"Project"> | number | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    images?: ImageListRelationFilter
    inferences?: InferenceListRelationFilter
    rooms?: RoomListRelationFilter
    events?: CalendarEventListRelationFilter
    projectAssignees?: UserToProjectListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    propertyData?: XOR<PropertyDataNullableScalarRelationFilter, PropertyDataWhereInput> | null
    AreaAffected?: AreaAffectedListRelationFilter
    photoAccessLinks?: PhotoAccessLinkListRelationFilter
    notes?: NotesListRelationFilter
    costs?: CostListRelationFilter
    projectEquipment?: ProjectEquipmentListRelationFilter
    weatherReportItems?: WeatherReportItemListRelationFilter
    currentStatus?: XOR<ProjectStatusValueNullableScalarRelationFilter, ProjectStatusValueWhereInput> | null
    PendingRoofReports?: PendingRoofReportsListRelationFilter
    ProjectNotes?: ProjectNotesListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrderInput | SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrderInput | SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrderInput | SortOrder
    rcvValue?: SortOrderInput | SortOrder
    actualValue?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    projectStatusValueId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
    inferences?: InferenceOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    events?: CalendarEventOrderByRelationAggregateInput
    projectAssignees?: UserToProjectOrderByRelationAggregateInput
    roomReadings?: RoomReadingOrderByRelationAggregateInput
    propertyData?: PropertyDataOrderByWithRelationInput
    AreaAffected?: AreaAffectedOrderByRelationAggregateInput
    photoAccessLinks?: PhotoAccessLinkOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    costs?: CostOrderByRelationAggregateInput
    projectEquipment?: ProjectEquipmentOrderByRelationAggregateInput
    weatherReportItems?: WeatherReportItemOrderByRelationAggregateInput
    currentStatus?: ProjectStatusValueOrderByWithRelationInput
    PendingRoofReports?: PendingRoofReportsOrderByRelationAggregateInput
    ProjectNotes?: ProjectNotesOrderByRelationAggregateInput
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    createdAt?: DateTimeFilter<"Project"> | Date | string
    closedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isDeleted?: BoolFilter<"Project"> | boolean
    organizationId?: IntFilter<"Project"> | number
    assignmentNumber?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    location?: StringFilter<"Project"> | string
    clientName?: StringFilter<"Project"> | string
    clientEmail?: StringFilter<"Project"> | string
    clientPhoneNumber?: StringFilter<"Project"> | string
    companyName?: StringFilter<"Project"> | string
    managerName?: StringFilter<"Project"> | string
    adjusterEmail?: StringFilter<"Project"> | string
    adjusterName?: StringFilter<"Project"> | string
    adjusterPhoneNumber?: StringFilter<"Project"> | string
    insuranceCompanyName?: StringFilter<"Project"> | string
    insuranceClaimId?: StringFilter<"Project"> | string
    lossType?: StringFilter<"Project"> | string
    catCode?: IntNullableFilter<"Project"> | number | null
    humidity?: StringFilter<"Project"> | string
    lastTimeWeatherFetched?: DateTimeNullableFilter<"Project"> | Date | string | null
    temperature?: StringFilter<"Project"> | string
    wind?: StringFilter<"Project"> | string
    lat?: StringFilter<"Project"> | string
    lng?: StringFilter<"Project"> | string
    forecast?: StringFilter<"Project"> | string
    claimSummary?: StringFilter<"Project"> | string
    roofSegments?: JsonNullableListFilter<"Project">
    roofSpecs?: JsonNullableFilter<"Project">
    rcvValue?: FloatNullableFilter<"Project"> | number | null
    actualValue?: FloatNullableFilter<"Project"> | number | null
    status?: EnumProjectStatusNullableFilter<"Project"> | $Enums.ProjectStatus | null
    projectStatusValueId?: IntNullableFilter<"Project"> | number | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    images?: ImageListRelationFilter
    inferences?: InferenceListRelationFilter
    rooms?: RoomListRelationFilter
    events?: CalendarEventListRelationFilter
    projectAssignees?: UserToProjectListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    propertyData?: XOR<PropertyDataNullableScalarRelationFilter, PropertyDataWhereInput> | null
    AreaAffected?: AreaAffectedListRelationFilter
    photoAccessLinks?: PhotoAccessLinkListRelationFilter
    notes?: NotesListRelationFilter
    costs?: CostListRelationFilter
    projectEquipment?: ProjectEquipmentListRelationFilter
    weatherReportItems?: WeatherReportItemListRelationFilter
    currentStatus?: XOR<ProjectStatusValueNullableScalarRelationFilter, ProjectStatusValueWhereInput> | null
    PendingRoofReports?: PendingRoofReportsListRelationFilter
    ProjectNotes?: ProjectNotesListRelationFilter
  }, "id" | "publicId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrderInput | SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrderInput | SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrderInput | SortOrder
    rcvValue?: SortOrderInput | SortOrder
    actualValue?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    projectStatusValueId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Project"> | boolean
    organizationId?: IntWithAggregatesFilter<"Project"> | number
    assignmentNumber?: StringWithAggregatesFilter<"Project"> | string
    publicId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    location?: StringWithAggregatesFilter<"Project"> | string
    clientName?: StringWithAggregatesFilter<"Project"> | string
    clientEmail?: StringWithAggregatesFilter<"Project"> | string
    clientPhoneNumber?: StringWithAggregatesFilter<"Project"> | string
    companyName?: StringWithAggregatesFilter<"Project"> | string
    managerName?: StringWithAggregatesFilter<"Project"> | string
    adjusterEmail?: StringWithAggregatesFilter<"Project"> | string
    adjusterName?: StringWithAggregatesFilter<"Project"> | string
    adjusterPhoneNumber?: StringWithAggregatesFilter<"Project"> | string
    insuranceCompanyName?: StringWithAggregatesFilter<"Project"> | string
    insuranceClaimId?: StringWithAggregatesFilter<"Project"> | string
    lossType?: StringWithAggregatesFilter<"Project"> | string
    catCode?: IntNullableWithAggregatesFilter<"Project"> | number | null
    humidity?: StringWithAggregatesFilter<"Project"> | string
    lastTimeWeatherFetched?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    temperature?: StringWithAggregatesFilter<"Project"> | string
    wind?: StringWithAggregatesFilter<"Project"> | string
    lat?: StringWithAggregatesFilter<"Project"> | string
    lng?: StringWithAggregatesFilter<"Project"> | string
    forecast?: StringWithAggregatesFilter<"Project"> | string
    claimSummary?: StringWithAggregatesFilter<"Project"> | string
    roofSegments?: JsonNullableListFilter<"Project">
    roofSpecs?: JsonNullableWithAggregatesFilter<"Project">
    rcvValue?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    actualValue?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    status?: EnumProjectStatusNullableWithAggregatesFilter<"Project"> | $Enums.ProjectStatus | null
    projectStatusValueId?: IntNullableWithAggregatesFilter<"Project"> | number | null
  }

  export type ProjectNotesWhereInput = {
    AND?: ProjectNotesWhereInput | ProjectNotesWhereInput[]
    OR?: ProjectNotesWhereInput[]
    NOT?: ProjectNotesWhereInput | ProjectNotesWhereInput[]
    id?: IntFilter<"ProjectNotes"> | number
    createdAt?: DateTimeFilter<"ProjectNotes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ProjectNotes"> | Date | string | null
    date?: DateTimeFilter<"ProjectNotes"> | Date | string
    isDeleted?: BoolFilter<"ProjectNotes"> | boolean
    publicId?: StringFilter<"ProjectNotes"> | string
    projectId?: IntFilter<"ProjectNotes"> | number
    body?: StringFilter<"ProjectNotes"> | string
    mentions?: StringNullableListFilter<"ProjectNotes">
    userId?: StringFilter<"ProjectNotes"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectNotesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: ProjectNotesOrderByRelevanceInput
  }

  export type ProjectNotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectNotesWhereInput | ProjectNotesWhereInput[]
    OR?: ProjectNotesWhereInput[]
    NOT?: ProjectNotesWhereInput | ProjectNotesWhereInput[]
    createdAt?: DateTimeFilter<"ProjectNotes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ProjectNotes"> | Date | string | null
    date?: DateTimeFilter<"ProjectNotes"> | Date | string
    isDeleted?: BoolFilter<"ProjectNotes"> | boolean
    publicId?: StringFilter<"ProjectNotes"> | string
    projectId?: IntFilter<"ProjectNotes"> | number
    body?: StringFilter<"ProjectNotes"> | string
    mentions?: StringNullableListFilter<"ProjectNotes">
    userId?: StringFilter<"ProjectNotes"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectNotesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    _count?: ProjectNotesCountOrderByAggregateInput
    _avg?: ProjectNotesAvgOrderByAggregateInput
    _max?: ProjectNotesMaxOrderByAggregateInput
    _min?: ProjectNotesMinOrderByAggregateInput
    _sum?: ProjectNotesSumOrderByAggregateInput
  }

  export type ProjectNotesScalarWhereWithAggregatesInput = {
    AND?: ProjectNotesScalarWhereWithAggregatesInput | ProjectNotesScalarWhereWithAggregatesInput[]
    OR?: ProjectNotesScalarWhereWithAggregatesInput[]
    NOT?: ProjectNotesScalarWhereWithAggregatesInput | ProjectNotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectNotes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectNotes"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProjectNotes"> | Date | string | null
    date?: DateTimeWithAggregatesFilter<"ProjectNotes"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"ProjectNotes"> | boolean
    publicId?: StringWithAggregatesFilter<"ProjectNotes"> | string
    projectId?: IntWithAggregatesFilter<"ProjectNotes"> | number
    body?: StringWithAggregatesFilter<"ProjectNotes"> | string
    mentions?: StringNullableListFilter<"ProjectNotes">
    userId?: StringWithAggregatesFilter<"ProjectNotes"> | string
  }

  export type ProjectStatusValueWhereInput = {
    AND?: ProjectStatusValueWhereInput | ProjectStatusValueWhereInput[]
    OR?: ProjectStatusValueWhereInput[]
    NOT?: ProjectStatusValueWhereInput | ProjectStatusValueWhereInput[]
    id?: IntFilter<"ProjectStatusValue"> | number
    createdAt?: DateTimeFilter<"ProjectStatusValue"> | Date | string
    isDeleted?: BoolFilter<"ProjectStatusValue"> | boolean
    publicId?: UuidFilter<"ProjectStatusValue"> | string
    label?: StringFilter<"ProjectStatusValue"> | string
    description?: StringFilter<"ProjectStatusValue"> | string
    color?: StringFilter<"ProjectStatusValue"> | string
    order?: IntNullableFilter<"ProjectStatusValue"> | number | null
    organizationId?: IntFilter<"ProjectStatusValue"> | number
    projects?: ProjectListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ProjectStatusValueOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: ProjectStatusValueOrderByRelevanceInput
  }

  export type ProjectStatusValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    organizationId_label?: ProjectStatusValueOrganizationIdLabelCompoundUniqueInput
    AND?: ProjectStatusValueWhereInput | ProjectStatusValueWhereInput[]
    OR?: ProjectStatusValueWhereInput[]
    NOT?: ProjectStatusValueWhereInput | ProjectStatusValueWhereInput[]
    createdAt?: DateTimeFilter<"ProjectStatusValue"> | Date | string
    isDeleted?: BoolFilter<"ProjectStatusValue"> | boolean
    label?: StringFilter<"ProjectStatusValue"> | string
    description?: StringFilter<"ProjectStatusValue"> | string
    color?: StringFilter<"ProjectStatusValue"> | string
    order?: IntNullableFilter<"ProjectStatusValue"> | number | null
    organizationId?: IntFilter<"ProjectStatusValue"> | number
    projects?: ProjectListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "publicId" | "organizationId_label">

  export type ProjectStatusValueOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    _count?: ProjectStatusValueCountOrderByAggregateInput
    _avg?: ProjectStatusValueAvgOrderByAggregateInput
    _max?: ProjectStatusValueMaxOrderByAggregateInput
    _min?: ProjectStatusValueMinOrderByAggregateInput
    _sum?: ProjectStatusValueSumOrderByAggregateInput
  }

  export type ProjectStatusValueScalarWhereWithAggregatesInput = {
    AND?: ProjectStatusValueScalarWhereWithAggregatesInput | ProjectStatusValueScalarWhereWithAggregatesInput[]
    OR?: ProjectStatusValueScalarWhereWithAggregatesInput[]
    NOT?: ProjectStatusValueScalarWhereWithAggregatesInput | ProjectStatusValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectStatusValue"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStatusValue"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"ProjectStatusValue"> | boolean
    publicId?: UuidWithAggregatesFilter<"ProjectStatusValue"> | string
    label?: StringWithAggregatesFilter<"ProjectStatusValue"> | string
    description?: StringWithAggregatesFilter<"ProjectStatusValue"> | string
    color?: StringWithAggregatesFilter<"ProjectStatusValue"> | string
    order?: IntNullableWithAggregatesFilter<"ProjectStatusValue"> | number | null
    organizationId?: IntWithAggregatesFilter<"ProjectStatusValue"> | number
  }

  export type PendingRoofReportsWhereInput = {
    AND?: PendingRoofReportsWhereInput | PendingRoofReportsWhereInput[]
    OR?: PendingRoofReportsWhereInput[]
    NOT?: PendingRoofReportsWhereInput | PendingRoofReportsWhereInput[]
    id?: IntFilter<"PendingRoofReports"> | number
    createdAt?: DateTimeFilter<"PendingRoofReports"> | Date | string
    isDeleted?: BoolFilter<"PendingRoofReports"> | boolean
    projectId?: IntFilter<"PendingRoofReports"> | number
    isCompleted?: BoolFilter<"PendingRoofReports"> | boolean
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type PendingRoofReportsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type PendingRoofReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingRoofReportsWhereInput | PendingRoofReportsWhereInput[]
    OR?: PendingRoofReportsWhereInput[]
    NOT?: PendingRoofReportsWhereInput | PendingRoofReportsWhereInput[]
    createdAt?: DateTimeFilter<"PendingRoofReports"> | Date | string
    isDeleted?: BoolFilter<"PendingRoofReports"> | boolean
    projectId?: IntFilter<"PendingRoofReports"> | number
    isCompleted?: BoolFilter<"PendingRoofReports"> | boolean
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type PendingRoofReportsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
    _count?: PendingRoofReportsCountOrderByAggregateInput
    _avg?: PendingRoofReportsAvgOrderByAggregateInput
    _max?: PendingRoofReportsMaxOrderByAggregateInput
    _min?: PendingRoofReportsMinOrderByAggregateInput
    _sum?: PendingRoofReportsSumOrderByAggregateInput
  }

  export type PendingRoofReportsScalarWhereWithAggregatesInput = {
    AND?: PendingRoofReportsScalarWhereWithAggregatesInput | PendingRoofReportsScalarWhereWithAggregatesInput[]
    OR?: PendingRoofReportsScalarWhereWithAggregatesInput[]
    NOT?: PendingRoofReportsScalarWhereWithAggregatesInput | PendingRoofReportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingRoofReports"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PendingRoofReports"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"PendingRoofReports"> | boolean
    projectId?: IntWithAggregatesFilter<"PendingRoofReports"> | number
    isCompleted?: BoolWithAggregatesFilter<"PendingRoofReports"> | boolean
  }

  export type WeatherReportItemWhereInput = {
    AND?: WeatherReportItemWhereInput | WeatherReportItemWhereInput[]
    OR?: WeatherReportItemWhereInput[]
    NOT?: WeatherReportItemWhereInput | WeatherReportItemWhereInput[]
    id?: IntFilter<"WeatherReportItem"> | number
    createdAt?: DateTimeFilter<"WeatherReportItem"> | Date | string
    isDeleted?: BoolFilter<"WeatherReportItem"> | boolean
    projectId?: IntFilter<"WeatherReportItem"> | number
    date?: DateTimeFilter<"WeatherReportItem"> | Date | string
    time?: StringFilter<"WeatherReportItem"> | string
    f_scale?: StringNullableFilter<"WeatherReportItem"> | string | null
    speed?: StringNullableFilter<"WeatherReportItem"> | string | null
    size?: StringNullableFilter<"WeatherReportItem"> | string | null
    location?: StringFilter<"WeatherReportItem"> | string
    county?: StringFilter<"WeatherReportItem"> | string
    state?: StringFilter<"WeatherReportItem"> | string
    lat?: StringFilter<"WeatherReportItem"> | string
    lon?: StringFilter<"WeatherReportItem"> | string
    comments?: StringFilter<"WeatherReportItem"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type WeatherReportItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: WeatherReportItemOrderByRelevanceInput
  }

  export type WeatherReportItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WeatherReportItemWhereInput | WeatherReportItemWhereInput[]
    OR?: WeatherReportItemWhereInput[]
    NOT?: WeatherReportItemWhereInput | WeatherReportItemWhereInput[]
    createdAt?: DateTimeFilter<"WeatherReportItem"> | Date | string
    isDeleted?: BoolFilter<"WeatherReportItem"> | boolean
    projectId?: IntFilter<"WeatherReportItem"> | number
    date?: DateTimeFilter<"WeatherReportItem"> | Date | string
    time?: StringFilter<"WeatherReportItem"> | string
    f_scale?: StringNullableFilter<"WeatherReportItem"> | string | null
    speed?: StringNullableFilter<"WeatherReportItem"> | string | null
    size?: StringNullableFilter<"WeatherReportItem"> | string | null
    location?: StringFilter<"WeatherReportItem"> | string
    county?: StringFilter<"WeatherReportItem"> | string
    state?: StringFilter<"WeatherReportItem"> | string
    lat?: StringFilter<"WeatherReportItem"> | string
    lon?: StringFilter<"WeatherReportItem"> | string
    comments?: StringFilter<"WeatherReportItem"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type WeatherReportItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
    _count?: WeatherReportItemCountOrderByAggregateInput
    _avg?: WeatherReportItemAvgOrderByAggregateInput
    _max?: WeatherReportItemMaxOrderByAggregateInput
    _min?: WeatherReportItemMinOrderByAggregateInput
    _sum?: WeatherReportItemSumOrderByAggregateInput
  }

  export type WeatherReportItemScalarWhereWithAggregatesInput = {
    AND?: WeatherReportItemScalarWhereWithAggregatesInput | WeatherReportItemScalarWhereWithAggregatesInput[]
    OR?: WeatherReportItemScalarWhereWithAggregatesInput[]
    NOT?: WeatherReportItemScalarWhereWithAggregatesInput | WeatherReportItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WeatherReportItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WeatherReportItem"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"WeatherReportItem"> | boolean
    projectId?: IntWithAggregatesFilter<"WeatherReportItem"> | number
    date?: DateTimeWithAggregatesFilter<"WeatherReportItem"> | Date | string
    time?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    f_scale?: StringNullableWithAggregatesFilter<"WeatherReportItem"> | string | null
    speed?: StringNullableWithAggregatesFilter<"WeatherReportItem"> | string | null
    size?: StringNullableWithAggregatesFilter<"WeatherReportItem"> | string | null
    location?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    county?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    state?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    lat?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    lon?: StringWithAggregatesFilter<"WeatherReportItem"> | string
    comments?: StringWithAggregatesFilter<"WeatherReportItem"> | string
  }

  export type ProjectEquipmentWhereInput = {
    AND?: ProjectEquipmentWhereInput | ProjectEquipmentWhereInput[]
    OR?: ProjectEquipmentWhereInput[]
    NOT?: ProjectEquipmentWhereInput | ProjectEquipmentWhereInput[]
    id?: IntFilter<"ProjectEquipment"> | number
    publicId?: UuidFilter<"ProjectEquipment"> | string
    createdAt?: DateTimeFilter<"ProjectEquipment"> | Date | string
    isDeleted?: BoolFilter<"ProjectEquipment"> | boolean
    quantity?: IntFilter<"ProjectEquipment"> | number
    projectId?: IntFilter<"ProjectEquipment"> | number
    equipmentId?: IntFilter<"ProjectEquipment"> | number
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: ProjectEquipmentOrderByRelevanceInput
  }

  export type ProjectEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    equipmentId_projectId?: ProjectEquipmentEquipmentIdProjectIdCompoundUniqueInput
    AND?: ProjectEquipmentWhereInput | ProjectEquipmentWhereInput[]
    OR?: ProjectEquipmentWhereInput[]
    NOT?: ProjectEquipmentWhereInput | ProjectEquipmentWhereInput[]
    createdAt?: DateTimeFilter<"ProjectEquipment"> | Date | string
    isDeleted?: BoolFilter<"ProjectEquipment"> | boolean
    quantity?: IntFilter<"ProjectEquipment"> | number
    projectId?: IntFilter<"ProjectEquipment"> | number
    equipmentId?: IntFilter<"ProjectEquipment"> | number
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "publicId" | "equipmentId_projectId">

  export type ProjectEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
    _count?: ProjectEquipmentCountOrderByAggregateInput
    _avg?: ProjectEquipmentAvgOrderByAggregateInput
    _max?: ProjectEquipmentMaxOrderByAggregateInput
    _min?: ProjectEquipmentMinOrderByAggregateInput
    _sum?: ProjectEquipmentSumOrderByAggregateInput
  }

  export type ProjectEquipmentScalarWhereWithAggregatesInput = {
    AND?: ProjectEquipmentScalarWhereWithAggregatesInput | ProjectEquipmentScalarWhereWithAggregatesInput[]
    OR?: ProjectEquipmentScalarWhereWithAggregatesInput[]
    NOT?: ProjectEquipmentScalarWhereWithAggregatesInput | ProjectEquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectEquipment"> | number
    publicId?: UuidWithAggregatesFilter<"ProjectEquipment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectEquipment"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"ProjectEquipment"> | boolean
    quantity?: IntWithAggregatesFilter<"ProjectEquipment"> | number
    projectId?: IntWithAggregatesFilter<"ProjectEquipment"> | number
    equipmentId?: IntWithAggregatesFilter<"ProjectEquipment"> | number
  }

  export type CostWhereInput = {
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    id?: IntFilter<"Cost"> | number
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
    estimatedCost?: FloatNullableFilter<"Cost"> | number | null
    actualCost?: FloatNullableFilter<"Cost"> | number | null
    name?: StringNullableFilter<"Cost"> | string | null
    projectId?: IntFilter<"Cost"> | number
    isDeleted?: BoolFilter<"Cost"> | boolean
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type CostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: CostOrderByRelevanceInput
  }

  export type CostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
    estimatedCost?: FloatNullableFilter<"Cost"> | number | null
    actualCost?: FloatNullableFilter<"Cost"> | number | null
    name?: StringNullableFilter<"Cost"> | string | null
    projectId?: IntFilter<"Cost"> | number
    isDeleted?: BoolFilter<"Cost"> | boolean
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type CostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    _count?: CostCountOrderByAggregateInput
    _avg?: CostAvgOrderByAggregateInput
    _max?: CostMaxOrderByAggregateInput
    _min?: CostMinOrderByAggregateInput
    _sum?: CostSumOrderByAggregateInput
  }

  export type CostScalarWhereWithAggregatesInput = {
    AND?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    OR?: CostScalarWhereWithAggregatesInput[]
    NOT?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cost"> | Date | string
    estimatedCost?: FloatNullableWithAggregatesFilter<"Cost"> | number | null
    actualCost?: FloatNullableWithAggregatesFilter<"Cost"> | number | null
    name?: StringNullableWithAggregatesFilter<"Cost"> | string | null
    projectId?: IntWithAggregatesFilter<"Cost"> | number
    isDeleted?: BoolWithAggregatesFilter<"Cost"> | boolean
    type?: EnumCostTypeWithAggregatesFilter<"Cost"> | $Enums.CostType
  }

  export type PropertyDataWhereInput = {
    AND?: PropertyDataWhereInput | PropertyDataWhereInput[]
    OR?: PropertyDataWhereInput[]
    NOT?: PropertyDataWhereInput | PropertyDataWhereInput[]
    id?: IntFilter<"PropertyData"> | number
    createdAt?: DateTimeFilter<"PropertyData"> | Date | string
    projectId?: IntNullableFilter<"PropertyData"> | number | null
    bathrooms?: FloatNullableFilter<"PropertyData"> | number | null
    bedrooms?: IntNullableFilter<"PropertyData"> | number | null
    squareFootage?: IntNullableFilter<"PropertyData"> | number | null
    realtyMoleId?: StringNullableFilter<"PropertyData"> | string | null
    data?: JsonNullableFilter<"PropertyData">
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type PropertyDataOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    squareFootage?: SortOrderInput | SortOrder
    realtyMoleId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: PropertyDataOrderByRelevanceInput
  }

  export type PropertyDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: PropertyDataWhereInput | PropertyDataWhereInput[]
    OR?: PropertyDataWhereInput[]
    NOT?: PropertyDataWhereInput | PropertyDataWhereInput[]
    createdAt?: DateTimeFilter<"PropertyData"> | Date | string
    bathrooms?: FloatNullableFilter<"PropertyData"> | number | null
    bedrooms?: IntNullableFilter<"PropertyData"> | number | null
    squareFootage?: IntNullableFilter<"PropertyData"> | number | null
    realtyMoleId?: StringNullableFilter<"PropertyData"> | string | null
    data?: JsonNullableFilter<"PropertyData">
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "projectId">

  export type PropertyDataOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    squareFootage?: SortOrderInput | SortOrder
    realtyMoleId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: PropertyDataCountOrderByAggregateInput
    _avg?: PropertyDataAvgOrderByAggregateInput
    _max?: PropertyDataMaxOrderByAggregateInput
    _min?: PropertyDataMinOrderByAggregateInput
    _sum?: PropertyDataSumOrderByAggregateInput
  }

  export type PropertyDataScalarWhereWithAggregatesInput = {
    AND?: PropertyDataScalarWhereWithAggregatesInput | PropertyDataScalarWhereWithAggregatesInput[]
    OR?: PropertyDataScalarWhereWithAggregatesInput[]
    NOT?: PropertyDataScalarWhereWithAggregatesInput | PropertyDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PropertyData"> | Date | string
    projectId?: IntNullableWithAggregatesFilter<"PropertyData"> | number | null
    bathrooms?: FloatNullableWithAggregatesFilter<"PropertyData"> | number | null
    bedrooms?: IntNullableWithAggregatesFilter<"PropertyData"> | number | null
    squareFootage?: IntNullableWithAggregatesFilter<"PropertyData"> | number | null
    realtyMoleId?: StringNullableWithAggregatesFilter<"PropertyData"> | string | null
    data?: JsonNullableWithAggregatesFilter<"PropertyData">
  }

  export type DataDeletionRequestWhereInput = {
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    id?: IntFilter<"DataDeletionRequest"> | number
    createdAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    fullName?: StringFilter<"DataDeletionRequest"> | string
    email?: StringFilter<"DataDeletionRequest"> | string
    isVerified?: BoolFilter<"DataDeletionRequest"> | boolean
  }

  export type DataDeletionRequestOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    _relevance?: DataDeletionRequestOrderByRelevanceInput
  }

  export type DataDeletionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    createdAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    fullName?: StringFilter<"DataDeletionRequest"> | string
    isVerified?: BoolFilter<"DataDeletionRequest"> | boolean
  }, "id" | "email">

  export type DataDeletionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    _count?: DataDeletionRequestCountOrderByAggregateInput
    _avg?: DataDeletionRequestAvgOrderByAggregateInput
    _max?: DataDeletionRequestMaxOrderByAggregateInput
    _min?: DataDeletionRequestMinOrderByAggregateInput
    _sum?: DataDeletionRequestSumOrderByAggregateInput
  }

  export type DataDeletionRequestScalarWhereWithAggregatesInput = {
    AND?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    OR?: DataDeletionRequestScalarWhereWithAggregatesInput[]
    NOT?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataDeletionRequest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DataDeletionRequest"> | Date | string
    fullName?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    email?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    isVerified?: BoolWithAggregatesFilter<"DataDeletionRequest"> | boolean
  }

  export type PhotoAccessLinkWhereInput = {
    AND?: PhotoAccessLinkWhereInput | PhotoAccessLinkWhereInput[]
    OR?: PhotoAccessLinkWhereInput[]
    NOT?: PhotoAccessLinkWhereInput | PhotoAccessLinkWhereInput[]
    id?: IntFilter<"PhotoAccessLink"> | number
    createdAt?: DateTimeFilter<"PhotoAccessLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PhotoAccessLink"> | Date | string | null
    accessId?: StringFilter<"PhotoAccessLink"> | string
    email?: StringNullableFilter<"PhotoAccessLink"> | string | null
    phoneNumber?: StringNullableFilter<"PhotoAccessLink"> | string | null
    projectId?: IntFilter<"PhotoAccessLink"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type PhotoAccessLinkOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accessId?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: PhotoAccessLinkOrderByRelevanceInput
  }

  export type PhotoAccessLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    accessId?: string
    AND?: PhotoAccessLinkWhereInput | PhotoAccessLinkWhereInput[]
    OR?: PhotoAccessLinkWhereInput[]
    NOT?: PhotoAccessLinkWhereInput | PhotoAccessLinkWhereInput[]
    createdAt?: DateTimeFilter<"PhotoAccessLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PhotoAccessLink"> | Date | string | null
    email?: StringNullableFilter<"PhotoAccessLink"> | string | null
    phoneNumber?: StringNullableFilter<"PhotoAccessLink"> | string | null
    projectId?: IntFilter<"PhotoAccessLink"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "accessId">

  export type PhotoAccessLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accessId?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: PhotoAccessLinkCountOrderByAggregateInput
    _avg?: PhotoAccessLinkAvgOrderByAggregateInput
    _max?: PhotoAccessLinkMaxOrderByAggregateInput
    _min?: PhotoAccessLinkMinOrderByAggregateInput
    _sum?: PhotoAccessLinkSumOrderByAggregateInput
  }

  export type PhotoAccessLinkScalarWhereWithAggregatesInput = {
    AND?: PhotoAccessLinkScalarWhereWithAggregatesInput | PhotoAccessLinkScalarWhereWithAggregatesInput[]
    OR?: PhotoAccessLinkScalarWhereWithAggregatesInput[]
    NOT?: PhotoAccessLinkScalarWhereWithAggregatesInput | PhotoAccessLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PhotoAccessLink"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PhotoAccessLink"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PhotoAccessLink"> | Date | string | null
    accessId?: StringWithAggregatesFilter<"PhotoAccessLink"> | string
    email?: StringNullableWithAggregatesFilter<"PhotoAccessLink"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"PhotoAccessLink"> | string | null
    projectId?: IntWithAggregatesFilter<"PhotoAccessLink"> | number
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    createdAt?: DateTimeFilter<"Image"> | Date | string
    isDeleted?: BoolFilter<"Image"> | boolean
    publicId?: StringFilter<"Image"> | string
    key?: StringFilter<"Image"> | string
    projectId?: IntFilter<"Image"> | number
    organizationId?: IntNullableFilter<"Image"> | number | null
    includeInReport?: BoolFilter<"Image"> | boolean
    description?: StringNullableFilter<"Image"> | string | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    inference?: XOR<InferenceNullableScalarRelationFilter, InferenceWhereInput> | null
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    includeInReport?: SortOrder
    description?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    inference?: InferenceOrderByWithRelationInput
    ImageNote?: ImageNoteOrderByRelationAggregateInput
    Annotation?: AnnotationOrderByRelationAggregateInput
    _relevance?: ImageOrderByRelevanceInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    key?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    createdAt?: DateTimeFilter<"Image"> | Date | string
    isDeleted?: BoolFilter<"Image"> | boolean
    projectId?: IntFilter<"Image"> | number
    organizationId?: IntNullableFilter<"Image"> | number | null
    includeInReport?: BoolFilter<"Image"> | boolean
    description?: StringNullableFilter<"Image"> | string | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    inference?: XOR<InferenceNullableScalarRelationFilter, InferenceWhereInput> | null
    ImageNote?: ImageNoteListRelationFilter
    Annotation?: AnnotationListRelationFilter
  }, "id" | "publicId" | "key">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    includeInReport?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Image"> | boolean
    publicId?: StringWithAggregatesFilter<"Image"> | string
    key?: StringWithAggregatesFilter<"Image"> | string
    projectId?: IntWithAggregatesFilter<"Image"> | number
    organizationId?: IntNullableWithAggregatesFilter<"Image"> | number | null
    includeInReport?: BoolWithAggregatesFilter<"Image"> | boolean
    description?: StringNullableWithAggregatesFilter<"Image"> | string | null
  }

  export type AnnotationWhereInput = {
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    id?: IntFilter<"Annotation"> | number
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    updatedAt?: DateTimeFilter<"Annotation"> | Date | string
    imageId?: IntFilter<"Annotation"> | number
    coordinates?: JsonFilter<"Annotation">
    userId?: StringFilter<"Annotation"> | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
    Image?: XOR<ImageScalarRelationFilter, ImageWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnotationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    Image?: ImageOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: AnnotationOrderByRelevanceInput
  }

  export type AnnotationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    updatedAt?: DateTimeFilter<"Annotation"> | Date | string
    imageId?: IntFilter<"Annotation"> | number
    coordinates?: JsonFilter<"Annotation">
    userId?: StringFilter<"Annotation"> | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
    Image?: XOR<ImageScalarRelationFilter, ImageWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    _count?: AnnotationCountOrderByAggregateInput
    _avg?: AnnotationAvgOrderByAggregateInput
    _max?: AnnotationMaxOrderByAggregateInput
    _min?: AnnotationMinOrderByAggregateInput
    _sum?: AnnotationSumOrderByAggregateInput
  }

  export type AnnotationScalarWhereWithAggregatesInput = {
    AND?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    OR?: AnnotationScalarWhereWithAggregatesInput[]
    NOT?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Annotation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Annotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Annotation"> | Date | string
    imageId?: IntWithAggregatesFilter<"Annotation"> | number
    coordinates?: JsonWithAggregatesFilter<"Annotation">
    userId?: StringWithAggregatesFilter<"Annotation"> | string
    isDeleted?: BoolWithAggregatesFilter<"Annotation"> | boolean
  }

  export type ImageNoteWhereInput = {
    AND?: ImageNoteWhereInput | ImageNoteWhereInput[]
    OR?: ImageNoteWhereInput[]
    NOT?: ImageNoteWhereInput | ImageNoteWhereInput[]
    id?: IntFilter<"ImageNote"> | number
    createdAt?: DateTimeFilter<"ImageNote"> | Date | string
    updatedAt?: DateTimeFilter<"ImageNote"> | Date | string
    imageId?: IntFilter<"ImageNote"> | number
    body?: StringFilter<"ImageNote"> | string
    mentions?: StringNullableListFilter<"ImageNote">
    userId?: StringFilter<"ImageNote"> | string
    isDeleted?: BoolFilter<"ImageNote"> | boolean
    Image?: XOR<ImageScalarRelationFilter, ImageWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ImageNoteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    Image?: ImageOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: ImageNoteOrderByRelevanceInput
  }

  export type ImageNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImageNoteWhereInput | ImageNoteWhereInput[]
    OR?: ImageNoteWhereInput[]
    NOT?: ImageNoteWhereInput | ImageNoteWhereInput[]
    createdAt?: DateTimeFilter<"ImageNote"> | Date | string
    updatedAt?: DateTimeFilter<"ImageNote"> | Date | string
    imageId?: IntFilter<"ImageNote"> | number
    body?: StringFilter<"ImageNote"> | string
    mentions?: StringNullableListFilter<"ImageNote">
    userId?: StringFilter<"ImageNote"> | string
    isDeleted?: BoolFilter<"ImageNote"> | boolean
    Image?: XOR<ImageScalarRelationFilter, ImageWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ImageNoteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    _count?: ImageNoteCountOrderByAggregateInput
    _avg?: ImageNoteAvgOrderByAggregateInput
    _max?: ImageNoteMaxOrderByAggregateInput
    _min?: ImageNoteMinOrderByAggregateInput
    _sum?: ImageNoteSumOrderByAggregateInput
  }

  export type ImageNoteScalarWhereWithAggregatesInput = {
    AND?: ImageNoteScalarWhereWithAggregatesInput | ImageNoteScalarWhereWithAggregatesInput[]
    OR?: ImageNoteScalarWhereWithAggregatesInput[]
    NOT?: ImageNoteScalarWhereWithAggregatesInput | ImageNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ImageNote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ImageNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImageNote"> | Date | string
    imageId?: IntWithAggregatesFilter<"ImageNote"> | number
    body?: StringWithAggregatesFilter<"ImageNote"> | string
    mentions?: StringNullableListFilter<"ImageNote">
    userId?: StringWithAggregatesFilter<"ImageNote"> | string
    isDeleted?: BoolWithAggregatesFilter<"ImageNote"> | boolean
  }

  export type InferenceWhereInput = {
    AND?: InferenceWhereInput | InferenceWhereInput[]
    OR?: InferenceWhereInput[]
    NOT?: InferenceWhereInput | InferenceWhereInput[]
    id?: IntFilter<"Inference"> | number
    createdAt?: DateTimeFilter<"Inference"> | Date | string
    isDeleted?: BoolFilter<"Inference"> | boolean
    publicId?: StringFilter<"Inference"> | string
    imageId?: IntNullableFilter<"Inference"> | number | null
    imageKey?: StringNullableFilter<"Inference"> | string | null
    projectId?: IntFilter<"Inference"> | number
    roomId?: IntNullableFilter<"Inference"> | number | null
    image?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    detections?: DetectionListRelationFilter
  }

  export type InferenceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrderInput | SortOrder
    imageKey?: SortOrderInput | SortOrder
    projectId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    image?: ImageOrderByWithRelationInput
    Project?: ProjectOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    detections?: DetectionOrderByRelationAggregateInput
    _relevance?: InferenceOrderByRelevanceInput
  }

  export type InferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    imageId?: number
    imageKey?: string
    AND?: InferenceWhereInput | InferenceWhereInput[]
    OR?: InferenceWhereInput[]
    NOT?: InferenceWhereInput | InferenceWhereInput[]
    createdAt?: DateTimeFilter<"Inference"> | Date | string
    isDeleted?: BoolFilter<"Inference"> | boolean
    projectId?: IntFilter<"Inference"> | number
    roomId?: IntNullableFilter<"Inference"> | number | null
    image?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
    detections?: DetectionListRelationFilter
  }, "id" | "publicId" | "imageId" | "imageKey">

  export type InferenceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrderInput | SortOrder
    imageKey?: SortOrderInput | SortOrder
    projectId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    _count?: InferenceCountOrderByAggregateInput
    _avg?: InferenceAvgOrderByAggregateInput
    _max?: InferenceMaxOrderByAggregateInput
    _min?: InferenceMinOrderByAggregateInput
    _sum?: InferenceSumOrderByAggregateInput
  }

  export type InferenceScalarWhereWithAggregatesInput = {
    AND?: InferenceScalarWhereWithAggregatesInput | InferenceScalarWhereWithAggregatesInput[]
    OR?: InferenceScalarWhereWithAggregatesInput[]
    NOT?: InferenceScalarWhereWithAggregatesInput | InferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inference"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inference"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Inference"> | boolean
    publicId?: StringWithAggregatesFilter<"Inference"> | string
    imageId?: IntNullableWithAggregatesFilter<"Inference"> | number | null
    imageKey?: StringNullableWithAggregatesFilter<"Inference"> | string | null
    projectId?: IntWithAggregatesFilter<"Inference"> | number
    roomId?: IntNullableWithAggregatesFilter<"Inference"> | number | null
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    createdAt?: DateTimeFilter<"Room"> | Date | string
    isDeleted?: BoolFilter<"Room"> | boolean
    publicId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    projectId?: IntFilter<"Room"> | number
    gpp?: StringNullableFilter<"Room"> | string | null
    humidity?: StringNullableFilter<"Room"> | string | null
    dehuReading?: StringNullableFilter<"Room"> | string | null
    temperature?: StringNullableFilter<"Room"> | string | null
    length?: StringNullableFilter<"Room"> | string | null
    width?: StringNullableFilter<"Room"> | string | null
    height?: StringNullableFilter<"Room"> | string | null
    totalSqft?: StringNullableFilter<"Room"> | string | null
    windows?: IntNullableFilter<"Room"> | number | null
    doors?: IntNullableFilter<"Room"> | number | null
    equipmentUsed?: StringNullableListFilter<"Room">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    detections?: DetectionListRelationFilter
    inferences?: InferenceListRelationFilter
    templates?: TemplatesUsedListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    areasAffected?: AreaAffectedListRelationFilter
    notes?: NotesListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    dehuReading?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    totalSqft?: SortOrderInput | SortOrder
    windows?: SortOrderInput | SortOrder
    doors?: SortOrderInput | SortOrder
    equipmentUsed?: SortOrder
    project?: ProjectOrderByWithRelationInput
    detections?: DetectionOrderByRelationAggregateInput
    inferences?: InferenceOrderByRelationAggregateInput
    templates?: TemplatesUsedOrderByRelationAggregateInput
    roomReadings?: RoomReadingOrderByRelationAggregateInput
    areasAffected?: AreaAffectedOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    _relevance?: RoomOrderByRelevanceInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    projectId_name?: RoomProjectIdNameCompoundUniqueInput
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    createdAt?: DateTimeFilter<"Room"> | Date | string
    isDeleted?: BoolFilter<"Room"> | boolean
    name?: StringFilter<"Room"> | string
    projectId?: IntFilter<"Room"> | number
    gpp?: StringNullableFilter<"Room"> | string | null
    humidity?: StringNullableFilter<"Room"> | string | null
    dehuReading?: StringNullableFilter<"Room"> | string | null
    temperature?: StringNullableFilter<"Room"> | string | null
    length?: StringNullableFilter<"Room"> | string | null
    width?: StringNullableFilter<"Room"> | string | null
    height?: StringNullableFilter<"Room"> | string | null
    totalSqft?: StringNullableFilter<"Room"> | string | null
    windows?: IntNullableFilter<"Room"> | number | null
    doors?: IntNullableFilter<"Room"> | number | null
    equipmentUsed?: StringNullableListFilter<"Room">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    detections?: DetectionListRelationFilter
    inferences?: InferenceListRelationFilter
    templates?: TemplatesUsedListRelationFilter
    roomReadings?: RoomReadingListRelationFilter
    areasAffected?: AreaAffectedListRelationFilter
    notes?: NotesListRelationFilter
  }, "id" | "publicId" | "projectId_name">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    dehuReading?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    totalSqft?: SortOrderInput | SortOrder
    windows?: SortOrderInput | SortOrder
    doors?: SortOrderInput | SortOrder
    equipmentUsed?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Room"> | boolean
    publicId?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    projectId?: IntWithAggregatesFilter<"Room"> | number
    gpp?: StringNullableWithAggregatesFilter<"Room"> | string | null
    humidity?: StringNullableWithAggregatesFilter<"Room"> | string | null
    dehuReading?: StringNullableWithAggregatesFilter<"Room"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"Room"> | string | null
    length?: StringNullableWithAggregatesFilter<"Room"> | string | null
    width?: StringNullableWithAggregatesFilter<"Room"> | string | null
    height?: StringNullableWithAggregatesFilter<"Room"> | string | null
    totalSqft?: StringNullableWithAggregatesFilter<"Room"> | string | null
    windows?: IntNullableWithAggregatesFilter<"Room"> | number | null
    doors?: IntNullableWithAggregatesFilter<"Room"> | number | null
    equipmentUsed?: StringNullableListFilter<"Room">
  }

  export type RoomReadingWhereInput = {
    AND?: RoomReadingWhereInput | RoomReadingWhereInput[]
    OR?: RoomReadingWhereInput[]
    NOT?: RoomReadingWhereInput | RoomReadingWhereInput[]
    id?: IntFilter<"RoomReading"> | number
    createdAt?: DateTimeFilter<"RoomReading"> | Date | string
    date?: DateTimeFilter<"RoomReading"> | Date | string
    humidity?: StringNullableFilter<"RoomReading"> | string | null
    temperature?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentWall?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentFloor?: StringNullableFilter<"RoomReading"> | string | null
    equipmentUsed?: StringNullableListFilter<"RoomReading">
    roomId?: IntFilter<"RoomReading"> | number
    isDeleted?: BoolFilter<"RoomReading"> | boolean
    publicId?: StringFilter<"RoomReading"> | string
    projectId?: IntFilter<"RoomReading"> | number
    gpp?: StringNullableFilter<"RoomReading"> | string | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    genericRoomReadings?: GenericRoomReadingListRelationFilter
  }

  export type RoomReadingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    moistureContentWall?: SortOrderInput | SortOrder
    moistureContentFloor?: SortOrderInput | SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrderInput | SortOrder
    room?: RoomOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    genericRoomReadings?: GenericRoomReadingOrderByRelationAggregateInput
    _relevance?: RoomReadingOrderByRelevanceInput
  }

  export type RoomReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomReadingWhereInput | RoomReadingWhereInput[]
    OR?: RoomReadingWhereInput[]
    NOT?: RoomReadingWhereInput | RoomReadingWhereInput[]
    createdAt?: DateTimeFilter<"RoomReading"> | Date | string
    date?: DateTimeFilter<"RoomReading"> | Date | string
    humidity?: StringNullableFilter<"RoomReading"> | string | null
    temperature?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentWall?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentFloor?: StringNullableFilter<"RoomReading"> | string | null
    equipmentUsed?: StringNullableListFilter<"RoomReading">
    roomId?: IntFilter<"RoomReading"> | number
    isDeleted?: BoolFilter<"RoomReading"> | boolean
    publicId?: StringFilter<"RoomReading"> | string
    projectId?: IntFilter<"RoomReading"> | number
    gpp?: StringNullableFilter<"RoomReading"> | string | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    genericRoomReadings?: GenericRoomReadingListRelationFilter
  }, "id">

  export type RoomReadingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    moistureContentWall?: SortOrderInput | SortOrder
    moistureContentFloor?: SortOrderInput | SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrderInput | SortOrder
    _count?: RoomReadingCountOrderByAggregateInput
    _avg?: RoomReadingAvgOrderByAggregateInput
    _max?: RoomReadingMaxOrderByAggregateInput
    _min?: RoomReadingMinOrderByAggregateInput
    _sum?: RoomReadingSumOrderByAggregateInput
  }

  export type RoomReadingScalarWhereWithAggregatesInput = {
    AND?: RoomReadingScalarWhereWithAggregatesInput | RoomReadingScalarWhereWithAggregatesInput[]
    OR?: RoomReadingScalarWhereWithAggregatesInput[]
    NOT?: RoomReadingScalarWhereWithAggregatesInput | RoomReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomReading"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoomReading"> | Date | string
    date?: DateTimeWithAggregatesFilter<"RoomReading"> | Date | string
    humidity?: StringNullableWithAggregatesFilter<"RoomReading"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"RoomReading"> | string | null
    moistureContentWall?: StringNullableWithAggregatesFilter<"RoomReading"> | string | null
    moistureContentFloor?: StringNullableWithAggregatesFilter<"RoomReading"> | string | null
    equipmentUsed?: StringNullableListFilter<"RoomReading">
    roomId?: IntWithAggregatesFilter<"RoomReading"> | number
    isDeleted?: BoolWithAggregatesFilter<"RoomReading"> | boolean
    publicId?: StringWithAggregatesFilter<"RoomReading"> | string
    projectId?: IntWithAggregatesFilter<"RoomReading"> | number
    gpp?: StringNullableWithAggregatesFilter<"RoomReading"> | string | null
  }

  export type NotesWhereInput = {
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    id?: IntFilter<"Notes"> | number
    createdAt?: DateTimeFilter<"Notes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Notes"> | Date | string | null
    date?: DateTimeFilter<"Notes"> | Date | string
    roomId?: IntFilter<"Notes"> | number
    isDeleted?: BoolFilter<"Notes"> | boolean
    publicId?: StringFilter<"Notes"> | string
    projectId?: IntFilter<"Notes"> | number
    body?: StringFilter<"Notes"> | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    notesAuditTrail?: NotesAuditTrailListRelationFilter
  }

  export type NotesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    room?: RoomOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    notesAuditTrail?: NotesAuditTrailOrderByRelationAggregateInput
    _relevance?: NotesOrderByRelevanceInput
  }

  export type NotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    createdAt?: DateTimeFilter<"Notes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Notes"> | Date | string | null
    date?: DateTimeFilter<"Notes"> | Date | string
    roomId?: IntFilter<"Notes"> | number
    isDeleted?: BoolFilter<"Notes"> | boolean
    publicId?: StringFilter<"Notes"> | string
    projectId?: IntFilter<"Notes"> | number
    body?: StringFilter<"Notes"> | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    notesAuditTrail?: NotesAuditTrailListRelationFilter
  }, "id">

  export type NotesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    _count?: NotesCountOrderByAggregateInput
    _avg?: NotesAvgOrderByAggregateInput
    _max?: NotesMaxOrderByAggregateInput
    _min?: NotesMinOrderByAggregateInput
    _sum?: NotesSumOrderByAggregateInput
  }

  export type NotesScalarWhereWithAggregatesInput = {
    AND?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    OR?: NotesScalarWhereWithAggregatesInput[]
    NOT?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notes"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Notes"> | Date | string | null
    date?: DateTimeWithAggregatesFilter<"Notes"> | Date | string
    roomId?: IntWithAggregatesFilter<"Notes"> | number
    isDeleted?: BoolWithAggregatesFilter<"Notes"> | boolean
    publicId?: StringWithAggregatesFilter<"Notes"> | string
    projectId?: IntWithAggregatesFilter<"Notes"> | number
    body?: StringWithAggregatesFilter<"Notes"> | string
  }

  export type NotesAuditTrailWhereInput = {
    AND?: NotesAuditTrailWhereInput | NotesAuditTrailWhereInput[]
    OR?: NotesAuditTrailWhereInput[]
    NOT?: NotesAuditTrailWhereInput | NotesAuditTrailWhereInput[]
    id?: IntFilter<"NotesAuditTrail"> | number
    createdAt?: DateTimeFilter<"NotesAuditTrail"> | Date | string
    notesId?: IntFilter<"NotesAuditTrail"> | number
    userId?: StringFilter<"NotesAuditTrail"> | string
    userName?: StringNullableFilter<"NotesAuditTrail"> | string | null
    action?: EnumNotesAuditActionFilter<"NotesAuditTrail"> | $Enums.NotesAuditAction
    body?: StringFilter<"NotesAuditTrail"> | string
    note?: XOR<NotesScalarRelationFilter, NotesWhereInput>
  }

  export type NotesAuditTrailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    body?: SortOrder
    note?: NotesOrderByWithRelationInput
    _relevance?: NotesAuditTrailOrderByRelevanceInput
  }

  export type NotesAuditTrailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotesAuditTrailWhereInput | NotesAuditTrailWhereInput[]
    OR?: NotesAuditTrailWhereInput[]
    NOT?: NotesAuditTrailWhereInput | NotesAuditTrailWhereInput[]
    createdAt?: DateTimeFilter<"NotesAuditTrail"> | Date | string
    notesId?: IntFilter<"NotesAuditTrail"> | number
    userId?: StringFilter<"NotesAuditTrail"> | string
    userName?: StringNullableFilter<"NotesAuditTrail"> | string | null
    action?: EnumNotesAuditActionFilter<"NotesAuditTrail"> | $Enums.NotesAuditAction
    body?: StringFilter<"NotesAuditTrail"> | string
    note?: XOR<NotesScalarRelationFilter, NotesWhereInput>
  }, "id">

  export type NotesAuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    body?: SortOrder
    _count?: NotesAuditTrailCountOrderByAggregateInput
    _avg?: NotesAuditTrailAvgOrderByAggregateInput
    _max?: NotesAuditTrailMaxOrderByAggregateInput
    _min?: NotesAuditTrailMinOrderByAggregateInput
    _sum?: NotesAuditTrailSumOrderByAggregateInput
  }

  export type NotesAuditTrailScalarWhereWithAggregatesInput = {
    AND?: NotesAuditTrailScalarWhereWithAggregatesInput | NotesAuditTrailScalarWhereWithAggregatesInput[]
    OR?: NotesAuditTrailScalarWhereWithAggregatesInput[]
    NOT?: NotesAuditTrailScalarWhereWithAggregatesInput | NotesAuditTrailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotesAuditTrail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NotesAuditTrail"> | Date | string
    notesId?: IntWithAggregatesFilter<"NotesAuditTrail"> | number
    userId?: StringWithAggregatesFilter<"NotesAuditTrail"> | string
    userName?: StringNullableWithAggregatesFilter<"NotesAuditTrail"> | string | null
    action?: EnumNotesAuditActionWithAggregatesFilter<"NotesAuditTrail"> | $Enums.NotesAuditAction
    body?: StringWithAggregatesFilter<"NotesAuditTrail"> | string
  }

  export type AreaAffectedWhereInput = {
    AND?: AreaAffectedWhereInput | AreaAffectedWhereInput[]
    OR?: AreaAffectedWhereInput[]
    NOT?: AreaAffectedWhereInput | AreaAffectedWhereInput[]
    id?: IntFilter<"AreaAffected"> | number
    createdAt?: DateTimeFilter<"AreaAffected"> | Date | string
    date?: DateTimeFilter<"AreaAffected"> | Date | string
    roomId?: IntFilter<"AreaAffected"> | number
    material?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaMicrobialApplied?: StringNullableFilter<"AreaAffected"> | string | null
    cause?: StringNullableFilter<"AreaAffected"> | string | null
    category?: IntNullableFilter<"AreaAffected"> | number | null
    cabinetryRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    isDeleted?: BoolFilter<"AreaAffected"> | boolean
    publicId?: StringFilter<"AreaAffected"> | string
    projectId?: IntFilter<"AreaAffected"> | number
    type?: EnumAreaAffectedTypeFilter<"AreaAffected"> | $Enums.AreaAffectedType
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type AreaAffectedOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrderInput | SortOrder
    totalAreaRemoved?: SortOrderInput | SortOrder
    totalAreaMicrobialApplied?: SortOrderInput | SortOrder
    cause?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    cabinetryRemoved?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    room?: RoomOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: AreaAffectedOrderByRelevanceInput
  }

  export type AreaAffectedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type_roomId?: AreaAffectedTypeRoomIdCompoundUniqueInput
    AND?: AreaAffectedWhereInput | AreaAffectedWhereInput[]
    OR?: AreaAffectedWhereInput[]
    NOT?: AreaAffectedWhereInput | AreaAffectedWhereInput[]
    createdAt?: DateTimeFilter<"AreaAffected"> | Date | string
    date?: DateTimeFilter<"AreaAffected"> | Date | string
    roomId?: IntFilter<"AreaAffected"> | number
    material?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaMicrobialApplied?: StringNullableFilter<"AreaAffected"> | string | null
    cause?: StringNullableFilter<"AreaAffected"> | string | null
    category?: IntNullableFilter<"AreaAffected"> | number | null
    cabinetryRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    isDeleted?: BoolFilter<"AreaAffected"> | boolean
    publicId?: StringFilter<"AreaAffected"> | string
    projectId?: IntFilter<"AreaAffected"> | number
    type?: EnumAreaAffectedTypeFilter<"AreaAffected"> | $Enums.AreaAffectedType
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "type_roomId">

  export type AreaAffectedOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrderInput | SortOrder
    totalAreaRemoved?: SortOrderInput | SortOrder
    totalAreaMicrobialApplied?: SortOrderInput | SortOrder
    cause?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    cabinetryRemoved?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    _count?: AreaAffectedCountOrderByAggregateInput
    _avg?: AreaAffectedAvgOrderByAggregateInput
    _max?: AreaAffectedMaxOrderByAggregateInput
    _min?: AreaAffectedMinOrderByAggregateInput
    _sum?: AreaAffectedSumOrderByAggregateInput
  }

  export type AreaAffectedScalarWhereWithAggregatesInput = {
    AND?: AreaAffectedScalarWhereWithAggregatesInput | AreaAffectedScalarWhereWithAggregatesInput[]
    OR?: AreaAffectedScalarWhereWithAggregatesInput[]
    NOT?: AreaAffectedScalarWhereWithAggregatesInput | AreaAffectedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AreaAffected"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AreaAffected"> | Date | string
    date?: DateTimeWithAggregatesFilter<"AreaAffected"> | Date | string
    roomId?: IntWithAggregatesFilter<"AreaAffected"> | number
    material?: StringNullableWithAggregatesFilter<"AreaAffected"> | string | null
    totalAreaRemoved?: StringNullableWithAggregatesFilter<"AreaAffected"> | string | null
    totalAreaMicrobialApplied?: StringNullableWithAggregatesFilter<"AreaAffected"> | string | null
    cause?: StringNullableWithAggregatesFilter<"AreaAffected"> | string | null
    category?: IntNullableWithAggregatesFilter<"AreaAffected"> | number | null
    cabinetryRemoved?: StringNullableWithAggregatesFilter<"AreaAffected"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"AreaAffected"> | boolean
    publicId?: StringWithAggregatesFilter<"AreaAffected"> | string
    projectId?: IntWithAggregatesFilter<"AreaAffected"> | number
    type?: EnumAreaAffectedTypeWithAggregatesFilter<"AreaAffected"> | $Enums.AreaAffectedType
  }

  export type GenericRoomReadingWhereInput = {
    AND?: GenericRoomReadingWhereInput | GenericRoomReadingWhereInput[]
    OR?: GenericRoomReadingWhereInput[]
    NOT?: GenericRoomReadingWhereInput | GenericRoomReadingWhereInput[]
    id?: IntFilter<"GenericRoomReading"> | number
    createdAt?: DateTimeFilter<"GenericRoomReading"> | Date | string
    publicId?: StringFilter<"GenericRoomReading"> | string
    type?: EnumRoomReadingTypeFilter<"GenericRoomReading"> | $Enums.RoomReadingType
    value?: StringFilter<"GenericRoomReading"> | string
    humidity?: StringNullableFilter<"GenericRoomReading"> | string | null
    temperature?: StringNullableFilter<"GenericRoomReading"> | string | null
    gpp?: StringNullableFilter<"GenericRoomReading"> | string | null
    roomReadingId?: IntFilter<"GenericRoomReading"> | number
    isDeleted?: BoolFilter<"GenericRoomReading"> | boolean
    roomReading?: XOR<RoomReadingScalarRelationFilter, RoomReadingWhereInput>
  }

  export type GenericRoomReadingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    gpp?: SortOrderInput | SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
    roomReading?: RoomReadingOrderByWithRelationInput
    _relevance?: GenericRoomReadingOrderByRelevanceInput
  }

  export type GenericRoomReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GenericRoomReadingWhereInput | GenericRoomReadingWhereInput[]
    OR?: GenericRoomReadingWhereInput[]
    NOT?: GenericRoomReadingWhereInput | GenericRoomReadingWhereInput[]
    createdAt?: DateTimeFilter<"GenericRoomReading"> | Date | string
    publicId?: StringFilter<"GenericRoomReading"> | string
    type?: EnumRoomReadingTypeFilter<"GenericRoomReading"> | $Enums.RoomReadingType
    value?: StringFilter<"GenericRoomReading"> | string
    humidity?: StringNullableFilter<"GenericRoomReading"> | string | null
    temperature?: StringNullableFilter<"GenericRoomReading"> | string | null
    gpp?: StringNullableFilter<"GenericRoomReading"> | string | null
    roomReadingId?: IntFilter<"GenericRoomReading"> | number
    isDeleted?: BoolFilter<"GenericRoomReading"> | boolean
    roomReading?: XOR<RoomReadingScalarRelationFilter, RoomReadingWhereInput>
  }, "id">

  export type GenericRoomReadingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    gpp?: SortOrderInput | SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
    _count?: GenericRoomReadingCountOrderByAggregateInput
    _avg?: GenericRoomReadingAvgOrderByAggregateInput
    _max?: GenericRoomReadingMaxOrderByAggregateInput
    _min?: GenericRoomReadingMinOrderByAggregateInput
    _sum?: GenericRoomReadingSumOrderByAggregateInput
  }

  export type GenericRoomReadingScalarWhereWithAggregatesInput = {
    AND?: GenericRoomReadingScalarWhereWithAggregatesInput | GenericRoomReadingScalarWhereWithAggregatesInput[]
    OR?: GenericRoomReadingScalarWhereWithAggregatesInput[]
    NOT?: GenericRoomReadingScalarWhereWithAggregatesInput | GenericRoomReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GenericRoomReading"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GenericRoomReading"> | Date | string
    publicId?: StringWithAggregatesFilter<"GenericRoomReading"> | string
    type?: EnumRoomReadingTypeWithAggregatesFilter<"GenericRoomReading"> | $Enums.RoomReadingType
    value?: StringWithAggregatesFilter<"GenericRoomReading"> | string
    humidity?: StringNullableWithAggregatesFilter<"GenericRoomReading"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"GenericRoomReading"> | string | null
    gpp?: StringNullableWithAggregatesFilter<"GenericRoomReading"> | string | null
    roomReadingId?: IntWithAggregatesFilter<"GenericRoomReading"> | number
    isDeleted?: BoolWithAggregatesFilter<"GenericRoomReading"> | boolean
  }

  export type DetectionWhereInput = {
    AND?: DetectionWhereInput | DetectionWhereInput[]
    OR?: DetectionWhereInput[]
    NOT?: DetectionWhereInput | DetectionWhereInput[]
    id?: IntFilter<"Detection"> | number
    createdAt?: DateTimeFilter<"Detection"> | Date | string
    isDeleted?: BoolFilter<"Detection"> | boolean
    publicId?: StringFilter<"Detection"> | string
    inferenceId?: IntFilter<"Detection"> | number
    imageKey?: StringNullableFilter<"Detection"> | string | null
    xMinCord?: FloatNullableFilter<"Detection"> | number | null
    yMinCord?: FloatNullableFilter<"Detection"> | number | null
    confidence?: FloatNullableFilter<"Detection"> | number | null
    xMaxCord?: FloatNullableFilter<"Detection"> | number | null
    yMaxCord?: FloatNullableFilter<"Detection"> | number | null
    projectId?: IntFilter<"Detection"> | number
    category?: StringFilter<"Detection"> | string
    code?: StringFilter<"Detection"> | string
    item?: StringFilter<"Detection"> | string
    quality?: StringFilter<"Detection"> | string
    roomId?: IntNullableFilter<"Detection"> | number | null
    dimension?: IntNullableFilter<"Detection"> | number | null
    unit?: EnumDimensionUnitNullableFilter<"Detection"> | $Enums.DimensionUnit | null
    inference?: XOR<InferenceScalarRelationFilter, InferenceWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
  }

  export type DetectionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrderInput | SortOrder
    xMinCord?: SortOrderInput | SortOrder
    yMinCord?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    xMaxCord?: SortOrderInput | SortOrder
    yMaxCord?: SortOrderInput | SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrderInput | SortOrder
    dimension?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    inference?: InferenceOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    _relevance?: DetectionOrderByRelevanceInput
  }

  export type DetectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    projectId_category_code_roomId?: DetectionProjectIdCategoryCodeRoomIdCompoundUniqueInput
    AND?: DetectionWhereInput | DetectionWhereInput[]
    OR?: DetectionWhereInput[]
    NOT?: DetectionWhereInput | DetectionWhereInput[]
    createdAt?: DateTimeFilter<"Detection"> | Date | string
    isDeleted?: BoolFilter<"Detection"> | boolean
    inferenceId?: IntFilter<"Detection"> | number
    imageKey?: StringNullableFilter<"Detection"> | string | null
    xMinCord?: FloatNullableFilter<"Detection"> | number | null
    yMinCord?: FloatNullableFilter<"Detection"> | number | null
    confidence?: FloatNullableFilter<"Detection"> | number | null
    xMaxCord?: FloatNullableFilter<"Detection"> | number | null
    yMaxCord?: FloatNullableFilter<"Detection"> | number | null
    projectId?: IntFilter<"Detection"> | number
    category?: StringFilter<"Detection"> | string
    code?: StringFilter<"Detection"> | string
    item?: StringFilter<"Detection"> | string
    quality?: StringFilter<"Detection"> | string
    roomId?: IntNullableFilter<"Detection"> | number | null
    dimension?: IntNullableFilter<"Detection"> | number | null
    unit?: EnumDimensionUnitNullableFilter<"Detection"> | $Enums.DimensionUnit | null
    inference?: XOR<InferenceScalarRelationFilter, InferenceWhereInput>
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
  }, "id" | "publicId" | "projectId_category_code_roomId">

  export type DetectionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrderInput | SortOrder
    xMinCord?: SortOrderInput | SortOrder
    yMinCord?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    xMaxCord?: SortOrderInput | SortOrder
    yMaxCord?: SortOrderInput | SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrderInput | SortOrder
    dimension?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: DetectionCountOrderByAggregateInput
    _avg?: DetectionAvgOrderByAggregateInput
    _max?: DetectionMaxOrderByAggregateInput
    _min?: DetectionMinOrderByAggregateInput
    _sum?: DetectionSumOrderByAggregateInput
  }

  export type DetectionScalarWhereWithAggregatesInput = {
    AND?: DetectionScalarWhereWithAggregatesInput | DetectionScalarWhereWithAggregatesInput[]
    OR?: DetectionScalarWhereWithAggregatesInput[]
    NOT?: DetectionScalarWhereWithAggregatesInput | DetectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Detection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Detection"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Detection"> | boolean
    publicId?: StringWithAggregatesFilter<"Detection"> | string
    inferenceId?: IntWithAggregatesFilter<"Detection"> | number
    imageKey?: StringNullableWithAggregatesFilter<"Detection"> | string | null
    xMinCord?: FloatNullableWithAggregatesFilter<"Detection"> | number | null
    yMinCord?: FloatNullableWithAggregatesFilter<"Detection"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"Detection"> | number | null
    xMaxCord?: FloatNullableWithAggregatesFilter<"Detection"> | number | null
    yMaxCord?: FloatNullableWithAggregatesFilter<"Detection"> | number | null
    projectId?: IntWithAggregatesFilter<"Detection"> | number
    category?: StringWithAggregatesFilter<"Detection"> | string
    code?: StringWithAggregatesFilter<"Detection"> | string
    item?: StringWithAggregatesFilter<"Detection"> | string
    quality?: StringWithAggregatesFilter<"Detection"> | string
    roomId?: IntNullableWithAggregatesFilter<"Detection"> | number | null
    dimension?: IntNullableWithAggregatesFilter<"Detection"> | number | null
    unit?: EnumDimensionUnitNullableWithAggregatesFilter<"Detection"> | $Enums.DimensionUnit | null
  }

  export type TemplatesUsedWhereInput = {
    AND?: TemplatesUsedWhereInput | TemplatesUsedWhereInput[]
    OR?: TemplatesUsedWhereInput[]
    NOT?: TemplatesUsedWhereInput | TemplatesUsedWhereInput[]
    id?: IntFilter<"TemplatesUsed"> | number
    createdAt?: DateTimeFilter<"TemplatesUsed"> | Date | string
    templateCode?: StringFilter<"TemplatesUsed"> | string
    roomId?: IntNullableFilter<"TemplatesUsed"> | number | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
  }

  export type TemplatesUsedOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrderInput | SortOrder
    room?: RoomOrderByWithRelationInput
    _relevance?: TemplatesUsedOrderByRelevanceInput
  }

  export type TemplatesUsedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplatesUsedWhereInput | TemplatesUsedWhereInput[]
    OR?: TemplatesUsedWhereInput[]
    NOT?: TemplatesUsedWhereInput | TemplatesUsedWhereInput[]
    createdAt?: DateTimeFilter<"TemplatesUsed"> | Date | string
    templateCode?: StringFilter<"TemplatesUsed"> | string
    roomId?: IntNullableFilter<"TemplatesUsed"> | number | null
    room?: XOR<RoomNullableScalarRelationFilter, RoomWhereInput> | null
  }, "id">

  export type TemplatesUsedOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrderInput | SortOrder
    _count?: TemplatesUsedCountOrderByAggregateInput
    _avg?: TemplatesUsedAvgOrderByAggregateInput
    _max?: TemplatesUsedMaxOrderByAggregateInput
    _min?: TemplatesUsedMinOrderByAggregateInput
    _sum?: TemplatesUsedSumOrderByAggregateInput
  }

  export type TemplatesUsedScalarWhereWithAggregatesInput = {
    AND?: TemplatesUsedScalarWhereWithAggregatesInput | TemplatesUsedScalarWhereWithAggregatesInput[]
    OR?: TemplatesUsedScalarWhereWithAggregatesInput[]
    NOT?: TemplatesUsedScalarWhereWithAggregatesInput | TemplatesUsedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplatesUsed"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TemplatesUsed"> | Date | string
    templateCode?: StringWithAggregatesFilter<"TemplatesUsed"> | string
    roomId?: IntNullableWithAggregatesFilter<"TemplatesUsed"> | number | null
  }

  export type WaitListWhereInput = {
    AND?: WaitListWhereInput | WaitListWhereInput[]
    OR?: WaitListWhereInput[]
    NOT?: WaitListWhereInput | WaitListWhereInput[]
    id?: IntFilter<"WaitList"> | number
    createdAt?: DateTimeFilter<"WaitList"> | Date | string
    email?: StringFilter<"WaitList"> | string
  }

  export type WaitListOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    _relevance?: WaitListOrderByRelevanceInput
  }

  export type WaitListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: WaitListWhereInput | WaitListWhereInput[]
    OR?: WaitListWhereInput[]
    NOT?: WaitListWhereInput | WaitListWhereInput[]
    createdAt?: DateTimeFilter<"WaitList"> | Date | string
  }, "id" | "email">

  export type WaitListOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    _count?: WaitListCountOrderByAggregateInput
    _avg?: WaitListAvgOrderByAggregateInput
    _max?: WaitListMaxOrderByAggregateInput
    _min?: WaitListMinOrderByAggregateInput
    _sum?: WaitListSumOrderByAggregateInput
  }

  export type WaitListScalarWhereWithAggregatesInput = {
    AND?: WaitListScalarWhereWithAggregatesInput | WaitListScalarWhereWithAggregatesInput[]
    OR?: WaitListScalarWhereWithAggregatesInput[]
    NOT?: WaitListScalarWhereWithAggregatesInput | WaitListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WaitList"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WaitList"> | Date | string
    email?: StringWithAggregatesFilter<"WaitList"> | string
  }

  export type RekognitionRunsWhereInput = {
    AND?: RekognitionRunsWhereInput | RekognitionRunsWhereInput[]
    OR?: RekognitionRunsWhereInput[]
    NOT?: RekognitionRunsWhereInput | RekognitionRunsWhereInput[]
    id?: IntFilter<"RekognitionRuns"> | number
    createdAt?: DateTimeFilter<"RekognitionRuns"> | Date | string
  }

  export type RekognitionRunsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RekognitionRunsWhereInput | RekognitionRunsWhereInput[]
    OR?: RekognitionRunsWhereInput[]
    NOT?: RekognitionRunsWhereInput | RekognitionRunsWhereInput[]
    createdAt?: DateTimeFilter<"RekognitionRuns"> | Date | string
  }, "id">

  export type RekognitionRunsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    _count?: RekognitionRunsCountOrderByAggregateInput
    _avg?: RekognitionRunsAvgOrderByAggregateInput
    _max?: RekognitionRunsMaxOrderByAggregateInput
    _min?: RekognitionRunsMinOrderByAggregateInput
    _sum?: RekognitionRunsSumOrderByAggregateInput
  }

  export type RekognitionRunsScalarWhereWithAggregatesInput = {
    AND?: RekognitionRunsScalarWhereWithAggregatesInput | RekognitionRunsScalarWhereWithAggregatesInput[]
    OR?: RekognitionRunsScalarWhereWithAggregatesInput[]
    NOT?: RekognitionRunsScalarWhereWithAggregatesInput | RekognitionRunsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RekognitionRuns"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RekognitionRuns"> | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: IntFilter<"CalendarEvent"> | number
    publicId?: StringFilter<"CalendarEvent"> | string
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    subject?: StringFilter<"CalendarEvent"> | string
    payload?: StringFilter<"CalendarEvent"> | string
    projectId?: IntNullableFilter<"CalendarEvent"> | number | null
    date?: DateTimeFilter<"CalendarEvent"> | Date | string
    dynamicId?: StringFilter<"CalendarEvent"> | string
    isDeleted?: BoolFilter<"CalendarEvent"> | boolean
    remindClient?: BoolFilter<"CalendarEvent"> | boolean
    remindProjectOwners?: BoolFilter<"CalendarEvent"> | boolean
    reminders?: CalendarEventReminderListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrderInput | SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
    reminders?: CalendarEventReminderOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: CalendarEventOrderByRelevanceInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    publicId?: string
    dynamicId?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    subject?: StringFilter<"CalendarEvent"> | string
    payload?: StringFilter<"CalendarEvent"> | string
    projectId?: IntNullableFilter<"CalendarEvent"> | number | null
    date?: DateTimeFilter<"CalendarEvent"> | Date | string
    isDeleted?: BoolFilter<"CalendarEvent"> | boolean
    remindClient?: BoolFilter<"CalendarEvent"> | boolean
    remindProjectOwners?: BoolFilter<"CalendarEvent"> | boolean
    reminders?: CalendarEventReminderListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "publicId" | "dynamicId">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrderInput | SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _avg?: CalendarEventAvgOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
    _sum?: CalendarEventSumOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalendarEvent"> | number
    publicId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    subject?: StringWithAggregatesFilter<"CalendarEvent"> | string
    payload?: StringWithAggregatesFilter<"CalendarEvent"> | string
    projectId?: IntNullableWithAggregatesFilter<"CalendarEvent"> | number | null
    date?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    dynamicId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    isDeleted?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    remindClient?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    remindProjectOwners?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
  }

  export type CalendarEventReminderWhereInput = {
    AND?: CalendarEventReminderWhereInput | CalendarEventReminderWhereInput[]
    OR?: CalendarEventReminderWhereInput[]
    NOT?: CalendarEventReminderWhereInput | CalendarEventReminderWhereInput[]
    id?: IntFilter<"CalendarEventReminder"> | number
    reminderTarget?: EnumReminderTargetFilter<"CalendarEventReminder"> | $Enums.ReminderTarget
    createdAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    sendText?: BoolFilter<"CalendarEventReminder"> | boolean
    sendEmail?: BoolFilter<"CalendarEventReminder"> | boolean
    textSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    emailSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    calendarEventId?: IntNullableFilter<"CalendarEventReminder"> | number | null
    date?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    calendarEvent?: XOR<CalendarEventNullableScalarRelationFilter, CalendarEventWhereInput> | null
  }

  export type CalendarEventReminderOrderByWithRelationInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrderInput | SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    calendarEventId?: SortOrderInput | SortOrder
    date?: SortOrder
    calendarEvent?: CalendarEventOrderByWithRelationInput
  }

  export type CalendarEventReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CalendarEventReminderWhereInput | CalendarEventReminderWhereInput[]
    OR?: CalendarEventReminderWhereInput[]
    NOT?: CalendarEventReminderWhereInput | CalendarEventReminderWhereInput[]
    reminderTarget?: EnumReminderTargetFilter<"CalendarEventReminder"> | $Enums.ReminderTarget
    createdAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    sendText?: BoolFilter<"CalendarEventReminder"> | boolean
    sendEmail?: BoolFilter<"CalendarEventReminder"> | boolean
    textSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    emailSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    calendarEventId?: IntNullableFilter<"CalendarEventReminder"> | number | null
    date?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    calendarEvent?: XOR<CalendarEventNullableScalarRelationFilter, CalendarEventWhereInput> | null
  }, "id">

  export type CalendarEventReminderOrderByWithAggregationInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrderInput | SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    calendarEventId?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: CalendarEventReminderCountOrderByAggregateInput
    _avg?: CalendarEventReminderAvgOrderByAggregateInput
    _max?: CalendarEventReminderMaxOrderByAggregateInput
    _min?: CalendarEventReminderMinOrderByAggregateInput
    _sum?: CalendarEventReminderSumOrderByAggregateInput
  }

  export type CalendarEventReminderScalarWhereWithAggregatesInput = {
    AND?: CalendarEventReminderScalarWhereWithAggregatesInput | CalendarEventReminderScalarWhereWithAggregatesInput[]
    OR?: CalendarEventReminderScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventReminderScalarWhereWithAggregatesInput | CalendarEventReminderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalendarEventReminder"> | number
    reminderTarget?: EnumReminderTargetWithAggregatesFilter<"CalendarEventReminder"> | $Enums.ReminderTarget
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEventReminder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEventReminder"> | Date | string
    sendText?: BoolWithAggregatesFilter<"CalendarEventReminder"> | boolean
    sendEmail?: BoolWithAggregatesFilter<"CalendarEventReminder"> | boolean
    textSentAt?: DateTimeNullableWithAggregatesFilter<"CalendarEventReminder"> | Date | string | null
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"CalendarEventReminder"> | Date | string | null
    calendarEventId?: IntNullableWithAggregatesFilter<"CalendarEventReminder"> | number | null
    date?: DateTimeWithAggregatesFilter<"CalendarEventReminder"> | Date | string
  }

  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    id?: IntFilter<"ItemCategory"> | number
    xactimateKey?: StringFilter<"ItemCategory"> | string
    xactimateDescription?: StringFilter<"ItemCategory"> | string
    hasItems?: BoolFilter<"ItemCategory"> | boolean
    LineItem?: LineItemListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
    LineItem?: LineItemOrderByRelationAggregateInput
    _relevance?: ItemCategoryOrderByRelevanceInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    xactimateKey?: string
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    xactimateDescription?: StringFilter<"ItemCategory"> | string
    hasItems?: BoolFilter<"ItemCategory"> | boolean
    LineItem?: LineItemListRelationFilter
  }, "id" | "xactimateKey">

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemCategory"> | number
    xactimateKey?: StringWithAggregatesFilter<"ItemCategory"> | string
    xactimateDescription?: StringWithAggregatesFilter<"ItemCategory"> | string
    hasItems?: BoolWithAggregatesFilter<"ItemCategory"> | boolean
  }

  export type LineItemWhereInput = {
    AND?: LineItemWhereInput | LineItemWhereInput[]
    OR?: LineItemWhereInput[]
    NOT?: LineItemWhereInput | LineItemWhereInput[]
    id?: IntFilter<"LineItem"> | number
    xactimateCode?: StringFilter<"LineItem"> | string
    xactimateDescription?: StringFilter<"LineItem"> | string
    unit?: StringNullableFilter<"LineItem"> | string | null
    itemCategoryId?: IntFilter<"LineItem"> | number
    xactimateCategory?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    alternateItem?: AlternateItemListRelationFilter
    relatedItem?: RelatedItemListRelationFilter
  }

  export type LineItemOrderByWithRelationInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrderInput | SortOrder
    itemCategoryId?: SortOrder
    xactimateCategory?: ItemCategoryOrderByWithRelationInput
    alternateItem?: AlternateItemOrderByRelationAggregateInput
    relatedItem?: RelatedItemOrderByRelationAggregateInput
    _relevance?: LineItemOrderByRelevanceInput
  }

  export type LineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemCategoryId_xactimateCode?: LineItemItemCategoryIdXactimateCodeCompoundUniqueInput
    AND?: LineItemWhereInput | LineItemWhereInput[]
    OR?: LineItemWhereInput[]
    NOT?: LineItemWhereInput | LineItemWhereInput[]
    xactimateCode?: StringFilter<"LineItem"> | string
    xactimateDescription?: StringFilter<"LineItem"> | string
    unit?: StringNullableFilter<"LineItem"> | string | null
    itemCategoryId?: IntFilter<"LineItem"> | number
    xactimateCategory?: XOR<ItemCategoryScalarRelationFilter, ItemCategoryWhereInput>
    alternateItem?: AlternateItemListRelationFilter
    relatedItem?: RelatedItemListRelationFilter
  }, "id" | "itemCategoryId_xactimateCode">

  export type LineItemOrderByWithAggregationInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrderInput | SortOrder
    itemCategoryId?: SortOrder
    _count?: LineItemCountOrderByAggregateInput
    _avg?: LineItemAvgOrderByAggregateInput
    _max?: LineItemMaxOrderByAggregateInput
    _min?: LineItemMinOrderByAggregateInput
    _sum?: LineItemSumOrderByAggregateInput
  }

  export type LineItemScalarWhereWithAggregatesInput = {
    AND?: LineItemScalarWhereWithAggregatesInput | LineItemScalarWhereWithAggregatesInput[]
    OR?: LineItemScalarWhereWithAggregatesInput[]
    NOT?: LineItemScalarWhereWithAggregatesInput | LineItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LineItem"> | number
    xactimateCode?: StringWithAggregatesFilter<"LineItem"> | string
    xactimateDescription?: StringWithAggregatesFilter<"LineItem"> | string
    unit?: StringNullableWithAggregatesFilter<"LineItem"> | string | null
    itemCategoryId?: IntWithAggregatesFilter<"LineItem"> | number
  }

  export type RelatedItemWhereInput = {
    AND?: RelatedItemWhereInput | RelatedItemWhereInput[]
    OR?: RelatedItemWhereInput[]
    NOT?: RelatedItemWhereInput | RelatedItemWhereInput[]
    id?: IntFilter<"RelatedItem"> | number
    relationId?: StringFilter<"RelatedItem"> | string
    lineItemId?: IntFilter<"RelatedItem"> | number
    lineItem?: XOR<LineItemScalarRelationFilter, LineItemWhereInput>
  }

  export type RelatedItemOrderByWithRelationInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
    lineItem?: LineItemOrderByWithRelationInput
    _relevance?: RelatedItemOrderByRelevanceInput
  }

  export type RelatedItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelatedItemWhereInput | RelatedItemWhereInput[]
    OR?: RelatedItemWhereInput[]
    NOT?: RelatedItemWhereInput | RelatedItemWhereInput[]
    relationId?: StringFilter<"RelatedItem"> | string
    lineItemId?: IntFilter<"RelatedItem"> | number
    lineItem?: XOR<LineItemScalarRelationFilter, LineItemWhereInput>
  }, "id">

  export type RelatedItemOrderByWithAggregationInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
    _count?: RelatedItemCountOrderByAggregateInput
    _avg?: RelatedItemAvgOrderByAggregateInput
    _max?: RelatedItemMaxOrderByAggregateInput
    _min?: RelatedItemMinOrderByAggregateInput
    _sum?: RelatedItemSumOrderByAggregateInput
  }

  export type RelatedItemScalarWhereWithAggregatesInput = {
    AND?: RelatedItemScalarWhereWithAggregatesInput | RelatedItemScalarWhereWithAggregatesInput[]
    OR?: RelatedItemScalarWhereWithAggregatesInput[]
    NOT?: RelatedItemScalarWhereWithAggregatesInput | RelatedItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelatedItem"> | number
    relationId?: StringWithAggregatesFilter<"RelatedItem"> | string
    lineItemId?: IntWithAggregatesFilter<"RelatedItem"> | number
  }

  export type AlternateItemWhereInput = {
    AND?: AlternateItemWhereInput | AlternateItemWhereInput[]
    OR?: AlternateItemWhereInput[]
    NOT?: AlternateItemWhereInput | AlternateItemWhereInput[]
    id?: IntFilter<"AlternateItem"> | number
    alternateId?: StringFilter<"AlternateItem"> | string
    lineItemId?: IntFilter<"AlternateItem"> | number
    lineItem?: XOR<LineItemScalarRelationFilter, LineItemWhereInput>
  }

  export type AlternateItemOrderByWithRelationInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
    lineItem?: LineItemOrderByWithRelationInput
    _relevance?: AlternateItemOrderByRelevanceInput
  }

  export type AlternateItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlternateItemWhereInput | AlternateItemWhereInput[]
    OR?: AlternateItemWhereInput[]
    NOT?: AlternateItemWhereInput | AlternateItemWhereInput[]
    alternateId?: StringFilter<"AlternateItem"> | string
    lineItemId?: IntFilter<"AlternateItem"> | number
    lineItem?: XOR<LineItemScalarRelationFilter, LineItemWhereInput>
  }, "id">

  export type AlternateItemOrderByWithAggregationInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
    _count?: AlternateItemCountOrderByAggregateInput
    _avg?: AlternateItemAvgOrderByAggregateInput
    _max?: AlternateItemMaxOrderByAggregateInput
    _min?: AlternateItemMinOrderByAggregateInput
    _sum?: AlternateItemSumOrderByAggregateInput
  }

  export type AlternateItemScalarWhereWithAggregatesInput = {
    AND?: AlternateItemScalarWhereWithAggregatesInput | AlternateItemScalarWhereWithAggregatesInput[]
    OR?: AlternateItemScalarWhereWithAggregatesInput[]
    NOT?: AlternateItemScalarWhereWithAggregatesInput | AlternateItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlternateItem"> | number
    alternateId?: StringWithAggregatesFilter<"AlternateItem"> | string
    lineItemId?: IntWithAggregatesFilter<"AlternateItem"> | number
  }

  export type PlanEntitlementsWhereInput = {
    AND?: PlanEntitlementsWhereInput | PlanEntitlementsWhereInput[]
    OR?: PlanEntitlementsWhereInput[]
    NOT?: PlanEntitlementsWhereInput | PlanEntitlementsWhereInput[]
    id?: IntFilter<"PlanEntitlements"> | number
    createdAt?: DateTimeFilter<"PlanEntitlements"> | Date | string
    extPlanId?: StringFilter<"PlanEntitlements"> | string
    maxImages?: IntFilter<"PlanEntitlements"> | number
    maxProjects?: IntFilter<"PlanEntitlements"> | number
    maxSeats?: IntFilter<"PlanEntitlements"> | number
    description?: StringFilter<"PlanEntitlements"> | string
    period?: StringFilter<"PlanEntitlements"> | string
    price?: FloatFilter<"PlanEntitlements"> | number
  }

  export type PlanEntitlementsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
    _relevance?: PlanEntitlementsOrderByRelevanceInput
  }

  export type PlanEntitlementsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanEntitlementsWhereInput | PlanEntitlementsWhereInput[]
    OR?: PlanEntitlementsWhereInput[]
    NOT?: PlanEntitlementsWhereInput | PlanEntitlementsWhereInput[]
    createdAt?: DateTimeFilter<"PlanEntitlements"> | Date | string
    extPlanId?: StringFilter<"PlanEntitlements"> | string
    maxImages?: IntFilter<"PlanEntitlements"> | number
    maxProjects?: IntFilter<"PlanEntitlements"> | number
    maxSeats?: IntFilter<"PlanEntitlements"> | number
    description?: StringFilter<"PlanEntitlements"> | string
    period?: StringFilter<"PlanEntitlements"> | string
    price?: FloatFilter<"PlanEntitlements"> | number
  }, "id">

  export type PlanEntitlementsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
    _count?: PlanEntitlementsCountOrderByAggregateInput
    _avg?: PlanEntitlementsAvgOrderByAggregateInput
    _max?: PlanEntitlementsMaxOrderByAggregateInput
    _min?: PlanEntitlementsMinOrderByAggregateInput
    _sum?: PlanEntitlementsSumOrderByAggregateInput
  }

  export type PlanEntitlementsScalarWhereWithAggregatesInput = {
    AND?: PlanEntitlementsScalarWhereWithAggregatesInput | PlanEntitlementsScalarWhereWithAggregatesInput[]
    OR?: PlanEntitlementsScalarWhereWithAggregatesInput[]
    NOT?: PlanEntitlementsScalarWhereWithAggregatesInput | PlanEntitlementsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlanEntitlements"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlanEntitlements"> | Date | string
    extPlanId?: StringWithAggregatesFilter<"PlanEntitlements"> | string
    maxImages?: IntWithAggregatesFilter<"PlanEntitlements"> | number
    maxProjects?: IntWithAggregatesFilter<"PlanEntitlements"> | number
    maxSeats?: IntWithAggregatesFilter<"PlanEntitlements"> | number
    description?: StringWithAggregatesFilter<"PlanEntitlements"> | string
    period?: StringWithAggregatesFilter<"PlanEntitlements"> | string
    price?: FloatWithAggregatesFilter<"PlanEntitlements"> | number
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: IntFilter<"Customers"> | number
    customerId?: StringFilter<"Customers"> | string
    billingAddress?: JsonNullableFilter<"Customers">
    paymentMethod?: JsonNullableFilter<"Customers">
    organizationId?: IntFilter<"Customers"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: CustomersOrderByRelevanceInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    customerId?: string
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    billingAddress?: JsonNullableFilter<"Customers">
    paymentMethod?: JsonNullableFilter<"Customers">
    organizationId?: IntFilter<"Customers"> | number
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "customerId">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customers"> | number
    customerId?: StringWithAggregatesFilter<"Customers"> | string
    billingAddress?: JsonNullableWithAggregatesFilter<"Customers">
    paymentMethod?: JsonNullableWithAggregatesFilter<"Customers">
    organizationId?: IntWithAggregatesFilter<"Customers"> | number
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    id?: StringFilter<"Products"> | string
    active?: BoolFilter<"Products"> | boolean
    name?: StringFilter<"Products"> | string
    description?: StringNullableFilter<"Products"> | string | null
    image?: StringNullableFilter<"Products"> | string | null
    metadata?: JsonNullableFilter<"Products">
    prices?: PricesListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    prices?: PricesOrderByRelationAggregateInput
    _relevance?: ProductsOrderByRelevanceInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    active?: BoolFilter<"Products"> | boolean
    name?: StringFilter<"Products"> | string
    description?: StringNullableFilter<"Products"> | string | null
    image?: StringNullableFilter<"Products"> | string | null
    metadata?: JsonNullableFilter<"Products">
    prices?: PricesListRelationFilter
  }, "id">

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Products"> | string
    active?: BoolWithAggregatesFilter<"Products"> | boolean
    name?: StringWithAggregatesFilter<"Products"> | string
    description?: StringNullableWithAggregatesFilter<"Products"> | string | null
    image?: StringNullableWithAggregatesFilter<"Products"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Products">
  }

  export type PricesWhereInput = {
    AND?: PricesWhereInput | PricesWhereInput[]
    OR?: PricesWhereInput[]
    NOT?: PricesWhereInput | PricesWhereInput[]
    id?: StringFilter<"Prices"> | string
    productId?: StringFilter<"Prices"> | string
    active?: BoolFilter<"Prices"> | boolean
    unitAmount?: BigIntNullableFilter<"Prices"> | bigint | number | null
    currency?: StringFilter<"Prices"> | string
    type?: EnumPricingTypeFilter<"Prices"> | $Enums.PricingType
    interval?: EnumPricingPlanIntervalNullableFilter<"Prices"> | $Enums.PricingPlanInterval | null
    intervalCount?: IntNullableFilter<"Prices"> | number | null
    trialPeriodDays?: IntNullableFilter<"Prices"> | number | null
    metadata?: JsonNullableFilter<"Prices">
    description?: StringFilter<"Prices"> | string
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    Subscriptions?: SubscriptionsListRelationFilter
  }

  export type PricesOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrderInput | SortOrder
    intervalCount?: SortOrderInput | SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    description?: SortOrder
    product?: ProductsOrderByWithRelationInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
    _relevance?: PricesOrderByRelevanceInput
  }

  export type PricesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricesWhereInput | PricesWhereInput[]
    OR?: PricesWhereInput[]
    NOT?: PricesWhereInput | PricesWhereInput[]
    productId?: StringFilter<"Prices"> | string
    active?: BoolFilter<"Prices"> | boolean
    unitAmount?: BigIntNullableFilter<"Prices"> | bigint | number | null
    currency?: StringFilter<"Prices"> | string
    type?: EnumPricingTypeFilter<"Prices"> | $Enums.PricingType
    interval?: EnumPricingPlanIntervalNullableFilter<"Prices"> | $Enums.PricingPlanInterval | null
    intervalCount?: IntNullableFilter<"Prices"> | number | null
    trialPeriodDays?: IntNullableFilter<"Prices"> | number | null
    metadata?: JsonNullableFilter<"Prices">
    description?: StringFilter<"Prices"> | string
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    Subscriptions?: SubscriptionsListRelationFilter
  }, "id">

  export type PricesOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrderInput | SortOrder
    intervalCount?: SortOrderInput | SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: PricesCountOrderByAggregateInput
    _avg?: PricesAvgOrderByAggregateInput
    _max?: PricesMaxOrderByAggregateInput
    _min?: PricesMinOrderByAggregateInput
    _sum?: PricesSumOrderByAggregateInput
  }

  export type PricesScalarWhereWithAggregatesInput = {
    AND?: PricesScalarWhereWithAggregatesInput | PricesScalarWhereWithAggregatesInput[]
    OR?: PricesScalarWhereWithAggregatesInput[]
    NOT?: PricesScalarWhereWithAggregatesInput | PricesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prices"> | string
    productId?: StringWithAggregatesFilter<"Prices"> | string
    active?: BoolWithAggregatesFilter<"Prices"> | boolean
    unitAmount?: BigIntNullableWithAggregatesFilter<"Prices"> | bigint | number | null
    currency?: StringWithAggregatesFilter<"Prices"> | string
    type?: EnumPricingTypeWithAggregatesFilter<"Prices"> | $Enums.PricingType
    interval?: EnumPricingPlanIntervalNullableWithAggregatesFilter<"Prices"> | $Enums.PricingPlanInterval | null
    intervalCount?: IntNullableWithAggregatesFilter<"Prices"> | number | null
    trialPeriodDays?: IntNullableWithAggregatesFilter<"Prices"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"Prices">
    description?: StringWithAggregatesFilter<"Prices"> | string
  }

  export type SubscriptionsWhereInput = {
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    id?: StringFilter<"Subscriptions"> | string
    organizationId?: IntFilter<"Subscriptions"> | number
    status?: EnumSubscriptionStatusFilter<"Subscriptions"> | $Enums.SubscriptionStatus
    metadata?: JsonNullableFilter<"Subscriptions">
    pricesId?: StringFilter<"Subscriptions"> | string
    quantity?: IntFilter<"Subscriptions"> | number
    cancelAtPeriodEnd?: BoolFilter<"Subscriptions"> | boolean
    created?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    price?: XOR<PricesScalarRelationFilter, PricesWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SubscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    cancelAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    price?: PricesOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    _relevance?: SubscriptionsOrderByRelevanceInput
  }

  export type SubscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    organizationId?: IntFilter<"Subscriptions"> | number
    status?: EnumSubscriptionStatusFilter<"Subscriptions"> | $Enums.SubscriptionStatus
    metadata?: JsonNullableFilter<"Subscriptions">
    pricesId?: StringFilter<"Subscriptions"> | string
    quantity?: IntFilter<"Subscriptions"> | number
    cancelAtPeriodEnd?: BoolFilter<"Subscriptions"> | boolean
    created?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    price?: XOR<PricesScalarRelationFilter, PricesWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type SubscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    cancelAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    _count?: SubscriptionsCountOrderByAggregateInput
    _avg?: SubscriptionsAvgOrderByAggregateInput
    _max?: SubscriptionsMaxOrderByAggregateInput
    _min?: SubscriptionsMinOrderByAggregateInput
    _sum?: SubscriptionsSumOrderByAggregateInput
  }

  export type SubscriptionsScalarWhereWithAggregatesInput = {
    AND?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    OR?: SubscriptionsScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriptions"> | string
    organizationId?: IntWithAggregatesFilter<"Subscriptions"> | number
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscriptions"> | $Enums.SubscriptionStatus
    metadata?: JsonNullableWithAggregatesFilter<"Subscriptions">
    pricesId?: StringWithAggregatesFilter<"Subscriptions"> | string
    quantity?: IntWithAggregatesFilter<"Subscriptions"> | number
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscriptions"> | boolean
    created?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    cancelAt?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationCreateInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
  }

  export type OrganizationUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organization: OrganizationCreateNestedOneWithoutEquipmentInput
    ProjectEquipment?: ProjectEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
    ProjectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutEquipmentNestedInput
    ProjectEquipment?: ProjectEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
  }

  export type EquipmentUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
    userId: string
  }

  export type NotificationUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationSavedOptionCreateInput = {
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
    organization: OrganizationCreateNestedOneWithoutOrganizationSavedOptionInput
  }

  export type OrganizationSavedOptionUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
    organizationId: number
  }

  export type OrganizationSavedOptionUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationSavedOptionNestedInput
  }

  export type OrganizationSavedOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationSavedOptionCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
    organizationId: number
  }

  export type OrganizationSavedOptionUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToOrganizationCreateInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutOrgInput
  }

  export type UserToOrganizationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    userId: string
  }

  export type UserToOrganizationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutOrgNestedInput
  }

  export type UserToOrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToOrganizationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    userId: string
  }

  export type UserToOrganizationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
  }

  export type UserToOrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationInvitationCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type OrganizationInvitationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type OrganizationInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    organizationId: number
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserToProjectCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserToProjectInput
    project: ProjectCreateNestedOneWithoutProjectAssigneesInput
  }

  export type UserToProjectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    projectId: number
  }

  export type UserToProjectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserToProjectNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput
  }

  export type UserToProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToProjectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    projectId: number
  }

  export type UserToProjectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectNotesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
    project: ProjectCreateNestedOneWithoutProjectNotesInput
  }

  export type ProjectNotesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
  }

  export type ProjectNotesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutProjectNotesNestedInput
  }

  export type ProjectNotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
  }

  export type ProjectNotesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectStatusValueCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectCreateNestedManyWithoutCurrentStatusInput
    organization: OrganizationCreateNestedOneWithoutProjectStatusValueInput
  }

  export type ProjectStatusValueUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
    projects?: ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUpdateManyWithoutCurrentStatusNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
    projects?: ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
  }

  export type ProjectStatusValueUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectStatusValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type PendingRoofReportsCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
    project: ProjectCreateNestedOneWithoutPendingRoofReportsInput
  }

  export type PendingRoofReportsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    isCompleted?: boolean
  }

  export type PendingRoofReportsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneRequiredWithoutPendingRoofReportsNestedInput
  }

  export type PendingRoofReportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    isCompleted?: boolean
  }

  export type PendingRoofReportsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WeatherReportItemCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
    project: ProjectCreateNestedOneWithoutWeatherReportItemsInput
  }

  export type WeatherReportItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutWeatherReportItemsNestedInput
  }

  export type WeatherReportItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    projectId: number
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    projectId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectEquipmentCreateInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipment: EquipmentCreateNestedOneWithoutProjectEquipmentInput
    project: ProjectCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
    equipmentId: number
  }

  export type ProjectEquipmentUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipment?: EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
    equipmentId: number
  }

  export type ProjectEquipmentUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type CostCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: $Enums.CostType
    project: ProjectCreateNestedOneWithoutCostsInput
  }

  export type CostUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    projectId: number
    isDeleted?: boolean
    type: $Enums.CostType
  }

  export type CostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    project?: ProjectUpdateOneRequiredWithoutCostsNestedInput
  }

  export type CostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type CostCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    projectId: number
    isDeleted?: boolean
    type: $Enums.CostType
  }

  export type CostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type CostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type PropertyDataCreateInput = {
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectCreateNestedOneWithoutPropertyDataInput
  }

  export type PropertyDataUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    projectId?: number | null
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneWithoutPropertyDataNestedInput
  }

  export type PropertyDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataCreateManyInput = {
    id?: number
    createdAt?: Date | string
    projectId?: number | null
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DataDeletionRequestCreateInput = {
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestCreateManyInput = {
    id?: number
    createdAt?: Date | string
    fullName: string
    email: string
    isVerified?: boolean
  }

  export type DataDeletionRequestUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DataDeletionRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhotoAccessLinkCreateInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    project: ProjectCreateNestedOneWithoutPhotoAccessLinksInput
  }

  export type PhotoAccessLinkUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    projectId: number
  }

  export type PhotoAccessLinkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutPhotoAccessLinksNestedInput
  }

  export type PhotoAccessLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoAccessLinkCreateManyInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
    projectId: number
  }

  export type PhotoAccessLinkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
  }

  export type ImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnotationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutAnnotationInput
    User: UserCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutAnnotationNestedInput
    User?: UserUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutImageNoteInput
    User: UserCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutImageNoteNestedInput
    User?: UserUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InferenceCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
  }

  export type InferenceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
  }

  export type RoomUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
  }

  export type RoomReadingCreateInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type RoomReadingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    project: ProjectCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NotesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type NotesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailCreateInput = {
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
    note: NotesCreateNestedOneWithoutNotesAuditTrailInput
  }

  export type NotesAuditTrailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    notesId: number
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
    note?: NotesUpdateOneRequiredWithoutNotesAuditTrailNestedInput
  }

  export type NotesAuditTrailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    notesId: number
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type AreaAffectedCreateInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: $Enums.AreaAffectedType
    room: RoomCreateNestedOneWithoutAreasAffectedInput
    project: ProjectCreateNestedOneWithoutAreaAffectedInput
  }

  export type AreaAffectedUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: $Enums.AreaAffectedType
  }

  export type AreaAffectedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
    room?: RoomUpdateOneRequiredWithoutAreasAffectedNestedInput
    project?: ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type AreaAffectedCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: $Enums.AreaAffectedType
  }

  export type AreaAffectedUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type GenericRoomReadingCreateInput = {
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
    roomReading: RoomReadingCreateNestedOneWithoutGenericRoomReadingsInput
  }

  export type GenericRoomReadingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    roomReadingId: number
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    roomReading?: RoomReadingUpdateOneRequiredWithoutGenericRoomReadingsNestedInput
  }

  export type GenericRoomReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    roomReadingId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    roomReadingId: number
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    roomReadingId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DetectionCreateInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
    inference: InferenceCreateNestedOneWithoutDetectionsInput
    room?: RoomCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type DetectionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
    inference?: InferenceUpdateOneRequiredWithoutDetectionsNestedInput
    room?: RoomUpdateOneWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type DetectionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type DetectionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type DetectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type TemplatesUsedCreateInput = {
    createdAt?: Date | string
    templateCode: string
    room?: RoomCreateNestedOneWithoutTemplatesInput
  }

  export type TemplatesUsedUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
    roomId?: number | null
  }

  export type TemplatesUsedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneWithoutTemplatesNestedInput
  }

  export type TemplatesUsedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplatesUsedCreateManyInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
    roomId?: number | null
  }

  export type TemplatesUsedUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WaitListCreateInput = {
    createdAt?: Date | string
    email: string
  }

  export type WaitListUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    email: string
  }

  export type WaitListUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListCreateManyInput = {
    id?: number
    createdAt?: Date | string
    email: string
  }

  export type WaitListUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type WaitListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type RekognitionRunsCreateInput = {
    createdAt?: Date | string
  }

  export type RekognitionRunsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
  }

  export type RekognitionRunsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsCreateManyInput = {
    id?: number
    createdAt?: Date | string
  }

  export type RekognitionRunsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RekognitionRunsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderCreateNestedManyWithoutCalendarEventInput
    project?: ProjectCreateNestedOneWithoutEventsInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventUpdateInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventCreateManyInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type CalendarEventUpdateManyMutationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarEventReminderCreateInput = {
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
    calendarEvent?: CalendarEventCreateNestedOneWithoutRemindersInput
  }

  export type CalendarEventReminderUncheckedCreateInput = {
    id?: number
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    calendarEventId?: number | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    calendarEvent?: CalendarEventUpdateOneWithoutRemindersNestedInput
  }

  export type CalendarEventReminderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEventId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderCreateManyInput = {
    id?: number
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    calendarEventId?: number | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateManyMutationInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEventId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCreateInput = {
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
    LineItem?: LineItemCreateNestedManyWithoutXactimateCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
    LineItem?: LineItemUncheckedCreateNestedManyWithoutXactimateCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
    LineItem?: LineItemUpdateManyWithoutXactimateCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
    LineItem?: LineItemUncheckedUpdateManyWithoutXactimateCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryUpdateManyMutationInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LineItemCreateInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUpdateInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemCreateManyInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
  }

  export type LineItemUpdateManyMutationInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LineItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedItemCreateInput = {
    relationId: string
    lineItem: LineItemCreateNestedOneWithoutRelatedItemInput
  }

  export type RelatedItemUncheckedCreateInput = {
    id?: number
    relationId: string
    lineItemId: number
  }

  export type RelatedItemUpdateInput = {
    relationId?: StringFieldUpdateOperationsInput | string
    lineItem?: LineItemUpdateOneRequiredWithoutRelatedItemNestedInput
  }

  export type RelatedItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedItemCreateManyInput = {
    id?: number
    relationId: string
    lineItemId: number
  }

  export type RelatedItemUpdateManyMutationInput = {
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type AlternateItemCreateInput = {
    alternateId: string
    lineItem: LineItemCreateNestedOneWithoutAlternateItemInput
  }

  export type AlternateItemUncheckedCreateInput = {
    id?: number
    alternateId: string
    lineItemId: number
  }

  export type AlternateItemUpdateInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItem?: LineItemUpdateOneRequiredWithoutAlternateItemNestedInput
  }

  export type AlternateItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type AlternateItemCreateManyInput = {
    id?: number
    alternateId: string
    lineItemId: number
  }

  export type AlternateItemUpdateManyMutationInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
    lineItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsCreateInput = {
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    extPlanId: string
    maxImages: number
    maxProjects: number
    maxSeats: number
    description: string
    period: string
    price: number
  }

  export type PlanEntitlementsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PlanEntitlementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extPlanId?: StringFieldUpdateOperationsInput | string
    maxImages?: IntFieldUpdateOperationsInput | number
    maxProjects?: IntFieldUpdateOperationsInput | number
    maxSeats?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CustomersCreateInput = {
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organization: OrganizationCreateNestedOneWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId: number
  }

  export type CustomersUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organization?: OrganizationUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomersCreateManyInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId: number
  }

  export type CustomersUpdateManyMutationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsCreateInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    prices?: PricesUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsCreateManyInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PricesCreateInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    product: ProductsCreateNestedOneWithoutPricesInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutPriceInput
  }

  export type PricesUncheckedCreateInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PricesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateOneRequiredWithoutPricesNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricesCreateManyInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PricesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsCreateInput = {
    id: string
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    price: PricesCreateNestedOneWithoutSubscriptionsInput
    organization: OrganizationCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateInput = {
    id: string
    organizationId: number
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: PricesUpdateOneRequiredWithoutSubscriptionsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsCreateManyInput = {
    id: string
    organizationId: number
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDashboardViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardViews | EnumDashboardViewsFieldRefInput<$PrismaModel>
    in?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumDashboardViewsFilter<$PrismaModel> | $Enums.DashboardViews
  }

  export type EnumPhotoViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoViews | EnumPhotoViewsFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoViewsFilter<$PrismaModel> | $Enums.PhotoViews
  }

  export type EnumGroupByViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupByViews | EnumGroupByViewsFieldRefInput<$PrismaModel>
    in?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupByViewsFilter<$PrismaModel> | $Enums.GroupByViews
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UserToOrganizationNullableScalarRelationFilter = {
    is?: UserToOrganizationWhereInput | null
    isNot?: UserToOrganizationWhereInput | null
  }

  export type UserToProjectListRelationFilter = {
    every?: UserToProjectWhereInput
    some?: UserToProjectWhereInput
    none?: UserToProjectWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ImageNoteListRelationFilter = {
    every?: ImageNoteWhereInput
    some?: ImageNoteWhereInput
    none?: ImageNoteWhereInput
  }

  export type AnnotationListRelationFilter = {
    every?: AnnotationWhereInput
    some?: AnnotationWhereInput
    none?: AnnotationWhereInput
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserToProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    productTourData?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    onboardingStatus?: SortOrder
    organizationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    organizationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    inviteId?: SortOrder
    isSupportUser?: SortOrder
    hasSeenProductTour?: SortOrder
    savedDashboardView?: SortOrder
    photoView?: SortOrder
    groupView?: SortOrder
    organizationId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumDashboardViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardViews | EnumDashboardViewsFieldRefInput<$PrismaModel>
    in?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumDashboardViewsWithAggregatesFilter<$PrismaModel> | $Enums.DashboardViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDashboardViewsFilter<$PrismaModel>
    _max?: NestedEnumDashboardViewsFilter<$PrismaModel>
  }

  export type EnumPhotoViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoViews | EnumPhotoViewsFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoViewsWithAggregatesFilter<$PrismaModel> | $Enums.PhotoViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhotoViewsFilter<$PrismaModel>
    _max?: NestedEnumPhotoViewsFilter<$PrismaModel>
  }

  export type EnumGroupByViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupByViews | EnumGroupByViewsFieldRefInput<$PrismaModel>
    in?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupByViewsWithAggregatesFilter<$PrismaModel> | $Enums.GroupByViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupByViewsFilter<$PrismaModel>
    _max?: NestedEnumGroupByViewsFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type OrganizationInvitationListRelationFilter = {
    every?: OrganizationInvitationWhereInput
    some?: OrganizationInvitationWhereInput
    none?: OrganizationInvitationWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type UserToOrganizationListRelationFilter = {
    every?: UserToOrganizationWhereInput
    some?: UserToOrganizationWhereInput
    none?: UserToOrganizationWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type SubscriptionsListRelationFilter = {
    every?: SubscriptionsWhereInput
    some?: SubscriptionsWhereInput
    none?: SubscriptionsWhereInput
  }

  export type OrganizationSavedOptionListRelationFilter = {
    every?: OrganizationSavedOptionWhereInput
    some?: OrganizationSavedOptionWhereInput
    none?: OrganizationSavedOptionWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type ProjectStatusValueListRelationFilter = {
    every?: ProjectStatusValueWhereInput
    some?: ProjectStatusValueWhereInput
    none?: ProjectStatusValueWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationSavedOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectStatusValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByRelevanceInput = {
    fields: OrganizationOrderByRelevanceFieldEnum | OrganizationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    address?: SortOrder
    faxNumber?: SortOrder
    size?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    logoId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type ProjectEquipmentListRelationFilter = {
    every?: ProjectEquipmentWhereInput
    some?: ProjectEquipmentWhereInput
    none?: ProjectEquipmentWhereInput
  }

  export type ProjectEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelevanceInput = {
    fields: EquipmentOrderByRelevanceFieldEnum | EquipmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isSeen?: SortOrder
    link?: SortOrder
    linkText?: SortOrder
    type?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumSavedOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SavedOptionType | EnumSavedOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavedOptionTypeFilter<$PrismaModel> | $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionOrderByRelevanceInput = {
    fields: OrganizationSavedOptionOrderByRelevanceFieldEnum | OrganizationSavedOptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganizationSavedOptionCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    label?: SortOrder
    value?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationSavedOptionSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumSavedOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SavedOptionType | EnumSavedOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavedOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SavedOptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSavedOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSavedOptionTypeFilter<$PrismaModel>
  }

  export type EnumAccessLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAccessLevelNullableFilter<$PrismaModel> | $Enums.AccessLevel | null
  }

  export type UserToOrganizationOrderByRelevanceInput = {
    fields: UserToOrganizationOrderByRelevanceFieldEnum | UserToOrganizationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserToOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type UserToOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    accessLevel?: SortOrder
    userId?: SortOrder
  }

  export type UserToOrganizationSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumAccessLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAccessLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelNullableFilter<$PrismaModel>
  }

  export type OrganizationInvitationOrderByRelevanceInput = {
    fields: OrganizationInvitationOrderByRelevanceFieldEnum | OrganizationInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganizationInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type OrganizationInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    invitationId?: SortOrder
    isAccepted?: SortOrder
  }

  export type OrganizationInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserToProjectOrderByRelevanceInput = {
    fields: UserToProjectOrderByRelevanceFieldEnum | UserToProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserToProjectUserIdProjectIdCompoundUniqueInput = {
    userId: string
    projectId: number
  }

  export type UserToProjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type UserToProjectSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProjectStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProjectStatusNullableFilter<$PrismaModel> | $Enums.ProjectStatus | null
  }

  export type InferenceListRelationFilter = {
    every?: InferenceWhereInput
    some?: InferenceWhereInput
    none?: InferenceWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type RoomReadingListRelationFilter = {
    every?: RoomReadingWhereInput
    some?: RoomReadingWhereInput
    none?: RoomReadingWhereInput
  }

  export type PropertyDataNullableScalarRelationFilter = {
    is?: PropertyDataWhereInput | null
    isNot?: PropertyDataWhereInput | null
  }

  export type AreaAffectedListRelationFilter = {
    every?: AreaAffectedWhereInput
    some?: AreaAffectedWhereInput
    none?: AreaAffectedWhereInput
  }

  export type PhotoAccessLinkListRelationFilter = {
    every?: PhotoAccessLinkWhereInput
    some?: PhotoAccessLinkWhereInput
    none?: PhotoAccessLinkWhereInput
  }

  export type NotesListRelationFilter = {
    every?: NotesWhereInput
    some?: NotesWhereInput
    none?: NotesWhereInput
  }

  export type CostListRelationFilter = {
    every?: CostWhereInput
    some?: CostWhereInput
    none?: CostWhereInput
  }

  export type WeatherReportItemListRelationFilter = {
    every?: WeatherReportItemWhereInput
    some?: WeatherReportItemWhereInput
    none?: WeatherReportItemWhereInput
  }

  export type ProjectStatusValueNullableScalarRelationFilter = {
    is?: ProjectStatusValueWhereInput | null
    isNot?: ProjectStatusValueWhereInput | null
  }

  export type PendingRoofReportsListRelationFilter = {
    every?: PendingRoofReportsWhereInput
    some?: PendingRoofReportsWhereInput
    none?: PendingRoofReportsWhereInput
  }

  export type ProjectNotesListRelationFilter = {
    every?: ProjectNotesWhereInput
    some?: ProjectNotesWhereInput
    none?: ProjectNotesWhereInput
  }

  export type InferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaAffectedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotoAccessLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeatherReportItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingRoofReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectNotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelevanceInput = {
    fields: ProjectOrderByRelevanceFieldEnum | ProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    roofSegments?: SortOrder
    roofSpecs?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    catCode?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    isDeleted?: SortOrder
    organizationId?: SortOrder
    assignmentNumber?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientPhoneNumber?: SortOrder
    companyName?: SortOrder
    managerName?: SortOrder
    adjusterEmail?: SortOrder
    adjusterName?: SortOrder
    adjusterPhoneNumber?: SortOrder
    insuranceCompanyName?: SortOrder
    insuranceClaimId?: SortOrder
    lossType?: SortOrder
    catCode?: SortOrder
    humidity?: SortOrder
    lastTimeWeatherFetched?: SortOrder
    temperature?: SortOrder
    wind?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    forecast?: SortOrder
    claimSummary?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    status?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    catCode?: SortOrder
    rcvValue?: SortOrder
    actualValue?: SortOrder
    projectStatusValueId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumProjectStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProjectStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProjectNotesOrderByRelevanceInput = {
    fields: ProjectNotesOrderByRelevanceFieldEnum | ProjectNotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectNotesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotesSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatusValueOrderByRelevanceInput = {
    fields: ProjectStatusValueOrderByRelevanceFieldEnum | ProjectStatusValueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectStatusValueOrganizationIdLabelCompoundUniqueInput = {
    organizationId: number
    label: string
  }

  export type ProjectStatusValueCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    color?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type ProjectStatusValueSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organizationId?: SortOrder
  }

  export type PendingRoofReportsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PendingRoofReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    isCompleted?: SortOrder
  }

  export type PendingRoofReportsSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type WeatherReportItemOrderByRelevanceInput = {
    fields: WeatherReportItemOrderByRelevanceFieldEnum | WeatherReportItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WeatherReportItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type WeatherReportItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    f_scale?: SortOrder
    speed?: SortOrder
    size?: SortOrder
    location?: SortOrder
    county?: SortOrder
    state?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    comments?: SortOrder
  }

  export type WeatherReportItemSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type ProjectEquipmentOrderByRelevanceInput = {
    fields: ProjectEquipmentOrderByRelevanceFieldEnum | ProjectEquipmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectEquipmentEquipmentIdProjectIdCompoundUniqueInput = {
    equipmentId: number
    projectId: number
  }

  export type ProjectEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type ProjectEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    projectId?: SortOrder
    equipmentId?: SortOrder
  }

  export type EnumCostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeFilter<$PrismaModel> | $Enums.CostType
  }

  export type CostOrderByRelevanceInput = {
    fields: CostOrderByRelevanceFieldEnum | CostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    projectId?: SortOrder
  }

  export type CostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
  }

  export type CostSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
    projectId?: SortOrder
  }

  export type EnumCostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeWithAggregatesFilter<$PrismaModel> | $Enums.CostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostTypeFilter<$PrismaModel>
    _max?: NestedEnumCostTypeFilter<$PrismaModel>
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type PropertyDataOrderByRelevanceInput = {
    fields: PropertyDataOrderByRelevanceFieldEnum | PropertyDataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PropertyDataCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
    data?: SortOrder
  }

  export type PropertyDataAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
  }

  export type PropertyDataMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
  }

  export type PropertyDataMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
    realtyMoleId?: SortOrder
  }

  export type PropertyDataSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    squareFootage?: SortOrder
  }

  export type DataDeletionRequestOrderByRelevanceInput = {
    fields: DataDeletionRequestOrderByRelevanceFieldEnum | DataDeletionRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DataDeletionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DataDeletionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
  }

  export type DataDeletionRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PhotoAccessLinkOrderByRelevanceInput = {
    fields: PhotoAccessLinkOrderByRelevanceFieldEnum | PhotoAccessLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PhotoAccessLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    accessId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    projectId?: SortOrder
  }

  export type PhotoAccessLinkSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type InferenceNullableScalarRelationFilter = {
    is?: InferenceWhereInput | null
    isNot?: InferenceWhereInput | null
  }

  export type ImageOrderByRelevanceInput = {
    fields: ImageOrderByRelevanceFieldEnum | ImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    key?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    includeInReport?: SortOrder
    description?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ImageScalarRelationFilter = {
    is?: ImageWhereInput
    isNot?: ImageWhereInput
  }

  export type AnnotationOrderByRelevanceInput = {
    fields: AnnotationOrderByRelevanceFieldEnum | AnnotationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    coordinates?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type AnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ImageNoteOrderByRelevanceInput = {
    fields: ImageNoteOrderByRelevanceFieldEnum | ImageNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImageNoteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    mentions?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type ImageNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageId?: SortOrder
    body?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
  }

  export type ImageNoteSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type ImageNullableScalarRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type RoomNullableScalarRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type DetectionListRelationFilter = {
    every?: DetectionWhereInput
    some?: DetectionWhereInput
    none?: DetectionWhereInput
  }

  export type DetectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InferenceOrderByRelevanceInput = {
    fields: InferenceOrderByRelevanceFieldEnum | InferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InferenceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    imageId?: SortOrder
    imageKey?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type InferenceSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedListRelationFilter = {
    every?: TemplatesUsedWhereInput
    some?: TemplatesUsedWhereInput
    none?: TemplatesUsedWhereInput
  }

  export type TemplatesUsedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelevanceInput = {
    fields: RoomOrderByRelevanceFieldEnum | RoomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
    equipmentUsed?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
    humidity?: SortOrder
    dehuReading?: SortOrder
    temperature?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    totalSqft?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    windows?: SortOrder
    doors?: SortOrder
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type GenericRoomReadingListRelationFilter = {
    every?: GenericRoomReadingWhereInput
    some?: GenericRoomReadingWhereInput
    none?: GenericRoomReadingWhereInput
  }

  export type GenericRoomReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomReadingOrderByRelevanceInput = {
    fields: RoomReadingOrderByRelevanceFieldEnum | RoomReadingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomReadingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    equipmentUsed?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type RoomReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    moistureContentWall?: SortOrder
    moistureContentFloor?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    gpp?: SortOrder
  }

  export type RoomReadingSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type NotesAuditTrailListRelationFilter = {
    every?: NotesAuditTrailWhereInput
    some?: NotesAuditTrailWhereInput
    none?: NotesAuditTrailWhereInput
  }

  export type NotesAuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelevanceInput = {
    fields: NotesOrderByRelevanceFieldEnum | NotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type NotesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    body?: SortOrder
  }

  export type NotesSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    projectId?: SortOrder
  }

  export type EnumNotesAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.NotesAuditAction | EnumNotesAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotesAuditActionFilter<$PrismaModel> | $Enums.NotesAuditAction
  }

  export type NotesScalarRelationFilter = {
    is?: NotesWhereInput
    isNot?: NotesWhereInput
  }

  export type NotesAuditTrailOrderByRelevanceInput = {
    fields: NotesAuditTrailOrderByRelevanceFieldEnum | NotesAuditTrailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotesAuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailAvgOrderByAggregateInput = {
    id?: SortOrder
    notesId?: SortOrder
  }

  export type NotesAuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    notesId?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    body?: SortOrder
  }

  export type NotesAuditTrailSumOrderByAggregateInput = {
    id?: SortOrder
    notesId?: SortOrder
  }

  export type EnumNotesAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotesAuditAction | EnumNotesAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotesAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.NotesAuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotesAuditActionFilter<$PrismaModel>
    _max?: NestedEnumNotesAuditActionFilter<$PrismaModel>
  }

  export type EnumAreaAffectedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaAffectedType | EnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAreaAffectedTypeFilter<$PrismaModel> | $Enums.AreaAffectedType
  }

  export type AreaAffectedOrderByRelevanceInput = {
    fields: AreaAffectedOrderByRelevanceFieldEnum | AreaAffectedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AreaAffectedTypeRoomIdCompoundUniqueInput = {
    type: $Enums.AreaAffectedType
    roomId: number
  }

  export type AreaAffectedCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    category?: SortOrder
    projectId?: SortOrder
  }

  export type AreaAffectedMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    roomId?: SortOrder
    material?: SortOrder
    totalAreaRemoved?: SortOrder
    totalAreaMicrobialApplied?: SortOrder
    cause?: SortOrder
    category?: SortOrder
    cabinetryRemoved?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type AreaAffectedSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    category?: SortOrder
    projectId?: SortOrder
  }

  export type EnumAreaAffectedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaAffectedType | EnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAreaAffectedTypeWithAggregatesFilter<$PrismaModel> | $Enums.AreaAffectedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaAffectedTypeFilter<$PrismaModel>
    _max?: NestedEnumAreaAffectedTypeFilter<$PrismaModel>
  }

  export type EnumRoomReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomReadingType | EnumRoomReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomReadingTypeFilter<$PrismaModel> | $Enums.RoomReadingType
  }

  export type RoomReadingScalarRelationFilter = {
    is?: RoomReadingWhereInput
    isNot?: RoomReadingWhereInput
  }

  export type GenericRoomReadingOrderByRelevanceInput = {
    fields: GenericRoomReadingOrderByRelevanceFieldEnum | GenericRoomReadingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GenericRoomReadingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomReadingId?: SortOrder
  }

  export type GenericRoomReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    publicId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    humidity?: SortOrder
    temperature?: SortOrder
    gpp?: SortOrder
    roomReadingId?: SortOrder
    isDeleted?: SortOrder
  }

  export type GenericRoomReadingSumOrderByAggregateInput = {
    id?: SortOrder
    roomReadingId?: SortOrder
  }

  export type EnumRoomReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomReadingType | EnumRoomReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomReadingTypeFilter<$PrismaModel>
  }

  export type EnumDimensionUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDimensionUnitNullableFilter<$PrismaModel> | $Enums.DimensionUnit | null
  }

  export type InferenceScalarRelationFilter = {
    is?: InferenceWhereInput
    isNot?: InferenceWhereInput
  }

  export type DetectionOrderByRelevanceInput = {
    fields: DetectionOrderByRelevanceFieldEnum | DetectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DetectionProjectIdCategoryCodeRoomIdCompoundUniqueInput = {
    projectId: number
    category: string
    code: string
    roomId: number
  }

  export type DetectionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionAvgOrderByAggregateInput = {
    id?: SortOrder
    inferenceId?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
  }

  export type DetectionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    publicId?: SortOrder
    inferenceId?: SortOrder
    imageKey?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    item?: SortOrder
    quality?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
    unit?: SortOrder
  }

  export type DetectionSumOrderByAggregateInput = {
    id?: SortOrder
    inferenceId?: SortOrder
    xMinCord?: SortOrder
    yMinCord?: SortOrder
    confidence?: SortOrder
    xMaxCord?: SortOrder
    yMaxCord?: SortOrder
    projectId?: SortOrder
    roomId?: SortOrder
    dimension?: SortOrder
  }

  export type EnumDimensionUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDimensionUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitNullableFilter<$PrismaModel>
  }

  export type TemplatesUsedOrderByRelevanceInput = {
    fields: TemplatesUsedOrderByRelevanceFieldEnum | TemplatesUsedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TemplatesUsedCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    templateCode?: SortOrder
    roomId?: SortOrder
  }

  export type TemplatesUsedSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type WaitListOrderByRelevanceInput = {
    fields: WaitListOrderByRelevanceFieldEnum | WaitListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WaitListCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaitListMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
  }

  export type WaitListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RekognitionRunsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RekognitionRunsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type RekognitionRunsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CalendarEventReminderListRelationFilter = {
    every?: CalendarEventReminderWhereInput
    some?: CalendarEventReminderWhereInput
    none?: CalendarEventReminderWhereInput
  }

  export type CalendarEventReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelevanceInput = {
    fields: CalendarEventOrderByRelevanceFieldEnum | CalendarEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    payload?: SortOrder
    projectId?: SortOrder
    date?: SortOrder
    dynamicId?: SortOrder
    isDeleted?: SortOrder
    remindClient?: SortOrder
    remindProjectOwners?: SortOrder
  }

  export type CalendarEventSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EnumReminderTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderTarget | EnumReminderTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTargetFilter<$PrismaModel> | $Enums.ReminderTarget
  }

  export type CalendarEventNullableScalarRelationFilter = {
    is?: CalendarEventWhereInput | null
    isNot?: CalendarEventWhereInput | null
  }

  export type CalendarEventReminderCountOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderAvgOrderByAggregateInput = {
    id?: SortOrder
    calendarEventId?: SortOrder
  }

  export type CalendarEventReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderMinOrderByAggregateInput = {
    id?: SortOrder
    reminderTarget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendText?: SortOrder
    sendEmail?: SortOrder
    textSentAt?: SortOrder
    emailSentAt?: SortOrder
    calendarEventId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEventReminderSumOrderByAggregateInput = {
    id?: SortOrder
    calendarEventId?: SortOrder
  }

  export type EnumReminderTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderTarget | EnumReminderTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTargetWithAggregatesFilter<$PrismaModel> | $Enums.ReminderTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTargetFilter<$PrismaModel>
    _max?: NestedEnumReminderTargetFilter<$PrismaModel>
  }

  export type LineItemListRelationFilter = {
    every?: LineItemWhereInput
    some?: LineItemWhereInput
    none?: LineItemWhereInput
  }

  export type LineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryOrderByRelevanceInput = {
    fields: ItemCategoryOrderByRelevanceFieldEnum | ItemCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    xactimateKey?: SortOrder
    xactimateDescription?: SortOrder
    hasItems?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ItemCategoryScalarRelationFilter = {
    is?: ItemCategoryWhereInput
    isNot?: ItemCategoryWhereInput
  }

  export type AlternateItemListRelationFilter = {
    every?: AlternateItemWhereInput
    some?: AlternateItemWhereInput
    none?: AlternateItemWhereInput
  }

  export type RelatedItemListRelationFilter = {
    every?: RelatedItemWhereInput
    some?: RelatedItemWhereInput
    none?: RelatedItemWhereInput
  }

  export type AlternateItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelatedItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineItemOrderByRelevanceInput = {
    fields: LineItemOrderByRelevanceFieldEnum | LineItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LineItemItemCategoryIdXactimateCodeCompoundUniqueInput = {
    itemCategoryId: number
    xactimateCode: string
  }

  export type LineItemCountOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemAvgOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemMinOrderByAggregateInput = {
    id?: SortOrder
    xactimateCode?: SortOrder
    xactimateDescription?: SortOrder
    unit?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemSumOrderByAggregateInput = {
    id?: SortOrder
    itemCategoryId?: SortOrder
  }

  export type LineItemScalarRelationFilter = {
    is?: LineItemWhereInput
    isNot?: LineItemWhereInput
  }

  export type RelatedItemOrderByRelevanceInput = {
    fields: RelatedItemOrderByRelevanceFieldEnum | RelatedItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelatedItemCountOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemAvgOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemMaxOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemMinOrderByAggregateInput = {
    id?: SortOrder
    relationId?: SortOrder
    lineItemId?: SortOrder
  }

  export type RelatedItemSumOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemOrderByRelevanceInput = {
    fields: AlternateItemOrderByRelevanceFieldEnum | AlternateItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AlternateItemCountOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemAvgOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemMaxOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemMinOrderByAggregateInput = {
    id?: SortOrder
    alternateId?: SortOrder
    lineItemId?: SortOrder
  }

  export type AlternateItemSumOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
  }

  export type PlanEntitlementsOrderByRelevanceInput = {
    fields: PlanEntitlementsOrderByRelevanceFieldEnum | PlanEntitlementsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanEntitlementsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsAvgOrderByAggregateInput = {
    id?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    extPlanId?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    description?: SortOrder
    period?: SortOrder
    price?: SortOrder
  }

  export type PlanEntitlementsSumOrderByAggregateInput = {
    id?: SortOrder
    maxImages?: SortOrder
    maxProjects?: SortOrder
    maxSeats?: SortOrder
    price?: SortOrder
  }

  export type CustomersOrderByRelevanceInput = {
    fields: CustomersOrderByRelevanceFieldEnum | CustomersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    billingAddress?: SortOrder
    paymentMethod?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    organizationId?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type PricesListRelationFilter = {
    every?: PricesWhereInput
    some?: PricesWhereInput
    none?: PricesWhereInput
  }

  export type PricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsOrderByRelevanceInput = {
    fields: ProductsOrderByRelevanceFieldEnum | ProductsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type EnumPricingPlanIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingPlanInterval | EnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel> | $Enums.PricingPlanInterval | null
  }

  export type ProductsScalarRelationFilter = {
    is?: ProductsWhereInput
    isNot?: ProductsWhereInput
  }

  export type PricesOrderByRelevanceInput = {
    fields: PricesOrderByRelevanceFieldEnum | PricesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PricesCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    metadata?: SortOrder
    description?: SortOrder
  }

  export type PricesAvgOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type PricesMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    description?: SortOrder
  }

  export type PricesMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    unitAmount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    description?: SortOrder
  }

  export type PricesSumOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type EnumPricingPlanIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingPlanInterval | EnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingPlanIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricingPlanInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type PricesScalarRelationFilter = {
    is?: PricesWhereInput
    isNot?: PricesWhereInput
  }

  export type SubscriptionsOrderByRelevanceInput = {
    fields: SubscriptionsOrderByRelevanceFieldEnum | SubscriptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    quantity?: SortOrder
  }

  export type SubscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    pricesId?: SortOrder
    quantity?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    created?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    endedAt?: SortOrder
    cancelAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
  }

  export type SubscriptionsSumOrderByAggregateInput = {
    organizationId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type UserToOrganizationCreateNestedOneWithoutUserInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    connect?: UserToOrganizationWhereUniqueInput
  }

  export type UserToProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput> | UserToProjectCreateWithoutUserInput[] | UserToProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutUserInput | UserToProjectCreateOrConnectWithoutUserInput[]
    createMany?: UserToProjectCreateManyUserInputEnvelope
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ImageNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput> | ImageNoteCreateWithoutUserInput[] | ImageNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutUserInput | ImageNoteCreateOrConnectWithoutUserInput[]
    createMany?: ImageNoteCreateManyUserInputEnvelope
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
  }

  export type AnnotationCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserToOrganizationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    connect?: UserToOrganizationWhereUniqueInput
  }

  export type UserToProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput> | UserToProjectCreateWithoutUserInput[] | UserToProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutUserInput | UserToProjectCreateOrConnectWithoutUserInput[]
    createMany?: UserToProjectCreateManyUserInputEnvelope
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ImageNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput> | ImageNoteCreateWithoutUserInput[] | ImageNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutUserInput | ImageNoteCreateOrConnectWithoutUserInput[]
    createMany?: ImageNoteCreateManyUserInputEnvelope
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
  }

  export type AnnotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumDashboardViewsFieldUpdateOperationsInput = {
    set?: $Enums.DashboardViews
  }

  export type EnumPhotoViewsFieldUpdateOperationsInput = {
    set?: $Enums.PhotoViews
  }

  export type EnumGroupByViewsFieldUpdateOperationsInput = {
    set?: $Enums.GroupByViews
  }

  export type UserToOrganizationUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    upsert?: UserToOrganizationUpsertWithoutUserInput
    disconnect?: UserToOrganizationWhereInput | boolean
    delete?: UserToOrganizationWhereInput | boolean
    connect?: UserToOrganizationWhereUniqueInput
    update?: XOR<XOR<UserToOrganizationUpdateToOneWithWhereWithoutUserInput, UserToOrganizationUpdateWithoutUserInput>, UserToOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput> | UserToProjectCreateWithoutUserInput[] | UserToProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutUserInput | UserToProjectCreateOrConnectWithoutUserInput[]
    upsert?: UserToProjectUpsertWithWhereUniqueWithoutUserInput | UserToProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToProjectCreateManyUserInputEnvelope
    set?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    disconnect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    delete?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    update?: UserToProjectUpdateWithWhereUniqueWithoutUserInput | UserToProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToProjectUpdateManyWithWhereWithoutUserInput | UserToProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ImageNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput> | ImageNoteCreateWithoutUserInput[] | ImageNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutUserInput | ImageNoteCreateOrConnectWithoutUserInput[]
    upsert?: ImageNoteUpsertWithWhereUniqueWithoutUserInput | ImageNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImageNoteCreateManyUserInputEnvelope
    set?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    disconnect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    delete?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    update?: ImageNoteUpdateWithWhereUniqueWithoutUserInput | ImageNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImageNoteUpdateManyWithWhereWithoutUserInput | ImageNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
  }

  export type AnnotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type OrganizationUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    upsert?: OrganizationUpsertWithoutUserInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUserInput, OrganizationUpdateWithoutUserInput>, OrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutUserInput
    upsert?: UserToOrganizationUpsertWithoutUserInput
    disconnect?: UserToOrganizationWhereInput | boolean
    delete?: UserToOrganizationWhereInput | boolean
    connect?: UserToOrganizationWhereUniqueInput
    update?: XOR<XOR<UserToOrganizationUpdateToOneWithWhereWithoutUserInput, UserToOrganizationUpdateWithoutUserInput>, UserToOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput> | UserToProjectCreateWithoutUserInput[] | UserToProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutUserInput | UserToProjectCreateOrConnectWithoutUserInput[]
    upsert?: UserToProjectUpsertWithWhereUniqueWithoutUserInput | UserToProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToProjectCreateManyUserInputEnvelope
    set?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    disconnect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    delete?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    update?: UserToProjectUpdateWithWhereUniqueWithoutUserInput | UserToProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToProjectUpdateManyWithWhereWithoutUserInput | UserToProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ImageNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput> | ImageNoteCreateWithoutUserInput[] | ImageNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutUserInput | ImageNoteCreateOrConnectWithoutUserInput[]
    upsert?: ImageNoteUpsertWithWhereUniqueWithoutUserInput | ImageNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImageNoteCreateManyUserInputEnvelope
    set?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    disconnect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    delete?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    update?: ImageNoteUpdateWithWhereUniqueWithoutUserInput | ImageNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImageNoteUpdateManyWithWhereWithoutUserInput | ImageNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
  }

  export type AnnotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type ImageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput> | ImageCreateWithoutOrganizationInput[] | ImageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutOrganizationInput | ImageCreateOrConnectWithoutOrganizationInput[]
    createMany?: ImageCreateManyOrganizationInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type OrganizationInvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserToOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput> | UserToOrganizationCreateWithoutOrganizationInput[] | UserToOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutOrganizationInput | UserToOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
  }

  export type CustomersCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput> | CustomersCreateWithoutOrganizationInput[] | CustomersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutOrganizationInput | CustomersCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type SubscriptionsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput> | SubscriptionsCreateWithoutOrganizationInput[] | SubscriptionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutOrganizationInput | SubscriptionsCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput> | OrganizationSavedOptionCreateWithoutOrganizationInput[] | OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput | OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    connect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput> | EquipmentCreateWithoutOrganizationInput[] | EquipmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutOrganizationInput | EquipmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type ProjectStatusValueCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput> | ProjectStatusValueCreateWithoutOrganizationInput[] | ProjectStatusValueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutOrganizationInput | ProjectStatusValueCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    connect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput> | ImageCreateWithoutOrganizationInput[] | ImageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutOrganizationInput | ImageCreateOrConnectWithoutOrganizationInput[]
    createMany?: ImageCreateManyOrganizationInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput> | UserToOrganizationCreateWithoutOrganizationInput[] | UserToOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutOrganizationInput | UserToOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput> | CustomersCreateWithoutOrganizationInput[] | CustomersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutOrganizationInput | CustomersCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput> | SubscriptionsCreateWithoutOrganizationInput[] | SubscriptionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutOrganizationInput | SubscriptionsCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput> | OrganizationSavedOptionCreateWithoutOrganizationInput[] | OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput | OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    connect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput> | EquipmentCreateWithoutOrganizationInput[] | EquipmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutOrganizationInput | EquipmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput> | ProjectStatusValueCreateWithoutOrganizationInput[] | ProjectStatusValueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutOrganizationInput | ProjectStatusValueCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    connect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ImageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput> | ImageCreateWithoutOrganizationInput[] | ImageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutOrganizationInput | ImageCreateOrConnectWithoutOrganizationInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutOrganizationInput | ImageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ImageCreateManyOrganizationInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutOrganizationInput | ImageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutOrganizationInput | ImageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type OrganizationInvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    disconnect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    delete?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    update?: OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput | OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserToOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput> | UserToOrganizationCreateWithoutOrganizationInput[] | UserToOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutOrganizationInput | UserToOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    set?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    disconnect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    delete?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    connect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    update?: UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserToOrganizationScalarWhereInput | UserToOrganizationScalarWhereInput[]
  }

  export type CustomersUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput> | CustomersCreateWithoutOrganizationInput[] | CustomersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutOrganizationInput | CustomersCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutOrganizationInput | CustomersUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutOrganizationInput | CustomersUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutOrganizationInput | CustomersUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type SubscriptionsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput> | SubscriptionsCreateWithoutOrganizationInput[] | SubscriptionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutOrganizationInput | SubscriptionsCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput | SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput | SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutOrganizationInput | SubscriptionsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput> | OrganizationSavedOptionCreateWithoutOrganizationInput[] | OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput | OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    set?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    disconnect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    delete?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    connect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    update?: OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput | OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationSavedOptionScalarWhereInput | OrganizationSavedOptionScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput> | EquipmentCreateWithoutOrganizationInput[] | EquipmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutOrganizationInput | EquipmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutOrganizationInput | EquipmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutOrganizationInput | EquipmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutOrganizationInput | EquipmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type ProjectStatusValueUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput> | ProjectStatusValueCreateWithoutOrganizationInput[] | ProjectStatusValueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutOrganizationInput | ProjectStatusValueCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput | ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    set?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    disconnect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    delete?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    connect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    update?: ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput | ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput | ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectStatusValueScalarWhereInput | ProjectStatusValueScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ImageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput> | ImageCreateWithoutOrganizationInput[] | ImageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutOrganizationInput | ImageCreateOrConnectWithoutOrganizationInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutOrganizationInput | ImageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ImageCreateManyOrganizationInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutOrganizationInput | ImageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutOrganizationInput | ImageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    disconnect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    delete?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    update?: OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput | OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput> | UserToOrganizationCreateWithoutOrganizationInput[] | UserToOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserToOrganizationCreateOrConnectWithoutOrganizationInput | UserToOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserToOrganizationCreateManyOrganizationInputEnvelope
    set?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    disconnect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    delete?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    connect?: UserToOrganizationWhereUniqueInput | UserToOrganizationWhereUniqueInput[]
    update?: UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserToOrganizationScalarWhereInput | UserToOrganizationScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput> | CustomersCreateWithoutOrganizationInput[] | CustomersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutOrganizationInput | CustomersCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutOrganizationInput | CustomersUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomersCreateManyOrganizationInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutOrganizationInput | CustomersUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutOrganizationInput | CustomersUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput> | SubscriptionsCreateWithoutOrganizationInput[] | SubscriptionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutOrganizationInput | SubscriptionsCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput | SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriptionsCreateManyOrganizationInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput | SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutOrganizationInput | SubscriptionsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput> | OrganizationSavedOptionCreateWithoutOrganizationInput[] | OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput | OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationSavedOptionCreateManyOrganizationInputEnvelope
    set?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    disconnect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    delete?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    connect?: OrganizationSavedOptionWhereUniqueInput | OrganizationSavedOptionWhereUniqueInput[]
    update?: OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput | OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationSavedOptionScalarWhereInput | OrganizationSavedOptionScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput> | EquipmentCreateWithoutOrganizationInput[] | EquipmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutOrganizationInput | EquipmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutOrganizationInput | EquipmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EquipmentCreateManyOrganizationInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutOrganizationInput | EquipmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutOrganizationInput | EquipmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput> | ProjectStatusValueCreateWithoutOrganizationInput[] | ProjectStatusValueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutOrganizationInput | ProjectStatusValueCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput | ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectStatusValueCreateManyOrganizationInputEnvelope
    set?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    disconnect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    delete?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    connect?: ProjectStatusValueWhereUniqueInput | ProjectStatusValueWhereUniqueInput[]
    update?: ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput | ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput | ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectStatusValueScalarWhereInput | ProjectStatusValueScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEquipmentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectEquipmentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput> | ProjectEquipmentCreateWithoutEquipmentInput[] | ProjectEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutEquipmentInput | ProjectEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
  }

  export type ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput> | ProjectEquipmentCreateWithoutEquipmentInput[] | ProjectEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutEquipmentInput | ProjectEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEquipmentInput
    upsert?: OrganizationUpsertWithoutEquipmentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEquipmentInput, OrganizationUpdateWithoutEquipmentInput>, OrganizationUncheckedUpdateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput> | ProjectEquipmentCreateWithoutEquipmentInput[] | ProjectEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutEquipmentInput | ProjectEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    set?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    disconnect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    delete?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    update?: ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput | ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput> | ProjectEquipmentCreateWithoutEquipmentInput[] | ProjectEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutEquipmentInput | ProjectEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: ProjectEquipmentCreateManyEquipmentInputEnvelope
    set?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    disconnect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    delete?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    update?: ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput | ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type OrganizationCreateNestedOneWithoutOrganizationSavedOptionInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSavedOptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SavedOptionType
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationSavedOptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput
    upsert?: OrganizationUpsertWithoutOrganizationSavedOptionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationSavedOptionInput, OrganizationUpdateWithoutOrganizationSavedOptionInput>, OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel | null
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput
    upsert?: UserUpsertWithoutOrgInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrgInput, UserUpdateWithoutOrgInput>, UserUncheckedUpdateWithoutOrgInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutUserToProjectInput = {
    create?: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToProjectInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectAssigneesInput = {
    create?: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAssigneesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserToProjectNestedInput = {
    create?: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToProjectInput
    upsert?: UserUpsertWithoutUserToProjectInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserToProjectInput, UserUpdateWithoutUserToProjectInput>, UserUncheckedUpdateWithoutUserToProjectInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectAssigneesInput
    upsert?: ProjectUpsertWithoutProjectAssigneesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectAssigneesInput, ProjectUpdateWithoutProjectAssigneesInput>, ProjectUncheckedUpdateWithoutProjectAssigneesInput>
  }

  export type ProjectCreateroofSegmentsInput = {
    set: InputJsonValue[]
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutProjectInput = {
    create?: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput> | ImageCreateWithoutProjectInput[] | ImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProjectInput | ImageCreateOrConnectWithoutProjectInput[]
    createMany?: ImageCreateManyProjectInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type InferenceCreateNestedManyWithoutProjectInput = {
    create?: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput> | InferenceCreateWithoutProjectInput[] | InferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutProjectInput | InferenceCreateOrConnectWithoutProjectInput[]
    createMany?: InferenceCreateManyProjectInputEnvelope
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput> | RoomCreateWithoutProjectInput[] | RoomUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProjectInput | RoomCreateOrConnectWithoutProjectInput[]
    createMany?: RoomCreateManyProjectInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type UserToProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput> | UserToProjectCreateWithoutProjectInput[] | UserToProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutProjectInput | UserToProjectCreateOrConnectWithoutProjectInput[]
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
  }

  export type RoomReadingCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput> | RoomReadingCreateWithoutProjectInput[] | RoomReadingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutProjectInput | RoomReadingCreateOrConnectWithoutProjectInput[]
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
  }

  export type PropertyDataCreateNestedOneWithoutProjectInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    connect?: PropertyDataWhereUniqueInput
  }

  export type AreaAffectedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput> | AreaAffectedCreateWithoutProjectInput[] | AreaAffectedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutProjectInput | AreaAffectedCreateOrConnectWithoutProjectInput[]
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
  }

  export type PhotoAccessLinkCreateNestedManyWithoutProjectInput = {
    create?: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput> | PhotoAccessLinkCreateWithoutProjectInput[] | PhotoAccessLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PhotoAccessLinkCreateOrConnectWithoutProjectInput | PhotoAccessLinkCreateOrConnectWithoutProjectInput[]
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    connect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
  }

  export type NotesCreateNestedManyWithoutProjectInput = {
    create?: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput> | NotesCreateWithoutProjectInput[] | NotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutProjectInput | NotesCreateOrConnectWithoutProjectInput[]
    createMany?: NotesCreateManyProjectInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type CostCreateNestedManyWithoutProjectInput = {
    create?: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput> | CostCreateWithoutProjectInput[] | CostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostCreateOrConnectWithoutProjectInput | CostCreateOrConnectWithoutProjectInput[]
    createMany?: CostCreateManyProjectInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type ProjectEquipmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput> | ProjectEquipmentCreateWithoutProjectInput[] | ProjectEquipmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutProjectInput | ProjectEquipmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
  }

  export type WeatherReportItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput> | WeatherReportItemCreateWithoutProjectInput[] | WeatherReportItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WeatherReportItemCreateOrConnectWithoutProjectInput | WeatherReportItemCreateOrConnectWithoutProjectInput[]
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    connect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
  }

  export type ProjectStatusValueCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutProjectsInput
    connect?: ProjectStatusValueWhereUniqueInput
  }

  export type PendingRoofReportsCreateNestedManyWithoutProjectInput = {
    create?: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput> | PendingRoofReportsCreateWithoutProjectInput[] | PendingRoofReportsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PendingRoofReportsCreateOrConnectWithoutProjectInput | PendingRoofReportsCreateOrConnectWithoutProjectInput[]
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    connect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
  }

  export type ProjectNotesCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput> | ProjectNotesCreateWithoutProjectInput[] | ProjectNotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotesCreateOrConnectWithoutProjectInput | ProjectNotesCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    connect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput> | ImageCreateWithoutProjectInput[] | ImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProjectInput | ImageCreateOrConnectWithoutProjectInput[]
    createMany?: ImageCreateManyProjectInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type InferenceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput> | InferenceCreateWithoutProjectInput[] | InferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutProjectInput | InferenceCreateOrConnectWithoutProjectInput[]
    createMany?: InferenceCreateManyProjectInputEnvelope
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput> | RoomCreateWithoutProjectInput[] | RoomUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProjectInput | RoomCreateOrConnectWithoutProjectInput[]
    createMany?: RoomCreateManyProjectInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type UserToProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput> | UserToProjectCreateWithoutProjectInput[] | UserToProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutProjectInput | UserToProjectCreateOrConnectWithoutProjectInput[]
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
  }

  export type RoomReadingUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput> | RoomReadingCreateWithoutProjectInput[] | RoomReadingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutProjectInput | RoomReadingCreateOrConnectWithoutProjectInput[]
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
  }

  export type PropertyDataUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    connect?: PropertyDataWhereUniqueInput
  }

  export type AreaAffectedUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput> | AreaAffectedCreateWithoutProjectInput[] | AreaAffectedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutProjectInput | AreaAffectedCreateOrConnectWithoutProjectInput[]
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
  }

  export type PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput> | PhotoAccessLinkCreateWithoutProjectInput[] | PhotoAccessLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PhotoAccessLinkCreateOrConnectWithoutProjectInput | PhotoAccessLinkCreateOrConnectWithoutProjectInput[]
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    connect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput> | NotesCreateWithoutProjectInput[] | NotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutProjectInput | NotesCreateOrConnectWithoutProjectInput[]
    createMany?: NotesCreateManyProjectInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type CostUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput> | CostCreateWithoutProjectInput[] | CostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostCreateOrConnectWithoutProjectInput | CostCreateOrConnectWithoutProjectInput[]
    createMany?: CostCreateManyProjectInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput> | ProjectEquipmentCreateWithoutProjectInput[] | ProjectEquipmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutProjectInput | ProjectEquipmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
  }

  export type WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput> | WeatherReportItemCreateWithoutProjectInput[] | WeatherReportItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WeatherReportItemCreateOrConnectWithoutProjectInput | WeatherReportItemCreateOrConnectWithoutProjectInput[]
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    connect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
  }

  export type PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput> | PendingRoofReportsCreateWithoutProjectInput[] | PendingRoofReportsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PendingRoofReportsCreateOrConnectWithoutProjectInput | PendingRoofReportsCreateOrConnectWithoutProjectInput[]
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    connect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
  }

  export type ProjectNotesUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput> | ProjectNotesCreateWithoutProjectInput[] | ProjectNotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotesCreateOrConnectWithoutProjectInput | ProjectNotesCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    connect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateroofSegmentsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus | null
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type ImageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput> | ImageCreateWithoutProjectInput[] | ImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProjectInput | ImageCreateOrConnectWithoutProjectInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutProjectInput | ImageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ImageCreateManyProjectInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutProjectInput | ImageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutProjectInput | ImageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type InferenceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput> | InferenceCreateWithoutProjectInput[] | InferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutProjectInput | InferenceCreateOrConnectWithoutProjectInput[]
    upsert?: InferenceUpsertWithWhereUniqueWithoutProjectInput | InferenceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InferenceCreateManyProjectInputEnvelope
    set?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    disconnect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    delete?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    update?: InferenceUpdateWithWhereUniqueWithoutProjectInput | InferenceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InferenceUpdateManyWithWhereWithoutProjectInput | InferenceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput> | RoomCreateWithoutProjectInput[] | RoomUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProjectInput | RoomCreateOrConnectWithoutProjectInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutProjectInput | RoomUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoomCreateManyProjectInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutProjectInput | RoomUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutProjectInput | RoomUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutProjectInput | CalendarEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutProjectInput | CalendarEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutProjectInput | CalendarEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type UserToProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput> | UserToProjectCreateWithoutProjectInput[] | UserToProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutProjectInput | UserToProjectCreateOrConnectWithoutProjectInput[]
    upsert?: UserToProjectUpsertWithWhereUniqueWithoutProjectInput | UserToProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    set?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    disconnect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    delete?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    update?: UserToProjectUpdateWithWhereUniqueWithoutProjectInput | UserToProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UserToProjectUpdateManyWithWhereWithoutProjectInput | UserToProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
  }

  export type RoomReadingUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput> | RoomReadingCreateWithoutProjectInput[] | RoomReadingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutProjectInput | RoomReadingCreateOrConnectWithoutProjectInput[]
    upsert?: RoomReadingUpsertWithWhereUniqueWithoutProjectInput | RoomReadingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    set?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    disconnect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    delete?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    update?: RoomReadingUpdateWithWhereUniqueWithoutProjectInput | RoomReadingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoomReadingUpdateManyWithWhereWithoutProjectInput | RoomReadingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
  }

  export type PropertyDataUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    upsert?: PropertyDataUpsertWithoutProjectInput
    disconnect?: PropertyDataWhereInput | boolean
    delete?: PropertyDataWhereInput | boolean
    connect?: PropertyDataWhereUniqueInput
    update?: XOR<XOR<PropertyDataUpdateToOneWithWhereWithoutProjectInput, PropertyDataUpdateWithoutProjectInput>, PropertyDataUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput> | AreaAffectedCreateWithoutProjectInput[] | AreaAffectedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutProjectInput | AreaAffectedCreateOrConnectWithoutProjectInput[]
    upsert?: AreaAffectedUpsertWithWhereUniqueWithoutProjectInput | AreaAffectedUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    set?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    disconnect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    delete?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    update?: AreaAffectedUpdateWithWhereUniqueWithoutProjectInput | AreaAffectedUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AreaAffectedUpdateManyWithWhereWithoutProjectInput | AreaAffectedUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
  }

  export type PhotoAccessLinkUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput> | PhotoAccessLinkCreateWithoutProjectInput[] | PhotoAccessLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PhotoAccessLinkCreateOrConnectWithoutProjectInput | PhotoAccessLinkCreateOrConnectWithoutProjectInput[]
    upsert?: PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput | PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    set?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    disconnect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    delete?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    connect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    update?: PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput | PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput | PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PhotoAccessLinkScalarWhereInput | PhotoAccessLinkScalarWhereInput[]
  }

  export type NotesUpdateManyWithoutProjectNestedInput = {
    create?: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput> | NotesCreateWithoutProjectInput[] | NotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutProjectInput | NotesCreateOrConnectWithoutProjectInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutProjectInput | NotesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: NotesCreateManyProjectInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutProjectInput | NotesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutProjectInput | NotesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type CostUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput> | CostCreateWithoutProjectInput[] | CostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostCreateOrConnectWithoutProjectInput | CostCreateOrConnectWithoutProjectInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutProjectInput | CostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CostCreateManyProjectInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutProjectInput | CostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CostUpdateManyWithWhereWithoutProjectInput | CostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type ProjectEquipmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput> | ProjectEquipmentCreateWithoutProjectInput[] | ProjectEquipmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutProjectInput | ProjectEquipmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput | ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    set?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    disconnect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    delete?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    update?: ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput | ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectEquipmentUpdateManyWithWhereWithoutProjectInput | ProjectEquipmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
  }

  export type WeatherReportItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput> | WeatherReportItemCreateWithoutProjectInput[] | WeatherReportItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WeatherReportItemCreateOrConnectWithoutProjectInput | WeatherReportItemCreateOrConnectWithoutProjectInput[]
    upsert?: WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput | WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    set?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    disconnect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    delete?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    connect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    update?: WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput | WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WeatherReportItemUpdateManyWithWhereWithoutProjectInput | WeatherReportItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WeatherReportItemScalarWhereInput | WeatherReportItemScalarWhereInput[]
  }

  export type ProjectStatusValueUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusValueCreateOrConnectWithoutProjectsInput
    upsert?: ProjectStatusValueUpsertWithoutProjectsInput
    disconnect?: ProjectStatusValueWhereInput | boolean
    delete?: ProjectStatusValueWhereInput | boolean
    connect?: ProjectStatusValueWhereUniqueInput
    update?: XOR<XOR<ProjectStatusValueUpdateToOneWithWhereWithoutProjectsInput, ProjectStatusValueUpdateWithoutProjectsInput>, ProjectStatusValueUncheckedUpdateWithoutProjectsInput>
  }

  export type PendingRoofReportsUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput> | PendingRoofReportsCreateWithoutProjectInput[] | PendingRoofReportsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PendingRoofReportsCreateOrConnectWithoutProjectInput | PendingRoofReportsCreateOrConnectWithoutProjectInput[]
    upsert?: PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput | PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    set?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    disconnect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    delete?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    connect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    update?: PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput | PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PendingRoofReportsUpdateManyWithWhereWithoutProjectInput | PendingRoofReportsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PendingRoofReportsScalarWhereInput | PendingRoofReportsScalarWhereInput[]
  }

  export type ProjectNotesUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput> | ProjectNotesCreateWithoutProjectInput[] | ProjectNotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotesCreateOrConnectWithoutProjectInput | ProjectNotesCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotesUpsertWithWhereUniqueWithoutProjectInput | ProjectNotesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    set?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    disconnect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    delete?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    connect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    update?: ProjectNotesUpdateWithWhereUniqueWithoutProjectInput | ProjectNotesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotesUpdateManyWithWhereWithoutProjectInput | ProjectNotesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotesScalarWhereInput | ProjectNotesScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput> | ImageCreateWithoutProjectInput[] | ImageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProjectInput | ImageCreateOrConnectWithoutProjectInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutProjectInput | ImageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ImageCreateManyProjectInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutProjectInput | ImageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutProjectInput | ImageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type InferenceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput> | InferenceCreateWithoutProjectInput[] | InferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutProjectInput | InferenceCreateOrConnectWithoutProjectInput[]
    upsert?: InferenceUpsertWithWhereUniqueWithoutProjectInput | InferenceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InferenceCreateManyProjectInputEnvelope
    set?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    disconnect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    delete?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    update?: InferenceUpdateWithWhereUniqueWithoutProjectInput | InferenceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InferenceUpdateManyWithWhereWithoutProjectInput | InferenceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput> | RoomCreateWithoutProjectInput[] | RoomUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProjectInput | RoomCreateOrConnectWithoutProjectInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutProjectInput | RoomUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoomCreateManyProjectInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutProjectInput | RoomUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutProjectInput | RoomUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutProjectInput | CalendarEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutProjectInput | CalendarEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutProjectInput | CalendarEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type UserToProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput> | UserToProjectCreateWithoutProjectInput[] | UserToProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserToProjectCreateOrConnectWithoutProjectInput | UserToProjectCreateOrConnectWithoutProjectInput[]
    upsert?: UserToProjectUpsertWithWhereUniqueWithoutProjectInput | UserToProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UserToProjectCreateManyProjectInputEnvelope
    set?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    disconnect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    delete?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    connect?: UserToProjectWhereUniqueInput | UserToProjectWhereUniqueInput[]
    update?: UserToProjectUpdateWithWhereUniqueWithoutProjectInput | UserToProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UserToProjectUpdateManyWithWhereWithoutProjectInput | UserToProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
  }

  export type RoomReadingUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput> | RoomReadingCreateWithoutProjectInput[] | RoomReadingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutProjectInput | RoomReadingCreateOrConnectWithoutProjectInput[]
    upsert?: RoomReadingUpsertWithWhereUniqueWithoutProjectInput | RoomReadingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoomReadingCreateManyProjectInputEnvelope
    set?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    disconnect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    delete?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    update?: RoomReadingUpdateWithWhereUniqueWithoutProjectInput | RoomReadingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoomReadingUpdateManyWithWhereWithoutProjectInput | RoomReadingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
  }

  export type PropertyDataUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PropertyDataCreateOrConnectWithoutProjectInput
    upsert?: PropertyDataUpsertWithoutProjectInput
    disconnect?: PropertyDataWhereInput | boolean
    delete?: PropertyDataWhereInput | boolean
    connect?: PropertyDataWhereUniqueInput
    update?: XOR<XOR<PropertyDataUpdateToOneWithWhereWithoutProjectInput, PropertyDataUpdateWithoutProjectInput>, PropertyDataUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput> | AreaAffectedCreateWithoutProjectInput[] | AreaAffectedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutProjectInput | AreaAffectedCreateOrConnectWithoutProjectInput[]
    upsert?: AreaAffectedUpsertWithWhereUniqueWithoutProjectInput | AreaAffectedUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AreaAffectedCreateManyProjectInputEnvelope
    set?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    disconnect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    delete?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    update?: AreaAffectedUpdateWithWhereUniqueWithoutProjectInput | AreaAffectedUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AreaAffectedUpdateManyWithWhereWithoutProjectInput | AreaAffectedUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
  }

  export type PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput> | PhotoAccessLinkCreateWithoutProjectInput[] | PhotoAccessLinkUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PhotoAccessLinkCreateOrConnectWithoutProjectInput | PhotoAccessLinkCreateOrConnectWithoutProjectInput[]
    upsert?: PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput | PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PhotoAccessLinkCreateManyProjectInputEnvelope
    set?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    disconnect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    delete?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    connect?: PhotoAccessLinkWhereUniqueInput | PhotoAccessLinkWhereUniqueInput[]
    update?: PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput | PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput | PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PhotoAccessLinkScalarWhereInput | PhotoAccessLinkScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput> | NotesCreateWithoutProjectInput[] | NotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutProjectInput | NotesCreateOrConnectWithoutProjectInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutProjectInput | NotesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: NotesCreateManyProjectInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutProjectInput | NotesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutProjectInput | NotesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type CostUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput> | CostCreateWithoutProjectInput[] | CostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostCreateOrConnectWithoutProjectInput | CostCreateOrConnectWithoutProjectInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutProjectInput | CostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CostCreateManyProjectInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutProjectInput | CostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CostUpdateManyWithWhereWithoutProjectInput | CostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput> | ProjectEquipmentCreateWithoutProjectInput[] | ProjectEquipmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEquipmentCreateOrConnectWithoutProjectInput | ProjectEquipmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput | ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectEquipmentCreateManyProjectInputEnvelope
    set?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    disconnect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    delete?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    connect?: ProjectEquipmentWhereUniqueInput | ProjectEquipmentWhereUniqueInput[]
    update?: ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput | ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectEquipmentUpdateManyWithWhereWithoutProjectInput | ProjectEquipmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
  }

  export type WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput> | WeatherReportItemCreateWithoutProjectInput[] | WeatherReportItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WeatherReportItemCreateOrConnectWithoutProjectInput | WeatherReportItemCreateOrConnectWithoutProjectInput[]
    upsert?: WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput | WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WeatherReportItemCreateManyProjectInputEnvelope
    set?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    disconnect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    delete?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    connect?: WeatherReportItemWhereUniqueInput | WeatherReportItemWhereUniqueInput[]
    update?: WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput | WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WeatherReportItemUpdateManyWithWhereWithoutProjectInput | WeatherReportItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WeatherReportItemScalarWhereInput | WeatherReportItemScalarWhereInput[]
  }

  export type PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput> | PendingRoofReportsCreateWithoutProjectInput[] | PendingRoofReportsUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PendingRoofReportsCreateOrConnectWithoutProjectInput | PendingRoofReportsCreateOrConnectWithoutProjectInput[]
    upsert?: PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput | PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PendingRoofReportsCreateManyProjectInputEnvelope
    set?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    disconnect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    delete?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    connect?: PendingRoofReportsWhereUniqueInput | PendingRoofReportsWhereUniqueInput[]
    update?: PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput | PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PendingRoofReportsUpdateManyWithWhereWithoutProjectInput | PendingRoofReportsUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PendingRoofReportsScalarWhereInput | PendingRoofReportsScalarWhereInput[]
  }

  export type ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput> | ProjectNotesCreateWithoutProjectInput[] | ProjectNotesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotesCreateOrConnectWithoutProjectInput | ProjectNotesCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotesUpsertWithWhereUniqueWithoutProjectInput | ProjectNotesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotesCreateManyProjectInputEnvelope
    set?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    disconnect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    delete?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    connect?: ProjectNotesWhereUniqueInput | ProjectNotesWhereUniqueInput[]
    update?: ProjectNotesUpdateWithWhereUniqueWithoutProjectInput | ProjectNotesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotesUpdateManyWithWhereWithoutProjectInput | ProjectNotesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotesScalarWhereInput | ProjectNotesScalarWhereInput[]
  }

  export type ProjectNotesCreatementionsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutProjectNotesInput = {
    create?: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectNotesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectNotesUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutProjectNotesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectNotesInput
    upsert?: ProjectUpsertWithoutProjectNotesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectNotesInput, ProjectUpdateWithoutProjectNotesInput>, ProjectUncheckedUpdateWithoutProjectNotesInput>
  }

  export type ProjectCreateNestedManyWithoutCurrentStatusInput = {
    create?: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput> | ProjectCreateWithoutCurrentStatusInput[] | ProjectUncheckedCreateWithoutCurrentStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCurrentStatusInput | ProjectCreateOrConnectWithoutCurrentStatusInput[]
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutProjectStatusValueInput = {
    create?: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectStatusValueInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput = {
    create?: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput> | ProjectCreateWithoutCurrentStatusInput[] | ProjectUncheckedCreateWithoutCurrentStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCurrentStatusInput | ProjectCreateOrConnectWithoutCurrentStatusInput[]
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutCurrentStatusNestedInput = {
    create?: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput> | ProjectCreateWithoutCurrentStatusInput[] | ProjectUncheckedCreateWithoutCurrentStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCurrentStatusInput | ProjectCreateOrConnectWithoutCurrentStatusInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput | ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput[]
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput | ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCurrentStatusInput | ProjectUpdateManyWithWhereWithoutCurrentStatusInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectStatusValueInput
    upsert?: OrganizationUpsertWithoutProjectStatusValueInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectStatusValueInput, OrganizationUpdateWithoutProjectStatusValueInput>, OrganizationUncheckedUpdateWithoutProjectStatusValueInput>
  }

  export type ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput = {
    create?: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput> | ProjectCreateWithoutCurrentStatusInput[] | ProjectUncheckedCreateWithoutCurrentStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCurrentStatusInput | ProjectCreateOrConnectWithoutCurrentStatusInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput | ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput[]
    createMany?: ProjectCreateManyCurrentStatusInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput | ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCurrentStatusInput | ProjectUpdateManyWithWhereWithoutCurrentStatusInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutPendingRoofReportsInput = {
    create?: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPendingRoofReportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPendingRoofReportsNestedInput = {
    create?: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPendingRoofReportsInput
    upsert?: ProjectUpsertWithoutPendingRoofReportsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPendingRoofReportsInput, ProjectUpdateWithoutPendingRoofReportsInput>, ProjectUncheckedUpdateWithoutPendingRoofReportsInput>
  }

  export type ProjectCreateNestedOneWithoutWeatherReportItemsInput = {
    create?: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWeatherReportItemsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutWeatherReportItemsNestedInput = {
    create?: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWeatherReportItemsInput
    upsert?: ProjectUpsertWithoutWeatherReportItemsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWeatherReportItemsInput, ProjectUpdateWithoutWeatherReportItemsInput>, ProjectUncheckedUpdateWithoutWeatherReportItemsInput>
  }

  export type EquipmentCreateNestedOneWithoutProjectEquipmentInput = {
    create?: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProjectEquipmentInput
    connect?: EquipmentWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectEquipmentInput = {
    create?: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEquipmentInput
    connect?: ProjectWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput = {
    create?: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProjectEquipmentInput
    upsert?: EquipmentUpsertWithoutProjectEquipmentInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutProjectEquipmentInput, EquipmentUpdateWithoutProjectEquipmentInput>, EquipmentUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEquipmentInput
    upsert?: ProjectUpsertWithoutProjectEquipmentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectEquipmentInput, ProjectUpdateWithoutProjectEquipmentInput>, ProjectUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type ProjectCreateNestedOneWithoutCostsInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumCostTypeFieldUpdateOperationsInput = {
    set?: $Enums.CostType
  }

  export type ProjectUpdateOneRequiredWithoutCostsNestedInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    upsert?: ProjectUpsertWithoutCostsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCostsInput, ProjectUpdateWithoutCostsInput>, ProjectUncheckedUpdateWithoutCostsInput>
  }

  export type ProjectCreateNestedOneWithoutPropertyDataInput = {
    create?: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyDataInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutPropertyDataNestedInput = {
    create?: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyDataInput
    upsert?: ProjectUpsertWithoutPropertyDataInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPropertyDataInput, ProjectUpdateWithoutPropertyDataInput>, ProjectUncheckedUpdateWithoutPropertyDataInput>
  }

  export type ProjectCreateNestedOneWithoutPhotoAccessLinksInput = {
    create?: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhotoAccessLinksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPhotoAccessLinksNestedInput = {
    create?: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhotoAccessLinksInput
    upsert?: ProjectUpsertWithoutPhotoAccessLinksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPhotoAccessLinksInput, ProjectUpdateWithoutPhotoAccessLinksInput>, ProjectUncheckedUpdateWithoutPhotoAccessLinksInput>
  }

  export type OrganizationCreateNestedOneWithoutImageInput = {
    create?: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type InferenceCreateNestedOneWithoutImageInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    connect?: InferenceWhereUniqueInput
  }

  export type ImageNoteCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput> | ImageNoteCreateWithoutImageInput[] | ImageNoteUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutImageInput | ImageNoteCreateOrConnectWithoutImageInput[]
    createMany?: ImageNoteCreateManyImageInputEnvelope
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
  }

  export type AnnotationCreateNestedManyWithoutImageInput = {
    create?: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput> | AnnotationCreateWithoutImageInput[] | AnnotationUncheckedCreateWithoutImageInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutImageInput | AnnotationCreateOrConnectWithoutImageInput[]
    createMany?: AnnotationCreateManyImageInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type InferenceUncheckedCreateNestedOneWithoutImageInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    connect?: InferenceWhereUniqueInput
  }

  export type ImageNoteUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput> | ImageNoteCreateWithoutImageInput[] | ImageNoteUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutImageInput | ImageNoteCreateOrConnectWithoutImageInput[]
    createMany?: ImageNoteCreateManyImageInputEnvelope
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
  }

  export type AnnotationUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput> | AnnotationCreateWithoutImageInput[] | AnnotationUncheckedCreateWithoutImageInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutImageInput | AnnotationCreateOrConnectWithoutImageInput[]
    createMany?: AnnotationCreateManyImageInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type OrganizationUpdateOneWithoutImageNestedInput = {
    create?: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageInput
    upsert?: OrganizationUpsertWithoutImageInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutImageInput, OrganizationUpdateWithoutImageInput>, OrganizationUncheckedUpdateWithoutImageInput>
  }

  export type ProjectUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImagesInput
    upsert?: ProjectUpsertWithoutImagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutImagesInput, ProjectUpdateWithoutImagesInput>, ProjectUncheckedUpdateWithoutImagesInput>
  }

  export type InferenceUpdateOneWithoutImageNestedInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    upsert?: InferenceUpsertWithoutImageInput
    disconnect?: InferenceWhereInput | boolean
    delete?: InferenceWhereInput | boolean
    connect?: InferenceWhereUniqueInput
    update?: XOR<XOR<InferenceUpdateToOneWithWhereWithoutImageInput, InferenceUpdateWithoutImageInput>, InferenceUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput> | ImageNoteCreateWithoutImageInput[] | ImageNoteUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutImageInput | ImageNoteCreateOrConnectWithoutImageInput[]
    upsert?: ImageNoteUpsertWithWhereUniqueWithoutImageInput | ImageNoteUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageNoteCreateManyImageInputEnvelope
    set?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    disconnect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    delete?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    update?: ImageNoteUpdateWithWhereUniqueWithoutImageInput | ImageNoteUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageNoteUpdateManyWithWhereWithoutImageInput | ImageNoteUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
  }

  export type AnnotationUpdateManyWithoutImageNestedInput = {
    create?: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput> | AnnotationCreateWithoutImageInput[] | AnnotationUncheckedCreateWithoutImageInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutImageInput | AnnotationCreateOrConnectWithoutImageInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutImageInput | AnnotationUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: AnnotationCreateManyImageInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutImageInput | AnnotationUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutImageInput | AnnotationUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type InferenceUncheckedUpdateOneWithoutImageNestedInput = {
    create?: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutImageInput
    upsert?: InferenceUpsertWithoutImageInput
    disconnect?: InferenceWhereInput | boolean
    delete?: InferenceWhereInput | boolean
    connect?: InferenceWhereUniqueInput
    update?: XOR<XOR<InferenceUpdateToOneWithWhereWithoutImageInput, InferenceUpdateWithoutImageInput>, InferenceUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput> | ImageNoteCreateWithoutImageInput[] | ImageNoteUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageNoteCreateOrConnectWithoutImageInput | ImageNoteCreateOrConnectWithoutImageInput[]
    upsert?: ImageNoteUpsertWithWhereUniqueWithoutImageInput | ImageNoteUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageNoteCreateManyImageInputEnvelope
    set?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    disconnect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    delete?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    connect?: ImageNoteWhereUniqueInput | ImageNoteWhereUniqueInput[]
    update?: ImageNoteUpdateWithWhereUniqueWithoutImageInput | ImageNoteUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageNoteUpdateManyWithWhereWithoutImageInput | ImageNoteUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
  }

  export type AnnotationUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput> | AnnotationCreateWithoutImageInput[] | AnnotationUncheckedCreateWithoutImageInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutImageInput | AnnotationCreateOrConnectWithoutImageInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutImageInput | AnnotationUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: AnnotationCreateManyImageInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutImageInput | AnnotationUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutImageInput | AnnotationUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type ImageCreateNestedOneWithoutAnnotationInput = {
    create?: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: ImageCreateOrConnectWithoutAnnotationInput
    connect?: ImageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotationInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    connect?: UserWhereUniqueInput
  }

  export type ImageUpdateOneRequiredWithoutAnnotationNestedInput = {
    create?: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: ImageCreateOrConnectWithoutAnnotationInput
    upsert?: ImageUpsertWithoutAnnotationInput
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutAnnotationInput, ImageUpdateWithoutAnnotationInput>, ImageUncheckedUpdateWithoutAnnotationInput>
  }

  export type UserUpdateOneRequiredWithoutAnnotationNestedInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    upsert?: UserUpsertWithoutAnnotationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotationInput, UserUpdateWithoutAnnotationInput>, UserUncheckedUpdateWithoutAnnotationInput>
  }

  export type ImageNoteCreatementionsInput = {
    set: string[]
  }

  export type ImageCreateNestedOneWithoutImageNoteInput = {
    create?: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: ImageCreateOrConnectWithoutImageNoteInput
    connect?: ImageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutImageNoteInput = {
    create?: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageNoteInput
    connect?: UserWhereUniqueInput
  }

  export type ImageNoteUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ImageUpdateOneRequiredWithoutImageNoteNestedInput = {
    create?: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: ImageCreateOrConnectWithoutImageNoteInput
    upsert?: ImageUpsertWithoutImageNoteInput
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutImageNoteInput, ImageUpdateWithoutImageNoteInput>, ImageUncheckedUpdateWithoutImageNoteInput>
  }

  export type UserUpdateOneRequiredWithoutImageNoteNestedInput = {
    create?: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageNoteInput
    upsert?: UserUpsertWithoutImageNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImageNoteInput, UserUpdateWithoutImageNoteInput>, UserUncheckedUpdateWithoutImageNoteInput>
  }

  export type ImageCreateNestedOneWithoutInferenceInput = {
    create?: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
    connectOrCreate?: ImageCreateOrConnectWithoutInferenceInput
    connect?: ImageWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInferencesInput = {
    create?: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInferencesInput
    connect?: ProjectWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutInferencesInput = {
    create?: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInferencesInput
    connect?: RoomWhereUniqueInput
  }

  export type DetectionCreateNestedManyWithoutInferenceInput = {
    create?: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput> | DetectionCreateWithoutInferenceInput[] | DetectionUncheckedCreateWithoutInferenceInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutInferenceInput | DetectionCreateOrConnectWithoutInferenceInput[]
    createMany?: DetectionCreateManyInferenceInputEnvelope
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
  }

  export type DetectionUncheckedCreateNestedManyWithoutInferenceInput = {
    create?: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput> | DetectionCreateWithoutInferenceInput[] | DetectionUncheckedCreateWithoutInferenceInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutInferenceInput | DetectionCreateOrConnectWithoutInferenceInput[]
    createMany?: DetectionCreateManyInferenceInputEnvelope
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
  }

  export type ImageUpdateOneWithoutInferenceNestedInput = {
    create?: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
    connectOrCreate?: ImageCreateOrConnectWithoutInferenceInput
    upsert?: ImageUpsertWithoutInferenceInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutInferenceInput, ImageUpdateWithoutInferenceInput>, ImageUncheckedUpdateWithoutInferenceInput>
  }

  export type ProjectUpdateOneRequiredWithoutInferencesNestedInput = {
    create?: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInferencesInput
    upsert?: ProjectUpsertWithoutInferencesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInferencesInput, ProjectUpdateWithoutInferencesInput>, ProjectUncheckedUpdateWithoutInferencesInput>
  }

  export type RoomUpdateOneWithoutInferencesNestedInput = {
    create?: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutInferencesInput
    upsert?: RoomUpsertWithoutInferencesInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutInferencesInput, RoomUpdateWithoutInferencesInput>, RoomUncheckedUpdateWithoutInferencesInput>
  }

  export type DetectionUpdateManyWithoutInferenceNestedInput = {
    create?: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput> | DetectionCreateWithoutInferenceInput[] | DetectionUncheckedCreateWithoutInferenceInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutInferenceInput | DetectionCreateOrConnectWithoutInferenceInput[]
    upsert?: DetectionUpsertWithWhereUniqueWithoutInferenceInput | DetectionUpsertWithWhereUniqueWithoutInferenceInput[]
    createMany?: DetectionCreateManyInferenceInputEnvelope
    set?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    disconnect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    delete?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    update?: DetectionUpdateWithWhereUniqueWithoutInferenceInput | DetectionUpdateWithWhereUniqueWithoutInferenceInput[]
    updateMany?: DetectionUpdateManyWithWhereWithoutInferenceInput | DetectionUpdateManyWithWhereWithoutInferenceInput[]
    deleteMany?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
  }

  export type DetectionUncheckedUpdateManyWithoutInferenceNestedInput = {
    create?: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput> | DetectionCreateWithoutInferenceInput[] | DetectionUncheckedCreateWithoutInferenceInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutInferenceInput | DetectionCreateOrConnectWithoutInferenceInput[]
    upsert?: DetectionUpsertWithWhereUniqueWithoutInferenceInput | DetectionUpsertWithWhereUniqueWithoutInferenceInput[]
    createMany?: DetectionCreateManyInferenceInputEnvelope
    set?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    disconnect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    delete?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    update?: DetectionUpdateWithWhereUniqueWithoutInferenceInput | DetectionUpdateWithWhereUniqueWithoutInferenceInput[]
    updateMany?: DetectionUpdateManyWithWhereWithoutInferenceInput | DetectionUpdateManyWithWhereWithoutInferenceInput[]
    deleteMany?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
  }

  export type RoomCreateequipmentUsedInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DetectionCreateNestedManyWithoutRoomInput = {
    create?: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput> | DetectionCreateWithoutRoomInput[] | DetectionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutRoomInput | DetectionCreateOrConnectWithoutRoomInput[]
    createMany?: DetectionCreateManyRoomInputEnvelope
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
  }

  export type InferenceCreateNestedManyWithoutRoomInput = {
    create?: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput> | InferenceCreateWithoutRoomInput[] | InferenceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutRoomInput | InferenceCreateOrConnectWithoutRoomInput[]
    createMany?: InferenceCreateManyRoomInputEnvelope
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
  }

  export type TemplatesUsedCreateNestedManyWithoutRoomInput = {
    create?: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput> | TemplatesUsedCreateWithoutRoomInput[] | TemplatesUsedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: TemplatesUsedCreateOrConnectWithoutRoomInput | TemplatesUsedCreateOrConnectWithoutRoomInput[]
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    connect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
  }

  export type RoomReadingCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput> | RoomReadingCreateWithoutRoomInput[] | RoomReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutRoomInput | RoomReadingCreateOrConnectWithoutRoomInput[]
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
  }

  export type AreaAffectedCreateNestedManyWithoutRoomInput = {
    create?: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput> | AreaAffectedCreateWithoutRoomInput[] | AreaAffectedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutRoomInput | AreaAffectedCreateOrConnectWithoutRoomInput[]
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
  }

  export type NotesCreateNestedManyWithoutRoomInput = {
    create?: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput> | NotesCreateWithoutRoomInput[] | NotesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutRoomInput | NotesCreateOrConnectWithoutRoomInput[]
    createMany?: NotesCreateManyRoomInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type DetectionUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput> | DetectionCreateWithoutRoomInput[] | DetectionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutRoomInput | DetectionCreateOrConnectWithoutRoomInput[]
    createMany?: DetectionCreateManyRoomInputEnvelope
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
  }

  export type InferenceUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput> | InferenceCreateWithoutRoomInput[] | InferenceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutRoomInput | InferenceCreateOrConnectWithoutRoomInput[]
    createMany?: InferenceCreateManyRoomInputEnvelope
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
  }

  export type TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput> | TemplatesUsedCreateWithoutRoomInput[] | TemplatesUsedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: TemplatesUsedCreateOrConnectWithoutRoomInput | TemplatesUsedCreateOrConnectWithoutRoomInput[]
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    connect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
  }

  export type RoomReadingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput> | RoomReadingCreateWithoutRoomInput[] | RoomReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutRoomInput | RoomReadingCreateOrConnectWithoutRoomInput[]
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
  }

  export type AreaAffectedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput> | AreaAffectedCreateWithoutRoomInput[] | AreaAffectedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutRoomInput | AreaAffectedCreateOrConnectWithoutRoomInput[]
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput> | NotesCreateWithoutRoomInput[] | NotesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutRoomInput | NotesCreateOrConnectWithoutRoomInput[]
    createMany?: NotesCreateManyRoomInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type RoomUpdateequipmentUsedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomsInput
    upsert?: ProjectUpsertWithoutRoomsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRoomsInput, ProjectUpdateWithoutRoomsInput>, ProjectUncheckedUpdateWithoutRoomsInput>
  }

  export type DetectionUpdateManyWithoutRoomNestedInput = {
    create?: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput> | DetectionCreateWithoutRoomInput[] | DetectionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutRoomInput | DetectionCreateOrConnectWithoutRoomInput[]
    upsert?: DetectionUpsertWithWhereUniqueWithoutRoomInput | DetectionUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: DetectionCreateManyRoomInputEnvelope
    set?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    disconnect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    delete?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    update?: DetectionUpdateWithWhereUniqueWithoutRoomInput | DetectionUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: DetectionUpdateManyWithWhereWithoutRoomInput | DetectionUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
  }

  export type InferenceUpdateManyWithoutRoomNestedInput = {
    create?: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput> | InferenceCreateWithoutRoomInput[] | InferenceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutRoomInput | InferenceCreateOrConnectWithoutRoomInput[]
    upsert?: InferenceUpsertWithWhereUniqueWithoutRoomInput | InferenceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: InferenceCreateManyRoomInputEnvelope
    set?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    disconnect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    delete?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    update?: InferenceUpdateWithWhereUniqueWithoutRoomInput | InferenceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: InferenceUpdateManyWithWhereWithoutRoomInput | InferenceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
  }

  export type TemplatesUsedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput> | TemplatesUsedCreateWithoutRoomInput[] | TemplatesUsedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: TemplatesUsedCreateOrConnectWithoutRoomInput | TemplatesUsedCreateOrConnectWithoutRoomInput[]
    upsert?: TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput | TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    set?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    disconnect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    delete?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    connect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    update?: TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput | TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: TemplatesUsedUpdateManyWithWhereWithoutRoomInput | TemplatesUsedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: TemplatesUsedScalarWhereInput | TemplatesUsedScalarWhereInput[]
  }

  export type RoomReadingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput> | RoomReadingCreateWithoutRoomInput[] | RoomReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutRoomInput | RoomReadingCreateOrConnectWithoutRoomInput[]
    upsert?: RoomReadingUpsertWithWhereUniqueWithoutRoomInput | RoomReadingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    set?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    disconnect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    delete?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    update?: RoomReadingUpdateWithWhereUniqueWithoutRoomInput | RoomReadingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomReadingUpdateManyWithWhereWithoutRoomInput | RoomReadingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
  }

  export type AreaAffectedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput> | AreaAffectedCreateWithoutRoomInput[] | AreaAffectedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutRoomInput | AreaAffectedCreateOrConnectWithoutRoomInput[]
    upsert?: AreaAffectedUpsertWithWhereUniqueWithoutRoomInput | AreaAffectedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    set?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    disconnect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    delete?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    update?: AreaAffectedUpdateWithWhereUniqueWithoutRoomInput | AreaAffectedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: AreaAffectedUpdateManyWithWhereWithoutRoomInput | AreaAffectedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
  }

  export type NotesUpdateManyWithoutRoomNestedInput = {
    create?: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput> | NotesCreateWithoutRoomInput[] | NotesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutRoomInput | NotesCreateOrConnectWithoutRoomInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutRoomInput | NotesUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: NotesCreateManyRoomInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutRoomInput | NotesUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutRoomInput | NotesUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type DetectionUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput> | DetectionCreateWithoutRoomInput[] | DetectionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: DetectionCreateOrConnectWithoutRoomInput | DetectionCreateOrConnectWithoutRoomInput[]
    upsert?: DetectionUpsertWithWhereUniqueWithoutRoomInput | DetectionUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: DetectionCreateManyRoomInputEnvelope
    set?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    disconnect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    delete?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    connect?: DetectionWhereUniqueInput | DetectionWhereUniqueInput[]
    update?: DetectionUpdateWithWhereUniqueWithoutRoomInput | DetectionUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: DetectionUpdateManyWithWhereWithoutRoomInput | DetectionUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
  }

  export type InferenceUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput> | InferenceCreateWithoutRoomInput[] | InferenceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: InferenceCreateOrConnectWithoutRoomInput | InferenceCreateOrConnectWithoutRoomInput[]
    upsert?: InferenceUpsertWithWhereUniqueWithoutRoomInput | InferenceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: InferenceCreateManyRoomInputEnvelope
    set?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    disconnect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    delete?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    connect?: InferenceWhereUniqueInput | InferenceWhereUniqueInput[]
    update?: InferenceUpdateWithWhereUniqueWithoutRoomInput | InferenceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: InferenceUpdateManyWithWhereWithoutRoomInput | InferenceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
  }

  export type TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput> | TemplatesUsedCreateWithoutRoomInput[] | TemplatesUsedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: TemplatesUsedCreateOrConnectWithoutRoomInput | TemplatesUsedCreateOrConnectWithoutRoomInput[]
    upsert?: TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput | TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: TemplatesUsedCreateManyRoomInputEnvelope
    set?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    disconnect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    delete?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    connect?: TemplatesUsedWhereUniqueInput | TemplatesUsedWhereUniqueInput[]
    update?: TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput | TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: TemplatesUsedUpdateManyWithWhereWithoutRoomInput | TemplatesUsedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: TemplatesUsedScalarWhereInput | TemplatesUsedScalarWhereInput[]
  }

  export type RoomReadingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput> | RoomReadingCreateWithoutRoomInput[] | RoomReadingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomReadingCreateOrConnectWithoutRoomInput | RoomReadingCreateOrConnectWithoutRoomInput[]
    upsert?: RoomReadingUpsertWithWhereUniqueWithoutRoomInput | RoomReadingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomReadingCreateManyRoomInputEnvelope
    set?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    disconnect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    delete?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    connect?: RoomReadingWhereUniqueInput | RoomReadingWhereUniqueInput[]
    update?: RoomReadingUpdateWithWhereUniqueWithoutRoomInput | RoomReadingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomReadingUpdateManyWithWhereWithoutRoomInput | RoomReadingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
  }

  export type AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput> | AreaAffectedCreateWithoutRoomInput[] | AreaAffectedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: AreaAffectedCreateOrConnectWithoutRoomInput | AreaAffectedCreateOrConnectWithoutRoomInput[]
    upsert?: AreaAffectedUpsertWithWhereUniqueWithoutRoomInput | AreaAffectedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: AreaAffectedCreateManyRoomInputEnvelope
    set?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    disconnect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    delete?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    connect?: AreaAffectedWhereUniqueInput | AreaAffectedWhereUniqueInput[]
    update?: AreaAffectedUpdateWithWhereUniqueWithoutRoomInput | AreaAffectedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: AreaAffectedUpdateManyWithWhereWithoutRoomInput | AreaAffectedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput> | NotesCreateWithoutRoomInput[] | NotesUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutRoomInput | NotesCreateOrConnectWithoutRoomInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutRoomInput | NotesUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: NotesCreateManyRoomInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutRoomInput | NotesUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutRoomInput | NotesUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type RoomReadingCreateequipmentUsedInput = {
    set: string[]
  }

  export type RoomCreateNestedOneWithoutRoomReadingsInput = {
    create?: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomReadingsInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutRoomReadingsInput = {
    create?: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomReadingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type GenericRoomReadingCreateNestedManyWithoutRoomReadingInput = {
    create?: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput> | GenericRoomReadingCreateWithoutRoomReadingInput[] | GenericRoomReadingUncheckedCreateWithoutRoomReadingInput[]
    connectOrCreate?: GenericRoomReadingCreateOrConnectWithoutRoomReadingInput | GenericRoomReadingCreateOrConnectWithoutRoomReadingInput[]
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    connect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
  }

  export type GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput = {
    create?: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput> | GenericRoomReadingCreateWithoutRoomReadingInput[] | GenericRoomReadingUncheckedCreateWithoutRoomReadingInput[]
    connectOrCreate?: GenericRoomReadingCreateOrConnectWithoutRoomReadingInput | GenericRoomReadingCreateOrConnectWithoutRoomReadingInput[]
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    connect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
  }

  export type RoomReadingUpdateequipmentUsedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoomUpdateOneRequiredWithoutRoomReadingsNestedInput = {
    create?: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomReadingsInput
    upsert?: RoomUpsertWithoutRoomReadingsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutRoomReadingsInput, RoomUpdateWithoutRoomReadingsInput>, RoomUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoomReadingsInput
    upsert?: ProjectUpsertWithoutRoomReadingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRoomReadingsInput, ProjectUpdateWithoutRoomReadingsInput>, ProjectUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput = {
    create?: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput> | GenericRoomReadingCreateWithoutRoomReadingInput[] | GenericRoomReadingUncheckedCreateWithoutRoomReadingInput[]
    connectOrCreate?: GenericRoomReadingCreateOrConnectWithoutRoomReadingInput | GenericRoomReadingCreateOrConnectWithoutRoomReadingInput[]
    upsert?: GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput | GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput[]
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    set?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    disconnect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    delete?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    connect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    update?: GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput | GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput[]
    updateMany?: GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput | GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput[]
    deleteMany?: GenericRoomReadingScalarWhereInput | GenericRoomReadingScalarWhereInput[]
  }

  export type GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput = {
    create?: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput> | GenericRoomReadingCreateWithoutRoomReadingInput[] | GenericRoomReadingUncheckedCreateWithoutRoomReadingInput[]
    connectOrCreate?: GenericRoomReadingCreateOrConnectWithoutRoomReadingInput | GenericRoomReadingCreateOrConnectWithoutRoomReadingInput[]
    upsert?: GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput | GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput[]
    createMany?: GenericRoomReadingCreateManyRoomReadingInputEnvelope
    set?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    disconnect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    delete?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    connect?: GenericRoomReadingWhereUniqueInput | GenericRoomReadingWhereUniqueInput[]
    update?: GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput | GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput[]
    updateMany?: GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput | GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput[]
    deleteMany?: GenericRoomReadingScalarWhereInput | GenericRoomReadingScalarWhereInput[]
  }

  export type RoomCreateNestedOneWithoutNotesInput = {
    create?: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutNotesInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutNotesInput = {
    create?: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotesInput
    connect?: ProjectWhereUniqueInput
  }

  export type NotesAuditTrailCreateNestedManyWithoutNoteInput = {
    create?: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput> | NotesAuditTrailCreateWithoutNoteInput[] | NotesAuditTrailUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NotesAuditTrailCreateOrConnectWithoutNoteInput | NotesAuditTrailCreateOrConnectWithoutNoteInput[]
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    connect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
  }

  export type NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput> | NotesAuditTrailCreateWithoutNoteInput[] | NotesAuditTrailUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NotesAuditTrailCreateOrConnectWithoutNoteInput | NotesAuditTrailCreateOrConnectWithoutNoteInput[]
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    connect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
  }

  export type RoomUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutNotesInput
    upsert?: RoomUpsertWithoutNotesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutNotesInput, RoomUpdateWithoutNotesInput>, RoomUncheckedUpdateWithoutNotesInput>
  }

  export type ProjectUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotesInput
    upsert?: ProjectUpsertWithoutNotesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutNotesInput, ProjectUpdateWithoutNotesInput>, ProjectUncheckedUpdateWithoutNotesInput>
  }

  export type NotesAuditTrailUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput> | NotesAuditTrailCreateWithoutNoteInput[] | NotesAuditTrailUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NotesAuditTrailCreateOrConnectWithoutNoteInput | NotesAuditTrailCreateOrConnectWithoutNoteInput[]
    upsert?: NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput | NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    set?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    disconnect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    delete?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    connect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    update?: NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput | NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NotesAuditTrailUpdateManyWithWhereWithoutNoteInput | NotesAuditTrailUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NotesAuditTrailScalarWhereInput | NotesAuditTrailScalarWhereInput[]
  }

  export type NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput> | NotesAuditTrailCreateWithoutNoteInput[] | NotesAuditTrailUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NotesAuditTrailCreateOrConnectWithoutNoteInput | NotesAuditTrailCreateOrConnectWithoutNoteInput[]
    upsert?: NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput | NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NotesAuditTrailCreateManyNoteInputEnvelope
    set?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    disconnect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    delete?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    connect?: NotesAuditTrailWhereUniqueInput | NotesAuditTrailWhereUniqueInput[]
    update?: NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput | NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NotesAuditTrailUpdateManyWithWhereWithoutNoteInput | NotesAuditTrailUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NotesAuditTrailScalarWhereInput | NotesAuditTrailScalarWhereInput[]
  }

  export type NotesCreateNestedOneWithoutNotesAuditTrailInput = {
    create?: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
    connectOrCreate?: NotesCreateOrConnectWithoutNotesAuditTrailInput
    connect?: NotesWhereUniqueInput
  }

  export type EnumNotesAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.NotesAuditAction
  }

  export type NotesUpdateOneRequiredWithoutNotesAuditTrailNestedInput = {
    create?: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
    connectOrCreate?: NotesCreateOrConnectWithoutNotesAuditTrailInput
    upsert?: NotesUpsertWithoutNotesAuditTrailInput
    connect?: NotesWhereUniqueInput
    update?: XOR<XOR<NotesUpdateToOneWithWhereWithoutNotesAuditTrailInput, NotesUpdateWithoutNotesAuditTrailInput>, NotesUncheckedUpdateWithoutNotesAuditTrailInput>
  }

  export type RoomCreateNestedOneWithoutAreasAffectedInput = {
    create?: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAreasAffectedInput
    connect?: RoomWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAreaAffectedInput = {
    create?: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAreaAffectedInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAreaAffectedTypeFieldUpdateOperationsInput = {
    set?: $Enums.AreaAffectedType
  }

  export type RoomUpdateOneRequiredWithoutAreasAffectedNestedInput = {
    create?: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAreasAffectedInput
    upsert?: RoomUpsertWithoutAreasAffectedInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAreasAffectedInput, RoomUpdateWithoutAreasAffectedInput>, RoomUncheckedUpdateWithoutAreasAffectedInput>
  }

  export type ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput = {
    create?: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAreaAffectedInput
    upsert?: ProjectUpsertWithoutAreaAffectedInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAreaAffectedInput, ProjectUpdateWithoutAreaAffectedInput>, ProjectUncheckedUpdateWithoutAreaAffectedInput>
  }

  export type RoomReadingCreateNestedOneWithoutGenericRoomReadingsInput = {
    create?: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
    connectOrCreate?: RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput
    connect?: RoomReadingWhereUniqueInput
  }

  export type EnumRoomReadingTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomReadingType
  }

  export type RoomReadingUpdateOneRequiredWithoutGenericRoomReadingsNestedInput = {
    create?: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
    connectOrCreate?: RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput
    upsert?: RoomReadingUpsertWithoutGenericRoomReadingsInput
    connect?: RoomReadingWhereUniqueInput
    update?: XOR<XOR<RoomReadingUpdateToOneWithWhereWithoutGenericRoomReadingsInput, RoomReadingUpdateWithoutGenericRoomReadingsInput>, RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput>
  }

  export type InferenceCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutDetectionsInput
    connect?: InferenceWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutDetectionsInput
    connect?: RoomWhereUniqueInput
  }

  export type NullableEnumDimensionUnitFieldUpdateOperationsInput = {
    set?: $Enums.DimensionUnit | null
  }

  export type InferenceUpdateOneRequiredWithoutDetectionsNestedInput = {
    create?: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InferenceCreateOrConnectWithoutDetectionsInput
    upsert?: InferenceUpsertWithoutDetectionsInput
    connect?: InferenceWhereUniqueInput
    update?: XOR<XOR<InferenceUpdateToOneWithWhereWithoutDetectionsInput, InferenceUpdateWithoutDetectionsInput>, InferenceUncheckedUpdateWithoutDetectionsInput>
  }

  export type RoomUpdateOneWithoutDetectionsNestedInput = {
    create?: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutDetectionsInput
    upsert?: RoomUpsertWithoutDetectionsInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutDetectionsInput, RoomUpdateWithoutDetectionsInput>, RoomUncheckedUpdateWithoutDetectionsInput>
  }

  export type RoomCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTemplatesInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTemplatesInput
    upsert?: RoomUpsertWithoutTemplatesInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutTemplatesInput, RoomUpdateWithoutTemplatesInput>, RoomUncheckedUpdateWithoutTemplatesInput>
  }

  export type CalendarEventReminderCreateNestedManyWithoutCalendarEventInput = {
    create?: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput> | CalendarEventReminderCreateWithoutCalendarEventInput[] | CalendarEventReminderUncheckedCreateWithoutCalendarEventInput[]
    connectOrCreate?: CalendarEventReminderCreateOrConnectWithoutCalendarEventInput | CalendarEventReminderCreateOrConnectWithoutCalendarEventInput[]
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    connect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutEventsInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput = {
    create?: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput> | CalendarEventReminderCreateWithoutCalendarEventInput[] | CalendarEventReminderUncheckedCreateWithoutCalendarEventInput[]
    connectOrCreate?: CalendarEventReminderCreateOrConnectWithoutCalendarEventInput | CalendarEventReminderCreateOrConnectWithoutCalendarEventInput[]
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    connect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
  }

  export type CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput = {
    create?: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput> | CalendarEventReminderCreateWithoutCalendarEventInput[] | CalendarEventReminderUncheckedCreateWithoutCalendarEventInput[]
    connectOrCreate?: CalendarEventReminderCreateOrConnectWithoutCalendarEventInput | CalendarEventReminderCreateOrConnectWithoutCalendarEventInput[]
    upsert?: CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput | CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput[]
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    set?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    disconnect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    delete?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    connect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    update?: CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput | CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput[]
    updateMany?: CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput | CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput[]
    deleteMany?: CalendarEventReminderScalarWhereInput | CalendarEventReminderScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    upsert?: ProjectUpsertWithoutEventsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEventsInput, ProjectUpdateWithoutEventsInput>, ProjectUncheckedUpdateWithoutEventsInput>
  }

  export type CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput = {
    create?: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput> | CalendarEventReminderCreateWithoutCalendarEventInput[] | CalendarEventReminderUncheckedCreateWithoutCalendarEventInput[]
    connectOrCreate?: CalendarEventReminderCreateOrConnectWithoutCalendarEventInput | CalendarEventReminderCreateOrConnectWithoutCalendarEventInput[]
    upsert?: CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput | CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput[]
    createMany?: CalendarEventReminderCreateManyCalendarEventInputEnvelope
    set?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    disconnect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    delete?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    connect?: CalendarEventReminderWhereUniqueInput | CalendarEventReminderWhereUniqueInput[]
    update?: CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput | CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput[]
    updateMany?: CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput | CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput[]
    deleteMany?: CalendarEventReminderScalarWhereInput | CalendarEventReminderScalarWhereInput[]
  }

  export type CalendarEventCreateNestedOneWithoutRemindersInput = {
    create?: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutRemindersInput
    connect?: CalendarEventWhereUniqueInput
  }

  export type EnumReminderTargetFieldUpdateOperationsInput = {
    set?: $Enums.ReminderTarget
  }

  export type CalendarEventUpdateOneWithoutRemindersNestedInput = {
    create?: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutRemindersInput
    upsert?: CalendarEventUpsertWithoutRemindersInput
    disconnect?: CalendarEventWhereInput | boolean
    delete?: CalendarEventWhereInput | boolean
    connect?: CalendarEventWhereUniqueInput
    update?: XOR<XOR<CalendarEventUpdateToOneWithWhereWithoutRemindersInput, CalendarEventUpdateWithoutRemindersInput>, CalendarEventUncheckedUpdateWithoutRemindersInput>
  }

  export type LineItemCreateNestedManyWithoutXactimateCategoryInput = {
    create?: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput> | LineItemCreateWithoutXactimateCategoryInput[] | LineItemUncheckedCreateWithoutXactimateCategoryInput[]
    connectOrCreate?: LineItemCreateOrConnectWithoutXactimateCategoryInput | LineItemCreateOrConnectWithoutXactimateCategoryInput[]
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    connect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
  }

  export type LineItemUncheckedCreateNestedManyWithoutXactimateCategoryInput = {
    create?: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput> | LineItemCreateWithoutXactimateCategoryInput[] | LineItemUncheckedCreateWithoutXactimateCategoryInput[]
    connectOrCreate?: LineItemCreateOrConnectWithoutXactimateCategoryInput | LineItemCreateOrConnectWithoutXactimateCategoryInput[]
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    connect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
  }

  export type LineItemUpdateManyWithoutXactimateCategoryNestedInput = {
    create?: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput> | LineItemCreateWithoutXactimateCategoryInput[] | LineItemUncheckedCreateWithoutXactimateCategoryInput[]
    connectOrCreate?: LineItemCreateOrConnectWithoutXactimateCategoryInput | LineItemCreateOrConnectWithoutXactimateCategoryInput[]
    upsert?: LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput | LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput[]
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    set?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    disconnect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    delete?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    connect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    update?: LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput | LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput[]
    updateMany?: LineItemUpdateManyWithWhereWithoutXactimateCategoryInput | LineItemUpdateManyWithWhereWithoutXactimateCategoryInput[]
    deleteMany?: LineItemScalarWhereInput | LineItemScalarWhereInput[]
  }

  export type LineItemUncheckedUpdateManyWithoutXactimateCategoryNestedInput = {
    create?: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput> | LineItemCreateWithoutXactimateCategoryInput[] | LineItemUncheckedCreateWithoutXactimateCategoryInput[]
    connectOrCreate?: LineItemCreateOrConnectWithoutXactimateCategoryInput | LineItemCreateOrConnectWithoutXactimateCategoryInput[]
    upsert?: LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput | LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput[]
    createMany?: LineItemCreateManyXactimateCategoryInputEnvelope
    set?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    disconnect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    delete?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    connect?: LineItemWhereUniqueInput | LineItemWhereUniqueInput[]
    update?: LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput | LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput[]
    updateMany?: LineItemUpdateManyWithWhereWithoutXactimateCategoryInput | LineItemUpdateManyWithWhereWithoutXactimateCategoryInput[]
    deleteMany?: LineItemScalarWhereInput | LineItemScalarWhereInput[]
  }

  export type ItemCategoryCreateNestedOneWithoutLineItemInput = {
    create?: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutLineItemInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type AlternateItemCreateNestedManyWithoutLineItemInput = {
    create?: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput> | AlternateItemCreateWithoutLineItemInput[] | AlternateItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: AlternateItemCreateOrConnectWithoutLineItemInput | AlternateItemCreateOrConnectWithoutLineItemInput[]
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    connect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
  }

  export type RelatedItemCreateNestedManyWithoutLineItemInput = {
    create?: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput> | RelatedItemCreateWithoutLineItemInput[] | RelatedItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: RelatedItemCreateOrConnectWithoutLineItemInput | RelatedItemCreateOrConnectWithoutLineItemInput[]
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    connect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
  }

  export type AlternateItemUncheckedCreateNestedManyWithoutLineItemInput = {
    create?: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput> | AlternateItemCreateWithoutLineItemInput[] | AlternateItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: AlternateItemCreateOrConnectWithoutLineItemInput | AlternateItemCreateOrConnectWithoutLineItemInput[]
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    connect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
  }

  export type RelatedItemUncheckedCreateNestedManyWithoutLineItemInput = {
    create?: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput> | RelatedItemCreateWithoutLineItemInput[] | RelatedItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: RelatedItemCreateOrConnectWithoutLineItemInput | RelatedItemCreateOrConnectWithoutLineItemInput[]
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    connect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
  }

  export type ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutLineItemInput
    upsert?: ItemCategoryUpsertWithoutLineItemInput
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutLineItemInput, ItemCategoryUpdateWithoutLineItemInput>, ItemCategoryUncheckedUpdateWithoutLineItemInput>
  }

  export type AlternateItemUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput> | AlternateItemCreateWithoutLineItemInput[] | AlternateItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: AlternateItemCreateOrConnectWithoutLineItemInput | AlternateItemCreateOrConnectWithoutLineItemInput[]
    upsert?: AlternateItemUpsertWithWhereUniqueWithoutLineItemInput | AlternateItemUpsertWithWhereUniqueWithoutLineItemInput[]
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    set?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    disconnect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    delete?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    connect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    update?: AlternateItemUpdateWithWhereUniqueWithoutLineItemInput | AlternateItemUpdateWithWhereUniqueWithoutLineItemInput[]
    updateMany?: AlternateItemUpdateManyWithWhereWithoutLineItemInput | AlternateItemUpdateManyWithWhereWithoutLineItemInput[]
    deleteMany?: AlternateItemScalarWhereInput | AlternateItemScalarWhereInput[]
  }

  export type RelatedItemUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput> | RelatedItemCreateWithoutLineItemInput[] | RelatedItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: RelatedItemCreateOrConnectWithoutLineItemInput | RelatedItemCreateOrConnectWithoutLineItemInput[]
    upsert?: RelatedItemUpsertWithWhereUniqueWithoutLineItemInput | RelatedItemUpsertWithWhereUniqueWithoutLineItemInput[]
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    set?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    disconnect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    delete?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    connect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    update?: RelatedItemUpdateWithWhereUniqueWithoutLineItemInput | RelatedItemUpdateWithWhereUniqueWithoutLineItemInput[]
    updateMany?: RelatedItemUpdateManyWithWhereWithoutLineItemInput | RelatedItemUpdateManyWithWhereWithoutLineItemInput[]
    deleteMany?: RelatedItemScalarWhereInput | RelatedItemScalarWhereInput[]
  }

  export type AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput> | AlternateItemCreateWithoutLineItemInput[] | AlternateItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: AlternateItemCreateOrConnectWithoutLineItemInput | AlternateItemCreateOrConnectWithoutLineItemInput[]
    upsert?: AlternateItemUpsertWithWhereUniqueWithoutLineItemInput | AlternateItemUpsertWithWhereUniqueWithoutLineItemInput[]
    createMany?: AlternateItemCreateManyLineItemInputEnvelope
    set?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    disconnect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    delete?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    connect?: AlternateItemWhereUniqueInput | AlternateItemWhereUniqueInput[]
    update?: AlternateItemUpdateWithWhereUniqueWithoutLineItemInput | AlternateItemUpdateWithWhereUniqueWithoutLineItemInput[]
    updateMany?: AlternateItemUpdateManyWithWhereWithoutLineItemInput | AlternateItemUpdateManyWithWhereWithoutLineItemInput[]
    deleteMany?: AlternateItemScalarWhereInput | AlternateItemScalarWhereInput[]
  }

  export type RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput = {
    create?: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput> | RelatedItemCreateWithoutLineItemInput[] | RelatedItemUncheckedCreateWithoutLineItemInput[]
    connectOrCreate?: RelatedItemCreateOrConnectWithoutLineItemInput | RelatedItemCreateOrConnectWithoutLineItemInput[]
    upsert?: RelatedItemUpsertWithWhereUniqueWithoutLineItemInput | RelatedItemUpsertWithWhereUniqueWithoutLineItemInput[]
    createMany?: RelatedItemCreateManyLineItemInputEnvelope
    set?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    disconnect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    delete?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    connect?: RelatedItemWhereUniqueInput | RelatedItemWhereUniqueInput[]
    update?: RelatedItemUpdateWithWhereUniqueWithoutLineItemInput | RelatedItemUpdateWithWhereUniqueWithoutLineItemInput[]
    updateMany?: RelatedItemUpdateManyWithWhereWithoutLineItemInput | RelatedItemUpdateManyWithWhereWithoutLineItemInput[]
    deleteMany?: RelatedItemScalarWhereInput | RelatedItemScalarWhereInput[]
  }

  export type LineItemCreateNestedOneWithoutRelatedItemInput = {
    create?: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutRelatedItemInput
    connect?: LineItemWhereUniqueInput
  }

  export type LineItemUpdateOneRequiredWithoutRelatedItemNestedInput = {
    create?: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutRelatedItemInput
    upsert?: LineItemUpsertWithoutRelatedItemInput
    connect?: LineItemWhereUniqueInput
    update?: XOR<XOR<LineItemUpdateToOneWithWhereWithoutRelatedItemInput, LineItemUpdateWithoutRelatedItemInput>, LineItemUncheckedUpdateWithoutRelatedItemInput>
  }

  export type LineItemCreateNestedOneWithoutAlternateItemInput = {
    create?: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutAlternateItemInput
    connect?: LineItemWhereUniqueInput
  }

  export type LineItemUpdateOneRequiredWithoutAlternateItemNestedInput = {
    create?: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
    connectOrCreate?: LineItemCreateOrConnectWithoutAlternateItemInput
    upsert?: LineItemUpsertWithoutAlternateItemInput
    connect?: LineItemWhereUniqueInput
    update?: XOR<XOR<LineItemUpdateToOneWithWhereWithoutAlternateItemInput, LineItemUpdateWithoutAlternateItemInput>, LineItemUncheckedUpdateWithoutAlternateItemInput>
  }

  export type OrganizationCreateNestedOneWithoutCustomersInput = {
    create?: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomersInput
    upsert?: OrganizationUpsertWithoutCustomersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCustomersInput, OrganizationUpdateWithoutCustomersInput>, OrganizationUncheckedUpdateWithoutCustomersInput>
  }

  export type PricesCreateNestedManyWithoutProductInput = {
    create?: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput> | PricesCreateWithoutProductInput[] | PricesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PricesCreateOrConnectWithoutProductInput | PricesCreateOrConnectWithoutProductInput[]
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
  }

  export type PricesUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput> | PricesCreateWithoutProductInput[] | PricesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PricesCreateOrConnectWithoutProductInput | PricesCreateOrConnectWithoutProductInput[]
    createMany?: PricesCreateManyProductInputEnvelope
    connect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
  }

  export type PricesUpdateManyWithoutProductNestedInput = {
    create?: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput> | PricesCreateWithoutProductInput[] | PricesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PricesCreateOrConnectWithoutProductInput | PricesCreateOrConnectWithoutProductInput[]
    upsert?: PricesUpsertWithWhereUniqueWithoutProductInput | PricesUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PricesCreateManyProductInputEnvelope
    set?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    disconnect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    delete?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    connect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    update?: PricesUpdateWithWhereUniqueWithoutProductInput | PricesUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PricesUpdateManyWithWhereWithoutProductInput | PricesUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PricesScalarWhereInput | PricesScalarWhereInput[]
  }

  export type PricesUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput> | PricesCreateWithoutProductInput[] | PricesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PricesCreateOrConnectWithoutProductInput | PricesCreateOrConnectWithoutProductInput[]
    upsert?: PricesUpsertWithWhereUniqueWithoutProductInput | PricesUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PricesCreateManyProductInputEnvelope
    set?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    disconnect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    delete?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    connect?: PricesWhereUniqueInput | PricesWhereUniqueInput[]
    update?: PricesUpdateWithWhereUniqueWithoutProductInput | PricesUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PricesUpdateManyWithWhereWithoutProductInput | PricesUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PricesScalarWhereInput | PricesScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutPricesInput = {
    create?: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPricesInput
    connect?: ProductsWhereUniqueInput
  }

  export type SubscriptionsCreateNestedManyWithoutPriceInput = {
    create?: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput> | SubscriptionsCreateWithoutPriceInput[] | SubscriptionsUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPriceInput | SubscriptionsCreateOrConnectWithoutPriceInput[]
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput> | SubscriptionsCreateWithoutPriceInput[] | SubscriptionsUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPriceInput | SubscriptionsCreateOrConnectWithoutPriceInput[]
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumPricingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PricingType
  }

  export type NullableEnumPricingPlanIntervalFieldUpdateOperationsInput = {
    set?: $Enums.PricingPlanInterval | null
  }

  export type ProductsUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPricesInput
    upsert?: ProductsUpsertWithoutPricesInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutPricesInput, ProductsUpdateWithoutPricesInput>, ProductsUncheckedUpdateWithoutPricesInput>
  }

  export type SubscriptionsUpdateManyWithoutPriceNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput> | SubscriptionsCreateWithoutPriceInput[] | SubscriptionsUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPriceInput | SubscriptionsCreateOrConnectWithoutPriceInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutPriceInput | SubscriptionsUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutPriceInput | SubscriptionsUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutPriceInput | SubscriptionsUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput> | SubscriptionsCreateWithoutPriceInput[] | SubscriptionsUncheckedCreateWithoutPriceInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPriceInput | SubscriptionsCreateOrConnectWithoutPriceInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutPriceInput | SubscriptionsUpsertWithWhereUniqueWithoutPriceInput[]
    createMany?: SubscriptionsCreateManyPriceInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutPriceInput | SubscriptionsUpdateWithWhereUniqueWithoutPriceInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutPriceInput | SubscriptionsUpdateManyWithWhereWithoutPriceInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type PricesCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutSubscriptionsInput
    connect?: PricesWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type PricesUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PricesCreateOrConnectWithoutSubscriptionsInput
    upsert?: PricesUpsertWithoutSubscriptionsInput
    connect?: PricesWhereUniqueInput
    update?: XOR<XOR<PricesUpdateToOneWithWhereWithoutSubscriptionsInput, PricesUpdateWithoutSubscriptionsInput>, PricesUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionsInput
    upsert?: OrganizationUpsertWithoutSubscriptionsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubscriptionsInput, OrganizationUpdateWithoutSubscriptionsInput>, OrganizationUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumDashboardViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardViews | EnumDashboardViewsFieldRefInput<$PrismaModel>
    in?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumDashboardViewsFilter<$PrismaModel> | $Enums.DashboardViews
  }

  export type NestedEnumPhotoViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoViews | EnumPhotoViewsFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoViewsFilter<$PrismaModel> | $Enums.PhotoViews
  }

  export type NestedEnumGroupByViewsFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupByViews | EnumGroupByViewsFieldRefInput<$PrismaModel>
    in?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupByViewsFilter<$PrismaModel> | $Enums.GroupByViews
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDashboardViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardViews | EnumDashboardViewsFieldRefInput<$PrismaModel>
    in?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.DashboardViews[] | ListEnumDashboardViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumDashboardViewsWithAggregatesFilter<$PrismaModel> | $Enums.DashboardViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDashboardViewsFilter<$PrismaModel>
    _max?: NestedEnumDashboardViewsFilter<$PrismaModel>
  }

  export type NestedEnumPhotoViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhotoViews | EnumPhotoViewsFieldRefInput<$PrismaModel>
    in?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhotoViews[] | ListEnumPhotoViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumPhotoViewsWithAggregatesFilter<$PrismaModel> | $Enums.PhotoViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhotoViewsFilter<$PrismaModel>
    _max?: NestedEnumPhotoViewsFilter<$PrismaModel>
  }

  export type NestedEnumGroupByViewsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupByViews | EnumGroupByViewsFieldRefInput<$PrismaModel>
    in?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupByViews[] | ListEnumGroupByViewsFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupByViewsWithAggregatesFilter<$PrismaModel> | $Enums.GroupByViews
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupByViewsFilter<$PrismaModel>
    _max?: NestedEnumGroupByViewsFilter<$PrismaModel>
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSavedOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SavedOptionType | EnumSavedOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavedOptionTypeFilter<$PrismaModel> | $Enums.SavedOptionType
  }

  export type NestedEnumSavedOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SavedOptionType | EnumSavedOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavedOptionType[] | ListEnumSavedOptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavedOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SavedOptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSavedOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSavedOptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAccessLevelNullableFilter<$PrismaModel> | $Enums.AccessLevel | null
  }

  export type NestedEnumAccessLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAccessLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProjectStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProjectStatusNullableFilter<$PrismaModel> | $Enums.ProjectStatus | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProjectStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeFilter<$PrismaModel> | $Enums.CostType
  }

  export type NestedEnumCostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeWithAggregatesFilter<$PrismaModel> | $Enums.CostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostTypeFilter<$PrismaModel>
    _max?: NestedEnumCostTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotesAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.NotesAuditAction | EnumNotesAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotesAuditActionFilter<$PrismaModel> | $Enums.NotesAuditAction
  }

  export type NestedEnumNotesAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotesAuditAction | EnumNotesAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotesAuditAction[] | ListEnumNotesAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumNotesAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.NotesAuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotesAuditActionFilter<$PrismaModel>
    _max?: NestedEnumNotesAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAreaAffectedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaAffectedType | EnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAreaAffectedTypeFilter<$PrismaModel> | $Enums.AreaAffectedType
  }

  export type NestedEnumAreaAffectedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaAffectedType | EnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AreaAffectedType[] | ListEnumAreaAffectedTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAreaAffectedTypeWithAggregatesFilter<$PrismaModel> | $Enums.AreaAffectedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaAffectedTypeFilter<$PrismaModel>
    _max?: NestedEnumAreaAffectedTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoomReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomReadingType | EnumRoomReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomReadingTypeFilter<$PrismaModel> | $Enums.RoomReadingType
  }

  export type NestedEnumRoomReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomReadingType | EnumRoomReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomReadingType[] | ListEnumRoomReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomReadingTypeFilter<$PrismaModel>
  }

  export type NestedEnumDimensionUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDimensionUnitNullableFilter<$PrismaModel> | $Enums.DimensionUnit | null
  }

  export type NestedEnumDimensionUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDimensionUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitNullableFilter<$PrismaModel>
  }

  export type NestedEnumReminderTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderTarget | EnumReminderTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTargetFilter<$PrismaModel> | $Enums.ReminderTarget
  }

  export type NestedEnumReminderTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderTarget | EnumReminderTargetFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderTarget[] | ListEnumReminderTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTargetWithAggregatesFilter<$PrismaModel> | $Enums.ReminderTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTargetFilter<$PrismaModel>
    _max?: NestedEnumReminderTargetFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingPlanInterval | EnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel> | $Enums.PricingPlanInterval | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type NestedEnumPricingPlanIntervalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingPlanInterval | EnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingPlanInterval[] | ListEnumPricingPlanIntervalFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingPlanIntervalNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricingPlanInterval | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel>
    _max?: NestedEnumPricingPlanIntervalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type UserToOrganizationCreateWithoutUserInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UserToOrganizationUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    organizationId: number
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
  }

  export type UserToOrganizationCreateOrConnectWithoutUserInput = {
    where: UserToOrganizationWhereUniqueInput
    create: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectCreateWithoutUserInput = {
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectAssigneesInput
  }

  export type UserToProjectUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type UserToProjectCreateOrConnectWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    create: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectCreateManyUserInputEnvelope = {
    data: UserToProjectCreateManyUserInput | UserToProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ImageNoteCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    isDeleted?: boolean
  }

  export type ImageNoteCreateOrConnectWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    create: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput>
  }

  export type ImageNoteCreateManyUserInputEnvelope = {
    data: ImageNoteCreateManyUserInput | ImageNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    Image: ImageCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationCreateManyUserInputEnvelope = {
    data: AnnotationCreateManyUserInput | AnnotationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutUserInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserToOrganizationUpsertWithoutUserInput = {
    update: XOR<UserToOrganizationUpdateWithoutUserInput, UserToOrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<UserToOrganizationCreateWithoutUserInput, UserToOrganizationUncheckedCreateWithoutUserInput>
    where?: UserToOrganizationWhereInput
  }

  export type UserToOrganizationUpdateToOneWithWhereWithoutUserInput = {
    where?: UserToOrganizationWhereInput
    data: XOR<UserToOrganizationUpdateWithoutUserInput, UserToOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserToOrganizationUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserToOrganizationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
  }

  export type UserToProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    update: XOR<UserToProjectUpdateWithoutUserInput, UserToProjectUncheckedUpdateWithoutUserInput>
    create: XOR<UserToProjectCreateWithoutUserInput, UserToProjectUncheckedCreateWithoutUserInput>
  }

  export type UserToProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToProjectWhereUniqueInput
    data: XOR<UserToProjectUpdateWithoutUserInput, UserToProjectUncheckedUpdateWithoutUserInput>
  }

  export type UserToProjectUpdateManyWithWhereWithoutUserInput = {
    where: UserToProjectScalarWhereInput
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type UserToProjectScalarWhereInput = {
    AND?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
    OR?: UserToProjectScalarWhereInput[]
    NOT?: UserToProjectScalarWhereInput | UserToProjectScalarWhereInput[]
    id?: IntFilter<"UserToProject"> | number
    createdAt?: DateTimeFilter<"UserToProject"> | Date | string
    userId?: StringFilter<"UserToProject"> | string
    projectId?: IntFilter<"UserToProject"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    publicId?: UuidFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isSeen?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    linkText?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    userId?: StringFilter<"Notification"> | string
  }

  export type ImageNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    update: XOR<ImageNoteUpdateWithoutUserInput, ImageNoteUncheckedUpdateWithoutUserInput>
    create: XOR<ImageNoteCreateWithoutUserInput, ImageNoteUncheckedCreateWithoutUserInput>
  }

  export type ImageNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ImageNoteWhereUniqueInput
    data: XOR<ImageNoteUpdateWithoutUserInput, ImageNoteUncheckedUpdateWithoutUserInput>
  }

  export type ImageNoteUpdateManyWithWhereWithoutUserInput = {
    where: ImageNoteScalarWhereInput
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ImageNoteScalarWhereInput = {
    AND?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
    OR?: ImageNoteScalarWhereInput[]
    NOT?: ImageNoteScalarWhereInput | ImageNoteScalarWhereInput[]
    id?: IntFilter<"ImageNote"> | number
    createdAt?: DateTimeFilter<"ImageNote"> | Date | string
    updatedAt?: DateTimeFilter<"ImageNote"> | Date | string
    imageId?: IntFilter<"ImageNote"> | number
    body?: StringFilter<"ImageNote"> | string
    mentions?: StringNullableListFilter<"ImageNote">
    userId?: StringFilter<"ImageNote"> | string
    isDeleted?: BoolFilter<"ImageNote"> | boolean
  }

  export type AnnotationUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutUserInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutUserInput>
  }

  export type AnnotationScalarWhereInput = {
    AND?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    OR?: AnnotationScalarWhereInput[]
    NOT?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    id?: IntFilter<"Annotation"> | number
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    updatedAt?: DateTimeFilter<"Annotation"> | Date | string
    imageId?: IntFilter<"Annotation"> | number
    coordinates?: JsonFilter<"Annotation">
    userId?: StringFilter<"Annotation"> | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
  }

  export type OrganizationUpsertWithoutUserInput = {
    update: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUserInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUpdateWithoutUserInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ImageCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageCreateManyOrganizationInputEnvelope = {
    data: ImageCreateManyOrganizationInput | ImageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationInvitationCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type OrganizationInvitationCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationCreateManyOrganizationInputEnvelope = {
    data: OrganizationInvitationCreateManyOrganizationInput | OrganizationInvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: ProjectCreateManyOrganizationInput | ProjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserToOrganizationCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    user: UserCreateNestedOneWithoutOrgInput
  }

  export type UserToOrganizationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    userId: string
  }

  export type UserToOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    create: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserToOrganizationCreateManyOrganizationInputEnvelope = {
    data: UserToOrganizationCreateManyOrganizationInput | UserToOrganizationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutOrganizationInput = {
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedCreateWithoutOrganizationInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersCreateOrConnectWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomersCreateManyOrganizationInputEnvelope = {
    data: CustomersCreateManyOrganizationInput | CustomersCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionsCreateWithoutOrganizationInput = {
    id: string
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    price: PricesCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutOrganizationInput = {
    id: string
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsCreateOrConnectWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionsCreateManyOrganizationInputEnvelope = {
    data: SubscriptionsCreateManyOrganizationInput | SubscriptionsCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationSavedOptionCreateWithoutOrganizationInput = {
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    create: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionCreateManyOrganizationInputEnvelope = {
    data: OrganizationSavedOptionCreateManyOrganizationInput | OrganizationSavedOptionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutOrganizationInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    ProjectEquipment?: ProjectEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    ProjectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput>
  }

  export type EquipmentCreateManyOrganizationInputEnvelope = {
    data: EquipmentCreateManyOrganizationInput | EquipmentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectStatusValueCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueUncheckedCreateWithoutOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    projects?: ProjectUncheckedCreateNestedManyWithoutCurrentStatusInput
  }

  export type ProjectStatusValueCreateOrConnectWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    create: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectStatusValueCreateManyOrganizationInputEnvelope = {
    data: ProjectStatusValueCreateManyOrganizationInput | ProjectStatusValueCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutOrganizationInput, ImageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ImageCreateWithoutOrganizationInput, ImageUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutOrganizationInput, ImageUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageUpdateManyWithWhereWithoutOrganizationInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: IntFilter<"Image"> | number
    createdAt?: DateTimeFilter<"Image"> | Date | string
    isDeleted?: BoolFilter<"Image"> | boolean
    publicId?: StringFilter<"Image"> | string
    key?: StringFilter<"Image"> | string
    projectId?: IntFilter<"Image"> | number
    organizationId?: IntNullableFilter<"Image"> | number | null
    includeInReport?: BoolFilter<"Image"> | boolean
    description?: StringNullableFilter<"Image"> | string | null
  }

  export type OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    update: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    data: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationInvitationScalarWhereInput
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationInvitationScalarWhereInput = {
    AND?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
    OR?: OrganizationInvitationScalarWhereInput[]
    NOT?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
    id?: IntFilter<"OrganizationInvitation"> | number
    createdAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    isDeleted?: BoolFilter<"OrganizationInvitation"> | boolean
    organizationId?: IntFilter<"OrganizationInvitation"> | number
    email?: StringFilter<"OrganizationInvitation"> | string
    invitationId?: StringFilter<"OrganizationInvitation"> | string
    isAccepted?: BoolFilter<"OrganizationInvitation"> | boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    closedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isDeleted?: BoolFilter<"Project"> | boolean
    organizationId?: IntFilter<"Project"> | number
    assignmentNumber?: StringFilter<"Project"> | string
    publicId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    location?: StringFilter<"Project"> | string
    clientName?: StringFilter<"Project"> | string
    clientEmail?: StringFilter<"Project"> | string
    clientPhoneNumber?: StringFilter<"Project"> | string
    companyName?: StringFilter<"Project"> | string
    managerName?: StringFilter<"Project"> | string
    adjusterEmail?: StringFilter<"Project"> | string
    adjusterName?: StringFilter<"Project"> | string
    adjusterPhoneNumber?: StringFilter<"Project"> | string
    insuranceCompanyName?: StringFilter<"Project"> | string
    insuranceClaimId?: StringFilter<"Project"> | string
    lossType?: StringFilter<"Project"> | string
    catCode?: IntNullableFilter<"Project"> | number | null
    humidity?: StringFilter<"Project"> | string
    lastTimeWeatherFetched?: DateTimeNullableFilter<"Project"> | Date | string | null
    temperature?: StringFilter<"Project"> | string
    wind?: StringFilter<"Project"> | string
    lat?: StringFilter<"Project"> | string
    lng?: StringFilter<"Project"> | string
    forecast?: StringFilter<"Project"> | string
    claimSummary?: StringFilter<"Project"> | string
    roofSegments?: JsonNullableListFilter<"Project">
    roofSpecs?: JsonNullableFilter<"Project">
    rcvValue?: FloatNullableFilter<"Project"> | number | null
    actualValue?: FloatNullableFilter<"Project"> | number | null
    status?: EnumProjectStatusNullableFilter<"Project"> | $Enums.ProjectStatus | null
    projectStatusValueId?: IntNullableFilter<"Project"> | number | null
  }

  export type UserToOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    update: XOR<UserToOrganizationUpdateWithoutOrganizationInput, UserToOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserToOrganizationCreateWithoutOrganizationInput, UserToOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserToOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserToOrganizationWhereUniqueInput
    data: XOR<UserToOrganizationUpdateWithoutOrganizationInput, UserToOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserToOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserToOrganizationScalarWhereInput
    data: XOR<UserToOrganizationUpdateManyMutationInput, UserToOrganizationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserToOrganizationScalarWhereInput = {
    AND?: UserToOrganizationScalarWhereInput | UserToOrganizationScalarWhereInput[]
    OR?: UserToOrganizationScalarWhereInput[]
    NOT?: UserToOrganizationScalarWhereInput | UserToOrganizationScalarWhereInput[]
    id?: IntFilter<"UserToOrganization"> | number
    createdAt?: DateTimeFilter<"UserToOrganization"> | Date | string
    isAdmin?: BoolFilter<"UserToOrganization"> | boolean
    isDeleted?: BoolFilter<"UserToOrganization"> | boolean
    organizationId?: IntFilter<"UserToOrganization"> | number
    role?: StringNullableFilter<"UserToOrganization"> | string | null
    accessLevel?: EnumAccessLevelNullableFilter<"UserToOrganization"> | $Enums.AccessLevel | null
    userId?: StringFilter<"UserToOrganization"> | string
  }

  export type CustomersUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutOrganizationInput, CustomersUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CustomersCreateWithoutOrganizationInput, CustomersUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutOrganizationInput, CustomersUncheckedUpdateWithoutOrganizationInput>
  }

  export type CustomersUpdateManyWithWhereWithoutOrganizationInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    OR?: CustomersScalarWhereInput[]
    NOT?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    id?: IntFilter<"Customers"> | number
    customerId?: StringFilter<"Customers"> | string
    billingAddress?: JsonNullableFilter<"Customers">
    paymentMethod?: JsonNullableFilter<"Customers">
    organizationId?: IntFilter<"Customers"> | number
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutOrganizationInput, SubscriptionsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubscriptionsCreateWithoutOrganizationInput, SubscriptionsUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutOrganizationInput, SubscriptionsUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SubscriptionsScalarWhereInput = {
    AND?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    OR?: SubscriptionsScalarWhereInput[]
    NOT?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    id?: StringFilter<"Subscriptions"> | string
    organizationId?: IntFilter<"Subscriptions"> | number
    status?: EnumSubscriptionStatusFilter<"Subscriptions"> | $Enums.SubscriptionStatus
    metadata?: JsonNullableFilter<"Subscriptions">
    pricesId?: StringFilter<"Subscriptions"> | string
    quantity?: IntFilter<"Subscriptions"> | number
    cancelAtPeriodEnd?: BoolFilter<"Subscriptions"> | boolean
    created?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    cancelAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
  }

  export type OrganizationSavedOptionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    update: XOR<OrganizationSavedOptionUpdateWithoutOrganizationInput, OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationSavedOptionCreateWithoutOrganizationInput, OrganizationSavedOptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSavedOptionWhereUniqueInput
    data: XOR<OrganizationSavedOptionUpdateWithoutOrganizationInput, OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationSavedOptionScalarWhereInput
    data: XOR<OrganizationSavedOptionUpdateManyMutationInput, OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationSavedOptionScalarWhereInput = {
    AND?: OrganizationSavedOptionScalarWhereInput | OrganizationSavedOptionScalarWhereInput[]
    OR?: OrganizationSavedOptionScalarWhereInput[]
    NOT?: OrganizationSavedOptionScalarWhereInput | OrganizationSavedOptionScalarWhereInput[]
    id?: IntFilter<"OrganizationSavedOption"> | number
    publicId?: UuidFilter<"OrganizationSavedOption"> | string
    createdAt?: DateTimeFilter<"OrganizationSavedOption"> | Date | string
    label?: StringFilter<"OrganizationSavedOption"> | string
    value?: StringFilter<"OrganizationSavedOption"> | string
    isDeleted?: BoolFilter<"OrganizationSavedOption"> | boolean
    type?: EnumSavedOptionTypeFilter<"OrganizationSavedOption"> | $Enums.SavedOptionType
    organizationId?: IntFilter<"OrganizationSavedOption"> | number
  }

  export type EquipmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutOrganizationInput, EquipmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EquipmentCreateWithoutOrganizationInput, EquipmentUncheckedCreateWithoutOrganizationInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutOrganizationInput, EquipmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: IntFilter<"Equipment"> | number
    publicId?: UuidFilter<"Equipment"> | string
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    isDeleted?: BoolFilter<"Equipment"> | boolean
    name?: StringFilter<"Equipment"> | string
    quantity?: IntFilter<"Equipment"> | number
    organizationId?: IntFilter<"Equipment"> | number
  }

  export type ProjectStatusValueUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    update: XOR<ProjectStatusValueUpdateWithoutOrganizationInput, ProjectStatusValueUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectStatusValueCreateWithoutOrganizationInput, ProjectStatusValueUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectStatusValueUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectStatusValueWhereUniqueInput
    data: XOR<ProjectStatusValueUpdateWithoutOrganizationInput, ProjectStatusValueUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectStatusValueUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectStatusValueScalarWhereInput
    data: XOR<ProjectStatusValueUpdateManyMutationInput, ProjectStatusValueUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectStatusValueScalarWhereInput = {
    AND?: ProjectStatusValueScalarWhereInput | ProjectStatusValueScalarWhereInput[]
    OR?: ProjectStatusValueScalarWhereInput[]
    NOT?: ProjectStatusValueScalarWhereInput | ProjectStatusValueScalarWhereInput[]
    id?: IntFilter<"ProjectStatusValue"> | number
    createdAt?: DateTimeFilter<"ProjectStatusValue"> | Date | string
    isDeleted?: BoolFilter<"ProjectStatusValue"> | boolean
    publicId?: UuidFilter<"ProjectStatusValue"> | string
    label?: StringFilter<"ProjectStatusValue"> | string
    description?: StringFilter<"ProjectStatusValue"> | string
    color?: StringFilter<"ProjectStatusValue"> | string
    order?: IntNullableFilter<"ProjectStatusValue"> | number | null
    organizationId?: IntFilter<"ProjectStatusValue"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    token?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    isDeleted?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    inviteId?: StringNullableFilter<"User"> | string | null
    isSupportUser?: BoolFilter<"User"> | boolean
    hasSeenProductTour?: BoolFilter<"User"> | boolean
    productTourData?: JsonNullableFilter<"User">
    savedDashboardView?: EnumDashboardViewsFilter<"User"> | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFilter<"User"> | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFilter<"User"> | $Enums.GroupByViews
    onboardingStatus?: JsonNullableFilter<"User">
    organizationId?: UuidFilter<"User"> | string
  }

  export type OrganizationCreateWithoutEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEquipmentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentCreateWithoutEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    project: ProjectCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateWithoutEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
  }

  export type ProjectEquipmentCreateOrConnectWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    create: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentCreateManyEquipmentInputEnvelope = {
    data: ProjectEquipmentCreateManyEquipmentInput | ProjectEquipmentCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutEquipmentInput = {
    update: XOR<OrganizationUpdateWithoutEquipmentInput, OrganizationUncheckedUpdateWithoutEquipmentInput>
    create: XOR<OrganizationCreateWithoutEquipmentInput, OrganizationUncheckedCreateWithoutEquipmentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEquipmentInput, OrganizationUncheckedUpdateWithoutEquipmentInput>
  }

  export type OrganizationUpdateWithoutEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectEquipmentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    update: XOR<ProjectEquipmentUpdateWithoutEquipmentInput, ProjectEquipmentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<ProjectEquipmentCreateWithoutEquipmentInput, ProjectEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: ProjectEquipmentWhereUniqueInput
    data: XOR<ProjectEquipmentUpdateWithoutEquipmentInput, ProjectEquipmentUncheckedUpdateWithoutEquipmentInput>
  }

  export type ProjectEquipmentUpdateManyWithWhereWithoutEquipmentInput = {
    where: ProjectEquipmentScalarWhereInput
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type ProjectEquipmentScalarWhereInput = {
    AND?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
    OR?: ProjectEquipmentScalarWhereInput[]
    NOT?: ProjectEquipmentScalarWhereInput | ProjectEquipmentScalarWhereInput[]
    id?: IntFilter<"ProjectEquipment"> | number
    publicId?: UuidFilter<"ProjectEquipment"> | string
    createdAt?: DateTimeFilter<"ProjectEquipment"> | Date | string
    isDeleted?: BoolFilter<"ProjectEquipment"> | boolean
    quantity?: IntFilter<"ProjectEquipment"> | number
    projectId?: IntFilter<"ProjectEquipment"> | number
    equipmentId?: IntFilter<"ProjectEquipment"> | number
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutOrganizationSavedOptionInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationSavedOptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationUpsertWithoutOrganizationSavedOptionInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationSavedOptionInput, OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput>
    create: XOR<OrganizationCreateWithoutOrganizationSavedOptionInput, OrganizationUncheckedCreateWithoutOrganizationSavedOptionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationSavedOptionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationSavedOptionInput, OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput>
  }

  export type OrganizationUpdateWithoutOrganizationSavedOptionInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationSavedOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutUsersInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutOrgInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrgInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrgInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrgInput = {
    update: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrgInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
  }

  export type UserUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutUserToProjectInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserToProjectInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserToProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
  }

  export type ProjectCreateWithoutProjectAssigneesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectAssigneesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectAssigneesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
  }

  export type UserUpsertWithoutUserToProjectInput = {
    update: XOR<UserUpdateWithoutUserToProjectInput, UserUncheckedUpdateWithoutUserToProjectInput>
    create: XOR<UserCreateWithoutUserToProjectInput, UserUncheckedCreateWithoutUserToProjectInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserToProjectInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserToProjectInput, UserUncheckedUpdateWithoutUserToProjectInput>
  }

  export type UserUpdateWithoutUserToProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserToProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutProjectAssigneesInput = {
    update: XOR<ProjectUpdateWithoutProjectAssigneesInput, ProjectUncheckedUpdateWithoutProjectAssigneesInput>
    create: XOR<ProjectCreateWithoutProjectAssigneesInput, ProjectUncheckedCreateWithoutProjectAssigneesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectAssigneesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectAssigneesInput, ProjectUncheckedUpdateWithoutProjectAssigneesInput>
  }

  export type ProjectUpdateWithoutProjectAssigneesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutProjectsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type ImageCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutProjectInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput>
  }

  export type ImageCreateManyProjectInputEnvelope = {
    data: ImageCreateManyProjectInput | ImageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InferenceCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput>
  }

  export type InferenceCreateManyProjectInputEnvelope = {
    data: InferenceCreateManyProjectInput | InferenceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutProjectInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput>
  }

  export type RoomCreateManyProjectInputEnvelope = {
    data: RoomCreateManyProjectInput | RoomCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutProjectInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventUncheckedCreateWithoutProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    reminders?: CalendarEventReminderUncheckedCreateNestedManyWithoutCalendarEventInput
  }

  export type CalendarEventCreateOrConnectWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventCreateManyProjectInputEnvelope = {
    data: CalendarEventCreateManyProjectInput | CalendarEventCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserToProjectCreateWithoutProjectInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserToProjectInput
  }

  export type UserToProjectUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type UserToProjectCreateOrConnectWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    create: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput>
  }

  export type UserToProjectCreateManyProjectInputEnvelope = {
    data: UserToProjectCreateManyProjectInput | UserToProjectCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RoomReadingCreateWithoutProjectInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    roomId: number
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingCreateOrConnectWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput>
  }

  export type RoomReadingCreateManyProjectInputEnvelope = {
    data: RoomReadingCreateManyProjectInput | RoomReadingCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PropertyDataCreateWithoutProjectInput = {
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    bathrooms?: number | null
    bedrooms?: number | null
    squareFootage?: number | null
    realtyMoleId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataCreateOrConnectWithoutProjectInput = {
    where: PropertyDataWhereUniqueInput
    create: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedCreateWithoutProjectInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: $Enums.AreaAffectedType
    room: RoomCreateNestedOneWithoutAreasAffectedInput
  }

  export type AreaAffectedUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: $Enums.AreaAffectedType
  }

  export type AreaAffectedCreateOrConnectWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    create: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedCreateManyProjectInputEnvelope = {
    data: AreaAffectedCreateManyProjectInput | AreaAffectedCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PhotoAccessLinkCreateWithoutProjectInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type PhotoAccessLinkUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type PhotoAccessLinkCreateOrConnectWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    create: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput>
  }

  export type PhotoAccessLinkCreateManyProjectInputEnvelope = {
    data: PhotoAccessLinkCreateManyProjectInput | PhotoAccessLinkCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type NotesCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesCreateOrConnectWithoutProjectInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput>
  }

  export type NotesCreateManyProjectInputEnvelope = {
    data: NotesCreateManyProjectInput | NotesCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CostCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: $Enums.CostType
  }

  export type CostUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: $Enums.CostType
  }

  export type CostCreateOrConnectWithoutProjectInput = {
    where: CostWhereUniqueInput
    create: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput>
  }

  export type CostCreateManyProjectInputEnvelope = {
    data: CostCreateManyProjectInput | CostCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectEquipmentCreateWithoutProjectInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipment: EquipmentCreateNestedOneWithoutProjectEquipmentInput
  }

  export type ProjectEquipmentUncheckedCreateWithoutProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipmentId: number
  }

  export type ProjectEquipmentCreateOrConnectWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    create: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEquipmentCreateManyProjectInputEnvelope = {
    data: ProjectEquipmentCreateManyProjectInput | ProjectEquipmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WeatherReportItemCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type WeatherReportItemCreateOrConnectWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    create: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput>
  }

  export type WeatherReportItemCreateManyProjectInputEnvelope = {
    data: WeatherReportItemCreateManyProjectInput | WeatherReportItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectStatusValueCreateWithoutProjectsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organization: OrganizationCreateNestedOneWithoutProjectStatusValueInput
  }

  export type ProjectStatusValueUncheckedCreateWithoutProjectsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
    organizationId: number
  }

  export type ProjectStatusValueCreateOrConnectWithoutProjectsInput = {
    where: ProjectStatusValueWhereUniqueInput
    create: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
  }

  export type PendingRoofReportsCreateWithoutProjectInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type PendingRoofReportsUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type PendingRoofReportsCreateOrConnectWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    create: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput>
  }

  export type PendingRoofReportsCreateManyProjectInputEnvelope = {
    data: PendingRoofReportsCreateManyProjectInput | PendingRoofReportsCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectNotesCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
  }

  export type ProjectNotesUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
  }

  export type ProjectNotesCreateOrConnectWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    create: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotesCreateManyProjectInputEnvelope = {
    data: ProjectNotesCreateManyProjectInput | ProjectNotesCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutProjectInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutProjectInput, ImageUncheckedUpdateWithoutProjectInput>
    create: XOR<ImageCreateWithoutProjectInput, ImageUncheckedCreateWithoutProjectInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutProjectInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutProjectInput, ImageUncheckedUpdateWithoutProjectInput>
  }

  export type ImageUpdateManyWithWhereWithoutProjectInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutProjectInput>
  }

  export type InferenceUpsertWithWhereUniqueWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    update: XOR<InferenceUpdateWithoutProjectInput, InferenceUncheckedUpdateWithoutProjectInput>
    create: XOR<InferenceCreateWithoutProjectInput, InferenceUncheckedCreateWithoutProjectInput>
  }

  export type InferenceUpdateWithWhereUniqueWithoutProjectInput = {
    where: InferenceWhereUniqueInput
    data: XOR<InferenceUpdateWithoutProjectInput, InferenceUncheckedUpdateWithoutProjectInput>
  }

  export type InferenceUpdateManyWithWhereWithoutProjectInput = {
    where: InferenceScalarWhereInput
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyWithoutProjectInput>
  }

  export type InferenceScalarWhereInput = {
    AND?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
    OR?: InferenceScalarWhereInput[]
    NOT?: InferenceScalarWhereInput | InferenceScalarWhereInput[]
    id?: IntFilter<"Inference"> | number
    createdAt?: DateTimeFilter<"Inference"> | Date | string
    isDeleted?: BoolFilter<"Inference"> | boolean
    publicId?: StringFilter<"Inference"> | string
    imageId?: IntNullableFilter<"Inference"> | number | null
    imageKey?: StringNullableFilter<"Inference"> | string | null
    projectId?: IntFilter<"Inference"> | number
    roomId?: IntNullableFilter<"Inference"> | number | null
  }

  export type RoomUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutProjectInput, RoomUncheckedUpdateWithoutProjectInput>
    create: XOR<RoomCreateWithoutProjectInput, RoomUncheckedCreateWithoutProjectInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutProjectInput, RoomUncheckedUpdateWithoutProjectInput>
  }

  export type RoomUpdateManyWithWhereWithoutProjectInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    createdAt?: DateTimeFilter<"Room"> | Date | string
    isDeleted?: BoolFilter<"Room"> | boolean
    publicId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    projectId?: IntFilter<"Room"> | number
    gpp?: StringNullableFilter<"Room"> | string | null
    humidity?: StringNullableFilter<"Room"> | string | null
    dehuReading?: StringNullableFilter<"Room"> | string | null
    temperature?: StringNullableFilter<"Room"> | string | null
    length?: StringNullableFilter<"Room"> | string | null
    width?: StringNullableFilter<"Room"> | string | null
    height?: StringNullableFilter<"Room"> | string | null
    totalSqft?: StringNullableFilter<"Room"> | string | null
    windows?: IntNullableFilter<"Room"> | number | null
    doors?: IntNullableFilter<"Room"> | number | null
    equipmentUsed?: StringNullableListFilter<"Room">
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutProjectInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutProjectInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: IntFilter<"CalendarEvent"> | number
    publicId?: StringFilter<"CalendarEvent"> | string
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    subject?: StringFilter<"CalendarEvent"> | string
    payload?: StringFilter<"CalendarEvent"> | string
    projectId?: IntNullableFilter<"CalendarEvent"> | number | null
    date?: DateTimeFilter<"CalendarEvent"> | Date | string
    dynamicId?: StringFilter<"CalendarEvent"> | string
    isDeleted?: BoolFilter<"CalendarEvent"> | boolean
    remindClient?: BoolFilter<"CalendarEvent"> | boolean
    remindProjectOwners?: BoolFilter<"CalendarEvent"> | boolean
  }

  export type UserToProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    update: XOR<UserToProjectUpdateWithoutProjectInput, UserToProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<UserToProjectCreateWithoutProjectInput, UserToProjectUncheckedCreateWithoutProjectInput>
  }

  export type UserToProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: UserToProjectWhereUniqueInput
    data: XOR<UserToProjectUpdateWithoutProjectInput, UserToProjectUncheckedUpdateWithoutProjectInput>
  }

  export type UserToProjectUpdateManyWithWhereWithoutProjectInput = {
    where: UserToProjectScalarWhereInput
    data: XOR<UserToProjectUpdateManyMutationInput, UserToProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoomReadingUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    update: XOR<RoomReadingUpdateWithoutProjectInput, RoomReadingUncheckedUpdateWithoutProjectInput>
    create: XOR<RoomReadingCreateWithoutProjectInput, RoomReadingUncheckedCreateWithoutProjectInput>
  }

  export type RoomReadingUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoomReadingWhereUniqueInput
    data: XOR<RoomReadingUpdateWithoutProjectInput, RoomReadingUncheckedUpdateWithoutProjectInput>
  }

  export type RoomReadingUpdateManyWithWhereWithoutProjectInput = {
    where: RoomReadingScalarWhereInput
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoomReadingScalarWhereInput = {
    AND?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
    OR?: RoomReadingScalarWhereInput[]
    NOT?: RoomReadingScalarWhereInput | RoomReadingScalarWhereInput[]
    id?: IntFilter<"RoomReading"> | number
    createdAt?: DateTimeFilter<"RoomReading"> | Date | string
    date?: DateTimeFilter<"RoomReading"> | Date | string
    humidity?: StringNullableFilter<"RoomReading"> | string | null
    temperature?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentWall?: StringNullableFilter<"RoomReading"> | string | null
    moistureContentFloor?: StringNullableFilter<"RoomReading"> | string | null
    equipmentUsed?: StringNullableListFilter<"RoomReading">
    roomId?: IntFilter<"RoomReading"> | number
    isDeleted?: BoolFilter<"RoomReading"> | boolean
    publicId?: StringFilter<"RoomReading"> | string
    projectId?: IntFilter<"RoomReading"> | number
    gpp?: StringNullableFilter<"RoomReading"> | string | null
  }

  export type PropertyDataUpsertWithoutProjectInput = {
    update: XOR<PropertyDataUpdateWithoutProjectInput, PropertyDataUncheckedUpdateWithoutProjectInput>
    create: XOR<PropertyDataCreateWithoutProjectInput, PropertyDataUncheckedCreateWithoutProjectInput>
    where?: PropertyDataWhereInput
  }

  export type PropertyDataUpdateToOneWithWhereWithoutProjectInput = {
    where?: PropertyDataWhereInput
    data: XOR<PropertyDataUpdateWithoutProjectInput, PropertyDataUncheckedUpdateWithoutProjectInput>
  }

  export type PropertyDataUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PropertyDataUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    realtyMoleId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AreaAffectedUpsertWithWhereUniqueWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    update: XOR<AreaAffectedUpdateWithoutProjectInput, AreaAffectedUncheckedUpdateWithoutProjectInput>
    create: XOR<AreaAffectedCreateWithoutProjectInput, AreaAffectedUncheckedCreateWithoutProjectInput>
  }

  export type AreaAffectedUpdateWithWhereUniqueWithoutProjectInput = {
    where: AreaAffectedWhereUniqueInput
    data: XOR<AreaAffectedUpdateWithoutProjectInput, AreaAffectedUncheckedUpdateWithoutProjectInput>
  }

  export type AreaAffectedUpdateManyWithWhereWithoutProjectInput = {
    where: AreaAffectedScalarWhereInput
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyWithoutProjectInput>
  }

  export type AreaAffectedScalarWhereInput = {
    AND?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
    OR?: AreaAffectedScalarWhereInput[]
    NOT?: AreaAffectedScalarWhereInput | AreaAffectedScalarWhereInput[]
    id?: IntFilter<"AreaAffected"> | number
    createdAt?: DateTimeFilter<"AreaAffected"> | Date | string
    date?: DateTimeFilter<"AreaAffected"> | Date | string
    roomId?: IntFilter<"AreaAffected"> | number
    material?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    totalAreaMicrobialApplied?: StringNullableFilter<"AreaAffected"> | string | null
    cause?: StringNullableFilter<"AreaAffected"> | string | null
    category?: IntNullableFilter<"AreaAffected"> | number | null
    cabinetryRemoved?: StringNullableFilter<"AreaAffected"> | string | null
    isDeleted?: BoolFilter<"AreaAffected"> | boolean
    publicId?: StringFilter<"AreaAffected"> | string
    projectId?: IntFilter<"AreaAffected"> | number
    type?: EnumAreaAffectedTypeFilter<"AreaAffected"> | $Enums.AreaAffectedType
  }

  export type PhotoAccessLinkUpsertWithWhereUniqueWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    update: XOR<PhotoAccessLinkUpdateWithoutProjectInput, PhotoAccessLinkUncheckedUpdateWithoutProjectInput>
    create: XOR<PhotoAccessLinkCreateWithoutProjectInput, PhotoAccessLinkUncheckedCreateWithoutProjectInput>
  }

  export type PhotoAccessLinkUpdateWithWhereUniqueWithoutProjectInput = {
    where: PhotoAccessLinkWhereUniqueInput
    data: XOR<PhotoAccessLinkUpdateWithoutProjectInput, PhotoAccessLinkUncheckedUpdateWithoutProjectInput>
  }

  export type PhotoAccessLinkUpdateManyWithWhereWithoutProjectInput = {
    where: PhotoAccessLinkScalarWhereInput
    data: XOR<PhotoAccessLinkUpdateManyMutationInput, PhotoAccessLinkUncheckedUpdateManyWithoutProjectInput>
  }

  export type PhotoAccessLinkScalarWhereInput = {
    AND?: PhotoAccessLinkScalarWhereInput | PhotoAccessLinkScalarWhereInput[]
    OR?: PhotoAccessLinkScalarWhereInput[]
    NOT?: PhotoAccessLinkScalarWhereInput | PhotoAccessLinkScalarWhereInput[]
    id?: IntFilter<"PhotoAccessLink"> | number
    createdAt?: DateTimeFilter<"PhotoAccessLink"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PhotoAccessLink"> | Date | string | null
    accessId?: StringFilter<"PhotoAccessLink"> | string
    email?: StringNullableFilter<"PhotoAccessLink"> | string | null
    phoneNumber?: StringNullableFilter<"PhotoAccessLink"> | string | null
    projectId?: IntFilter<"PhotoAccessLink"> | number
  }

  export type NotesUpsertWithWhereUniqueWithoutProjectInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutProjectInput, NotesUncheckedUpdateWithoutProjectInput>
    create: XOR<NotesCreateWithoutProjectInput, NotesUncheckedCreateWithoutProjectInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutProjectInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutProjectInput, NotesUncheckedUpdateWithoutProjectInput>
  }

  export type NotesUpdateManyWithWhereWithoutProjectInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutProjectInput>
  }

  export type NotesScalarWhereInput = {
    AND?: NotesScalarWhereInput | NotesScalarWhereInput[]
    OR?: NotesScalarWhereInput[]
    NOT?: NotesScalarWhereInput | NotesScalarWhereInput[]
    id?: IntFilter<"Notes"> | number
    createdAt?: DateTimeFilter<"Notes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Notes"> | Date | string | null
    date?: DateTimeFilter<"Notes"> | Date | string
    roomId?: IntFilter<"Notes"> | number
    isDeleted?: BoolFilter<"Notes"> | boolean
    publicId?: StringFilter<"Notes"> | string
    projectId?: IntFilter<"Notes"> | number
    body?: StringFilter<"Notes"> | string
  }

  export type CostUpsertWithWhereUniqueWithoutProjectInput = {
    where: CostWhereUniqueInput
    update: XOR<CostUpdateWithoutProjectInput, CostUncheckedUpdateWithoutProjectInput>
    create: XOR<CostCreateWithoutProjectInput, CostUncheckedCreateWithoutProjectInput>
  }

  export type CostUpdateWithWhereUniqueWithoutProjectInput = {
    where: CostWhereUniqueInput
    data: XOR<CostUpdateWithoutProjectInput, CostUncheckedUpdateWithoutProjectInput>
  }

  export type CostUpdateManyWithWhereWithoutProjectInput = {
    where: CostScalarWhereInput
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyWithoutProjectInput>
  }

  export type CostScalarWhereInput = {
    AND?: CostScalarWhereInput | CostScalarWhereInput[]
    OR?: CostScalarWhereInput[]
    NOT?: CostScalarWhereInput | CostScalarWhereInput[]
    id?: IntFilter<"Cost"> | number
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
    estimatedCost?: FloatNullableFilter<"Cost"> | number | null
    actualCost?: FloatNullableFilter<"Cost"> | number | null
    name?: StringNullableFilter<"Cost"> | string | null
    projectId?: IntFilter<"Cost"> | number
    isDeleted?: BoolFilter<"Cost"> | boolean
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
  }

  export type ProjectEquipmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    update: XOR<ProjectEquipmentUpdateWithoutProjectInput, ProjectEquipmentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectEquipmentCreateWithoutProjectInput, ProjectEquipmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEquipmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectEquipmentWhereUniqueInput
    data: XOR<ProjectEquipmentUpdateWithoutProjectInput, ProjectEquipmentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectEquipmentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectEquipmentScalarWhereInput
    data: XOR<ProjectEquipmentUpdateManyMutationInput, ProjectEquipmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type WeatherReportItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    update: XOR<WeatherReportItemUpdateWithoutProjectInput, WeatherReportItemUncheckedUpdateWithoutProjectInput>
    create: XOR<WeatherReportItemCreateWithoutProjectInput, WeatherReportItemUncheckedCreateWithoutProjectInput>
  }

  export type WeatherReportItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: WeatherReportItemWhereUniqueInput
    data: XOR<WeatherReportItemUpdateWithoutProjectInput, WeatherReportItemUncheckedUpdateWithoutProjectInput>
  }

  export type WeatherReportItemUpdateManyWithWhereWithoutProjectInput = {
    where: WeatherReportItemScalarWhereInput
    data: XOR<WeatherReportItemUpdateManyMutationInput, WeatherReportItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type WeatherReportItemScalarWhereInput = {
    AND?: WeatherReportItemScalarWhereInput | WeatherReportItemScalarWhereInput[]
    OR?: WeatherReportItemScalarWhereInput[]
    NOT?: WeatherReportItemScalarWhereInput | WeatherReportItemScalarWhereInput[]
    id?: IntFilter<"WeatherReportItem"> | number
    createdAt?: DateTimeFilter<"WeatherReportItem"> | Date | string
    isDeleted?: BoolFilter<"WeatherReportItem"> | boolean
    projectId?: IntFilter<"WeatherReportItem"> | number
    date?: DateTimeFilter<"WeatherReportItem"> | Date | string
    time?: StringFilter<"WeatherReportItem"> | string
    f_scale?: StringNullableFilter<"WeatherReportItem"> | string | null
    speed?: StringNullableFilter<"WeatherReportItem"> | string | null
    size?: StringNullableFilter<"WeatherReportItem"> | string | null
    location?: StringFilter<"WeatherReportItem"> | string
    county?: StringFilter<"WeatherReportItem"> | string
    state?: StringFilter<"WeatherReportItem"> | string
    lat?: StringFilter<"WeatherReportItem"> | string
    lon?: StringFilter<"WeatherReportItem"> | string
    comments?: StringFilter<"WeatherReportItem"> | string
  }

  export type ProjectStatusValueUpsertWithoutProjectsInput = {
    update: XOR<ProjectStatusValueUpdateWithoutProjectsInput, ProjectStatusValueUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectStatusValueCreateWithoutProjectsInput, ProjectStatusValueUncheckedCreateWithoutProjectsInput>
    where?: ProjectStatusValueWhereInput
  }

  export type ProjectStatusValueUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProjectStatusValueWhereInput
    data: XOR<ProjectStatusValueUpdateWithoutProjectsInput, ProjectStatusValueUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectStatusValueUpdateWithoutProjectsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectStatusValueNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type PendingRoofReportsUpsertWithWhereUniqueWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    update: XOR<PendingRoofReportsUpdateWithoutProjectInput, PendingRoofReportsUncheckedUpdateWithoutProjectInput>
    create: XOR<PendingRoofReportsCreateWithoutProjectInput, PendingRoofReportsUncheckedCreateWithoutProjectInput>
  }

  export type PendingRoofReportsUpdateWithWhereUniqueWithoutProjectInput = {
    where: PendingRoofReportsWhereUniqueInput
    data: XOR<PendingRoofReportsUpdateWithoutProjectInput, PendingRoofReportsUncheckedUpdateWithoutProjectInput>
  }

  export type PendingRoofReportsUpdateManyWithWhereWithoutProjectInput = {
    where: PendingRoofReportsScalarWhereInput
    data: XOR<PendingRoofReportsUpdateManyMutationInput, PendingRoofReportsUncheckedUpdateManyWithoutProjectInput>
  }

  export type PendingRoofReportsScalarWhereInput = {
    AND?: PendingRoofReportsScalarWhereInput | PendingRoofReportsScalarWhereInput[]
    OR?: PendingRoofReportsScalarWhereInput[]
    NOT?: PendingRoofReportsScalarWhereInput | PendingRoofReportsScalarWhereInput[]
    id?: IntFilter<"PendingRoofReports"> | number
    createdAt?: DateTimeFilter<"PendingRoofReports"> | Date | string
    isDeleted?: BoolFilter<"PendingRoofReports"> | boolean
    projectId?: IntFilter<"PendingRoofReports"> | number
    isCompleted?: BoolFilter<"PendingRoofReports"> | boolean
  }

  export type ProjectNotesUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    update: XOR<ProjectNotesUpdateWithoutProjectInput, ProjectNotesUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectNotesCreateWithoutProjectInput, ProjectNotesUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotesUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotesWhereUniqueInput
    data: XOR<ProjectNotesUpdateWithoutProjectInput, ProjectNotesUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectNotesUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectNotesScalarWhereInput
    data: XOR<ProjectNotesUpdateManyMutationInput, ProjectNotesUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectNotesScalarWhereInput = {
    AND?: ProjectNotesScalarWhereInput | ProjectNotesScalarWhereInput[]
    OR?: ProjectNotesScalarWhereInput[]
    NOT?: ProjectNotesScalarWhereInput | ProjectNotesScalarWhereInput[]
    id?: IntFilter<"ProjectNotes"> | number
    createdAt?: DateTimeFilter<"ProjectNotes"> | Date | string
    updatedAt?: DateTimeNullableFilter<"ProjectNotes"> | Date | string | null
    date?: DateTimeFilter<"ProjectNotes"> | Date | string
    isDeleted?: BoolFilter<"ProjectNotes"> | boolean
    publicId?: StringFilter<"ProjectNotes"> | string
    projectId?: IntFilter<"ProjectNotes"> | number
    body?: StringFilter<"ProjectNotes"> | string
    mentions?: StringNullableListFilter<"ProjectNotes">
    userId?: StringFilter<"ProjectNotes"> | string
  }

  export type ProjectCreateWithoutProjectNotesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectNotesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectNotesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
  }

  export type ProjectUpsertWithoutProjectNotesInput = {
    update: XOR<ProjectUpdateWithoutProjectNotesInput, ProjectUncheckedUpdateWithoutProjectNotesInput>
    create: XOR<ProjectCreateWithoutProjectNotesInput, ProjectUncheckedCreateWithoutProjectNotesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectNotesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectNotesInput, ProjectUncheckedUpdateWithoutProjectNotesInput>
  }

  export type ProjectUpdateWithoutProjectNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutCurrentStatusInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCurrentStatusInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput>
  }

  export type ProjectCreateManyCurrentStatusInputEnvelope = {
    data: ProjectCreateManyCurrentStatusInput | ProjectCreateManyCurrentStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProjectStatusValueInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectStatusValueInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectStatusValueInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCurrentStatusInput, ProjectUncheckedUpdateWithoutCurrentStatusInput>
    create: XOR<ProjectCreateWithoutCurrentStatusInput, ProjectUncheckedCreateWithoutCurrentStatusInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCurrentStatusInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCurrentStatusInput, ProjectUncheckedUpdateWithoutCurrentStatusInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCurrentStatusInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCurrentStatusInput>
  }

  export type OrganizationUpsertWithoutProjectStatusValueInput = {
    update: XOR<OrganizationUpdateWithoutProjectStatusValueInput, OrganizationUncheckedUpdateWithoutProjectStatusValueInput>
    create: XOR<OrganizationCreateWithoutProjectStatusValueInput, OrganizationUncheckedCreateWithoutProjectStatusValueInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectStatusValueInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectStatusValueInput, OrganizationUncheckedUpdateWithoutProjectStatusValueInput>
  }

  export type OrganizationUpdateWithoutProjectStatusValueInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectStatusValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectCreateWithoutPendingRoofReportsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPendingRoofReportsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPendingRoofReportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
  }

  export type ProjectUpsertWithoutPendingRoofReportsInput = {
    update: XOR<ProjectUpdateWithoutPendingRoofReportsInput, ProjectUncheckedUpdateWithoutPendingRoofReportsInput>
    create: XOR<ProjectCreateWithoutPendingRoofReportsInput, ProjectUncheckedCreateWithoutPendingRoofReportsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPendingRoofReportsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPendingRoofReportsInput, ProjectUncheckedUpdateWithoutPendingRoofReportsInput>
  }

  export type ProjectUpdateWithoutPendingRoofReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPendingRoofReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutWeatherReportItemsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWeatherReportItemsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWeatherReportItemsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
  }

  export type ProjectUpsertWithoutWeatherReportItemsInput = {
    update: XOR<ProjectUpdateWithoutWeatherReportItemsInput, ProjectUncheckedUpdateWithoutWeatherReportItemsInput>
    create: XOR<ProjectCreateWithoutWeatherReportItemsInput, ProjectUncheckedCreateWithoutWeatherReportItemsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWeatherReportItemsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWeatherReportItemsInput, ProjectUncheckedUpdateWithoutWeatherReportItemsInput>
  }

  export type ProjectUpdateWithoutWeatherReportItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWeatherReportItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EquipmentCreateWithoutProjectEquipmentInput = {
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organization: OrganizationCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutProjectEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
    organizationId: number
  }

  export type EquipmentCreateOrConnectWithoutProjectEquipmentInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type ProjectCreateWithoutProjectEquipmentInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectEquipmentInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectEquipmentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
  }

  export type EquipmentUpsertWithoutProjectEquipmentInput = {
    update: XOR<EquipmentUpdateWithoutProjectEquipmentInput, EquipmentUncheckedUpdateWithoutProjectEquipmentInput>
    create: XOR<EquipmentCreateWithoutProjectEquipmentInput, EquipmentUncheckedCreateWithoutProjectEquipmentInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutProjectEquipmentInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutProjectEquipmentInput, EquipmentUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type EquipmentUpdateWithoutProjectEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutProjectEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectUpsertWithoutProjectEquipmentInput = {
    update: XOR<ProjectUpdateWithoutProjectEquipmentInput, ProjectUncheckedUpdateWithoutProjectEquipmentInput>
    create: XOR<ProjectCreateWithoutProjectEquipmentInput, ProjectUncheckedCreateWithoutProjectEquipmentInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectEquipmentInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectEquipmentInput, ProjectUncheckedUpdateWithoutProjectEquipmentInput>
  }

  export type ProjectUpdateWithoutProjectEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutCostsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCostsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCostsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
  }

  export type ProjectUpsertWithoutCostsInput = {
    update: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCostsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
  }

  export type ProjectUpdateWithoutCostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPropertyDataInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPropertyDataInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPropertyDataInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
  }

  export type ProjectUpsertWithoutPropertyDataInput = {
    update: XOR<ProjectUpdateWithoutPropertyDataInput, ProjectUncheckedUpdateWithoutPropertyDataInput>
    create: XOR<ProjectCreateWithoutPropertyDataInput, ProjectUncheckedCreateWithoutPropertyDataInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPropertyDataInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPropertyDataInput, ProjectUncheckedUpdateWithoutPropertyDataInput>
  }

  export type ProjectUpdateWithoutPropertyDataInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPropertyDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPhotoAccessLinksInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPhotoAccessLinksInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPhotoAccessLinksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
  }

  export type ProjectUpsertWithoutPhotoAccessLinksInput = {
    update: XOR<ProjectUpdateWithoutPhotoAccessLinksInput, ProjectUncheckedUpdateWithoutPhotoAccessLinksInput>
    create: XOR<ProjectCreateWithoutPhotoAccessLinksInput, ProjectUncheckedCreateWithoutPhotoAccessLinksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPhotoAccessLinksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPhotoAccessLinksInput, ProjectUncheckedUpdateWithoutPhotoAccessLinksInput>
  }

  export type ProjectUpdateWithoutPhotoAccessLinksInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPhotoAccessLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutImageInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutImageInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutImageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
  }

  export type ProjectCreateWithoutImagesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutImagesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutImagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
  }

  export type InferenceCreateWithoutImageInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    projectId: number
    roomId?: number | null
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutImageInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteCreateWithoutImageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    isDeleted?: boolean
    User: UserCreateNestedOneWithoutImageNoteInput
  }

  export type ImageNoteUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteCreateOrConnectWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    create: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteCreateManyImageInputEnvelope = {
    data: ImageNoteCreateManyImageInput | ImageNoteCreateManyImageInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutImageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    User: UserCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput>
  }

  export type AnnotationCreateManyImageInputEnvelope = {
    data: AnnotationCreateManyImageInput | AnnotationCreateManyImageInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutImageInput = {
    update: XOR<OrganizationUpdateWithoutImageInput, OrganizationUncheckedUpdateWithoutImageInput>
    create: XOR<OrganizationCreateWithoutImageInput, OrganizationUncheckedCreateWithoutImageInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutImageInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutImageInput, OrganizationUncheckedUpdateWithoutImageInput>
  }

  export type OrganizationUpdateWithoutImageInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithoutImagesInput = {
    update: XOR<ProjectUpdateWithoutImagesInput, ProjectUncheckedUpdateWithoutImagesInput>
    create: XOR<ProjectCreateWithoutImagesInput, ProjectUncheckedCreateWithoutImagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutImagesInput, ProjectUncheckedUpdateWithoutImagesInput>
  }

  export type ProjectUpdateWithoutImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type InferenceUpsertWithoutImageInput = {
    update: XOR<InferenceUpdateWithoutImageInput, InferenceUncheckedUpdateWithoutImageInput>
    create: XOR<InferenceCreateWithoutImageInput, InferenceUncheckedCreateWithoutImageInput>
    where?: InferenceWhereInput
  }

  export type InferenceUpdateToOneWithWhereWithoutImageInput = {
    where?: InferenceWhereInput
    data: XOR<InferenceUpdateWithoutImageInput, InferenceUncheckedUpdateWithoutImageInput>
  }

  export type InferenceUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type ImageNoteUpsertWithWhereUniqueWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    update: XOR<ImageNoteUpdateWithoutImageInput, ImageNoteUncheckedUpdateWithoutImageInput>
    create: XOR<ImageNoteCreateWithoutImageInput, ImageNoteUncheckedCreateWithoutImageInput>
  }

  export type ImageNoteUpdateWithWhereUniqueWithoutImageInput = {
    where: ImageNoteWhereUniqueInput
    data: XOR<ImageNoteUpdateWithoutImageInput, ImageNoteUncheckedUpdateWithoutImageInput>
  }

  export type ImageNoteUpdateManyWithWhereWithoutImageInput = {
    where: ImageNoteScalarWhereInput
    data: XOR<ImageNoteUpdateManyMutationInput, ImageNoteUncheckedUpdateManyWithoutImageInput>
  }

  export type AnnotationUpsertWithWhereUniqueWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutImageInput, AnnotationUncheckedUpdateWithoutImageInput>
    create: XOR<AnnotationCreateWithoutImageInput, AnnotationUncheckedCreateWithoutImageInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutImageInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutImageInput, AnnotationUncheckedUpdateWithoutImageInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutImageInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutImageInput>
  }

  export type ImageCreateWithoutAnnotationInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutAnnotationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutAnnotationInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
  }

  export type UserCreateWithoutAnnotationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnotationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnotationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
  }

  export type ImageUpsertWithoutAnnotationInput = {
    update: XOR<ImageUpdateWithoutAnnotationInput, ImageUncheckedUpdateWithoutAnnotationInput>
    create: XOR<ImageCreateWithoutAnnotationInput, ImageUncheckedCreateWithoutAnnotationInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutAnnotationInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutAnnotationInput, ImageUncheckedUpdateWithoutAnnotationInput>
  }

  export type ImageUpdateWithoutAnnotationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutAnnotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UserUpsertWithoutAnnotationInput = {
    update: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
  }

  export type UserUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImageCreateWithoutImageNoteInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    inference?: InferenceCreateNestedOneWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutImageNoteInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    inference?: InferenceUncheckedCreateNestedOneWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutImageNoteInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
  }

  export type UserCreateWithoutImageNoteInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Annotation?: AnnotationCreateNestedManyWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageNoteInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId: string
    org?: UserToOrganizationUncheckedCreateNestedOneWithoutUserInput
    UserToProject?: UserToProjectUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
  }

  export type ImageUpsertWithoutImageNoteInput = {
    update: XOR<ImageUpdateWithoutImageNoteInput, ImageUncheckedUpdateWithoutImageNoteInput>
    create: XOR<ImageCreateWithoutImageNoteInput, ImageUncheckedCreateWithoutImageNoteInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutImageNoteInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutImageNoteInput, ImageUncheckedUpdateWithoutImageNoteInput>
  }

  export type ImageUpdateWithoutImageNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutImageNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UserUpsertWithoutImageNoteInput = {
    update: XOR<UserUpdateWithoutImageNoteInput, UserUncheckedUpdateWithoutImageNoteInput>
    create: XOR<UserCreateWithoutImageNoteInput, UserUncheckedCreateWithoutImageNoteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImageNoteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImageNoteInput, UserUncheckedUpdateWithoutImageNoteInput>
  }

  export type UserUpdateWithoutImageNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImageCreateWithoutInferenceInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    includeInReport?: boolean
    description?: string | null
    organization?: OrganizationCreateNestedOneWithoutImageInput
    project: ProjectCreateNestedOneWithoutImagesInput
    ImageNote?: ImageNoteCreateNestedManyWithoutImageInput
    Annotation?: AnnotationCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
    ImageNote?: ImageNoteUncheckedCreateNestedManyWithoutImageInput
    Annotation?: AnnotationUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutInferenceInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
  }

  export type ProjectCreateWithoutInferencesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInferencesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInferencesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
  }

  export type RoomCreateWithoutInferencesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutInferencesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutInferencesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
  }

  export type DetectionCreateWithoutInferenceInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
    room?: RoomCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateWithoutInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type DetectionCreateOrConnectWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    create: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput>
  }

  export type DetectionCreateManyInferenceInputEnvelope = {
    data: DetectionCreateManyInferenceInput | DetectionCreateManyInferenceInput[]
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithoutInferenceInput = {
    update: XOR<ImageUpdateWithoutInferenceInput, ImageUncheckedUpdateWithoutInferenceInput>
    create: XOR<ImageCreateWithoutInferenceInput, ImageUncheckedCreateWithoutInferenceInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutInferenceInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutInferenceInput, ImageUncheckedUpdateWithoutInferenceInput>
  }

  export type ImageUpdateWithoutInferenceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutInferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ProjectUpsertWithoutInferencesInput = {
    update: XOR<ProjectUpdateWithoutInferencesInput, ProjectUncheckedUpdateWithoutInferencesInput>
    create: XOR<ProjectCreateWithoutInferencesInput, ProjectUncheckedCreateWithoutInferencesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInferencesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInferencesInput, ProjectUncheckedUpdateWithoutInferencesInput>
  }

  export type ProjectUpdateWithoutInferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RoomUpsertWithoutInferencesInput = {
    update: XOR<RoomUpdateWithoutInferencesInput, RoomUncheckedUpdateWithoutInferencesInput>
    create: XOR<RoomCreateWithoutInferencesInput, RoomUncheckedCreateWithoutInferencesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutInferencesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutInferencesInput, RoomUncheckedUpdateWithoutInferencesInput>
  }

  export type RoomUpdateWithoutInferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutInferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type DetectionUpsertWithWhereUniqueWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    update: XOR<DetectionUpdateWithoutInferenceInput, DetectionUncheckedUpdateWithoutInferenceInput>
    create: XOR<DetectionCreateWithoutInferenceInput, DetectionUncheckedCreateWithoutInferenceInput>
  }

  export type DetectionUpdateWithWhereUniqueWithoutInferenceInput = {
    where: DetectionWhereUniqueInput
    data: XOR<DetectionUpdateWithoutInferenceInput, DetectionUncheckedUpdateWithoutInferenceInput>
  }

  export type DetectionUpdateManyWithWhereWithoutInferenceInput = {
    where: DetectionScalarWhereInput
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyWithoutInferenceInput>
  }

  export type DetectionScalarWhereInput = {
    AND?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
    OR?: DetectionScalarWhereInput[]
    NOT?: DetectionScalarWhereInput | DetectionScalarWhereInput[]
    id?: IntFilter<"Detection"> | number
    createdAt?: DateTimeFilter<"Detection"> | Date | string
    isDeleted?: BoolFilter<"Detection"> | boolean
    publicId?: StringFilter<"Detection"> | string
    inferenceId?: IntFilter<"Detection"> | number
    imageKey?: StringNullableFilter<"Detection"> | string | null
    xMinCord?: FloatNullableFilter<"Detection"> | number | null
    yMinCord?: FloatNullableFilter<"Detection"> | number | null
    confidence?: FloatNullableFilter<"Detection"> | number | null
    xMaxCord?: FloatNullableFilter<"Detection"> | number | null
    yMaxCord?: FloatNullableFilter<"Detection"> | number | null
    projectId?: IntFilter<"Detection"> | number
    category?: StringFilter<"Detection"> | string
    code?: StringFilter<"Detection"> | string
    item?: StringFilter<"Detection"> | string
    quality?: StringFilter<"Detection"> | string
    roomId?: IntNullableFilter<"Detection"> | number | null
    dimension?: IntNullableFilter<"Detection"> | number | null
    unit?: EnumDimensionUnitNullableFilter<"Detection"> | $Enums.DimensionUnit | null
  }

  export type ProjectCreateWithoutRoomsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoomsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoomsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
  }

  export type DetectionCreateWithoutRoomInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
    inference: InferenceCreateNestedOneWithoutDetectionsInput
  }

  export type DetectionUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type DetectionCreateOrConnectWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    create: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput>
  }

  export type DetectionCreateManyRoomInputEnvelope = {
    data: DetectionCreateManyRoomInput | DetectionCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type InferenceCreateWithoutRoomInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    detections?: DetectionCreateNestedManyWithoutInferenceInput
  }

  export type InferenceUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    detections?: DetectionUncheckedCreateNestedManyWithoutInferenceInput
  }

  export type InferenceCreateOrConnectWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput>
  }

  export type InferenceCreateManyRoomInputEnvelope = {
    data: InferenceCreateManyRoomInput | InferenceCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type TemplatesUsedCreateWithoutRoomInput = {
    createdAt?: Date | string
    templateCode: string
  }

  export type TemplatesUsedUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
  }

  export type TemplatesUsedCreateOrConnectWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    create: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput>
  }

  export type TemplatesUsedCreateManyRoomInputEnvelope = {
    data: TemplatesUsedCreateManyRoomInput | TemplatesUsedCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomReadingCreateWithoutRoomInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
    genericRoomReadings?: GenericRoomReadingCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
    genericRoomReadings?: GenericRoomReadingUncheckedCreateNestedManyWithoutRoomReadingInput
  }

  export type RoomReadingCreateOrConnectWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput>
  }

  export type RoomReadingCreateManyRoomInputEnvelope = {
    data: RoomReadingCreateManyRoomInput | RoomReadingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type AreaAffectedCreateWithoutRoomInput = {
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: $Enums.AreaAffectedType
    project: ProjectCreateNestedOneWithoutAreaAffectedInput
  }

  export type AreaAffectedUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: $Enums.AreaAffectedType
  }

  export type AreaAffectedCreateOrConnectWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    create: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput>
  }

  export type AreaAffectedCreateManyRoomInputEnvelope = {
    data: AreaAffectedCreateManyRoomInput | AreaAffectedCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type NotesCreateWithoutRoomInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    project: ProjectCreateNestedOneWithoutNotesInput
    notesAuditTrail?: NotesAuditTrailCreateNestedManyWithoutNoteInput
  }

  export type NotesUncheckedCreateWithoutRoomInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
    notesAuditTrail?: NotesAuditTrailUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NotesCreateOrConnectWithoutRoomInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput>
  }

  export type NotesCreateManyRoomInputEnvelope = {
    data: NotesCreateManyRoomInput | NotesCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutRoomsInput = {
    update: XOR<ProjectUpdateWithoutRoomsInput, ProjectUncheckedUpdateWithoutRoomsInput>
    create: XOR<ProjectCreateWithoutRoomsInput, ProjectUncheckedCreateWithoutRoomsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRoomsInput, ProjectUncheckedUpdateWithoutRoomsInput>
  }

  export type ProjectUpdateWithoutRoomsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DetectionUpsertWithWhereUniqueWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    update: XOR<DetectionUpdateWithoutRoomInput, DetectionUncheckedUpdateWithoutRoomInput>
    create: XOR<DetectionCreateWithoutRoomInput, DetectionUncheckedCreateWithoutRoomInput>
  }

  export type DetectionUpdateWithWhereUniqueWithoutRoomInput = {
    where: DetectionWhereUniqueInput
    data: XOR<DetectionUpdateWithoutRoomInput, DetectionUncheckedUpdateWithoutRoomInput>
  }

  export type DetectionUpdateManyWithWhereWithoutRoomInput = {
    where: DetectionScalarWhereInput
    data: XOR<DetectionUpdateManyMutationInput, DetectionUncheckedUpdateManyWithoutRoomInput>
  }

  export type InferenceUpsertWithWhereUniqueWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    update: XOR<InferenceUpdateWithoutRoomInput, InferenceUncheckedUpdateWithoutRoomInput>
    create: XOR<InferenceCreateWithoutRoomInput, InferenceUncheckedCreateWithoutRoomInput>
  }

  export type InferenceUpdateWithWhereUniqueWithoutRoomInput = {
    where: InferenceWhereUniqueInput
    data: XOR<InferenceUpdateWithoutRoomInput, InferenceUncheckedUpdateWithoutRoomInput>
  }

  export type InferenceUpdateManyWithWhereWithoutRoomInput = {
    where: InferenceScalarWhereInput
    data: XOR<InferenceUpdateManyMutationInput, InferenceUncheckedUpdateManyWithoutRoomInput>
  }

  export type TemplatesUsedUpsertWithWhereUniqueWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    update: XOR<TemplatesUsedUpdateWithoutRoomInput, TemplatesUsedUncheckedUpdateWithoutRoomInput>
    create: XOR<TemplatesUsedCreateWithoutRoomInput, TemplatesUsedUncheckedCreateWithoutRoomInput>
  }

  export type TemplatesUsedUpdateWithWhereUniqueWithoutRoomInput = {
    where: TemplatesUsedWhereUniqueInput
    data: XOR<TemplatesUsedUpdateWithoutRoomInput, TemplatesUsedUncheckedUpdateWithoutRoomInput>
  }

  export type TemplatesUsedUpdateManyWithWhereWithoutRoomInput = {
    where: TemplatesUsedScalarWhereInput
    data: XOR<TemplatesUsedUpdateManyMutationInput, TemplatesUsedUncheckedUpdateManyWithoutRoomInput>
  }

  export type TemplatesUsedScalarWhereInput = {
    AND?: TemplatesUsedScalarWhereInput | TemplatesUsedScalarWhereInput[]
    OR?: TemplatesUsedScalarWhereInput[]
    NOT?: TemplatesUsedScalarWhereInput | TemplatesUsedScalarWhereInput[]
    id?: IntFilter<"TemplatesUsed"> | number
    createdAt?: DateTimeFilter<"TemplatesUsed"> | Date | string
    templateCode?: StringFilter<"TemplatesUsed"> | string
    roomId?: IntNullableFilter<"TemplatesUsed"> | number | null
  }

  export type RoomReadingUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    update: XOR<RoomReadingUpdateWithoutRoomInput, RoomReadingUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomReadingCreateWithoutRoomInput, RoomReadingUncheckedCreateWithoutRoomInput>
  }

  export type RoomReadingUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomReadingWhereUniqueInput
    data: XOR<RoomReadingUpdateWithoutRoomInput, RoomReadingUncheckedUpdateWithoutRoomInput>
  }

  export type RoomReadingUpdateManyWithWhereWithoutRoomInput = {
    where: RoomReadingScalarWhereInput
    data: XOR<RoomReadingUpdateManyMutationInput, RoomReadingUncheckedUpdateManyWithoutRoomInput>
  }

  export type AreaAffectedUpsertWithWhereUniqueWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    update: XOR<AreaAffectedUpdateWithoutRoomInput, AreaAffectedUncheckedUpdateWithoutRoomInput>
    create: XOR<AreaAffectedCreateWithoutRoomInput, AreaAffectedUncheckedCreateWithoutRoomInput>
  }

  export type AreaAffectedUpdateWithWhereUniqueWithoutRoomInput = {
    where: AreaAffectedWhereUniqueInput
    data: XOR<AreaAffectedUpdateWithoutRoomInput, AreaAffectedUncheckedUpdateWithoutRoomInput>
  }

  export type AreaAffectedUpdateManyWithWhereWithoutRoomInput = {
    where: AreaAffectedScalarWhereInput
    data: XOR<AreaAffectedUpdateManyMutationInput, AreaAffectedUncheckedUpdateManyWithoutRoomInput>
  }

  export type NotesUpsertWithWhereUniqueWithoutRoomInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutRoomInput, NotesUncheckedUpdateWithoutRoomInput>
    create: XOR<NotesCreateWithoutRoomInput, NotesUncheckedCreateWithoutRoomInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutRoomInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutRoomInput, NotesUncheckedUpdateWithoutRoomInput>
  }

  export type NotesUpdateManyWithWhereWithoutRoomInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomCreateWithoutRoomReadingsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutRoomReadingsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
  }

  export type ProjectCreateWithoutRoomReadingsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoomReadingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
  }

  export type GenericRoomReadingCreateWithoutRoomReadingInput = {
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingUncheckedCreateWithoutRoomReadingInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingCreateOrConnectWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    create: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingCreateManyRoomReadingInputEnvelope = {
    data: GenericRoomReadingCreateManyRoomReadingInput | GenericRoomReadingCreateManyRoomReadingInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithoutRoomReadingsInput = {
    update: XOR<RoomUpdateWithoutRoomReadingsInput, RoomUncheckedUpdateWithoutRoomReadingsInput>
    create: XOR<RoomCreateWithoutRoomReadingsInput, RoomUncheckedCreateWithoutRoomReadingsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutRoomReadingsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutRoomReadingsInput, RoomUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type RoomUpdateWithoutRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutRoomReadingsInput = {
    update: XOR<ProjectUpdateWithoutRoomReadingsInput, ProjectUncheckedUpdateWithoutRoomReadingsInput>
    create: XOR<ProjectCreateWithoutRoomReadingsInput, ProjectUncheckedCreateWithoutRoomReadingsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRoomReadingsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRoomReadingsInput, ProjectUncheckedUpdateWithoutRoomReadingsInput>
  }

  export type ProjectUpdateWithoutRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type GenericRoomReadingUpsertWithWhereUniqueWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    update: XOR<GenericRoomReadingUpdateWithoutRoomReadingInput, GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput>
    create: XOR<GenericRoomReadingCreateWithoutRoomReadingInput, GenericRoomReadingUncheckedCreateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingUpdateWithWhereUniqueWithoutRoomReadingInput = {
    where: GenericRoomReadingWhereUniqueInput
    data: XOR<GenericRoomReadingUpdateWithoutRoomReadingInput, GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput>
  }

  export type GenericRoomReadingUpdateManyWithWhereWithoutRoomReadingInput = {
    where: GenericRoomReadingScalarWhereInput
    data: XOR<GenericRoomReadingUpdateManyMutationInput, GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingInput>
  }

  export type GenericRoomReadingScalarWhereInput = {
    AND?: GenericRoomReadingScalarWhereInput | GenericRoomReadingScalarWhereInput[]
    OR?: GenericRoomReadingScalarWhereInput[]
    NOT?: GenericRoomReadingScalarWhereInput | GenericRoomReadingScalarWhereInput[]
    id?: IntFilter<"GenericRoomReading"> | number
    createdAt?: DateTimeFilter<"GenericRoomReading"> | Date | string
    publicId?: StringFilter<"GenericRoomReading"> | string
    type?: EnumRoomReadingTypeFilter<"GenericRoomReading"> | $Enums.RoomReadingType
    value?: StringFilter<"GenericRoomReading"> | string
    humidity?: StringNullableFilter<"GenericRoomReading"> | string | null
    temperature?: StringNullableFilter<"GenericRoomReading"> | string | null
    gpp?: StringNullableFilter<"GenericRoomReading"> | string | null
    roomReadingId?: IntFilter<"GenericRoomReading"> | number
    isDeleted?: BoolFilter<"GenericRoomReading"> | boolean
  }

  export type RoomCreateWithoutNotesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutNotesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutNotesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
  }

  export type ProjectCreateWithoutNotesInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNotesInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNotesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
  }

  export type NotesAuditTrailCreateWithoutNoteInput = {
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUncheckedCreateWithoutNoteInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
  }

  export type NotesAuditTrailCreateOrConnectWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    create: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput>
  }

  export type NotesAuditTrailCreateManyNoteInputEnvelope = {
    data: NotesAuditTrailCreateManyNoteInput | NotesAuditTrailCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithoutNotesInput = {
    update: XOR<RoomUpdateWithoutNotesInput, RoomUncheckedUpdateWithoutNotesInput>
    create: XOR<RoomCreateWithoutNotesInput, RoomUncheckedCreateWithoutNotesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutNotesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutNotesInput, RoomUncheckedUpdateWithoutNotesInput>
  }

  export type RoomUpdateWithoutNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutNotesInput = {
    update: XOR<ProjectUpdateWithoutNotesInput, ProjectUncheckedUpdateWithoutNotesInput>
    create: XOR<ProjectCreateWithoutNotesInput, ProjectUncheckedCreateWithoutNotesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutNotesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutNotesInput, ProjectUncheckedUpdateWithoutNotesInput>
  }

  export type ProjectUpdateWithoutNotesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type NotesAuditTrailUpsertWithWhereUniqueWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    update: XOR<NotesAuditTrailUpdateWithoutNoteInput, NotesAuditTrailUncheckedUpdateWithoutNoteInput>
    create: XOR<NotesAuditTrailCreateWithoutNoteInput, NotesAuditTrailUncheckedCreateWithoutNoteInput>
  }

  export type NotesAuditTrailUpdateWithWhereUniqueWithoutNoteInput = {
    where: NotesAuditTrailWhereUniqueInput
    data: XOR<NotesAuditTrailUpdateWithoutNoteInput, NotesAuditTrailUncheckedUpdateWithoutNoteInput>
  }

  export type NotesAuditTrailUpdateManyWithWhereWithoutNoteInput = {
    where: NotesAuditTrailScalarWhereInput
    data: XOR<NotesAuditTrailUpdateManyMutationInput, NotesAuditTrailUncheckedUpdateManyWithoutNoteInput>
  }

  export type NotesAuditTrailScalarWhereInput = {
    AND?: NotesAuditTrailScalarWhereInput | NotesAuditTrailScalarWhereInput[]
    OR?: NotesAuditTrailScalarWhereInput[]
    NOT?: NotesAuditTrailScalarWhereInput | NotesAuditTrailScalarWhereInput[]
    id?: IntFilter<"NotesAuditTrail"> | number
    createdAt?: DateTimeFilter<"NotesAuditTrail"> | Date | string
    notesId?: IntFilter<"NotesAuditTrail"> | number
    userId?: StringFilter<"NotesAuditTrail"> | string
    userName?: StringNullableFilter<"NotesAuditTrail"> | string | null
    action?: EnumNotesAuditActionFilter<"NotesAuditTrail"> | $Enums.NotesAuditAction
    body?: StringFilter<"NotesAuditTrail"> | string
  }

  export type NotesCreateWithoutNotesAuditTrailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    room: RoomCreateNestedOneWithoutNotesInput
    project: ProjectCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutNotesAuditTrailInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type NotesCreateOrConnectWithoutNotesAuditTrailInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
  }

  export type NotesUpsertWithoutNotesAuditTrailInput = {
    update: XOR<NotesUpdateWithoutNotesAuditTrailInput, NotesUncheckedUpdateWithoutNotesAuditTrailInput>
    create: XOR<NotesCreateWithoutNotesAuditTrailInput, NotesUncheckedCreateWithoutNotesAuditTrailInput>
    where?: NotesWhereInput
  }

  export type NotesUpdateToOneWithWhereWithoutNotesAuditTrailInput = {
    where?: NotesWhereInput
    data: XOR<NotesUpdateWithoutNotesAuditTrailInput, NotesUncheckedUpdateWithoutNotesAuditTrailInput>
  }

  export type NotesUpdateWithoutNotesAuditTrailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutNotesAuditTrailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateWithoutAreasAffectedInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutAreasAffectedInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutAreasAffectedInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
  }

  export type ProjectCreateWithoutAreaAffectedInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    events?: CalendarEventCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAreaAffectedInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    events?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAreaAffectedInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
  }

  export type RoomUpsertWithoutAreasAffectedInput = {
    update: XOR<RoomUpdateWithoutAreasAffectedInput, RoomUncheckedUpdateWithoutAreasAffectedInput>
    create: XOR<RoomCreateWithoutAreasAffectedInput, RoomUncheckedCreateWithoutAreasAffectedInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAreasAffectedInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAreasAffectedInput, RoomUncheckedUpdateWithoutAreasAffectedInput>
  }

  export type RoomUpdateWithoutAreasAffectedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAreasAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProjectUpsertWithoutAreaAffectedInput = {
    update: XOR<ProjectUpdateWithoutAreaAffectedInput, ProjectUncheckedUpdateWithoutAreaAffectedInput>
    create: XOR<ProjectCreateWithoutAreaAffectedInput, ProjectUncheckedCreateWithoutAreaAffectedInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAreaAffectedInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAreaAffectedInput, ProjectUncheckedUpdateWithoutAreaAffectedInput>
  }

  export type ProjectUpdateWithoutAreaAffectedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAreaAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RoomReadingCreateWithoutGenericRoomReadingsInput = {
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
    room: RoomCreateNestedOneWithoutRoomReadingsInput
    project: ProjectCreateNestedOneWithoutRoomReadingsInput
  }

  export type RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    roomId: number
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type RoomReadingCreateOrConnectWithoutGenericRoomReadingsInput = {
    where: RoomReadingWhereUniqueInput
    create: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
  }

  export type RoomReadingUpsertWithoutGenericRoomReadingsInput = {
    update: XOR<RoomReadingUpdateWithoutGenericRoomReadingsInput, RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput>
    create: XOR<RoomReadingCreateWithoutGenericRoomReadingsInput, RoomReadingUncheckedCreateWithoutGenericRoomReadingsInput>
    where?: RoomReadingWhereInput
  }

  export type RoomReadingUpdateToOneWithWhereWithoutGenericRoomReadingsInput = {
    where?: RoomReadingWhereInput
    data: XOR<RoomReadingUpdateWithoutGenericRoomReadingsInput, RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput>
  }

  export type RoomReadingUpdateWithoutGenericRoomReadingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutGenericRoomReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceCreateWithoutDetectionsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    image?: ImageCreateNestedOneWithoutInferenceInput
    Project: ProjectCreateNestedOneWithoutInferencesInput
    room?: RoomCreateNestedOneWithoutInferencesInput
  }

  export type InferenceUncheckedCreateWithoutDetectionsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
    roomId?: number | null
  }

  export type InferenceCreateOrConnectWithoutDetectionsInput = {
    where: InferenceWhereUniqueInput
    create: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
  }

  export type RoomCreateWithoutDetectionsInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutDetectionsInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    templates?: TemplatesUsedUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutDetectionsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
  }

  export type InferenceUpsertWithoutDetectionsInput = {
    update: XOR<InferenceUpdateWithoutDetectionsInput, InferenceUncheckedUpdateWithoutDetectionsInput>
    create: XOR<InferenceCreateWithoutDetectionsInput, InferenceUncheckedCreateWithoutDetectionsInput>
    where?: InferenceWhereInput
  }

  export type InferenceUpdateToOneWithWhereWithoutDetectionsInput = {
    where?: InferenceWhereInput
    data: XOR<InferenceUpdateWithoutDetectionsInput, InferenceUncheckedUpdateWithoutDetectionsInput>
  }

  export type InferenceUpdateWithoutDetectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
  }

  export type InferenceUncheckedUpdateWithoutDetectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUpsertWithoutDetectionsInput = {
    update: XOR<RoomUpdateWithoutDetectionsInput, RoomUncheckedUpdateWithoutDetectionsInput>
    create: XOR<RoomCreateWithoutDetectionsInput, RoomUncheckedCreateWithoutDetectionsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutDetectionsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutDetectionsInput, RoomUncheckedUpdateWithoutDetectionsInput>
  }

  export type RoomUpdateWithoutDetectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutDetectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateWithoutTemplatesInput = {
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    project: ProjectCreateNestedOneWithoutRoomsInput
    detections?: DetectionCreateNestedManyWithoutRoomInput
    inferences?: InferenceCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedCreateNestedManyWithoutRoomInput
    notes?: NotesCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutTemplatesInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    projectId: number
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
    detections?: DetectionUncheckedCreateNestedManyWithoutRoomInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutRoomInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutRoomInput
    areasAffected?: AreaAffectedUncheckedCreateNestedManyWithoutRoomInput
    notes?: NotesUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutTemplatesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
  }

  export type RoomUpsertWithoutTemplatesInput = {
    update: XOR<RoomUpdateWithoutTemplatesInput, RoomUncheckedUpdateWithoutTemplatesInput>
    create: XOR<RoomCreateWithoutTemplatesInput, RoomUncheckedCreateWithoutTemplatesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutTemplatesInput, RoomUncheckedUpdateWithoutTemplatesInput>
  }

  export type RoomUpdateWithoutTemplatesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    project?: ProjectUpdateOneRequiredWithoutRoomsNestedInput
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type CalendarEventReminderCreateWithoutCalendarEventInput = {
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderUncheckedCreateWithoutCalendarEventInput = {
    id?: number
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderCreateOrConnectWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    create: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderCreateManyCalendarEventInputEnvelope = {
    data: CalendarEventReminderCreateManyCalendarEventInput | CalendarEventReminderCreateManyCalendarEventInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutEventsInput = {
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    images?: ImageCreateNestedManyWithoutProjectInput
    inferences?: InferenceCreateNestedManyWithoutProjectInput
    rooms?: RoomCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkCreateNestedManyWithoutProjectInput
    notes?: NotesCreateNestedManyWithoutProjectInput
    costs?: CostCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemCreateNestedManyWithoutProjectInput
    currentStatus?: ProjectStatusValueCreateNestedOneWithoutProjectsInput
    PendingRoofReports?: PendingRoofReportsCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEventsInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
    images?: ImageUncheckedCreateNestedManyWithoutProjectInput
    inferences?: InferenceUncheckedCreateNestedManyWithoutProjectInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProjectInput
    projectAssignees?: UserToProjectUncheckedCreateNestedManyWithoutProjectInput
    roomReadings?: RoomReadingUncheckedCreateNestedManyWithoutProjectInput
    propertyData?: PropertyDataUncheckedCreateNestedOneWithoutProjectInput
    AreaAffected?: AreaAffectedUncheckedCreateNestedManyWithoutProjectInput
    photoAccessLinks?: PhotoAccessLinkUncheckedCreateNestedManyWithoutProjectInput
    notes?: NotesUncheckedCreateNestedManyWithoutProjectInput
    costs?: CostUncheckedCreateNestedManyWithoutProjectInput
    projectEquipment?: ProjectEquipmentUncheckedCreateNestedManyWithoutProjectInput
    weatherReportItems?: WeatherReportItemUncheckedCreateNestedManyWithoutProjectInput
    PendingRoofReports?: PendingRoofReportsUncheckedCreateNestedManyWithoutProjectInput
    ProjectNotes?: ProjectNotesUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
  }

  export type CalendarEventReminderUpsertWithWhereUniqueWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    update: XOR<CalendarEventReminderUpdateWithoutCalendarEventInput, CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput>
    create: XOR<CalendarEventReminderCreateWithoutCalendarEventInput, CalendarEventReminderUncheckedCreateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderUpdateWithWhereUniqueWithoutCalendarEventInput = {
    where: CalendarEventReminderWhereUniqueInput
    data: XOR<CalendarEventReminderUpdateWithoutCalendarEventInput, CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput>
  }

  export type CalendarEventReminderUpdateManyWithWhereWithoutCalendarEventInput = {
    where: CalendarEventReminderScalarWhereInput
    data: XOR<CalendarEventReminderUpdateManyMutationInput, CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventInput>
  }

  export type CalendarEventReminderScalarWhereInput = {
    AND?: CalendarEventReminderScalarWhereInput | CalendarEventReminderScalarWhereInput[]
    OR?: CalendarEventReminderScalarWhereInput[]
    NOT?: CalendarEventReminderScalarWhereInput | CalendarEventReminderScalarWhereInput[]
    id?: IntFilter<"CalendarEventReminder"> | number
    reminderTarget?: EnumReminderTargetFilter<"CalendarEventReminder"> | $Enums.ReminderTarget
    createdAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEventReminder"> | Date | string
    sendText?: BoolFilter<"CalendarEventReminder"> | boolean
    sendEmail?: BoolFilter<"CalendarEventReminder"> | boolean
    textSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    emailSentAt?: DateTimeNullableFilter<"CalendarEventReminder"> | Date | string | null
    calendarEventId?: IntNullableFilter<"CalendarEventReminder"> | number | null
    date?: DateTimeFilter<"CalendarEventReminder"> | Date | string
  }

  export type ProjectUpsertWithoutEventsInput = {
    update: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEventsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
  }

  export type ProjectUpdateWithoutEventsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CalendarEventCreateWithoutRemindersInput = {
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
    project?: ProjectCreateNestedOneWithoutEventsInput
  }

  export type CalendarEventUncheckedCreateWithoutRemindersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    projectId?: number | null
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type CalendarEventCreateOrConnectWithoutRemindersInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
  }

  export type CalendarEventUpsertWithoutRemindersInput = {
    update: XOR<CalendarEventUpdateWithoutRemindersInput, CalendarEventUncheckedUpdateWithoutRemindersInput>
    create: XOR<CalendarEventCreateWithoutRemindersInput, CalendarEventUncheckedCreateWithoutRemindersInput>
    where?: CalendarEventWhereInput
  }

  export type CalendarEventUpdateToOneWithWhereWithoutRemindersInput = {
    where?: CalendarEventWhereInput
    data: XOR<CalendarEventUpdateWithoutRemindersInput, CalendarEventUncheckedUpdateWithoutRemindersInput>
  }

  export type CalendarEventUpdateWithoutRemindersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    project?: ProjectUpdateOneWithoutEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LineItemCreateWithoutXactimateCategoryInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutXactimateCategoryInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput>
  }

  export type LineItemCreateManyXactimateCategoryInputEnvelope = {
    data: LineItemCreateManyXactimateCategoryInput | LineItemCreateManyXactimateCategoryInput[]
    skipDuplicates?: boolean
  }

  export type LineItemUpsertWithWhereUniqueWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    update: XOR<LineItemUpdateWithoutXactimateCategoryInput, LineItemUncheckedUpdateWithoutXactimateCategoryInput>
    create: XOR<LineItemCreateWithoutXactimateCategoryInput, LineItemUncheckedCreateWithoutXactimateCategoryInput>
  }

  export type LineItemUpdateWithWhereUniqueWithoutXactimateCategoryInput = {
    where: LineItemWhereUniqueInput
    data: XOR<LineItemUpdateWithoutXactimateCategoryInput, LineItemUncheckedUpdateWithoutXactimateCategoryInput>
  }

  export type LineItemUpdateManyWithWhereWithoutXactimateCategoryInput = {
    where: LineItemScalarWhereInput
    data: XOR<LineItemUpdateManyMutationInput, LineItemUncheckedUpdateManyWithoutXactimateCategoryInput>
  }

  export type LineItemScalarWhereInput = {
    AND?: LineItemScalarWhereInput | LineItemScalarWhereInput[]
    OR?: LineItemScalarWhereInput[]
    NOT?: LineItemScalarWhereInput | LineItemScalarWhereInput[]
    id?: IntFilter<"LineItem"> | number
    xactimateCode?: StringFilter<"LineItem"> | string
    xactimateDescription?: StringFilter<"LineItem"> | string
    unit?: StringNullableFilter<"LineItem"> | string | null
    itemCategoryId?: IntFilter<"LineItem"> | number
  }

  export type ItemCategoryCreateWithoutLineItemInput = {
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryUncheckedCreateWithoutLineItemInput = {
    id?: number
    xactimateKey: string
    xactimateDescription: string
    hasItems?: boolean
  }

  export type ItemCategoryCreateOrConnectWithoutLineItemInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemCreateWithoutLineItemInput = {
    alternateId: string
  }

  export type AlternateItemUncheckedCreateWithoutLineItemInput = {
    id?: number
    alternateId: string
  }

  export type AlternateItemCreateOrConnectWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    create: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemCreateManyLineItemInputEnvelope = {
    data: AlternateItemCreateManyLineItemInput | AlternateItemCreateManyLineItemInput[]
    skipDuplicates?: boolean
  }

  export type RelatedItemCreateWithoutLineItemInput = {
    relationId: string
  }

  export type RelatedItemUncheckedCreateWithoutLineItemInput = {
    id?: number
    relationId: string
  }

  export type RelatedItemCreateOrConnectWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    create: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput>
  }

  export type RelatedItemCreateManyLineItemInputEnvelope = {
    data: RelatedItemCreateManyLineItemInput | RelatedItemCreateManyLineItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryUpsertWithoutLineItemInput = {
    update: XOR<ItemCategoryUpdateWithoutLineItemInput, ItemCategoryUncheckedUpdateWithoutLineItemInput>
    create: XOR<ItemCategoryCreateWithoutLineItemInput, ItemCategoryUncheckedCreateWithoutLineItemInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutLineItemInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutLineItemInput, ItemCategoryUncheckedUpdateWithoutLineItemInput>
  }

  export type ItemCategoryUpdateWithoutLineItemInput = {
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCategoryUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateKey?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    hasItems?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlternateItemUpsertWithWhereUniqueWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    update: XOR<AlternateItemUpdateWithoutLineItemInput, AlternateItemUncheckedUpdateWithoutLineItemInput>
    create: XOR<AlternateItemCreateWithoutLineItemInput, AlternateItemUncheckedCreateWithoutLineItemInput>
  }

  export type AlternateItemUpdateWithWhereUniqueWithoutLineItemInput = {
    where: AlternateItemWhereUniqueInput
    data: XOR<AlternateItemUpdateWithoutLineItemInput, AlternateItemUncheckedUpdateWithoutLineItemInput>
  }

  export type AlternateItemUpdateManyWithWhereWithoutLineItemInput = {
    where: AlternateItemScalarWhereInput
    data: XOR<AlternateItemUpdateManyMutationInput, AlternateItemUncheckedUpdateManyWithoutLineItemInput>
  }

  export type AlternateItemScalarWhereInput = {
    AND?: AlternateItemScalarWhereInput | AlternateItemScalarWhereInput[]
    OR?: AlternateItemScalarWhereInput[]
    NOT?: AlternateItemScalarWhereInput | AlternateItemScalarWhereInput[]
    id?: IntFilter<"AlternateItem"> | number
    alternateId?: StringFilter<"AlternateItem"> | string
    lineItemId?: IntFilter<"AlternateItem"> | number
  }

  export type RelatedItemUpsertWithWhereUniqueWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    update: XOR<RelatedItemUpdateWithoutLineItemInput, RelatedItemUncheckedUpdateWithoutLineItemInput>
    create: XOR<RelatedItemCreateWithoutLineItemInput, RelatedItemUncheckedCreateWithoutLineItemInput>
  }

  export type RelatedItemUpdateWithWhereUniqueWithoutLineItemInput = {
    where: RelatedItemWhereUniqueInput
    data: XOR<RelatedItemUpdateWithoutLineItemInput, RelatedItemUncheckedUpdateWithoutLineItemInput>
  }

  export type RelatedItemUpdateManyWithWhereWithoutLineItemInput = {
    where: RelatedItemScalarWhereInput
    data: XOR<RelatedItemUpdateManyMutationInput, RelatedItemUncheckedUpdateManyWithoutLineItemInput>
  }

  export type RelatedItemScalarWhereInput = {
    AND?: RelatedItemScalarWhereInput | RelatedItemScalarWhereInput[]
    OR?: RelatedItemScalarWhereInput[]
    NOT?: RelatedItemScalarWhereInput | RelatedItemScalarWhereInput[]
    id?: IntFilter<"RelatedItem"> | number
    relationId?: StringFilter<"RelatedItem"> | string
    lineItemId?: IntFilter<"RelatedItem"> | number
  }

  export type LineItemCreateWithoutRelatedItemInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    alternateItem?: AlternateItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutRelatedItemInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    alternateItem?: AlternateItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutRelatedItemInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
  }

  export type LineItemUpsertWithoutRelatedItemInput = {
    update: XOR<LineItemUpdateWithoutRelatedItemInput, LineItemUncheckedUpdateWithoutRelatedItemInput>
    create: XOR<LineItemCreateWithoutRelatedItemInput, LineItemUncheckedCreateWithoutRelatedItemInput>
    where?: LineItemWhereInput
  }

  export type LineItemUpdateToOneWithWhereWithoutRelatedItemInput = {
    where?: LineItemWhereInput
    data: XOR<LineItemUpdateWithoutRelatedItemInput, LineItemUncheckedUpdateWithoutRelatedItemInput>
  }

  export type LineItemUpdateWithoutRelatedItemInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutRelatedItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemCreateWithoutAlternateItemInput = {
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    xactimateCategory: ItemCategoryCreateNestedOneWithoutLineItemInput
    relatedItem?: RelatedItemCreateNestedManyWithoutLineItemInput
  }

  export type LineItemUncheckedCreateWithoutAlternateItemInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
    itemCategoryId: number
    relatedItem?: RelatedItemUncheckedCreateNestedManyWithoutLineItemInput
  }

  export type LineItemCreateOrConnectWithoutAlternateItemInput = {
    where: LineItemWhereUniqueInput
    create: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
  }

  export type LineItemUpsertWithoutAlternateItemInput = {
    update: XOR<LineItemUpdateWithoutAlternateItemInput, LineItemUncheckedUpdateWithoutAlternateItemInput>
    create: XOR<LineItemCreateWithoutAlternateItemInput, LineItemUncheckedCreateWithoutAlternateItemInput>
    where?: LineItemWhereInput
  }

  export type LineItemUpdateToOneWithWhereWithoutAlternateItemInput = {
    where?: LineItemWhereInput
    data: XOR<LineItemUpdateWithoutAlternateItemInput, LineItemUncheckedUpdateWithoutAlternateItemInput>
  }

  export type LineItemUpdateWithoutAlternateItemInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    xactimateCategory?: ItemCategoryUpdateOneRequiredWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutAlternateItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    itemCategoryId?: IntFieldUpdateOperationsInput | number
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type OrganizationCreateWithoutCustomersInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCustomersInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCustomersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
  }

  export type OrganizationUpsertWithoutCustomersInput = {
    update: XOR<OrganizationUpdateWithoutCustomersInput, OrganizationUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrganizationCreateWithoutCustomersInput, OrganizationUncheckedCreateWithoutCustomersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCustomersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCustomersInput, OrganizationUncheckedUpdateWithoutCustomersInput>
  }

  export type OrganizationUpdateWithoutCustomersInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type PricesCreateWithoutProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsCreateNestedManyWithoutPriceInput
  }

  export type PricesUncheckedCreateWithoutProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PricesCreateOrConnectWithoutProductInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesCreateManyProductInputEnvelope = {
    data: PricesCreateManyProductInput | PricesCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PricesUpsertWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    update: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
    create: XOR<PricesCreateWithoutProductInput, PricesUncheckedCreateWithoutProductInput>
  }

  export type PricesUpdateWithWhereUniqueWithoutProductInput = {
    where: PricesWhereUniqueInput
    data: XOR<PricesUpdateWithoutProductInput, PricesUncheckedUpdateWithoutProductInput>
  }

  export type PricesUpdateManyWithWhereWithoutProductInput = {
    where: PricesScalarWhereInput
    data: XOR<PricesUpdateManyMutationInput, PricesUncheckedUpdateManyWithoutProductInput>
  }

  export type PricesScalarWhereInput = {
    AND?: PricesScalarWhereInput | PricesScalarWhereInput[]
    OR?: PricesScalarWhereInput[]
    NOT?: PricesScalarWhereInput | PricesScalarWhereInput[]
    id?: StringFilter<"Prices"> | string
    productId?: StringFilter<"Prices"> | string
    active?: BoolFilter<"Prices"> | boolean
    unitAmount?: BigIntNullableFilter<"Prices"> | bigint | number | null
    currency?: StringFilter<"Prices"> | string
    type?: EnumPricingTypeFilter<"Prices"> | $Enums.PricingType
    interval?: EnumPricingPlanIntervalNullableFilter<"Prices"> | $Enums.PricingPlanInterval | null
    intervalCount?: IntNullableFilter<"Prices"> | number | null
    trialPeriodDays?: IntNullableFilter<"Prices"> | number | null
    metadata?: JsonNullableFilter<"Prices">
    description?: StringFilter<"Prices"> | string
  }

  export type ProductsCreateWithoutPricesInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedCreateWithoutPricesInput = {
    id: string
    active: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsCreateOrConnectWithoutPricesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
  }

  export type SubscriptionsCreateWithoutPriceInput = {
    id: string
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutPriceInput = {
    id: string
    organizationId: number
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsCreateOrConnectWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionsCreateManyPriceInputEnvelope = {
    data: SubscriptionsCreateManyPriceInput | SubscriptionsCreateManyPriceInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutPricesInput = {
    update: XOR<ProductsUpdateWithoutPricesInput, ProductsUncheckedUpdateWithoutPricesInput>
    create: XOR<ProductsCreateWithoutPricesInput, ProductsUncheckedCreateWithoutPricesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutPricesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutPricesInput, ProductsUncheckedUpdateWithoutPricesInput>
  }

  export type ProductsUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductsUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutPriceInput, SubscriptionsUncheckedUpdateWithoutPriceInput>
    create: XOR<SubscriptionsCreateWithoutPriceInput, SubscriptionsUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutPriceInput, SubscriptionsUncheckedUpdateWithoutPriceInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutPriceInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutPriceInput>
  }

  export type PricesCreateWithoutSubscriptionsInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
    product: ProductsCreateNestedOneWithoutPricesInput
  }

  export type PricesUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    productId: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesCreateOrConnectWithoutSubscriptionsInput = {
    where: PricesWhereUniqueInput
    create: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
  }

  export type OrganizationCreateWithoutSubscriptionsInput = {
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueCreateNestedManyWithoutOrganizationInput
    User?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    name: string
    address?: string
    faxNumber?: string
    size: string
    isDeleted?: boolean
    updatedAt?: Date | string
    logoId?: string | null
    lat: number
    lng: number
    Image?: ImageUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserToOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Customers?: CustomersUncheckedCreateNestedManyWithoutOrganizationInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedCreateNestedManyWithoutOrganizationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutOrganizationInput
    ProjectStatusValue?: ProjectStatusValueUncheckedCreateNestedManyWithoutOrganizationInput
    User?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubscriptionsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PricesUpsertWithoutSubscriptionsInput = {
    update: XOR<PricesUpdateWithoutSubscriptionsInput, PricesUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PricesCreateWithoutSubscriptionsInput, PricesUncheckedCreateWithoutSubscriptionsInput>
    where?: PricesWhereInput
  }

  export type PricesUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PricesWhereInput
    data: XOR<PricesUpdateWithoutSubscriptionsInput, PricesUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PricesUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateOneRequiredWithoutPricesNestedInput
  }

  export type PricesUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUpsertWithoutSubscriptionsInput = {
    update: XOR<OrganizationUpdateWithoutSubscriptionsInput, OrganizationUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<OrganizationCreateWithoutSubscriptionsInput, OrganizationUncheckedCreateWithoutSubscriptionsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubscriptionsInput, OrganizationUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type OrganizationUpdateWithoutSubscriptionsInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUpdateManyWithoutOrganizationNestedInput
    User?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    faxNumber?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    Image?: ImageUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserToOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Customers?: CustomersUncheckedUpdateManyWithoutOrganizationNestedInput
    OrganizationSavedOption?: OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutOrganizationNestedInput
    ProjectStatusValue?: ProjectStatusValueUncheckedUpdateManyWithoutOrganizationNestedInput
    User?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserToProjectCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    title: string
    content: string
    isSeen: boolean
    link?: string | null
    linkText?: string | null
    type: $Enums.NotificationType
  }

  export type ImageNoteCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    isDeleted?: boolean
  }

  export type AnnotationCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    imageId: number
    coordinates: JsonNullValueInput | InputJsonValue
    isDeleted?: boolean
  }

  export type UserToProjectUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectAssigneesNestedInput
  }

  export type UserToProjectUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type UserToProjectUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isSeen?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    linkText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  }

  export type ImageNoteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Image?: ImageUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: IntFieldUpdateOperationsInput | number
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    projectId: number
    includeInReport?: boolean
    description?: string | null
  }

  export type OrganizationInvitationCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    email: string
    invitationId: string
    isAccepted?: boolean
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
    projectStatusValueId?: number | null
  }

  export type UserToOrganizationCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isAdmin?: boolean
    isDeleted?: boolean
    role?: string | null
    accessLevel?: $Enums.AccessLevel | null
    userId: string
  }

  export type CustomersCreateManyOrganizationInput = {
    id?: number
    customerId: string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsCreateManyOrganizationInput = {
    id: string
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId: string
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type OrganizationSavedOptionCreateManyOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    label: string
    value: string
    isDeleted?: boolean
    type: $Enums.SavedOptionType
  }

  export type EquipmentCreateManyOrganizationInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    name: string
    quantity?: number
  }

  export type ProjectStatusValueCreateManyOrganizationInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    label: string
    description: string
    color: string
    order?: number | null
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    token?: string | null
    createdAt?: Date | string
    email: string
    isDeleted?: boolean
    updatedAt?: Date | string
    firstName: string
    lastName: string
    phone?: string
    inviteId?: string | null
    isSupportUser?: boolean
    hasSeenProductTour?: boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: $Enums.DashboardViews
    photoView?: $Enums.PhotoViews
    groupView?: $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ImageUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutImagesNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationInvitationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    currentStatus?: ProjectStatusValueUpdateOneWithoutProjectsNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    projectStatusValueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserToOrganizationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    user?: UserUpdateOneRequiredWithoutOrgNestedInput
  }

  export type UserToOrganizationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToOrganizationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accessLevel?: NullableEnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUpdateWithoutOrganizationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionsUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: PricesUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    pricesId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationSavedOptionUpdateWithoutOrganizationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
  }

  export type OrganizationSavedOptionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumSavedOptionTypeFieldUpdateOperationsInput | $Enums.SavedOptionType
  }

  export type EquipmentUpdateWithoutOrganizationInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ProjectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectStatusValueUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    projects?: ProjectUncheckedUpdateManyWithoutCurrentStatusNestedInput
  }

  export type ProjectStatusValueUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
    org?: UserToOrganizationUncheckedUpdateOneWithoutUserNestedInput
    UserToProject?: UserToProjectUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutUserNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    inviteId?: NullableStringFieldUpdateOperationsInput | string | null
    isSupportUser?: BoolFieldUpdateOperationsInput | boolean
    hasSeenProductTour?: BoolFieldUpdateOperationsInput | boolean
    productTourData?: NullableJsonNullValueInput | InputJsonValue
    savedDashboardView?: EnumDashboardViewsFieldUpdateOperationsInput | $Enums.DashboardViews
    photoView?: EnumPhotoViewsFieldUpdateOperationsInput | $Enums.PhotoViews
    groupView?: EnumGroupByViewsFieldUpdateOperationsInput | $Enums.GroupByViews
    onboardingStatus?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectEquipmentCreateManyEquipmentInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    projectId: number
  }

  export type ProjectEquipmentUpdateWithoutEquipmentInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    key: string
    organizationId?: number | null
    includeInReport?: boolean
    description?: string | null
  }

  export type InferenceCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    roomId?: number | null
  }

  export type RoomCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    name: string
    gpp?: string | null
    humidity?: string | null
    dehuReading?: string | null
    temperature?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    totalSqft?: string | null
    windows?: number | null
    doors?: number | null
    equipmentUsed?: RoomCreateequipmentUsedInput | string[]
  }

  export type CalendarEventCreateManyProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    payload: string
    date: Date | string
    dynamicId: string
    isDeleted?: boolean
    remindClient?: boolean
    remindProjectOwners?: boolean
  }

  export type UserToProjectCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type RoomReadingCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    roomId: number
    isDeleted?: boolean
    publicId: string
    gpp?: string | null
  }

  export type AreaAffectedCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    roomId: number
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    type: $Enums.AreaAffectedType
  }

  export type PhotoAccessLinkCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    expiresAt?: Date | string | null
    accessId: string
    email?: string | null
    phoneNumber?: string | null
  }

  export type NotesCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    roomId: number
    isDeleted?: boolean
    publicId: string
    body?: string
  }

  export type CostCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estimatedCost?: number | null
    actualCost?: number | null
    name?: string | null
    isDeleted?: boolean
    type: $Enums.CostType
  }

  export type ProjectEquipmentCreateManyProjectInput = {
    id?: number
    publicId: string
    createdAt?: Date | string
    isDeleted?: boolean
    quantity?: number
    equipmentId: number
  }

  export type WeatherReportItemCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    date: Date | string
    time: string
    f_scale?: string | null
    speed?: string | null
    size?: string | null
    location: string
    county: string
    state: string
    lat: string
    lon: string
    comments: string
  }

  export type PendingRoofReportsCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    isCompleted?: boolean
  }

  export type ProjectNotesCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    body?: string
    mentions?: ProjectNotesCreatementionsInput | string[]
    userId: string
  }

  export type ImageUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutImageNestedInput
    inference?: InferenceUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inference?: InferenceUncheckedUpdateOneWithoutImageNestedInput
    ImageNote?: ImageNoteUncheckedUpdateManyWithoutImageNestedInput
    Annotation?: AnnotationUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    includeInReport?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InferenceUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    room?: RoomUpdateOneWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUpdateManyWithoutRoomNestedInput
    notes?: NotesUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
    detections?: DetectionUncheckedUpdateManyWithoutRoomNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutRoomNestedInput
    templates?: TemplatesUsedUncheckedUpdateManyWithoutRoomNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutRoomNestedInput
    areasAffected?: AreaAffectedUncheckedUpdateManyWithoutRoomNestedInput
    notes?: NotesUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    dehuReading?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    totalSqft?: NullableStringFieldUpdateOperationsInput | string | null
    windows?: NullableIntFieldUpdateOperationsInput | number | null
    doors?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentUsed?: RoomUpdateequipmentUsedInput | string[]
  }

  export type CalendarEventUpdateWithoutProjectInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
    reminders?: CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventNestedInput
  }

  export type CalendarEventUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dynamicId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    remindClient?: BoolFieldUpdateOperationsInput | boolean
    remindProjectOwners?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserToProjectUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserToProjectNestedInput
  }

  export type UserToProjectUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToProjectUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomReadingUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    room?: RoomUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaAffectedUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
    room?: RoomUpdateOneRequiredWithoutAreasAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type PhotoAccessLinkUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoAccessLinkUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotesUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type CostUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type CostUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type CostUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
  }

  export type ProjectEquipmentUpdateWithoutProjectInput = {
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipment?: EquipmentUpdateOneRequiredWithoutProjectEquipmentNestedInput
  }

  export type ProjectEquipmentUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectEquipmentUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherReportItemUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type WeatherReportItemUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    f_scale?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lon?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type PendingRoofReportsUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PendingRoofReportsUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectNotesUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectNotesUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ProjectNotesUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyCurrentStatusInput = {
    id?: number
    createdAt?: Date | string
    closedAt?: Date | string | null
    isDeleted?: boolean
    organizationId: number
    assignmentNumber?: string
    publicId: string
    name: string
    location?: string
    clientName?: string
    clientEmail?: string
    clientPhoneNumber?: string
    companyName?: string
    managerName?: string
    adjusterEmail?: string
    adjusterName?: string
    adjusterPhoneNumber?: string
    insuranceCompanyName?: string
    insuranceClaimId?: string
    lossType?: string
    catCode?: number | null
    humidity?: string
    lastTimeWeatherFetched?: Date | string | null
    temperature?: string
    wind?: string
    lat?: string
    lng?: string
    forecast?: string
    claimSummary?: string
    roofSegments?: ProjectCreateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: number | null
    actualValue?: number | null
    status?: $Enums.ProjectStatus | null
  }

  export type ProjectUpdateWithoutCurrentStatusInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    images?: ImageUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUpdateManyWithoutProjectNestedInput
    rooms?: RoomUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUpdateManyWithoutProjectNestedInput
    notes?: NotesUpdateManyWithoutProjectNestedInput
    costs?: CostUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCurrentStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
    images?: ImageUncheckedUpdateManyWithoutProjectNestedInput
    inferences?: InferenceUncheckedUpdateManyWithoutProjectNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProjectNestedInput
    events?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
    projectAssignees?: UserToProjectUncheckedUpdateManyWithoutProjectNestedInput
    roomReadings?: RoomReadingUncheckedUpdateManyWithoutProjectNestedInput
    propertyData?: PropertyDataUncheckedUpdateOneWithoutProjectNestedInput
    AreaAffected?: AreaAffectedUncheckedUpdateManyWithoutProjectNestedInput
    photoAccessLinks?: PhotoAccessLinkUncheckedUpdateManyWithoutProjectNestedInput
    notes?: NotesUncheckedUpdateManyWithoutProjectNestedInput
    costs?: CostUncheckedUpdateManyWithoutProjectNestedInput
    projectEquipment?: ProjectEquipmentUncheckedUpdateManyWithoutProjectNestedInput
    weatherReportItems?: WeatherReportItemUncheckedUpdateManyWithoutProjectNestedInput
    PendingRoofReports?: PendingRoofReportsUncheckedUpdateManyWithoutProjectNestedInput
    ProjectNotes?: ProjectNotesUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCurrentStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: IntFieldUpdateOperationsInput | number
    assignmentNumber?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientPhoneNumber?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    managerName?: StringFieldUpdateOperationsInput | string
    adjusterEmail?: StringFieldUpdateOperationsInput | string
    adjusterName?: StringFieldUpdateOperationsInput | string
    adjusterPhoneNumber?: StringFieldUpdateOperationsInput | string
    insuranceCompanyName?: StringFieldUpdateOperationsInput | string
    insuranceClaimId?: StringFieldUpdateOperationsInput | string
    lossType?: StringFieldUpdateOperationsInput | string
    catCode?: NullableIntFieldUpdateOperationsInput | number | null
    humidity?: StringFieldUpdateOperationsInput | string
    lastTimeWeatherFetched?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperature?: StringFieldUpdateOperationsInput | string
    wind?: StringFieldUpdateOperationsInput | string
    lat?: StringFieldUpdateOperationsInput | string
    lng?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    claimSummary?: StringFieldUpdateOperationsInput | string
    roofSegments?: ProjectUpdateroofSegmentsInput | InputJsonValue[]
    roofSpecs?: NullableJsonNullValueInput | InputJsonValue
    rcvValue?: NullableFloatFieldUpdateOperationsInput | number | null
    actualValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus | null
  }

  export type ImageNoteCreateManyImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    body?: string
    mentions?: ImageNoteCreatementionsInput | string[]
    userId: string
    isDeleted?: boolean
  }

  export type AnnotationCreateManyImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coordinates: JsonNullValueInput | InputJsonValue
    userId: string
    isDeleted?: boolean
  }

  export type ImageNoteUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutImageNoteNestedInput
  }

  export type ImageNoteUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageNoteUncheckedUpdateManyWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    mentions?: ImageNoteUpdatementionsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coordinates?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DetectionCreateManyInferenceInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    roomId?: number | null
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type DetectionUpdateWithoutInferenceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
    room?: RoomUpdateOneWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateWithoutInferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type DetectionUncheckedUpdateManyWithoutInferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type DetectionCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    inferenceId: number
    imageKey?: string | null
    xMinCord?: number | null
    yMinCord?: number | null
    confidence?: number | null
    xMaxCord?: number | null
    yMaxCord?: number | null
    projectId: number
    category: string
    code: string
    item: string
    quality: string
    dimension?: number | null
    unit?: $Enums.DimensionUnit | null
  }

  export type InferenceCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    isDeleted?: boolean
    publicId: string
    imageId?: number | null
    imageKey?: string | null
    projectId: number
  }

  export type TemplatesUsedCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    templateCode: string
  }

  export type RoomReadingCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    humidity?: string | null
    temperature?: string | null
    moistureContentWall?: string | null
    moistureContentFloor?: string | null
    equipmentUsed?: RoomReadingCreateequipmentUsedInput | string[]
    isDeleted?: boolean
    publicId: string
    projectId: number
    gpp?: string | null
  }

  export type AreaAffectedCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    date?: Date | string
    material?: string | null
    totalAreaRemoved?: string | null
    totalAreaMicrobialApplied?: string | null
    cause?: string | null
    category?: number | null
    cabinetryRemoved?: string | null
    isDeleted?: boolean
    publicId: string
    projectId: number
    type: $Enums.AreaAffectedType
  }

  export type NotesCreateManyRoomInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    date?: Date | string
    isDeleted?: boolean
    publicId: string
    projectId: number
    body?: string
  }

  export type DetectionUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
    inference?: InferenceUpdateOneRequiredWithoutDetectionsNestedInput
  }

  export type DetectionUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type DetectionUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    inferenceId?: IntFieldUpdateOperationsInput | number
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    xMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMinCord?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    xMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    yMaxCord?: NullableFloatFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    dimension?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableEnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit | null
  }

  export type InferenceUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    image?: ImageUpdateOneWithoutInferenceNestedInput
    Project?: ProjectUpdateOneRequiredWithoutInferencesNestedInput
    detections?: DetectionUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
    detections?: DetectionUncheckedUpdateManyWithoutInferenceNestedInput
  }

  export type InferenceUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplatesUsedUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatesUsedUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateCode?: StringFieldUpdateOperationsInput | string
  }

  export type RoomReadingUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutRoomReadingsNestedInput
    genericRoomReadings?: GenericRoomReadingUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    genericRoomReadings?: GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingNestedInput
  }

  export type RoomReadingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentWall?: NullableStringFieldUpdateOperationsInput | string | null
    moistureContentFloor?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsed?: RoomReadingUpdateequipmentUsedInput | string[]
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaAffectedUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
    project?: ProjectUpdateOneRequiredWithoutAreaAffectedNestedInput
  }

  export type AreaAffectedUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type AreaAffectedUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    totalAreaMicrobialApplied?: NullableStringFieldUpdateOperationsInput | string | null
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    cabinetryRemoved?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    type?: EnumAreaAffectedTypeFieldUpdateOperationsInput | $Enums.AreaAffectedType
  }

  export type NotesUpdateWithoutRoomInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutNotesNestedInput
    notesAuditTrail?: NotesAuditTrailUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    notesAuditTrail?: NotesAuditTrailUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NotesUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    publicId?: StringFieldUpdateOperationsInput | string
    projectId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type GenericRoomReadingCreateManyRoomReadingInput = {
    id?: number
    createdAt?: Date | string
    publicId: string
    type: $Enums.RoomReadingType
    value: string
    humidity?: string | null
    temperature?: string | null
    gpp?: string | null
    isDeleted?: boolean
  }

  export type GenericRoomReadingUpdateWithoutRoomReadingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateWithoutRoomReadingInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenericRoomReadingUncheckedUpdateManyWithoutRoomReadingInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicId?: StringFieldUpdateOperationsInput | string
    type?: EnumRoomReadingTypeFieldUpdateOperationsInput | $Enums.RoomReadingType
    value?: StringFieldUpdateOperationsInput | string
    humidity?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    gpp?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesAuditTrailCreateManyNoteInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    userName?: string | null
    action: $Enums.NotesAuditAction
    body: string
  }

  export type NotesAuditTrailUpdateWithoutNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type NotesAuditTrailUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumNotesAuditActionFieldUpdateOperationsInput | $Enums.NotesAuditAction
    body?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventReminderCreateManyCalendarEventInput = {
    id?: number
    reminderTarget: $Enums.ReminderTarget
    createdAt?: Date | string
    updatedAt?: Date | string
    sendText?: boolean
    sendEmail?: boolean
    textSentAt?: Date | string | null
    emailSentAt?: Date | string | null
    date: Date | string
  }

  export type CalendarEventReminderUpdateWithoutCalendarEventInput = {
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateWithoutCalendarEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventReminderUncheckedUpdateManyWithoutCalendarEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminderTarget?: EnumReminderTargetFieldUpdateOperationsInput | $Enums.ReminderTarget
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendText?: BoolFieldUpdateOperationsInput | boolean
    sendEmail?: BoolFieldUpdateOperationsInput | boolean
    textSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineItemCreateManyXactimateCategoryInput = {
    id?: number
    xactimateCode: string
    xactimateDescription: string
    unit?: string | null
  }

  export type LineItemUpdateWithoutXactimateCategoryInput = {
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    alternateItem?: AlternateItemUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateWithoutXactimateCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    alternateItem?: AlternateItemUncheckedUpdateManyWithoutLineItemNestedInput
    relatedItem?: RelatedItemUncheckedUpdateManyWithoutLineItemNestedInput
  }

  export type LineItemUncheckedUpdateManyWithoutXactimateCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    xactimateCode?: StringFieldUpdateOperationsInput | string
    xactimateDescription?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlternateItemCreateManyLineItemInput = {
    id?: number
    alternateId: string
  }

  export type RelatedItemCreateManyLineItemInput = {
    id?: number
    relationId: string
  }

  export type AlternateItemUpdateWithoutLineItemInput = {
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternateItemUncheckedUpdateManyWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    alternateId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUpdateWithoutLineItemInput = {
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedItemUncheckedUpdateManyWithoutLineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationId?: StringFieldUpdateOperationsInput | string
  }

  export type PricesCreateManyProductInput = {
    id: string
    active: boolean
    unitAmount?: bigint | number | null
    currency: string
    type: $Enums.PricingType
    interval?: $Enums.PricingPlanInterval | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description: string
  }

  export type PricesUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PricesUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitAmount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    interval?: NullableEnumPricingPlanIntervalFieldUpdateOperationsInput | $Enums.PricingPlanInterval | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsCreateManyPriceInput = {
    id: string
    organizationId: number
    status: $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity: number
    cancelAtPeriodEnd: boolean
    created?: Date | string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    endedAt?: Date | string | null
    cancelAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
  }

  export type SubscriptionsUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    quantity?: IntFieldUpdateOperationsInput | number
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}